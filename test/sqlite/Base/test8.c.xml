<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="test8.c" filename=""><comment type="block">/*
** 2006 June 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Code for testing the virtual table interfaces.  This code
** is not included in the SQLite library.  It is used for automated
** testing of the SQLite library.
**
** $Id: test8.c,v 1.75 2008/08/31 00:29:08 shane Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>

<typedef>typedef <type><struct>struct <name>echo_vtab</name> echo_vtab;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>echo_cursor</name> echo_cursor;</struct></type></typedef>

<comment type="block">/*
** The test module defined in this file uses four global Tcl variables to
** commicate with test-scripts:
**
**     $::echo_module
**     $::echo_module_sync_fail
**     $::echo_module_begin_fail
**     $::echo_module_cost
**
** The variable ::echo_module is a list. Each time one of the following
** methods is called, one or more elements are appended to the list.
** This is used for automated testing of virtual table modules.
**
** The ::echo_module_sync_fail variable is set by test scripts and read
** by code in this file. If it is set to the name of a real table in the
** the database, then all xSync operations on echo virtual tables that
** use the named table as a backing store will fail.
*/</comment>

<comment type="block">/*
** Errors can be provoked within the following echo virtual table methods:
**
**   xBestIndex   xOpen     xFilter   xNext   
**   xColumn      xRowid    xUpdate   xSync   
**   xBegin       xRename
**
** This is done by setting the global tcl variable:
**
**   echo_module_fail($method,$tbl)
**
** where $method is set to the name of the virtual table method to fail
** (i.e. "xBestIndex") and $tbl is the name of the table being echoed (not
** the name of the virtual table, the name of the underlying real table).
*/</comment>

<comment type="block">/* 
** An echo virtual-table object.
**
** echo.vtab.aIndex is an array of booleans. The nth entry is true if 
** the nth column of the real table is the left-most column of an index
** (implicit or otherwise). In other words, if SQLite can optimize
** a query like "SELECT * FROM real_table WHERE col = ?".
**
** Member variable aCol[] contains copies of the column names of the real
** table.
*/</comment>
<struct>struct <name>echo_vtab</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>     <comment type="block">/* Tcl interpreter containing debug variables */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>            <comment type="block">/* Database connection */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>isPattern</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inTransaction</name></decl>;</decl_stmt>      <comment type="block">/* True if within a transaction */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zThis</name></decl>;</decl_stmt>            <comment type="block">/* Name of the echo table */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zTableName</name></decl>;</decl_stmt>       <comment type="block">/* Name of the real table */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zLogName</name></decl>;</decl_stmt>         <comment type="block">/* Name of the log table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>               <comment type="block">/* Number of columns in the real table */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aIndex</name></decl>;</decl_stmt>            <comment type="block">/* Array of size nCol. True if column has an index */</comment>
  <decl_stmt><decl><type><name>char</name> **</type><name>aCol</name></decl>;</decl_stmt>            <comment type="block">/* Array of size nCol. Column names */</comment>
</public>}</block>;</struct>

<comment type="block">/* An echo cursor object */</comment>
<struct>struct <name>echo_cursor</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>static</name> <name>int</name></type> <name>simulateVtabError</name><parameter_list>(<param><decl><type><name>echo_vtab</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zMethod</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zVarname</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>zVarname</name><index>[<expr>127</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>127</expr></argument>, <argument><expr><name>zVarname</name></expr></argument>, <argument><expr>"echo_module_fail(%s,%s)"</expr></argument>, <argument><expr><name>zMethod</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> = <call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>zVarname</name></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zErr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>base</name>.<name>zErrMsg</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"echo-vtab-error: %s"</expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>(<name>zErr</name>!=0)</expr>;</return>
}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>dequoteString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>quote</name> = <name><name>z</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>quote</name></expr> )</condition><block>{
    <case>case <expr>'\''</expr>:  <break>break;</break>
    </case><case>case <expr>'"'</expr>:   <break>break;</break>
    </case><case>case <expr>'`'</expr>:   <break>break;</break>                <comment type="block">/* For MySQL compatibility */</comment>
    </case><case>case <expr>'['</expr>:   <expr_stmt><expr><name>quote</name> = ']'</expr>;</expr_stmt>  <break>break;</break>  <comment type="block">/* For MS SqlServer compatibility */</comment>
    </case><default>default:    <return>return;</return>
  </default>}</block></switch>
  <for>for(<init><expr><name>i</name>=1</expr>, <expr><name>j</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>==<name>quote</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>==<name>quote</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>
        <break>break;</break>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Retrieve the column names for the table named zTab via database
** connection db. SQLITE_OK is returned on success, or an sqlite error
** code otherwise.
**
** If successful, the number of columns is written to *pnCol. *paCol is
** set to point at sqlite3_malloc()'d space containing the array of
** nCol column names. The caller is responsible for calling sqlite3_free
** on *paCol.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getColumnNames</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name></decl></param>,
  <param><decl><type><name>char</name> ***</type><name>paCol</name></decl></param>, 
  <param><decl><type><name>int</name> *</type><name>pnCol</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> **</type><name>aCol</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Prepare the statement "SELECT * FROM &lt;tbl&gt;". The column names
  ** of the result set of the compiled SELECT will be the same as
  ** the column names of table &lt;tbl&gt;.
  */</comment>
  <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"SELECT * FROM %Q"</expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zSql</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>out</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zSpace</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nCol</name> = <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Figure out how much space to allocate for the array of column names 
    ** (including space for the strings themselves). Then allocate it.
    */</comment>
    <expr_stmt><expr><name>nBytes</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call> * <name>nCol</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name> =<init> <expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>!<name>zName</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>nBytes</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call>+1</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>aCol</name> = (<name>char</name> **)<call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>aCol</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <comment type="block">/* Copy the column names into the allocated space and set up the
    ** pointers in the aCol[] array.
    */</comment>
    <expr_stmt><expr><name>zSpace</name> = (<name>char</name> *)(&amp;<name><name>aCol</name><index>[<expr><name>nCol</name></expr>]</index></name>)</expr>;</expr_stmt>
    <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>aCol</name><index>[<expr><name>ii</name></expr>]</index></name> = <name>zSpace</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSpace</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>zSpace</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSpace</name>++</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>zSpace</name>-<name>nBytes</name>)==(<name>char</name> *)<name>aCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr>*<name>paCol</name> = <name>aCol</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnCol</name> = <name>nCol</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Parameter zTab is the name of a table in database db with nCol 
** columns. This function allocates an array of integers nCol in 
** size and populates it according to any implicit or explicit 
** indices on table zTab.
**
** If successful, SQLITE_OK is returned and *paIndex set to point 
** at the allocated array. Otherwise, an error code is returned.
**
** See comments associated with the member variable aIndex above 
** "struct echo_vtab" for details of the contents of the array.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getIndexArray</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,             <comment type="block">/* Database connection */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name></decl></param>,        <comment type="block">/* Name of table in database db */</comment>
  <param><decl><type><name>int</name></type> <name>nCol</name></decl></param>,
  <param><decl><type><name>int</name> **</type><name>paIndex</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> *</type><name>aIndex</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate space for the index array */</comment>
  <expr_stmt><expr><name>aIndex</name> = (<name>int</name> *)<call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call> * <name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>aIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>get_index_array_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Compile an sqlite pragma to loop through all indices on table zTab */</comment>
  <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"PRAGMA index_list(%s)"</expr></argument>, <argument><expr><name>zTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zSql</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>get_index_array_out</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For each index, figure out the left-most column and set the 
  ** corresponding entry in aIndex[] to 1.
  */</comment>
  <while>while<condition>( <expr><name>pStmt</name> &amp;&amp; <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call>==<name>SQLITE_ROW</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zIdx</name> =<init> <expr>(<name>const</name> <name>char</name> *)<call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"PRAGMA index_info(%s)"</expr></argument>, <argument><expr><name>zIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zSql</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>get_index_array_out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pStmt2</name> &amp;&amp; <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt2</name></expr></argument>)</argument_list></call>==<name>SQLITE_ROW</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>cid</name> =<init> <expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt2</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cid</name>&gt;=0 &amp;&amp; <name>cid</name>&lt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aIndex</name><index>[<expr><name>cid</name></expr>]</index></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pStmt2</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <goto>goto <name>get_index_array_out</name>;</goto>
    }</block></then></if>
  }</block></while>


<label><name>get_index_array_out</name>:</label>
  <if>if<condition>( <expr><name>pStmt</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> =<init> <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>rc2</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>aIndex</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr>*<name>paIndex</name> = <name>aIndex</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Global Tcl variable $echo_module is a list. This routine appends
** the string element zArg to that list in interpreter interp.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>appendToEchoModule</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>(<name>TCL_APPEND_VALUE</name> | <name>TCL_LIST_ELEMENT</name> | <name>TCL_GLOBAL_ONLY</name>)</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module"</expr></argument>, <argument><expr>(<name>zArg</name>?<name>zArg</name>:"")</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This function is called from within the echo-modules xCreate and
** xConnect methods. The argc and argv arguments are copies of those 
** passed to the calling method. This function is responsible for
** calling sqlite3_declare_vtab() to declare the schema of the virtual
** table being created or connected.
**
** If the constructor was passed just one argument, i.e.:
**
**   CREATE TABLE t1 AS echo(t2);
**
** Then t2 is assumed to be the name of a *real* database table. The
** schema of the virtual table is declared by passing a copy of the 
** CREATE TABLE statement for the real table to sqlite3_declare_vtab().
** Hence, the virtual table should have exactly the same column names and 
** types as the real table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoDeclareVtab</name><parameter_list>(
  <param><decl><type><name>echo_vtab</name> *</type><name>pVtab</name></decl></param>, 
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param> 
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pVtab</name>-&gt;<name>zTableName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
        <argument><expr>"SELECT sql FROM sqlite_master WHERE type = 'table' AND name = ?"</expr></argument>,
        <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call>==<name>SQLITE_ROW</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zCreateTable</name> =<init> <expr>(<name>const</name> <name>char</name> *)<call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCreateTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc2</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <name>rc2</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{ 
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>getColumnNames</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>, <argument><expr>&amp;<name>pVtab</name>-&gt;<name>aCol</name></expr></argument>, <argument><expr>&amp;<name>pVtab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>getIndexArray</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr>&amp;<name>pVtab</name>-&gt;<name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function frees all runtime structures associated with the virtual
** table pVtab.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoDestructor</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>p</name> =<init> <expr>(<name>echo_vtab</name>*)<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zLogName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>EchoModule</name> EchoModule;</struct></type></typedef>
<struct>struct <name>EchoModule</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
** This function is called to do the work of the xConnect() method -
** to allocate the required in-memory structures for a newly connected
** virtual table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoConstructor</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *<name>const</name>*</type><name>argv</name></decl></param>,
  <param><decl><type><name>sqlite3_vtab</name> **</type><name>ppVtab</name></decl></param>,
  <param><decl><type><name>char</name> **</type><name>pzErr</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate the sqlite3_vtab/echo_vtab structure itself */</comment>
  <expr_stmt><expr><name>pVtab</name> = <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pVtab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pVtab</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>interp</name> = ((<name>EchoModule</name> *)<name>pAux</name>)-&gt;<name>interp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>

  <comment type="block">/* Allocate echo_vtab.zThis */</comment>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zThis</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pVtab</name>-&gt;<name>zThis</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>echoDestructor</name><argument_list>(<argument><expr>(<name>sqlite3_vtab</name> *)<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Allocate echo_vtab.zTableName */</comment>
  <if>if<condition>( <expr><name>argc</name>&gt;3</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>zTableName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dequoteString</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pVtab</name>-&gt;<name>zTableName</name> &amp;&amp; <name>pVtab</name>-&gt;<name><name>zTableName</name><index>[<expr>0</expr>]</index></name>=='*'</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"%s%s"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;(<name>pVtab</name>-&gt;<name><name>zTableName</name><index>[<expr>1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>zTableName</name> = <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>isPattern</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr>!<name>pVtab</name>-&gt;<name>zTableName</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>echoDestructor</name><argument_list>(<argument><expr>(<name>sqlite3_vtab</name> *)<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Log the arguments to this function to Tcl var ::echo_module */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Invoke sqlite3_declare_vtab and set up other members of the echo_vtab
  ** structure. If an error occurs, delete the sqlite3_vtab structure and
  ** return an error code.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>echoDeclareVtab</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>echoDestructor</name><argument_list>(<argument><expr>(<name>sqlite3_vtab</name> *)<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Success. Set *ppVtab and return */</comment>
  <expr_stmt><expr>*<name>ppVtab</name> = &amp;<name>pVtab</name>-&gt;<name>base</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xCreate method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoCreate</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *<name>const</name>*</type><name>argv</name></decl></param>,
  <param><decl><type><name>sqlite3_vtab</name> **</type><name>ppVtab</name></decl></param>,
  <param><decl><type><name>char</name> **</type><name>pzErr</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr>((<name>EchoModule</name> *)<name>pAux</name>)-&gt;<name>interp</name></expr></argument>, <argument><expr>"xCreate"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>echoConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there were two arguments passed to the module at the SQL level 
  ** (i.e. "CREATE VIRTUAL TABLE tbl USING echo(arg1, arg2)"), then 
  ** the second argument is used as a table name. Attempt to create
  ** such a table with a single column, "logmsg". This table will
  ** be used to log calls to the xUpdate method. It will be deleted
  ** when the virtual table is DROPed.
  **
  ** Note: The main point of this is to test that we can drop tables
  ** from within an xDestroy method call.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>argc</name>==5</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>*(<name>echo_vtab</name> **)<name>ppVtab</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>zLogName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"CREATE TABLE %Q(logmsg)"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zLogName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pzErr</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if<condition>( <expr>*<name>ppVtab</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>echoDestructor</name><argument_list>(<argument><expr>*<name>ppVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>ppVtab</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>(*(<name>echo_vtab</name>**)<name>ppVtab</name>)-&gt;<name>inTransaction</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xConnect method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoConnect</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *<name>const</name>*</type><name>argv</name></decl></param>,
  <param><decl><type><name>sqlite3_vtab</name> **</type><name>ppVtab</name></decl></param>,
  <param><decl><type><name>char</name> **</type><name>pzErr</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr>((<name>EchoModule</name> *)<name>pAux</name>)-&gt;<name>interp</name></expr></argument>, <argument><expr>"xConnect"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>echoConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVtab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xDisconnect method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoDisconnect</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr>((<name>echo_vtab</name> *)<name>pVtab</name>)-&gt;<name>interp</name></expr></argument>, <argument><expr>"xDisconnect"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>echoDestructor</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xDestroy method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoDestroy</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>p</name> =<init> <expr>(<name>echo_vtab</name> *)<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr>((<name>echo_vtab</name> *)<name>pVtab</name>)-&gt;<name>interp</name></expr></argument>, <argument><expr>"xDestroy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drop the "log" table, if one exists (see echoCreate() for details) */</comment>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>zLogName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"DROP TABLE %Q"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>zLogName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>echoDestructor</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xOpen method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoOpen</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVTab</name></decl></param>, <param><decl><type><name>sqlite3_vtab_cursor</name> **</type><name>ppCursor</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>echo_cursor</name> *</type><name>pCur</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr>(<name>echo_vtab</name> *)<name>pVTab</name></expr></argument>, <argument><expr>"xOpen"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name> = <call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>echo_cursor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>ppCursor</name> = (<name>sqlite3_vtab_cursor</name> *)<name>pCur</name></expr>;</expr_stmt>
  <return>return <expr>(<name>pCur</name> ? <name>SQLITE_OK</name> : <name>SQLITE_NOMEM</name>)</expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xClose method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoClose</name><parameter_list>(<param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>cur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_cursor</name> *</type><name>pCur</name> =<init> <expr>(<name>echo_cursor</name> *)<name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr><name>pCur</name>-&gt;<name>pStmt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pStmt</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return non-zero if the cursor does not currently point to a valid record
** (i.e if the scan has finished), or zero otherwise.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoEof</name><parameter_list>(<param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>cur</name></decl></param>)</parameter_list><block>{
  <return>return <expr>(((<name>echo_cursor</name> *)<name>cur</name>)-&gt;<name>pStmt</name> ? 0 : 1)</expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xNext method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoNext</name><parameter_list>(<param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>cur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_cursor</name> *</type><name>pCur</name> =<init> <expr>(<name>echo_cursor</name> *)<name>cur</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr>(<name>echo_vtab</name> *)(<name>cur</name>-&gt;<name>pVtab</name>)</expr></argument>, <argument><expr>"xNext"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>pStmt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_ROW</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pStmt</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xColumn method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoColumn</name><parameter_list>(<param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>cur</name></decl></param>, <param><decl><type><name>sqlite3_context</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>i</name> + 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>((<name>echo_cursor</name> *)<name>cur</name>)-&gt;<name>pStmt</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr>(<name>echo_vtab</name> *)(<name>cur</name>-&gt;<name>pVtab</name>)</expr></argument>, <argument><expr>"xColumn"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr>!<name>pStmt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_data_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call>&gt;<name>iCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xRowid method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoRowid</name><parameter_list>(<param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>cur</name></decl></param>, <param><decl><type><name>sqlite_int64</name> *</type><name>pRowid</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>((<name>echo_cursor</name> *)<name>cur</name>)-&gt;<name>pStmt</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr>(<name>echo_vtab</name> *)(<name>cur</name>-&gt;<name>pVtab</name>)</expr></argument>, <argument><expr>"xRowid"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>pRowid</name> = <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Compute a simple hash of the null terminated string zString.
**
** This module uses only sqlite3_index_info.idxStr, not 
** sqlite3_index_info.idxNum. So to test idxNum, when idxStr is set
** in echoBestIndex(), idxNum is set to the corresponding hash value.
** In echoFilter(), code assert()s that the supplied idxNum value is
** indeed the hash of the supplied idxStr.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>hashString</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zString</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name><name>zString</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 3) + (<name>int</name>)<name><name>zString</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>val</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Echo virtual table module xFilter method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoFilter</name><parameter_list>(
  <param><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>pVtabCursor</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>idxNum</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>idxStr</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>echo_cursor</name> *</type><name>pCur</name> =<init> <expr>(<name>echo_cursor</name> *)<name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>pVtabCursor</name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pVtab</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xFilter"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Check that idxNum matches idxStr */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxNum</name>==<call><name>hashString</name><argument_list>(<argument><expr><name>idxStr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Log arguments to the ::echo_module Tcl variable */</comment>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr>"xFilter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <macro><name>appendToEchoModule</name><argument_list>(<argument>pVtab-&gt;interp</argument>, <argument>(const char*)sqlite3_value_text(argv[i])</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  }</block></for>

  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pStmt</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Prepare the SQL statement created by echoBestIndex and bind the
  ** runtime parameters passed to this function to it.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idxStr</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pStmt</name> || <name>rc</name>!=<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pStmt</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* If everything was successful, advance to the first row of the scan */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>echoNext</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** A helper function used by echoUpdate() and echoBestIndex() for
** manipulating strings in concert with the sqlite3_mprintf() function.
**
** Parameter pzStr points to a pointer to a string allocated with
** sqlite3_mprintf. The second parameter, zAppend, points to another
** string. The two strings are concatenated together and *pzStr
** set to point at the result. The initial buffer pointed to by *pzStr
** is deallocated via sqlite3_free().
**
** If the third argument, doFree, is true, then sqlite3_free() is
** also called to free the buffer pointed to by zAppend.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>string_concat</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>pzStr</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zAppend</name></decl></param>, <param><decl><type><name>int</name></type> <name>doFree</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pRc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zIn</name> =<init> <expr>*<name>pzStr</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>zAppend</name> &amp;&amp; <name>doFree</name> &amp;&amp; *<name>pRc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr>*<name>pRc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>zIn</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zTemp</name> =<init> <expr><name>zIn</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zIn</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"%s%s"</expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>zIn</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr>!<name>zIn</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pRc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <expr_stmt><expr>*<name>pzStr</name> = <name>zIn</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>doFree</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** The echo module implements the subset of query constraints and sort
** orders that may take advantage of SQLite indices on the underlying
** real table. For example, if the real table is declared as:
**
**     CREATE TABLE real(a, b, c);
**     CREATE INDEX real_index ON real(b);
**
** then the echo module handles WHERE or ORDER BY clauses that refer
** to the column "b", but not "a" or "c". If a multi-column index is
** present, only its left most column is considered. 
**
** This xBestIndex method encodes the proposed search strategy as
** an SQL query on the real table underlying the virtual echo module 
** table and stores the query in sqlite3_index_info.idxStr. The SQL
** statement is of the form:
**
**   SELECT rowid, * FROM &lt;real-table&gt; ?&lt;where-clause&gt;? ?&lt;order-by-clause&gt;?
**
** where the &lt;where-clause&gt; and &lt;order-by-clause&gt; are determined
** by the contents of the structure pointed to by the pIdxInfo argument.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoBestIndex</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>, <param><decl><type><name>sqlite3_index_info</name> *</type><name>pIdxInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zQuery</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSep</name> =<init> <expr>"WHERE"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> =<init> <expr><name>pVtab</name>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>useIdx</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>useCost</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>cost</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isIgnoreUsable</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module_ignore_usable"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>isIgnoreUsable</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xBestIndex"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Determine the number of rows in the table and store this value in local
  ** variable nRow. The 'estimated-cost' of the scan will be the number of
  ** rows in the table for a linear scan, or the log (base 2) of the 
  ** number of rows if the proposed scan uses an index.  
  */</comment>
  <if>if<condition>( <expr><call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module_cost"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>cost</name> = <call><name>atof</name><argument_list>(<argument><expr><call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module_cost"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>useCost</name> = 1</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>zQuery</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"SELECT count(*) FROM %Q"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zQuery</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nRow</name> = <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></else></if>

  <expr_stmt><expr><name>zQuery</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"SELECT rowid, * FROM %Q"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zQuery</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>pIdxInfo</name>-&gt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>const</name> struct <name>sqlite3_index_constraint</name> *</type><name>pConstraint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>sqlite3_index_constraint_usage</name> *</type><name>pUsage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pConstraint</name> = &amp;<name>pIdxInfo</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pUsage</name> = &amp;<name>pIdxInfo</name>-&gt;<name><name>aConstraintUsage</name><index>[<expr><name>ii</name></expr>]</index></name></expr>;</expr_stmt>

    <if>if<condition>( <expr>!<name>isIgnoreUsable</name> &amp;&amp; !<name>pConstraint</name>-&gt;<name>usable</name></expr> )</condition><then> <continue>continue;</continue></then></if>

    <expr_stmt><expr><name>iCol</name> = <name>pConstraint</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pVtab</name>-&gt;<name><name>aIndex</name><index>[<expr><name>iCol</name></expr>]</index></name> || <name>iCol</name>&lt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zCol</name> =<init> <expr><name>pVtab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zOp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>useIdx</name> = 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zCol</name> = "rowid"</expr>;</expr_stmt>
      }</block></then></if>
      <switch>switch<condition>( <expr><name>pConstraint</name>-&gt;<name>op</name></expr> )</condition><block>{
        <case>case <expr><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "="</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LT</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "&lt;"</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GT</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "&gt;"</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>SQLITE_INDEX_CONSTRAINT_LE</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "&lt;="</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>SQLITE_INDEX_CONSTRAINT_GE</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "&gt;="</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr>:
          <expr_stmt><expr><name>zOp</name> = "LIKE"</expr>;</expr_stmt> <break>break;</break>
      </case>}</block></switch>
      <if>if<condition>( <expr><name><name>zOp</name><index>[<expr>0</expr>]</index></name>=='L'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>" %s %s LIKE (SELECT '%%'||?||'%%')"</expr></argument>, 
                               <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>" %s %s %s ?"</expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>zOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>zQuery</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>zSep</name> = "AND"</expr>;</expr_stmt>
      <expr_stmt><expr><name>pUsage</name>-&gt;<name>argvIndex</name> = ++<name>nArg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pUsage</name>-&gt;<name>omit</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* If there is only one term in the ORDER BY clause, and it is
  ** on a column that this virtual table has an index for, then consume 
  ** the ORDER BY clause.
  */</comment>
  <if>if<condition>( <expr><name>pIdxInfo</name>-&gt;<name>nOrderBy</name>==1 &amp;&amp; <name>pVtab</name>-&gt;<name><name>aIndex</name><index>[<expr><name>pIdxInfo</name>-&gt;<name>aOrderBy</name>-&gt;<name>iColumn</name></expr>]</index></name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>pIdxInfo</name>-&gt;<name>aOrderBy</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zCol</name> =<init> <expr><name>pVtab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zDir</name> =<init> <expr><name>pIdxInfo</name>-&gt;<name>aOrderBy</name>-&gt;<name>desc</name>?"DESC":"ASC"</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>zCol</name> = "rowid"</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>" ORDER BY %s %s"</expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>zQuery</name></expr></argument>, <argument><expr><name>zNew</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>orderByConsumed</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr>"xBestIndex"</expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>zQuery</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>idxNum</name> = <call><name>hashString</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>idxStr</name> = <name>zQuery</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>needToFreeIdxStr</name> = 1</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>useCost</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>estimatedCost</name> = <name>cost</name></expr>;</expr_stmt>
  }</block></then> <else>else <if>if<condition>( <expr><name>useIdx</name></expr> )</condition><then><block>{
    <comment type="block">/* Approximation of log2(nRow). */</comment>
    <for>for( <init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;(<call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>*8)</expr>;</condition> <incr><expr><name>ii</name>++</expr></incr> )<block>{
      <if>if<condition>( <expr><name>nRow</name> &amp; (1&lt;&lt;<name>ii</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>estimatedCost</name> = (<name>double</name>)<name>ii</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>estimatedCost</name> = (<name>double</name>)<name>nRow</name></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The xUpdate method for echo module virtual tables.
** 
**    apData[0]  apData[1]  apData[2..]
**
**    INTEGER                              DELETE            
**
**    INTEGER    NULL       (nCol args)    UPDATE (do not set rowid)
**    INTEGER    INTEGER    (nCol args)    UPDATE (with SET rowid = &lt;arg1&gt;)
**
**    NULL       NULL       (nCol args)    INSERT INTO (automatic rowid value)
**    NULL       INTEGER    (nCol args)    INSERT (incl. rowid value)
**
*/</comment>
<function><type><name>int</name></type> <name>echoUpdate</name><parameter_list>(
  <param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nData</name></decl></param>, 
  <param><decl><type><name>sqlite3_value</name> **</type><name>apData</name></decl></param>, 
  <param><decl><type><name>sqlite_int64</name> *</type><name>pRowid</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pVtab</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>               <comment type="block">/* SQL statement to execute */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bindArgZero</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* True to bind apData[0] to sql var no. nData */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bindArgOne</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* True to bind apData[1] to sql var no. 1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Counter variable used by for loops */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name>==<name>pVtab</name>-&gt;<name>nCol</name>+2 || <name>nData</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ticket #3083 - make sure we always start a transaction prior to
  ** making any changes to a virtual table */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xUpdate"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* If apData[0] is an integer and nData&gt;1 then do an UPDATE */</comment>
  <if>if<condition>( <expr><name>nData</name>&gt;1 &amp;&amp; <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_INTEGER</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zSep</name> =<init> <expr>" SET"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"UPDATE %Q"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>z</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>bindArgOne</name> = (<name><name>apData</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apData</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_INTEGER</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>bindArgZero</name> = 1</expr>;</expr_stmt>

    <if>if<condition>( <expr><name>bindArgOne</name></expr> )</condition><then><block>{
       <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr>" SET rowid=?1 "</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>zSep</name> = ","</expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>i</name>=2</expr>;</init> <condition><expr><name>i</name>&lt;<name>nData</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>apData</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_mprintf</name><argument_list>(
          <argument><expr>"%s %Q=?%d"</expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name>-2</expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSep</name> = ","</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>" WHERE rowid=?%d"</expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>

  <comment type="block">/* If apData[0] is an integer and nData==1 then do a DELETE */</comment>
  <else>else <if>if<condition>( <expr><name>nData</name>==1 &amp;&amp; <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_INTEGER</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"DELETE FROM %Q WHERE rowid = ?1"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>z</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>bindArgZero</name> = 1</expr>;</expr_stmt>
  }</block></then>

  <comment type="block">/* If the first argument is NULL and there are more than two args, INSERT */</comment>
  <else>else <if>if<condition>( <expr><name>nData</name>&gt;2 &amp;&amp; <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zInsert</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zValues</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  
    <expr_stmt><expr><name>zInsert</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"INSERT INTO %Q ("</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zInsert</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>apData</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_INTEGER</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>bindArgOne</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>zValues</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>zInsert</name></expr></argument>, <argument><expr>"rowid"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>pVtab</name>-&gt;<name>nCol</name>+2)==<name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>ii</name>=2</expr>;</init> <condition><expr><name>ii</name>&lt;<name>nData</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>zInsert</name></expr></argument>, 
          <argument><expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"%s%Q"</expr></argument>, <argument><expr><name>zValues</name>?", ":""</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name><name>aCol</name><index>[<expr><name>ii</name>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>zValues</name></expr></argument>, 
          <argument><expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"%s?%d"</expr></argument>, <argument><expr><name>zValues</name>?", ":""</expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr><name>zInsert</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr>") VALUES("</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr><name>zValues</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>string_concat</name><argument_list>(<argument><expr>&amp;<name>z</name></expr></argument>, <argument><expr>")"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>

  <comment type="block">/* Anything else is an error */</comment>
  <else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></else></if></else></if></else></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pStmt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then> <block>{
    <if>if<condition>( <expr><name>bindArgZero</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name><name>apData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>bindArgOne</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>apData</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>i</name>=2</expr>;</init> <condition><expr><name>i</name>&lt;<name>nData</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>apData</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><then> <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>apData</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>pRowid</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRowid</name> = <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>tab</name>-&gt;<name>zErrMsg</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"echo-vtab-error: %s"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** xBegin, xSync, xCommit and xRollback callbacks for echo module
** virtual tables. Do nothing other than add the name of the callback
** to the $::echo_module Tcl variable.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>echoTransactionCall</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zCall</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>tab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"echo(%s)"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>zCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendToEchoModule</name><argument_list>(<argument><expr><name>pVtab</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>echoBegin</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> =<init> <expr><name>pVtab</name>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zVal</name></decl>;</decl_stmt> 

  <comment type="block">/* Ticket #3083 - do not start a transaction if we are already in
  ** a transaction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pVtab</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xBegin"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>echoTransactionCall</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr>"xBegin"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* Check if the $::echo_module_begin_fail variable is defined. If it is,
    ** and it is set to the name of the real table underlying this virtual
    ** echo module table, then cause this xSync operation to fail.
    */</comment>
    <expr_stmt><expr><name>zVal</name> = <call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module_begin_fail"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zVal</name> &amp;&amp; 0==<call><name>strcmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>inTransaction</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>echoSync</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> =<init> <expr><name>pVtab</name>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zVal</name></decl>;</decl_stmt> 

  <comment type="block">/* Ticket #3083 - Only call xSync if we have previously started a
  ** transaction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xSync"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>echoTransactionCall</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr>"xSync"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* Check if the $::echo_module_sync_fail variable is defined. If it is,
    ** and it is set to the name of the real table underlying this virtual
    ** echo module table, then cause this xSync operation to fail.
    */</comment>
    <expr_stmt><expr><name>zVal</name> = <call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"echo_module_sync_fail"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zVal</name> &amp;&amp; 0==<call><name>strcmp</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zTableName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>echoCommit</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name>*)<name>tab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Ticket #3083 - Only call xCommit if we have previously started
  ** a transaction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>"xCommit"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>echoTransactionCall</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr>"xCommit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>inTransaction</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>echoRollback</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>tab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name>*)<name>tab</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Ticket #3083 - Only call xRollback if we have previously started
  ** a transaction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>echoTransactionCall</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr>"xRollback"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>inTransaction</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of "GLOB" function on the echo module.  Pass
** all arguments to the ::echo_glob_overload procedure of TCL
** and return the result of that procedure as a string.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>overloadedGlobFunction</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pContext</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>apArg</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> =<init> <expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>"::echo_glob_overload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>(<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This is the xFindFunction implementation for the echo module.
** SQLite calls this routine when the first argument of a function
** is a column of an echo virtual table.  This routine can optionally
** override the implementation of that function.  It will choose to
** do so if the function is named "glob", and a TCL command named
** ::echo_glob_overload exists.
*/</comment>
<function_decl><type><name>static</name> <name>int</name> <name>echoFindFunction</name></type>(
  <name>sqlite3_vtab</name> *vtab,
  int nArg,
  const char *zFuncName,
  void <parameter_list>(<param><decl><type>**</type><name>pxFunc</name></decl></param>)</parameter_list>(<specifier>sqlite3_context</specifier>*,<specifier>int</specifier>,<specifier>sqlite3_value</specifier>**</function_decl>),
  <decl_stmt><decl><type><name>void</name> **</type><name>ppArg</name>
)<block>{
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>pVtab</name> =<init> <expr>(<name>echo_vtab</name> *)<name>vtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name> =<init> <expr><name>pVtab</name>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_CmdInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFuncName</name></expr></argument>,<argument><expr>"glob"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>Tcl_GetCommandInfo</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"::echo_glob_overload"</expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pxFunc</name> = <name>overloadedGlobFunction</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>ppArg</name> = <name>interp</name></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
}</block></decl></decl_stmt>

<function><type><name>static</name> <name>int</name></type> <name>echoRename</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>vtab</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zNewName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>echo_vtab</name> *</type><name>p</name> =<init> <expr>(<name>echo_vtab</name> *)<name>vtab</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>simulateVtabError</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"xRename"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>isPattern</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nThis</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zThis</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name> =<init> <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"ALTER TABLE %s RENAME TO %s%s"</expr></argument>, 
        <argument><expr><name>p</name>-&gt;<name>zTableName</name></expr></argument>, <argument><expr><name>zNewName</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>zTableName</name><index>[<expr><name>nThis</name></expr>]</index></name></expr></argument>
    )</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** A virtual table module that merely "echos" the contents of another
** table (like an SQL VIEW).
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>sqlite3_module</name></type> <name>echoModule</name> =<init> <expr><block>{
  <expr>0</expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><name>echoCreate</name></expr>,
  <expr><name>echoConnect</name></expr>,
  <expr><name>echoBestIndex</name></expr>,
  <expr><name>echoDisconnect</name></expr>, 
  <expr><name>echoDestroy</name></expr>,
  <expr><name>echoOpen</name></expr>,                  <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>echoClose</name></expr>,                 <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>echoFilter</name></expr>,                <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>echoNext</name></expr>,                  <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>echoEof</name></expr>,                   <comment type="block">/* xEof */</comment>
  <expr><name>echoColumn</name></expr>,                <comment type="block">/* xColumn - read data */</comment>
  <expr><name>echoRowid</name></expr>,                 <comment type="block">/* xRowid - read data */</comment>
  <expr><name>echoUpdate</name></expr>,                <comment type="block">/* xUpdate - write data */</comment>
  <expr><name>echoBegin</name></expr>,                 <comment type="block">/* xBegin - begin transaction */</comment>
  <expr><name>echoSync</name></expr>,                  <comment type="block">/* xSync - sync transaction */</comment>
  <expr><name>echoCommit</name></expr>,                <comment type="block">/* xCommit - commit transaction */</comment>
  <expr><name>echoRollback</name></expr>,              <comment type="block">/* xRollback - rollback transaction */</comment>
  <expr><name>echoFindFunction</name></expr>,          <comment type="block">/* xFindFunction - function overloading */</comment>
  <expr><name>echoRename</name></expr>,                <comment type="block">/* xRename - rename the table */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Decode a pointer to an sqlite3 object.
*/</comment>
<function_decl><type><name>extern</name> <name>int</name></type> <name>getDbPointer</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zA</name></decl></param>, <param><decl><type><name>sqlite3</name> **</type><name>ppDb</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>static</name> <name>void</name></type> <name>moduleDestroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Register the echo virtual table module.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>register_echo_module</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>, <comment type="block">/* Pointer to sqlite3_enable_XXX function */</comment>
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,    <comment type="block">/* The TCL interpreter that invoked this command */</comment>
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,              <comment type="block">/* Number of arguments */</comment>
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>  <comment type="block">/* Command arguments */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EchoModule</name> *</type><name>pMod</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>objc</name>!=2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"DB"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>getDbPointer</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pMod</name> = <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>EchoModule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_create_module_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"echo"</expr></argument>, <argument><expr>&amp;<name>echoModule</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>pMod</name></expr></argument>, <argument><expr><name>moduleDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Tcl interface to sqlite3_declare_vtab, invoked as follows from Tcl:
**
** sqlite3_declare_vtab DB SQL
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>declare_vtab</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>, <comment type="block">/* Pointer to sqlite3_enable_XXX function */</comment>
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,    <comment type="block">/* The TCL interpreter that invoked this command */</comment>
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,              <comment type="block">/* Number of arguments */</comment>
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>  <comment type="block">/* Command arguments */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"DB SQL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>getDbPointer</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Register commands with the TCL interpreter.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitetest8_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>static</name> <struct>struct <block>{<public type="default"/>
     <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> *</type><name>xProc</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>void</name> *</type><name>clientData</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aObjCmd</name><index>[]</index></name> =<init> <expr><block>{
     <expr><block>{ <expr>"register_echo_module"</expr>,   <expr><name>register_echo_module</name></expr>, <expr>0</expr> }</block></expr>,
     <expr><block>{ <expr>"sqlite3_declare_vtab"</expr>,   <expr><name>declare_vtab</name></expr>, <expr>0</expr> }</block></expr>,
  }</block></expr></init></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>aObjCmd</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>aObjCmd</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, 
        <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>xProc</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>clientData</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
</unit>
