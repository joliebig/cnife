<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="expr.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used for analyzing expressions and
** for generating VDBE code that evaluates expressions in SQLite.
**
** $Id: expr.c,v 1.409 2009/01/10 13:24:51 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Return the 'affinity' of the expression pExpr if any.
**
** If pExpr is a column, a reference to a column via an 'AS' alias,
** or a sub-select with a column as the return value, then the 
** affinity of that column is returned. Otherwise, 0x00 is returned,
** indicating no affinity for the expression.
**
** i.e. the WHERE clause expresssions in the following statements all
** have an affinity:
**
** CREATE TABLE t1(a);
** SELECT * FROM t1 WHERE a;
** SELECT a AS b FROM t1 WHERE b;
** SELECT * FROM t1 WHERE (select a from t1);
*/</comment>
<function><type><name>char</name></type> <name>sqlite3ExprAffinity</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr><name>pExpr</name>-&gt;<name>op</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>TK_SELECT</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pSelect</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
  <if>if<condition>( <expr><name>op</name>==<name>TK_CAST</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3AffinityType</name><argument_list>(<argument><expr>&amp;<name>pExpr</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr>(<name>op</name>==<name>TK_AGG_COLUMN</name> || <name>op</name>==<name>TK_COLUMN</name> || <name>op</name>==<name>TK_REGISTER</name>) 
   &amp;&amp; <name>pExpr</name>-&gt;<name>pTab</name>!=0</expr>
  )</condition><then><block>{
    <comment type="block">/* op==TK_REGISTER &amp;&amp; pExpr-&gt;pTab!=0 happens when pExpr was originally
    ** a TK_COLUMN but was previously evaluated and cached in a register */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>pExpr</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>j</name>&lt;0</expr> )</condition><then> <return>return <expr><name>SQLITE_AFF_INTEGER</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pTab</name> &amp;&amp; <name>j</name>&lt;<name>pExpr</name>-&gt;<name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pExpr</name>-&gt;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>affinity</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>pExpr</name>-&gt;<name>affinity</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set the collating sequence for expression pExpr to be the collating
** sequence named by pToken.   Return a pointer to the revised expression.
** The collating sequence is marked as "explicit" using the EP_ExpCollate
** flag.  An explicit collating sequence will override implicit
** collating sequences.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3ExprSetColl</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pCollName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zColl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>            <comment type="block">/* Dequoted name of collation sequence */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>zColl</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCollName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name> &amp;&amp; <name>zColl</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pColl</name> = <name>pColl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>flags</name> |= <name>EP_ExpCollate</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pExpr</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the default collation sequence for the expression pExpr. If
** there is no default collation type, return 0.
*/</comment>
<function><type><name>CollSeq</name> *</type><name>sqlite3ExprCollSeq</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name> =<init> <expr><name>pExpr</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pColl</name> = <name>p</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then> <break>break;</break></then></if>
    <expr_stmt><expr><name>op</name> = <name>p</name>-&gt;<name>op</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>op</name>==<name>TK_AGG_COLUMN</name> || <name>op</name>==<name>TK_COLUMN</name> || <name>op</name>==<name>TK_REGISTER</name>) &amp;&amp; <name>p</name>-&gt;<name>pTab</name>!=0</expr> )</condition><then><block>{
      <comment type="block">/* op==TK_REGISTER &amp;&amp; p-&gt;pTab!=0 happens when pExpr was originally
      ** a TK_COLUMN but was previously evaluated and cached in a register */</comment>
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zColl</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>p</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>j</name>&gt;=0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zColl</name> = <name>p</name>-&gt;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zColl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pExpr</name>-&gt;<name>pColl</name> = <name>pColl</name></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block></then></if>
    <if>if<condition>( <expr><name>op</name>!=<name>TK_CAST</name> &amp;&amp; <name>op</name>!=<name>TK_UPLUS</name></expr> )</condition><then><block>{
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pLeft</name></expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><call><name>sqlite3CheckCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{ 
    <expr_stmt><expr><name>pColl</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pColl</name></expr>;</return>
}</block></function>

<comment type="block">/*
** pExpr is an operand of a comparison operator.  aff2 is the
** type affinity of the other operand.  This routine returns the
** type affinity that should be used for the comparison operator.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3CompareAffinity</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>char</name></type> <name>aff2</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name></type> <name>aff1</name> =<init> <expr><call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>aff1</name> &amp;&amp; <name>aff2</name></expr> )</condition><then><block>{
    <comment type="block">/* Both sides of the comparison are columns. If one has numeric
    ** affinity, use that. Otherwise use no affinity.
    */</comment>
    <if>if<condition>( <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff1</name></expr></argument>)</argument_list></call> || <call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>aff2</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_AFF_NUMERIC</name></expr>;</return>
    }</block></then><else>else<block>{
      <return>return <expr><name>SQLITE_AFF_NONE</name></expr>;</return>
    }</block></else></if>
  }</block></then><else>else <if>if<condition>( <expr>!<name>aff1</name> &amp;&amp; !<name>aff2</name></expr> )</condition><then><block>{
    <comment type="block">/* Neither side of the comparison is a column.  Compare the
    ** results directly.
    */</comment>
    <return>return <expr><name>SQLITE_AFF_NONE</name></expr>;</return>
  }</block></then><else>else<block>{
    <comment type="block">/* One side is a column, the other is not. Use the columns affinity. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aff1</name>==0 || <name>aff2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>aff1</name> + <name>aff2</name>)</expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="block">/*
** pExpr is a comparison operator.  Return the type affinity that should
** be applied to both operands prior to doing the comparison.
*/</comment>
<function><type><name>static</name> <name>char</name></type> <name>comparisonAffinity</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_EQ</name> || <name>pExpr</name>-&gt;<name>op</name>==<name>TK_IN</name> || <name>pExpr</name>-&gt;<name>op</name>==<name>TK_LT</name> ||
          <name>pExpr</name>-&gt;<name>op</name>==<name>TK_GT</name> || <name>pExpr</name>-&gt;<name>op</name>==<name>TK_GE</name> || <name>pExpr</name>-&gt;<name>op</name>==<name>TK_LE</name> ||
          <name>pExpr</name>-&gt;<name>op</name>==<name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aff</name> = <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pRight</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aff</name> = <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aff</name> = <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pSelect</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if<condition>( <expr>!<name>aff</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_NONE</name></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if>
  <return>return <expr><name>aff</name></expr>;</return>
}</block></function>

<comment type="block">/*
** pExpr is a comparison expression, eg. '=', '&lt;', IN(...) etc.
** idx_affinity is the affinity of an indexed column. Return true
** if the index with affinity idx_affinity may be used to implement
** the comparison in pExpr.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IndexAffinityOk</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>char</name></type> <name>idx_affinity</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name> =<init> <expr><call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>aff</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_AFF_NONE</name></expr>:
      <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>SQLITE_AFF_TEXT</name></expr>:
      <return>return <expr><name>idx_affinity</name>==<name>SQLITE_AFF_TEXT</name></expr>;</return>
    </case><default>default:
      <return>return <expr><call><name>sqlite3IsNumericAffinity</name><argument_list>(<argument><expr><name>idx_affinity</name></expr></argument>)</argument_list></call></expr>;</return>
  </default>}</block></switch>
}</block></function>

<comment type="block">/*
** Return the P5 value that should be used for a binary comparison
** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
*/</comment>
<function><type><name>static</name> <name>u8</name></type> <name>binaryCompareP5</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr1</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr2</name></decl></param>, <param><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>aff</name> =<init> <expr>(<name>char</name>)<call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pExpr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>aff</name> = (<name>u8</name>)<call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pExpr1</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>)</argument_list></call> | (<name>u8</name>)<name>jumpIfNull</name></expr>;</expr_stmt>
  <return>return <expr><name>aff</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a pointer to the collation sequence that should be used by
** a binary comparison operator comparing pLeft and pRight.
**
** If the left hand expression has a collating sequence type, then it is
** used. Otherwise the collation sequence for the right hand expression
** is used, or the default (BINARY) if neither expression has a collating
** type.
**
** Argument pRight (but not pLeft) may be a null pointer. In this case,
** it is not considered.
*/</comment>
<function><type><name>CollSeq</name> *</type><name>sqlite3BinaryCompareCollSeq</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, 
  <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>, 
  <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name>-&gt;<name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> = <name>pLeft</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pRight</name> &amp;&amp; <name>pRight</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRight</name>-&gt;<name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> = <name>pRight</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if></else></if>
  <return>return <expr><name>pColl</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate the operands for a comparison operation.  Before
** generating the code for each operand, set the EP_AnyAff
** flag on the expression so that it will be able to used a
** cached column value that has previously undergone an
** affinity change.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeCompareOperands</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>,      <comment type="block">/* The left operand */</comment>
  <param><decl><type><name>int</name> *</type><name>pRegLeft</name></decl></param>,    <comment type="block">/* Register where left operand is stored */</comment>
  <param><decl><type><name>int</name> *</type><name>pFreeLeft</name></decl></param>,   <comment type="block">/* Free this register when done */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>,     <comment type="block">/* The right operand */</comment>
  <param><decl><type><name>int</name> *</type><name>pRegRight</name></decl></param>,   <comment type="block">/* Register where right operand is stored */</comment>
  <param><decl><type><name>int</name> *</type><name>pFreeRight</name></decl></param>   <comment type="block">/* Write temp register for right operand there */</comment>
)</parameter_list><block>{
  <while>while<condition>( <expr><name>pLeft</name>-&gt;<name>op</name>==<name>TK_UPLUS</name></expr> )</condition> <expr_stmt><expr><name>pLeft</name> = <name>pLeft</name>-&gt;<name>pLeft</name></expr>;</expr_stmt></while>
  <expr_stmt><expr><name>pLeft</name>-&gt;<name>flags</name> |= <name>EP_AnyAff</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pRegLeft</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pFreeLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pRight</name>-&gt;<name>op</name>==<name>TK_UPLUS</name></expr> )</condition> <expr_stmt><expr><name>pRight</name> = <name>pRight</name>-&gt;<name>pLeft</name></expr>;</expr_stmt></while>
  <expr_stmt><expr><name>pRight</name>-&gt;<name>flags</name> |= <name>EP_AnyAff</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pRegRight</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pFreeRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Generate code for a comparison operator.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>codeCompare</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* The parsing (and code generating) context */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>,      <comment type="block">/* The left operand */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>,     <comment type="block">/* The right operand */</comment>
  <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>,       <comment type="block">/* The comparison opcode */</comment>
  <param><decl><type><name>int</name></type> <name>in1</name></decl></param>, <param><decl><type><name>int</name></type> <name>in2</name></decl></param>, <comment type="block">/* Register holding operands */</comment>
  <param><decl><type><name>int</name></type> <name>dest</name></decl></param>,         <comment type="block">/* Jump here if true.  */</comment>
  <param><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></param>    <comment type="block">/* If true, jump if either operand is NULL */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>p5</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>p4</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p4</name> = <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p5</name> = <call><name>binaryCompareP5</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>in1</name></expr></argument>,
                           <argument><expr>(<name>void</name>*)<name>p4</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p5</name> &amp; <name>SQLITE_AFF_MASK</name>)!=<name>SQLITE_AFF_NONE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>in1</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>in2</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>addr</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_EXPR_DEPTH</name>&gt;0</expr></cpp:if>
<comment type="block">/*
** Check that argument nHeight is less than or equal to the maximum
** expression depth allowed. If it is not, leave an error message in
** pParse.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCheckHeight</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>nHeight</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxHeight</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_EXPR_DEPTH</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>nHeight</name>&gt;<name>mxHeight</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
       <argument><expr>"Expression tree is too large (maximum depth %d)"</expr></argument>, <argument><expr><name>mxHeight</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* The following three functions, heightOfExpr(), heightOfExprList()
** and heightOfSelect(), are used to determine the maximum height
** of any expression tree referenced by the structure passed as the
** first argument.
**
** If this maximum height is greater than the current value pointed
** to by pnHeight, the second parameter, then set *pnHeight to that
** value.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>heightOfExpr</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pnHeight</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>nHeight</name>&gt;*<name>pnHeight</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pnHeight</name> = <name>p</name>-&gt;<name>nHeight</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>heightOfExprList</name><parameter_list>(<param><decl><type><name>ExprList</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pnHeight</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>heightOfSelect</name><parameter_list>(<param><decl><type><name>Select</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pnHeight</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pHaving</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pOffset</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pGroupBy</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>, <argument><expr><name>pnHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable in the structure passed as an 
** argument. An expression with no children, Expr.pList or 
** Expr.pSelect member has a height of 1. Any other expression
** has a height equal to the maximum height of any other 
** referenced Expr plus one.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>exprSetHeight</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>heightOfExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>heightOfExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pList</name></expr></argument>, <argument><expr>&amp;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>, <argument><expr>&amp;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nHeight</name> = <name>nHeight</name> + 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the Expr.nHeight variable using the exprSetHeight() function. If
** the height is greater than the maximum allowed expression depth,
** leave an error in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSetHeight</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>exprSetHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the maximum height of any expression tree referenced
** by the select statement passed as an argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3SelectExprHeight</name><parameter_list>(<param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nHeight</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>heightOfSelect</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nHeight</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>exprSetHeight</name>(y)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_EXPR_DEPTH&gt;0 */</comment>

<comment type="block">/*
** Construct a new expression node and return a pointer to it.  Memory
** for this node is obtained from sqlite3_malloc().  The calling function
** is responsible for making sure the node eventually gets freed.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3Expr</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,            <comment type="block">/* Handle for sqlite3DbMallocZero() (may be null) */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,                 <comment type="block">/* Expression opcode */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>,            <comment type="block">/* Left operand */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>,           <comment type="block">/* Right operand */</comment>
  <param><decl><type><name>const</name> <name>Token</name> *</type><name>pToken</name></decl></param>     <comment type="block">/* Argument token */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* When malloc fails, delete pLeft and pRight. Expressions passed to 
    ** this function must always be allocated with sqlite3Expr() for this 
    ** reason. 
    */</comment>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>op</name> = (<name>u8</name>)<name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pLeft</name> = <name>pLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pRight</name> = <name>pRight</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>iAgg</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>span</name>.<name>z</name> = (<name>u8</name>*)""</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pToken</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name>-&gt;<name>dyn</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>span</name> = <name>pNew</name>-&gt;<name>token</name> = *<name>pToken</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pLeft</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pRight</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pRight</name>-&gt;<name>span</name>.<name>dyn</name>==0 &amp;&amp; <name>pLeft</name>-&gt;<name>span</name>.<name>dyn</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprSpan</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>&amp;<name>pLeft</name>-&gt;<name>span</name></expr></argument>, <argument><expr>&amp;<name>pRight</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>pRight</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pNew</name>-&gt;<name>flags</name> |= <name>EP_ExpCollate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>pColl</name> = <name>pRight</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pNew</name>-&gt;<name>flags</name> |= <name>EP_ExpCollate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>pColl</name> = <name>pLeft</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if>

  <expr_stmt><expr><call><name>exprSetHeight</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Works like sqlite3Expr() except that it takes an extra Parse*
** argument and notifies the associated connection object if malloc fails.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3PExpr</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,                 <comment type="block">/* Expression opcode */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>,            <comment type="block">/* Left operand */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>,           <comment type="block">/* Right operand */</comment>
  <param><decl><type><name>const</name> <name>Token</name> *</type><name>pToken</name></decl></param>     <comment type="block">/* Argument token */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name> =<init> <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprCheckHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** When doing a nested parse, you can include terms in an expression
** that look like this:   #1 #2 ...  These terms refer to registers
** in the virtual machine.  #N is the N-th register.
**
** This routine is called by the parser to deal with on of those terms.
** It immediately generates code to store the value in a memory location.
** The returns an expression that will code to extract the value from
** that memory location as needed.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3RegisterExpr</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pToken</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nested</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"near \"%T\": syntax error"</expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_REGISTER</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>  <comment type="block">/* Malloc failed */</comment>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>iTable</name> = <call><name>atoi</name><argument_list>(<argument><expr>(<name>char</name>*)&amp;<name>pToken</name>-&gt;<name><name>z</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Join two expressions using an AND operator.  If either expression is
** NULL, then just return the other expression.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3ExprAnd</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pLeft</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pRight</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pLeft</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>pRight</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>pRight</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>pLeft</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="block">/*
** Set the Expr.span field of the given expression to span all
** text between the two given tokens.  Both tokens must be pointing
** at the same string.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprSpan</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pLeft</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pRight</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRight</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>span</name>.<name>z</name> = <name>pLeft</name>-&gt;<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>span</name>.<name>n</name> = <name>pRight</name>-&gt;<name>n</name> + (<name>pRight</name>-&gt;<name>z</name> - <name>pLeft</name>-&gt;<name>z</name>)</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Construct a new expression node for a function with multiple
** arguments.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3ExprFunction</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pToken</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Avoid leaking memory when malloc fails */</comment>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>op</name> = <name>TK_FUNCTION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pList</name> = <name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name>-&gt;<name>dyn</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>token</name> = *<name>pToken</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>span</name> = <name>pNew</name>-&gt;<name>token</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3ExprSetHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Assign a variable number to an expression that encodes a wildcard
** in the original SQL statement.  
**
** Wildcards consisting of a single "?" are assigned the next sequential
** variable number.
**
** Wildcards of the form "?nnn" are assigned the number "nnn".  We make
** sure "nnn" is not too be to avoid a denial of service attack when
** the SQL statement comes from an external source.
**
** Wildcards of the form ":aaa" or "$aaa" are assigned the same number
** as the previous instance of the same wildcard.  Or if this is the first
** instance of the wildcard, the next sequenial variable number is
** assigned.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAssignVarNumber</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Token</name> *</type><name>pToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pToken</name> = &amp;<name>pExpr</name>-&gt;<name>token</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name>-&gt;<name>n</name>&gt;=1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name>-&gt;<name>z</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToken</name>-&gt;<name><name>z</name><index>[<expr>0</expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pToken</name>-&gt;<name>n</name>==1</expr> )</condition><then><block>{
    <comment type="block">/* Wildcard of the form "?".  Assign the next variable number */</comment>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = ++<name>pParse</name>-&gt;<name>nVar</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pToken</name>-&gt;<name><name>z</name><index>[<expr>0</expr>]</index></name>=='?'</expr> )</condition><then><block>{
    <comment type="block">/* Wildcard of the form "?nnn".  Convert "nnn" to an integer and
    ** use it as the variable number */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>i</name> = <call><name>atoi</name><argument_list>(<argument><expr>(<name>char</name>*)&amp;<name>pToken</name>-&gt;<name><name>z</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name>==<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name>-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name>==<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>i</name>&lt;1 || <name>i</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"variable number must be between ?1 and ?%d"</expr></argument>,
          <argument><expr><name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>i</name>&gt;<name>pParse</name>-&gt;<name>nVar</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nVar</name> = <name>i</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <comment type="block">/* Wildcards of the form ":aaa" or "$aaa".  Reuse the same variable
    ** number as the prior appearance of the same name, or if the name
    ** has never appeared before, reuse the same variable number
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>n</name> = <name>pToken</name>-&gt;<name>n</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nVarExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name></decl>;</decl_stmt>
      <if>if<condition>( <expr>(<name>pE</name> = <name>pParse</name>-&gt;<name><name>apVarExpr</name><index>[<expr><name>i</name></expr>]</index></name>)!=0
          &amp;&amp; <name>pE</name>-&gt;<name>token</name>.<name>n</name>==<name>n</name>
          &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>pE</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pToken</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>pE</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>i</name>&gt;=<name>pParse</name>-&gt;<name>nVarExpr</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = ++<name>pParse</name>-&gt;<name>nVar</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nVarExpr</name>&gt;=<name>pParse</name>-&gt;<name>nVarExprAlloc</name>-1</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pParse</name>-&gt;<name>nVarExprAlloc</name> += <name>pParse</name>-&gt;<name>nVarExprAlloc</name> + 10</expr>;</expr_stmt>
        <expr_stmt><expr><name>pParse</name>-&gt;<name>apVarExpr</name> =
            <call><name>sqlite3DbReallocOrFree</name><argument_list>(
              <argument><expr><name>db</name></expr></argument>,
              <argument><expr><name>pParse</name>-&gt;<name>apVarExpr</name></expr></argument>,
              <argument><expr><name>pParse</name>-&gt;<name>nVarExprAlloc</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name><name>apVarExpr</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
            )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>apVarExpr</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pParse</name>-&gt;<name><name>apVarExpr</name><index>[<expr><name>pParse</name>-&gt;<name>nVarExpr</name>++</expr>]</index></name> = <name>pExpr</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if></else></if> 
  <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>nErr</name> &amp;&amp; <name>pParse</name>-&gt;<name>nVar</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_VARIABLE_NUMBER</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"too many SQL variables"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Clear an expression structure without deleting the structure itself.
** Substructure is deleted.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprClear</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>span</name>.<name>dyn</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>span</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>token</name>.<name>dyn</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>token</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Recursively delete an expression tree.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3ExprClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The Expr.token field might be a string literal that is quoted.
** If so, remove the quotation marks.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DequoteExpr</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><call><name>ExprHasAnyProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Dequoted</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_Dequoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>token</name>.<name>dyn</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>token</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>token</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The following group of routines make deep copies of expressions,
** expression lists, ID lists, and select statements.  The copies can
** be deleted (by being passed to their respective ...Delete() routines)
** without effecting the originals.
**
** The expression list, ID, and source lists return by sqlite3ExprListDup(),
** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded 
** by subsequent calls to sqlite*ListAppend() routines.
**
** Any tables that the SrcList might point to are not duplicated.
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3ExprDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>token</name>.<name>z</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pNew</name>-&gt;<name>token</name>.<name>z</name> = (<name>u8</name>*)<call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>token</name>.<name>dyn</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>token</name>.<name>z</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>span</name>.<name>z</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pLeft</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pRight</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pList</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pSelect</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3TokenCopy</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pTo</name>-&gt;<name>dyn</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pTo</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pFrom</name>-&gt;<name>z</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTo</name>-&gt;<name>n</name> = <name>pFrom</name>-&gt;<name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTo</name>-&gt;<name>z</name> = (<name>u8</name>*)<call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pFrom</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pFrom</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTo</name>-&gt;<name>dyn</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pTo</name>-&gt;<name>z</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<function><type><name>ExprList</name> *</type><name>sqlite3ExprListDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name>, *<name>pOldItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>iECursor</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nExpr</name> = <name>pNew</name>-&gt;<name>nAlloc</name> = <name>p</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>a</name> = <name>pItem</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>,  <argument><expr><name>p</name>-&gt;<name>nExpr</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pItem</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if> 
  <expr_stmt><expr><name>pOldItem</name> = <name>p</name>-&gt;<name>a</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr>, <expr><name>pOldItem</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pNewExpr</name>, *<name>pOldExpr</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>pExpr</name> = <name>pNewExpr</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldExpr</name> = <name>pOldItem</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOldExpr</name>-&gt;<name>span</name>.<name>z</name>!=0 &amp;&amp; <name>pNewExpr</name></expr> )</condition><then><block>{
      <comment type="block">/* Always make a copy of the span for top-level expressions in the
      ** expression list.  The logic in SELECT processing that determines
      ** the names of columns in the result set needs this information */</comment>
      <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pNewExpr</name>-&gt;<name>span</name></expr></argument>, <argument><expr>&amp;<name>pOldExpr</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNewExpr</name>==0 || <name>pNewExpr</name>-&gt;<name>span</name>.<name>z</name>!=0 
            || <name>pOldExpr</name>-&gt;<name>span</name>.<name>z</name>==0
            || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>sortOrder</name> = <name>pOldItem</name>-&gt;<name>sortOrder</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>done</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>iCol</name> = <name>pOldItem</name>-&gt;<name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>iAlias</name> = <name>pOldItem</name>-&gt;<name>iAlias</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If cursors, triggers, views and subqueries are all omitted from
** the build, then none of the following routines, except for 
** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes
** called with a NULL argument.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call> \
 || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>SrcList</name> *</type><name>sqlite3SrcListDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>nByte</name> = <call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> + (<name>p</name>-&gt;<name>nSrc</name>&gt;0 ? <call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> * (<name>p</name>-&gt;<name>nSrc</name>-1) : 0)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nSrc</name> = <name>pNew</name>-&gt;<name>nAlloc</name> = <name>p</name>-&gt;<name>nSrc</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pNewItem</name> =<init> <expr>&amp;<name>pNew</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pOldItem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>zDatabase</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>zAlias</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>jointype</name> = <name>pOldItem</name>-&gt;<name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>iCursor</name> = <name>pOldItem</name>-&gt;<name>iCursor</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>isPopulated</name> = <name>pOldItem</name>-&gt;<name>isPopulated</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>zIndex</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>notIndexed</name> = <name>pOldItem</name>-&gt;<name>notIndexed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>pIndex</name> = <name>pOldItem</name>-&gt;<name>pIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> = <name>pNewItem</name>-&gt;<name>pTab</name> = <name>pOldItem</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTab</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTab</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>pSelect</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>pOn</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>pOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>pUsing</name> = <call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>pUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>colUsed</name> = <name>pOldItem</name>-&gt;<name>colUsed</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>
<function><type><name>IdList</name> *</type><name>sqlite3IdListDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>IdList</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>IdList</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nId</name> = <name>pNew</name>-&gt;<name>nAlloc</name> = <name>p</name>-&gt;<name>nId</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>a</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nId</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>-&gt;<name>a</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nId</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>IdList_item</name> *</type><name>pNewItem</name> =<init> <expr>&amp;<name>pNew</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>IdList_item</name> *</type><name>pOldItem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOldItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewItem</name>-&gt;<name>idx</name> = <name>pOldItem</name>-&gt;<name>idx</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>
<function><type><name>Select</name> *</type><name>sqlite3SelectDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Select</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pEList</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pSrc</name> = <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pWhere</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pGroupBy</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pHaving</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pOrderBy</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>op</name> = <name>p</name>-&gt;<name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pPrior</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pLimit</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pOffset</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>iLimit</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>iOffset</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>selFlags</name> = <name>p</name>-&gt;<name>selFlags</name> &amp; ~<name>SF_UsesEphemeral</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pRightmost</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>1</expr>]</index></name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>2</expr>]</index></name> = -1</expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>Select</name> *</type><name>sqlite3SelectDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Add a new element to the end of an expression list.  If pList is
** initially NULL, then create a new expression list.
*/</comment>
<function><type><name>ExprList</name> *</type><name>sqlite3ExprListAppend</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,        <comment type="block">/* List to which to append. Might be NULL */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,            <comment type="block">/* Expression to be appended */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>            <comment type="block">/* AS keyword for the expression */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pList</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>ExprList</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
      <goto>goto <name>no_mem</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>-&gt;<name>nAlloc</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pList</name>-&gt;<name>nAlloc</name>&lt;=<name>pList</name>-&gt;<name>nExpr</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>a</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pList</name>-&gt;<name>nAlloc</name>*2 + 4</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name>a</name></expr></argument>, <argument><expr><name>n</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>a</name>==0</expr> )</condition><then><block>{
      <goto>goto <name>no_mem</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pList</name>-&gt;<name>a</name> = <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name>-&gt;<name>nAlloc</name> = <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>-&gt;<name>a</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name> || <name>pName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>pList</name>-&gt;<name>nExpr</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pItem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>pExpr</name> = <name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pItem</name>-&gt;<name>iAlias</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pList</name></expr>;</return>

<label><name>no_mem</name>:</label>     
  <comment type="block">/* Avoid leaking memory if malloc has failed. */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** If the expression list pEList contains more than iLimit elements,
** leave an error message in pParse.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListCheckLength</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zObject</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> &amp;&amp; <name>pEList</name>-&gt;<name>nExpr</name>==<name>mx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pEList</name> &amp;&amp; <name>pEList</name>-&gt;<name>nExpr</name>==<name>mx</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pEList</name> &amp;&amp; <name>pEList</name>-&gt;<name>nExpr</name>&gt;<name>mx</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"too many columns in %s"</expr></argument>, <argument><expr><name>zObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Delete an entire expression list.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprListDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>-&gt;<name>a</name>!=0 || (<name>pList</name>-&gt;<name>nExpr</name>==0 &amp;&amp; <name>pList</name>-&gt;<name>nAlloc</name>==0)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>-&gt;<name>nExpr</name>&lt;=<name>pList</name>-&gt;<name>nAlloc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** These routines are Walker callbacks.  Walker.u.pi is a pointer
** to an integer.  These routines are checking an expression to see
** if it is a constant.  Set *Walker.u.pi to 0 if the expression is
** not constant.
**
** These callback routines are used to implement the following:
**
**     sqlite3ExprIsConstant()
**     sqlite3ExprIsConstantNotJoin()
**     sqlite3ExprIsConstantOrFunction()
**
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>exprNodeIsConstant</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{

  <comment type="block">/* If pWalker-&gt;u.i is 3 then any term of the expression that comes from
  ** the ON or USING clauses of a join disqualifies the expression
  ** from being considered constant. */</comment>
  <if>if<condition>( <expr><name>pWalker</name>-&gt;<name>u</name>.<name>i</name>==3 &amp;&amp; <call><name>ExprHasAnyProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pWalker</name>-&gt;<name>u</name>.<name>i</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  }</block></then></if>

  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <comment type="block">/* Consider functions to be constant if all their arguments are constant
    ** and pWalker-&gt;u.i==2 */</comment>
    <case>case <expr><name>TK_FUNCTION</name></expr>:
      <if>if<condition>( <expr><name>pWalker</name>-&gt;<name>u</name>.<name>i</name>==2</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
      <comment type="block">/* Fall through */</comment>
    </case><case>case <expr><name>TK_ID</name></expr>:
    </case><case>case <expr><name>TK_COLUMN</name></expr>:
    </case><case>case <expr><name>TK_AGG_FUNCTION</name></expr>:
    </case><case>case <expr><name>TK_AGG_COLUMN</name></expr>:
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    </case><case>case <expr><name>TK_SELECT</name></expr>:
    </case><case>case <expr><name>TK_EXISTS</name></expr>:
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_ID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_AGG_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWalker</name>-&gt;<name>u</name>.<name>i</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    </case><default>default:
      <return>return <expr><name>WRC_Continue</name></expr>;</return>
  </default>}</block></switch>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>selectNodeIsConstant</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWalker</name>-&gt;<name>u</name>.<name>i</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>WRC_Abort</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>exprIsConst</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>initFlag</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>w</name>.<name>u</name>.<name>i</name> = <name>initFlag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xExprCallback</name> = <name>exprNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xSelectCallback</name> = <name>selectNodeIsConstant</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>w</name>.<name>u</name>.<name>i</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return 1 if the expression is constant
** and 0 if it involves variables or function calls.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstant</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return 1 if the expression is constant
** that does no originate from the ON or USING clauses of a join.
** Return 0 if it involves variables or function calls or terms from
** an ON or USING clause.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantNotJoin</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Walk an expression tree.  Return 1 if the expression is constant
** or a function call with constant arguments.  Return and 0 if there
** are any variables.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsConstantOrFunction</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>exprIsConst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** If the expression p codes a constant integer that is small enough
** to fit in a 32-bit integer, return 1 and put the value of the integer
** in *pValue.  If the expression is not an integer or if it is too big
** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprIsInteger</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pValue</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>EP_IntValue</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pValue</name> = <name>p</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <switch>switch<condition>( <expr><name>p</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_INTEGER</name></expr>: <block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3GetInt32</name><argument_list>(<argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_UPLUS</name></expr>: <block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_UMINUS</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>sqlite3ExprIsInteger</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr>*<name>pValue</name> = -<name>v</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><default>default: <break>break;</break>
  </default>}</block></switch>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>op</name> = <name>TK_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> |= <name>EP_IntValue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iTable</name> = *<name>pValue</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the given string is a row-id column name.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsRowid</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>"_ROWID_"</expr></argument>)</argument_list></call>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>"ROWID"</expr></argument>)</argument_list></call>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>"OID"</expr></argument>)</argument_list></call>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Return true if the IN operator optimization is enabled and
** the SELECT statement p exists and is of the
** simple form:
**
**     SELECT &lt;column&gt; FROM &lt;table&gt;
**
** If this is the case, it may be possible to use an existing table
** or index instead of generating an epheremal table.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>static</name> <name>int</name></type> <name>isCandidateForInOpt</name><parameter_list>(<param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>                   <comment type="block">/* right-hand side of IN is SELECT */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrior</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>              <comment type="block">/* Not a compound SELECT */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>selFlags</name> &amp; (<name>SF_Distinct</name>|<name>SF_Aggregate</name>)</expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return> <comment type="block">/* No DISTINCT keyword and no aggregate functions */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pGroupBy</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>            <comment type="block">/* Has no GROUP BY clause */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pLimit</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>              <comment type="block">/* Has no LIMIT clause */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pOffset</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pWhere</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>              <comment type="block">/* Has no WHERE clause */</comment>
  <expr_stmt><expr><name>pSrc</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSrc</name>-&gt;<name>nSrc</name>!=1</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>          <comment type="block">/* Single term in FROM clause */</comment>
  <if>if<condition>( <expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pSelect</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>     <comment type="block">/* FROM clause is not a subquery */</comment>
  <expr_stmt><expr><name>pTab</name> = <name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pTab</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>          <comment type="block">/* FROM clause is not a view */</comment>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>        <comment type="block">/* FROM clause not a virtual table */</comment>
  <expr_stmt><expr><name>pEList</name> = <name>p</name>-&gt;<name>pEList</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pEList</name>-&gt;<name>nExpr</name>!=1</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>       <comment type="block">/* One column in the result set */</comment>
  <if>if<condition>( <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if> <comment type="block">/* Result is a column */</comment>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<comment type="block">/*
** This function is used by the implementation of the IN (...) operator.
** It's job is to find or create a b-tree structure that may be used
** either to test for membership of the (...) set or to iterate through
** its members, skipping duplicates.
**
** The cursor opened on the structure (database table, database index 
** or ephermal table) is stored in pX-&gt;iTable before this function returns.
** The returned value indicates the structure type, as follows:
**
**   IN_INDEX_ROWID - The cursor was opened on a database table.
**   IN_INDEX_INDEX - The cursor was opened on a database index.
**   IN_INDEX_EPH -   The cursor was opened on a specially created and
**                    populated epheremal table.
**
** An existing structure may only be used if the SELECT is of the simple
** form:
**
**     SELECT &lt;column&gt; FROM &lt;table&gt;
**
** If prNotFound parameter is 0, then the structure will be used to iterate
** through the set members, skipping any duplicates. In this case an
** epheremal table must be used unless the selected &lt;column&gt; is guaranteed
** to be unique - either because it is an INTEGER PRIMARY KEY or it
** is unique by virtue of a constraint or implicit index.
**
** If the prNotFound parameter is not 0, then the structure will be used 
** for fast set membership tests. In this case an epheremal table must 
** be used unless &lt;column&gt; is an INTEGER PRIMARY KEY or an index can 
** be found with &lt;column&gt; as its left-most column.
**
** When the structure is being used for set membership tests, the user
** needs to know whether or not the structure contains an SQL NULL 
** value in order to correctly evaluate expressions like "X IN (Y, Z)".
** If there is a chance that the structure may contain a NULL value at
** runtime, then a register is allocated and the register number written
** to *prNotFound. If there is no chance that the structure contains a
** NULL value, then *prNotFound is left unchanged.
**
** If a register is allocated and its location stored in *prNotFound, then
** its initial value is NULL. If the structure does not remain constant
** for the duration of the query (i.e. the set is a correlated sub-select), 
** the value of the allocated register is reset to NULL each time the 
** structure is repopulated. This allows the caller to use vdbe code 
** equivalent to the following:
**
**   if( register==NULL ){
**     has_null = &lt;test if data structure contains null&gt;
**     register = 1
**   }
**
** in order to avoid running the &lt;test if data structure contains null&gt;
** test more often than is necessary.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3FindInIndex</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pX</name></decl></param>, <param><decl><type><name>int</name> *</type><name>prNotFound</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Select</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> =<init> <expr><name>pParse</name>-&gt;<name>nTab</name>++</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mustBeUnique</name> =<init> <expr>!<name>prNotFound</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The follwing if(...) expression is true if the SELECT is of the 
  ** simple form:
  **
  **     SELECT &lt;column&gt; FROM &lt;table&gt;
  **
  ** If this is the case, it may be possible to use an existing table
  ** or index instead of generating an epheremal table.
  */</comment>
  <expr_stmt><expr><name>p</name> = <name>pX</name>-&gt;<name>pSelect</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>isCandidateForInOpt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name> =<init> <expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>pExpr</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* This function is only called from two places. In both cases the vdbe
    ** has already been allocated. So assume sqlite3GetVdbe() is always
    ** successful here.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iMem</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>p</name>-&gt;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pTab</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>iAddr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eType</name> = <name>IN_INDEX_ROWID</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* The collation sequence used by the comparison. If an index is to 
      ** be used in place of a temp-table, it must be ordered according
      ** to this collation sequence.
      */</comment>
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pReq</name> =<init> <expr><call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Check that the affinity that will be used to perform the 
      ** comparison is the same as the affinity of the column. If
      ** it is not, it is not possible to use any index.
      */</comment>
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>p</name>-&gt;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pTab</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>aff</name> =<init> <expr><call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>affinity_ok</name> =<init> <expr>(<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>affinity</name>==<name>aff</name>||<name>aff</name>==<name>SQLITE_AFF_NONE</name>)</expr></init></decl>;</decl_stmt>

      <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name> &amp;&amp; <name>eType</name>==0 &amp;&amp; <name>affinity_ok</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
        <if>if<condition>( <expr>(<name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr>0</expr>]</index></name>==<name>iCol</name>)
         &amp;&amp; (<name>pReq</name>==<call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)
         &amp;&amp; (!<name>mustBeUnique</name> || (<name>pIdx</name>-&gt;<name>nColumn</name>==1 &amp;&amp; <name>pIdx</name>-&gt;<name>onError</name>!=<name>OE_None</name>))</expr>
        )</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iMem</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>iAddr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> *</type><name>pKey</name></decl>;</decl_stmt>
  
          <expr_stmt><expr><name>pKey</name> = (<name>char</name> *)<call><name>sqlite3IndexKeyinfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>iAddr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>,
                               <argument><expr><name>pKey</name></expr></argument>,<argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%s", <name>pIdx</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>eType</name> = <name>IN_INDEX_INDEX</name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>prNotFound</name> &amp;&amp; !<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>notNull</name></expr> )</condition><then><block>{
            <expr_stmt><expr>*<name>prNotFound</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
    }</block></else></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>eType</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rMayHaveNull</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>eType</name> = <name>IN_INDEX_EPH</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>prNotFound</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>prNotFound</name> = <name>rMayHaveNull</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pX</name>-&gt;<name>pLeft</name>-&gt;<name>iColumn</name>&lt;0 &amp;&amp; <name>pX</name>-&gt;<name>pSelect</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>eType</name> = <name>IN_INDEX_ROWID</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>, <argument><expr><name>eType</name>==<name>IN_INDEX_ROWID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pX</name>-&gt;<name>iTable</name> = <name>iTab</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>eType</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate code for scalar subqueries used as an expression
** and IN operators.  Examples:
**
**     (SELECT a FROM b)          -- subquery
**     EXISTS (SELECT a FROM b)   -- EXISTS subquery
**     x IN (4,5,11)              -- IN operator with list on right-hand side
**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right
**
** The pExpr parameter describes the expression that contains the IN
** operator or subquery.
**
** If parameter isRowid is non-zero, then expression pExpr is guaranteed
** to be of the form "&lt;rowid&gt; IN (?, ?, ?)", where &lt;rowid&gt; is a reference
** to some integer key column of a table B-Tree. In this case, use an
** intkey B-Tree to store the set of IN(...) values instead of the usual
** (slower) variable length keys B-Tree.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3CodeSubselect</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, 
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>rMayHaveNull</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>isRowid</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>testAddr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                       <comment type="block">/* One-time test address */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>


  <comment type="block">/* This code must be run in its entirety every time it is encountered
  ** if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can run this code just once
  ** save the results, and reuse the same result on subsequent invocations.
  */</comment>
  <if>if<condition>( <expr>!<call><name>ExprHasAnyProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_VarSelect</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>pParse</name>-&gt;<name>trigStack</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>mem</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>testAddr</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testAddr</name>&gt;0 || <name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_IN</name></expr>: <block>{
      <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name></type> <name>keyInfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>        <comment type="block">/* Address of OP_OpenEphemeral instruction */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></init></decl>;</decl_stmt>

      <if>if<condition>( <expr><name>rMayHaveNull</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <expr_stmt><expr><name>affinity</name> = <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Whether this is an 'x IN(SELECT...)' or an 'x IN(&lt;exprlist&gt;)'
      ** expression it is handled the same way. A virtual table is 
      ** filled with single-field index keys representing the results
      ** from the SELECT or the &lt;exprlist&gt;.
      **
      ** If the 'x' expression is a column value, or the SELECT...
      ** statement returns a column value, then the affinity of that
      ** column is used to build the index keys. If both 'x' and the
      ** SELECT... statement are columns, then numeric affinity is used
      ** if either column has NUMERIC or INTEGER affinity. If neither
      ** 'x' nor the SELECT... statement are columns, then numeric affinity
      ** is used.
      */</comment>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr>!<name>isRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>keyInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>keyInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>keyInfo</name>.<name>nField</name> = 1</expr>;</expr_stmt>

      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
        <comment type="block">/* Case 1:     expr IN (SELECT ...)
        **
        ** Generate code to write the results of the select into the temporary
        ** table allocated and opened above.
        */</comment>
        <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>isRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_Set</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dest</name>.<name>affinity</name> = (<name>u8</name>)<name>affinity</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pExpr</name>-&gt;<name>iTable</name>&amp;0x0000FFFF)==<name>pExpr</name>-&gt;<name>iTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pSelect</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>pEList</name> = <name>pExpr</name>-&gt;<name>pSelect</name>-&gt;<name>pEList</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pEList</name> &amp;&amp; <name>pEList</name>-&gt;<name>nExpr</name>&gt;0</expr> )</condition><then><block>{ 
          <expr_stmt><expr><name>keyInfo</name>.<name><name>aColl</name><index>[<expr>0</expr>]</index></name> = <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>,
              <argument><expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pList</name></expr> )</condition><then><block>{
        <comment type="block">/* Case 2:     expr IN (exprlist)
        **
        ** For each expression, build an index key from the evaluation and
        ** store it in the temporary table. If &lt;expr&gt; is a column, then use
        ** that columns affinity when building index keys. If &lt;expr&gt; is not
        ** a column, use numeric affinity.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name>, <name>r2</name>, <name>r3</name></decl>;</decl_stmt>

        <if>if<condition>( <expr>!<name>affinity</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>affinity</name> = <name>SQLITE_AFF_NONE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>keyInfo</name>.<name><name>aColl</name><index>[<expr>0</expr>]</index></name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Loop through each expression in &lt;exprlist&gt;. */</comment>
        <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=<name>pList</name>-&gt;<name>nExpr</name></expr>, <expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&gt;0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>Expr</name> *</type><name>pE2</name> =<init> <expr><name>pItem</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>

          <comment type="block">/* If the expression is not constant then we will need to
          ** disable the test that was generated above that makes sure
          ** this code only executes once.  Because for a non-constant
          ** expression we need to rerun this code each time.
          */</comment>
          <if>if<condition>( <expr><name>testAddr</name> &amp;&amp; !<call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pE2</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testAddr</name>-1</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>testAddr</name> = 0</expr>;</expr_stmt>
          }</block></then></if>

          <comment type="block">/* Evaluate the expression and insert it into the temp table */</comment>
          <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>r3</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>

          <if>if<condition>( <expr><name>isRowid</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr>&amp;<name>affinity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
      <if>if<condition>( <expr>!<name>isRowid</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>(<name>void</name> *)&amp;<name>keyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>

    </case><case>case <expr><name>TK_EXISTS</name></expr>:
    </case><case>case <expr><name>TK_SELECT</name></expr>: <block>{
      <comment type="block">/* This has to be a scalar SELECT.  Generate code to put the
      ** value of this select in a memory cell and record the number
      ** of the memory cell in iColumn.
      */</comment>
      <decl_stmt><decl><type><name>static</name> <name>const</name> <name>Token</name></type> <name>one</name> =<init> <expr><block>{ <expr>(<name>u8</name>*)"1"</expr>, <expr>0</expr>, <expr>1</expr> }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Select</name> *</type><name>pSel</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>pSel</name> = <name>pExpr</name>-&gt;<name>pSelect</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_SELECT</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>dest</name>.<name>eDest</name> = <name>SRT_Mem</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dest</name>.<name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "Init subquery result")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>dest</name>.<name>eDest</name> = <name>SRT_Exists</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dest</name>.<name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "Init EXISTS result")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pSel</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSel</name>-&gt;<name>pLimit</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iColumn</name> = <name>dest</name>.<name>iParm</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </case>}</block></switch>

  <if>if<condition>( <expr><name>testAddr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testAddr</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SUBQUERY */</comment>

<comment type="block">/*
** Duplicate an 8-byte value
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>dup8bytes</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>out</name> =<init> <expr><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>out</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>out</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate an instruction that will put the floating point
** value described by z[0..n-1] into register iMem.
**
** The z[] string will probably not be zero-terminated.  But the 
** z[n] character is guaranteed to be something that does not look
** like the continuation of the number.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeReal</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>negateFlag</name></decl></param>, <param><decl><type><name>int</name></type> <name>iMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name> || <name>v</name>==0 || <call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>z</name> || !<call><name>isdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zV</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr><name>negateFlag</name></expr> )</condition><then> <expr_stmt><expr><name>value</name> = -<name>value</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>zV</name> = <call><name>dup8bytes</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>char</name>*)&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Real</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zV</name></expr></argument>, <argument><expr><name>P4_REAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>


<comment type="block">/*
** Generate an instruction that will put the integer describe by
** text z[0..n-1] into register iMem.
**
** The z[] string will probably not be zero-terminated.  But the 
** z[n] character is guaranteed to be something that does not look
** like the continuation of the number.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeInteger</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>negFlag</name></decl></param>, <param><decl><type><name>int</name></type> <name>iMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>flags</name> &amp; <name>EP_IntValue</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pExpr</name>-&gt;<name>iTable</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>negFlag</name></expr> )</condition><then> <expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr>(<name>z</name> = (<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<call><name>isdigit</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3GetInt32</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>negFlag</name></expr> )</condition><then> <expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>sqlite3FitsIn64Bits</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>negFlag</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zV</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>negFlag</name></expr> )</condition><then> <expr_stmt><expr><name>value</name> = -<name>value</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>zV</name> = <call><name>dup8bytes</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>char</name>*)&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Int64</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zV</name></expr></argument>, <argument><expr><name>P4_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>negFlag</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then></if></else></if>
}</block></function>


<comment type="block">/*
** Generate code that will extract the iColumn-th column from
** table pTab and store the column value in a register.  An effort
** is made to store the column value in register iReg, but this is
** not guaranteed.  The location of the column value is returned.
**
** There must be an open cursor to pTab in iTable when this routine
** is called.  If iColumn&lt;0 then code is generated that extracts the rowid.
**
** This routine might attempt to reuse the value of the column that
** has already been loaded into a register.  The value will always
** be used if it has not undergone any affinity changes.  But if
** an affinity change has occurred, then the cached value will only be
** used if allowAffChng is true.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeGetColumn</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,   <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,     <comment type="block">/* Description of the table we are reading from */</comment>
  <param><decl><type><name>int</name></type> <name>iColumn</name></decl></param>,     <comment type="block">/* Index of the table column */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,      <comment type="block">/* The cursor pointing to the table */</comment>
  <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>,        <comment type="block">/* Store results here */</comment>
  <param><decl><type><name>int</name></type> <name>allowAffChng</name></decl></param> <comment type="block">/* True if prior affinity changes are OK */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>yColCache</name> *</type><name>p</name></decl>;</decl_stmt>

  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>p</name>=<name>pParse</name>-&gt;<name>aColCache</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>p</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>iTable</name>==<name>iTable</name> &amp;&amp; <name>p</name>-&gt;<name>iColumn</name>==<name>iColumn</name>
           &amp;&amp; (!<name>p</name>-&gt;<name>affChange</name> || <name>allowAffChng</name>)</expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
      sqlite3VdbeAddOp0(v, OP_Noop);
      VdbeComment((v, "OPT: tab%d.col%d -&gt; r%d", iTable, iColumn, p-&gt;iReg));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return <expr><name>p</name>-&gt;<name>iReg</name></expr>;</return>
    }</block></then></if>
  }</block></for>  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iColumn</name>&lt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr>(<name>pTab</name> &amp;&amp; <call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>) ? <name>OP_VRowid</name> : <name>OP_Rowid</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> ? <name>OP_VColumn</name> : <name>OP_Column</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name>.<name>affinity</name>==<name>SQLITE_AFF_REAL</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RealAffinity</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if></else></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>i</name> = <name>pParse</name>-&gt;<name>iColCache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = &amp;<name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iTable</name> = <name>iTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iColumn</name> = <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iReg</name> = <name>iReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>affChange</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>i</name>&gt;=<call><name>ArraySize</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>aColCache</name></expr></argument>)</argument_list></call></expr> )</condition><then> <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><name>i</name>&gt;<name>pParse</name>-&gt;<name>nColCache</name></expr> )</condition><then> <expr_stmt><expr><name>pParse</name>-&gt;<name>nColCache</name> = <name>i</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>iColCache</name> = <name>i</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>iReg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Clear all column cache entries associated with the vdbe
** cursor with cursor number iTable.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprClearColumnCache</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>iTable</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nColCache</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>iColCache</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iTable</name>==<name>iTable</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>i</name>==<name>pParse</name>-&gt;<name>nColCache</name>-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr>--<name>pParse</name>-&gt;<name>nColCache</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pParse</name>-&gt;<name>iColCache</name> = <name>pParse</name>-&gt;<name>nColCache</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Record the fact that an affinity change has occurred on iCount
** registers starting with iStart.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCacheAffinityChange</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iStart</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCount</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name> =<init> <expr><name>iStart</name> + <name>iCount</name> - 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> =<init> <expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iReg</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>r</name>&gt;=<name>iStart</name> &amp;&amp; <name>r</name>&lt;=<name>iEnd</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>affChange</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Generate code to move content from registers iFrom...iFrom+nReg-1
** over to iTo..iTo+nReg-1. Keep the column cache up-to-date.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeMove</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iFrom</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTo</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>iFrom</name>==<name>iTo</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>OP_Move</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>, <argument><expr><name>nReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name> =<init> <expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iReg</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>x</name>&gt;=<name>iFrom</name> &amp;&amp; <name>x</name>&lt;<name>iFrom</name>+<name>nReg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iReg</name> += <name>iTo</name>-<name>iFrom</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Generate code to copy content from registers iFrom...iFrom+nReg-1
** over to iTo..iTo+nReg-1.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeCopy</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iFrom</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTo</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>iFrom</name>==<name>iTo</name></expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nReg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>iFrom</name>+<name>i</name></expr></argument>, <argument><expr><name>iTo</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<comment type="block">/*
** Return true if any register in the range iFrom..iTo (inclusive)
** is used as part of the column cache.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>usedAsColumnCache</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iFrom</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r</name> =<init> <expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iReg</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>r</name>&gt;=<name>iFrom</name> &amp;&amp; <name>r</name>&lt;=<name>iTo</name></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** There is a value in register iReg.
**
** We are going to modify the value, so we need to make sure it
** is not a cached register.  If iReg is a cached register,
** then clear the corresponding cache line.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprWritableRegister</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>usedAsColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nColCache</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iReg</name>==<name>iReg</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pParse</name>-&gt;<name><name>aColCache</name><index>[<expr>--<name>pParse</name>-&gt;<name>nColCache</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pParse</name>-&gt;<name>iColCache</name> = <name>pParse</name>-&gt;<name>nColCache</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** If the last instruction coded is an ephemeral copy of any of
** the registers in the nReg registers beginning with iReg, then
** convert the last instruction from OP_SCopy to OP_Copy.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprHardCopy</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> = <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name> || <name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name> &amp;&amp; <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_SCopy</name> &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&gt;=<name>iReg</name> &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>iReg</name>+<name>nReg</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_Copy</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Generate code to store the value of the iAlias-th alias in register
** target.  The first time this is called, pExpr is evaluated to compute
** the value of the alias.  The value is stored in an auxiliary register
** and the number of that register is returned.  On subsequent calls,
** the register number is returned without generating any code.
**
** Note that in order for this to work, code must be generated in the
** same order that it is executed.
**
** Aliases are numbered starting with 1.  So iAlias is in the range
** of 1 to pParse-&gt;nAlias inclusive.  
**
** pParse-&gt;aAlias[iAlias-1] records the register number where the value
** of the iAlias-th alias is stored.  If zero, that means that the
** alias has not yet been computed.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>codeAlias</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iAlias</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>target</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nAliasAlloc</name>&lt;<name>pParse</name>-&gt;<name>nAlias</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>aAlias</name> = <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>aAlias</name></expr></argument>,
                                 <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name><name>aAlias</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>pParse</name>-&gt;<name>nAlias</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name> &amp;&amp; <name>pParse</name>-&gt;<name>nAliasAlloc</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pParse</name>-&gt;<name><name>aAlias</name><index>[<expr><name>pParse</name>-&gt;<name>nAliasAlloc</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
           <argument><expr>(<name>pParse</name>-&gt;<name>nAlias</name>-<name>pParse</name>-&gt;<name>nAliasAlloc</name>)*<call><name>sizeof</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name><name>aAlias</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nAliasAlloc</name> = <name>pParse</name>-&gt;<name>nAlias</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iAlias</name>&gt;0 &amp;&amp; <name>iAlias</name>&lt;=<name>pParse</name>-&gt;<name>nAlias</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iReg</name> = <name>pParse</name>-&gt;<name><name>aAlias</name><index>[<expr><name>iAlias</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iReg</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pParse</name>-&gt;<name>disableColCache</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>iReg</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>iReg</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aAlias</name><index>[<expr><name>iAlias</name>-1</expr>]</index></name> = <name>iReg</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>iReg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code into the current Vdbe to evaluate the given
** expression.  Attempt to store the results in register "target".
** Return the register where results are stored.
**
** With this routine, there is no guarantee that results will
** be stored in target.  The result might be stored in some other
** register if it is convenient to do so.  The calling function
** must check the return code and move the results to the desired
** register.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTarget</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>target</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The VM under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                   <comment type="block">/* The opcode being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name> =<init> <expr><name>target</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Results stored in register inReg */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* If non-zero free this temporary register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name>, <name>r2</name>, <name>r3</name>, <name>r4</name></decl>;</decl_stmt>       <comment type="block">/* Various register numbers */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0 || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name>&gt;0 &amp;&amp; <name>target</name>&lt;=<name>pParse</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>op</name> = <name>TK_NULL</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>op</name> = <name>pExpr</name>-&gt;<name>op</name></expr>;</expr_stmt>
  }</block></else></if>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>: <block>{
      <decl_stmt><decl><type><name>AggInfo</name> *</type><name>pAggInfo</name> =<init> <expr><name>pExpr</name>-&gt;<name>pAggInfo</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>AggInfo_col</name> *</type><name>pCol</name> =<init> <expr>&amp;<name>pAggInfo</name>-&gt;<name><name>aCol</name><index>[<expr><name>pExpr</name>-&gt;<name>iAgg</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>!<name>pAggInfo</name>-&gt;<name>directMode</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCol</name>-&gt;<name>iMem</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> = <name>pCol</name>-&gt;<name>iMem</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then><else>else <if>if<condition>( <expr><name>pAggInfo</name>-&gt;<name>useSortingIdx</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>pAggInfo</name>-&gt;<name>sortingIdx</name></expr></argument>,
                              <argument><expr><name>pCol</name>-&gt;<name>iSorterColumn</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if></else></if>
      <comment type="block">/* Otherwise, fall thru into the TK_COLUMN case */</comment>
    }</block>
    </case><case>case <expr><name>TK_COLUMN</name></expr>: <block>{
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iTable</name>&lt;0</expr> )</condition><then><block>{
        <comment type="block">/* This only happens when coding check constraints */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>ckBase</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> = <name>pExpr</name>-&gt;<name>iColumn</name> + <name>pParse</name>-&gt;<name>ckBase</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr>(<name>pExpr</name>-&gt;<name>flags</name> &amp; <name>EP_AnyAff</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> = <call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pTab</name></expr></argument>,
                                 <argument><expr><name>pExpr</name>-&gt;<name>iColumn</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                 <argument><expr><name>pExpr</name>-&gt;<name>flags</name> &amp; <name>EP_AnyAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_INTEGER</name></expr>: <block>{
      <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_FLOAT</name></expr>: <block>{
      <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_STRING</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3DequoteExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>OP_String8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_NULL</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
    </case><case>case <expr><name>TK_BLOB</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zBlob</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>&gt;=3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>=='x' || <name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>=='X'</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>1</expr>]</index></name>=='\''</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>-1</expr>]</index></name>=='\''</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> = <name>pExpr</name>-&gt;<name>token</name>.<name>n</name> - 3</expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> = (<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name> + 2</expr>;</expr_stmt>
      <expr_stmt><expr><name>zBlob</name> = <call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr><name>n</name>/2</expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>TK_VARIABLE</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Variable</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>&gt;1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_REGISTER</name></expr>: <block>{
      <expr_stmt><expr><name>inReg</name> = <name>pExpr</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_AS</name></expr>: <block>{
      <expr_stmt><expr><name>inReg</name> = <call><name>codeAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
    </case><case>case <expr><name>TK_CAST</name></expr>: <block>{
      <comment type="block">/* Expressions of the form:   CAST(pLeft AS token) */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>aff</name>, <name>to_op</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>inReg</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aff</name> = <call><name>sqlite3AffinityType</name><argument_list>(<argument><expr>&amp;<name>pExpr</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>to_op</name> = <name>aff</name> - <name>SQLITE_AFF_TEXT</name> + <name>OP_ToText</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToText</name>    || <name>aff</name>!=<name>SQLITE_AFF_TEXT</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToBlob</name>    || <name>aff</name>!=<name>SQLITE_AFF_NONE</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToNumeric</name> || <name>aff</name>!=<name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToInt</name>     || <name>aff</name>!=<name>SQLITE_AFF_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToReal</name>    || <name>aff</name>!=<name>SQLITE_AFF_REAL</name></expr></argument>    )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToText</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToBlob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToNumeric</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToInt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>to_op</name>==<name>OP_ToReal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>inReg</name>!=<name>target</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inReg</name> = <name>target</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>to_op</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><call><name>usedAsColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>
    </case><case>case <expr><name>TK_LT</name></expr>:
    </case><case>case <expr><name>TK_LE</name></expr>:
    </case><case>case <expr><name>TK_GT</name></expr>:
    </case><case>case <expr><name>TK_GE</name></expr>:
    </case><case>case <expr><name>TK_NE</name></expr>:
    </case><case>case <expr><name>TK_EQ</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name>==<name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name>==<name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name>==<name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name>==<name>OP_Ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_EQ</name>==<name>OP_Eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NE</name>==<name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompareOperands</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>r1</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>,
                                  <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>r2</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_AND</name></expr>:
    </case><case>case <expr><name>TK_OR</name></expr>:
    </case><case>case <expr><name>TK_PLUS</name></expr>:
    </case><case>case <expr><name>TK_STAR</name></expr>:
    </case><case>case <expr><name>TK_MINUS</name></expr>:
    </case><case>case <expr><name>TK_REM</name></expr>:
    </case><case>case <expr><name>TK_BITAND</name></expr>:
    </case><case>case <expr><name>TK_BITOR</name></expr>:
    </case><case>case <expr><name>TK_SLASH</name></expr>:
    </case><case>case <expr><name>TK_LSHIFT</name></expr>:
    </case><case>case <expr><name>TK_RSHIFT</name></expr>: 
    </case><case>case <expr><name>TK_CONCAT</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_AND</name>==<name>OP_And</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_OR</name>==<name>OP_Or</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_PLUS</name>==<name>OP_Add</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_MINUS</name>==<name>OP_Subtract</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_REM</name>==<name>OP_Remainder</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITAND</name>==<name>OP_BitAnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITOR</name>==<name>OP_BitOr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_SLASH</name>==<name>OP_Divide</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LSHIFT</name>==<name>OP_ShiftLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_RSHIFT</name>==<name>OP_ShiftRight</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_CONCAT</name>==<name>OP_Concat</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_PLUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_MINUS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_REM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_BITAND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_BITOR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_SLASH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_RSHIFT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_CONCAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_UMINUS</name></expr>: <block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>op</name>==<name>TK_FLOAT</name> || <name>pLeft</name>-&gt;<name>op</name>==<name>TK_INTEGER</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>op</name>==<name>TK_FLOAT</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>codeReal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pLeft</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pLeft</name>-&gt;<name>token</name>.<name>n</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>codeInteger</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>regFree1</name> = <name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r2</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Subtract</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>inReg</name> = <name>target</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_BITNOT</name></expr>:
    </case><case>case <expr><name>TK_NOT</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_BITNOT</name>==<name>OP_BitNot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOT</name>==<name>OP_Not</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_BITNOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NOT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>inReg</name> = <name>target</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_ISNULL</name></expr>:
    </case><case>case <expr><name>TK_NOTNULL</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name>==<name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name>==<name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_AGG_FUNCTION</name></expr>: <block>{
      <decl_stmt><decl><type><name>AggInfo</name> *</type><name>pInfo</name> =<init> <expr><name>pExpr</name>-&gt;<name>pAggInfo</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pInfo</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"misuse of aggregate: %T"</expr></argument>,
            <argument><expr>&amp;<name>pExpr</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>inReg</name> = <name>pInfo</name>-&gt;<name><name>aFunc</name><index>[<expr><name>pExpr</name>-&gt;<name>iAgg</name></expr>]</index></name>.<name>iMem</name></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_CONST_FUNC</name></expr>:
    </case><case>case <expr><name>TK_FUNCTION</name></expr>: <block>{
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> =<init> <expr><name>pList</name> ? <name>pList</name>-&gt;<name>nExpr</name> : 0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nId</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zId</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>constMask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> =<init> <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_CONST_FUNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_FUNCTION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zId</name> = (<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nId</name> = <name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDef</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zId</name></expr></argument>, <argument><expr><name>nId</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDef</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>nExpr</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>nExpr</name> = <name>r1</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <comment type="block">/* Possibly overload the function if the first argument is
      ** a virtual table column.
      **
      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the
      ** second argument, not the first, as the argument to test to
      ** see if it is a column in a virtual table.  This is done because
      ** the left operand of infix functions (the operand we want to
      ** control overloading) ends up as the second argument to the
      ** function.  The expression "A glob B" is equivalent to 
      ** "glob(B,A).  We want to use the A in "A glob B" to test
      ** for function overloading.  But we use the B term in "glob(B,A)".
      */</comment>
      <if>if<condition>( <expr><name>nExpr</name>&gt;=2 &amp;&amp; (<name>pExpr</name>-&gt;<name>flags</name> &amp; <name>EP_InfixFunc</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDef</name> = <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>nExpr</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDef</name> = <call><name>sqlite3VtabOverloadFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nExpr</name> &amp;&amp; <name>i</name>&lt;32</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><call><name>sqlite3ExprIsConstant</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>constMask</name> |= (1&lt;&lt;<name>i</name>)</expr>;</expr_stmt>
        }</block></then></if>
        <if>if<condition>( <expr>(<name>pDef</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_NEEDCOLL</name>)!=0 &amp;&amp; !<name>pColl</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>pDef</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then> <expr_stmt><expr><name>pColl</name> = <name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt></then></if> 
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>char</name> *)<name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Function</name></expr></argument>, <argument><expr><name>constMask</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                        <argument><expr>(<name>char</name>*)<name>pDef</name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nExpr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    </case><case>case <expr><name>TK_EXISTS</name></expr>:
    </case><case>case <expr><name>TK_SELECT</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_EXISTS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_SELECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iColumn</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3CodeSubselect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>inReg</name> = <name>pExpr</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_IN</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rNotFound</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rMayHaveNull</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j2</name>, <name>j3</name>, <name>j4</name>, <name>j5</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "begin IN expr r%d", <name>target</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>eType</name> = <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>rMayHaveNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rMayHaveNull</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rNotFound</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="block">/* Figure out the affinity to use to create a key from the results
      ** of the expression. affinityStr stores a static string suitable for
      ** P4 of OP_MakeRecord.
      */</comment>
      <expr_stmt><expr><name>affinity</name> = <call><name>comparisonAffinity</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


      <comment type="block">/* Code the &lt;expr&gt; from "&lt;expr&gt; IN (...)". The temporary table
      ** pExpr-&gt;iTable contains the values that make up the (...) set.
      */</comment>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><name>j2</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>eType</name>==<name>IN_INDEX_ROWID</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>j3</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j4</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j5</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>r2</name> = <name>regFree2</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Create a record and test for set membership. If the set contains
        ** the value, then jump to the end of the test code. The target
        ** register still contains the true (1) value written to it earlier.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr>&amp;<name>affinity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j5</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the set membership test fails, then the result of the 
        ** "x IN (...)" expression must be either 0 or NULL. If the set
        ** contains no NULL values, then the result is 0. If the set 
        ** contains one or more NULL values, then the result of the
        ** expression is also NULL.
        */</comment>
        <if>if<condition>( <expr><name>rNotFound</name>==0</expr> )</condition><then><block>{
          <comment type="block">/* This branch runs if it is known at compile time (now) that 
          ** the set contains no NULL values. This happens as the result
          ** of a "NOT NULL" constraint in the database schema. No need
          ** to test the data structure at runtime in this case.
          */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <comment type="block">/* This block populates the rNotFound register with either NULL
          ** or 0 (an integer value). If the data structure contains one
          ** or more NULLs, then set rNotFound to NULL. Otherwise, set it
          ** to 0. If register rMayHaveNull is already set to some value
          ** other than NULL, then the test has already been run and 
          ** rNotFound is already populated.
          */</comment>
          <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>nullRecord</name><index>[]</index></name> =<init> <expr><block>{ <expr>0x02</expr>, <expr>0x00</expr> }</block></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>j3</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Blob</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>, <argument><expr>0</expr></argument>, 
                             <argument><expr><name>nullRecord</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>j4</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rMayHaveNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Copy the value of register rNotFound (which is either NULL or 0)
          ** into the target register. This will be the result of the
          ** expression.
          */</comment>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>rNotFound</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "end IN expr r%d", <name>target</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
    **    x BETWEEN y AND z
    **
    ** This is equivalent to
    **
    **    x&gt;=y AND x&lt;=z
    **
    ** X is stored in pExpr-&gt;pLeft.
    ** Y is stored in pExpr-&gt;pList-&gt;a[0].pExpr.
    ** Z is stored in pExpr-&gt;pList-&gt;a[1].pExpr.
    */</comment>
    </case><case>case <expr><name>TK_BETWEEN</name></expr>: <block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pLItem</name> =<init> <expr><name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pRight</name> =<init> <expr><name>pLItem</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>codeCompareOperands</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>r1</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>,
                                  <argument><expr><name>pRight</name></expr></argument>, <argument><expr>&amp;<name>r2</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r3</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r4</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLItem</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> = <name>pLItem</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r2</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>OP_Le</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>, <argument><expr><name>SQLITE_STOREP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_And</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_UPLUS</name></expr>: <block>{
      <expr_stmt><expr><name>inReg</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/*
    ** Form A:
    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form B:
    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form A is can be transformed into the equivalent form B as follows:
    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...
    **        WHEN x=eN THEN rN ELSE y END
    **
    ** X (if it exists) is in pExpr-&gt;pLeft.
    ** Y is in pExpr-&gt;pRight.  The Y is also optional.  If there is no
    ** ELSE clause and no other term matches, then the result of the
    ** exprssion is NULL.
    ** Ei is in pExpr-&gt;pList-&gt;a[i*2] and Ri is pExpr-&gt;pList-&gt;a[i*2+1].
    **
    ** The result of the expression is the Ri for the first matching Ei,
    ** or if there is no matching Ei, the ELSE term Y, or if there is
    ** no ELSE term, NULL.
    */</comment>
    </case><case>case <expr><name>TK_CASE</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>endLabel</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for end of CASE stmt */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nextCase</name></decl>;</decl_stmt>                     <comment type="block">/* GOTO label for next WHEN clause */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>                        <comment type="block">/* 2x number of WHEN terms */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name></decl>;</decl_stmt>                 <comment type="block">/* List of WHEN terms */</comment>
      <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>aListelem</name></decl>;</decl_stmt>  <comment type="block">/* Array of WHEN terms */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>opCompare</name></decl>;</decl_stmt>                   <comment type="block">/* The X==Ei expression */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>cacheX</name></decl>;</decl_stmt>                      <comment type="block">/* Cached expression X */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pX</name></decl>;</decl_stmt>                         <comment type="block">/* The X expression */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pTest</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                  <comment type="block">/* X==Ei (form A) or just Ei (form B) */</comment>

      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name> % 2) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEList</name> = <name>pExpr</name>-&gt;<name>pList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>aListelem</name> = <name>pEList</name>-&gt;<name>a</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExpr</name> = <name>pEList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>endLabel</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>pX</name> = <name>pExpr</name>-&gt;<name>pLeft</name>)!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>cacheX</name> = *<name>pX</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pX</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> || <name>pX</name>-&gt;<name>op</name>==<name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cacheX</name>.<name>iTable</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cacheX</name>.<name>op</name> = <name>TK_REGISTER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>opCompare</name>.<name>op</name> = <name>TK_EQ</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>opCompare</name>.<name>pLeft</name> = &amp;<name>cacheX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTest</name> = &amp;<name>opCompare</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>=<name>i</name>+2</expr></incr>)<block>{
        <if>if<condition>( <expr><name>pX</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTest</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>opCompare</name>.<name>pRight</name> = <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>pTest</name> = <name><name>aListelem</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>nextCase</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTest</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> || <name>pTest</name>-&gt;<name>op</name>==<name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTest</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name>+1</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name>+1</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name>==<name>TK_REGISTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>aListelem</name><index>[<expr><name>i</name>+1</expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nextCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pRight</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
    </case><case>case <expr><name>TK_RAISE</name></expr>: <block>{
      <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>trigStack</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                       <argument><expr>"RAISE() may only be used within a trigger-program"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
      <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iColumn</name>!=<name>OE_Ignore</name></expr> )</condition><then><block>{
         <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>iColumn</name>==<name>OE_Rollback</name> ||
                 <name>pExpr</name>-&gt;<name>iColumn</name> == <name>OE_Abort</name> ||
                 <name>pExpr</name>-&gt;<name>iColumn</name> == <name>OE_Fail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>sqlite3DequoteExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iColumn</name></expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
         <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>iColumn</name> == <name>OE_Ignore</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ContextPop</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>trigStack</name>-&gt;<name>ignoreJump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "raise(IGNORE)")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>inReg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code to evaluate an expression and store the results
** into a register.  Return the register number where the results
** are stored.
**
** If the register is a temporary register that can be deallocated,
** then write its number into *pReg.  If the result register is not
** a temporary, then set *pReg to zero.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeTemp</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r2</name> =<init> <expr><call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>r2</name>==<name>r1</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pReg</name> = <name>r1</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pReg</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>r2</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCode</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>target</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name>&gt;0 &amp;&amp; <name>target</name>&lt;=<name>pParse</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>inReg</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>pVdbe</name> || <name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>inReg</name>!=<name>target</name> &amp;&amp; <name>pParse</name>-&gt;<name>pVdbe</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>target</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code that evalutes the given expression and puts the result
** in register target.
**
** Also make a copy of the expression results into another "cache" register
** and modify the expression so that the next time it is evaluated,
** the result is a copy of the cache register.
**
** This routine is used for expressions that are used multiple 
** times.  They are evaluated once and the results of the expression
** are reused.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeAndCache</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>target</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inReg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>inReg</name> = <call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_REGISTER</name></expr> )</condition><then><block>{  
    <decl_stmt><decl><type><name>int</name></type> <name>iMem</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>iMem</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>inReg</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>iMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>TK_REGISTER</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>inReg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if pExpr is an constant expression that is appropriate
** for factoring out of a loop.  Appropriate expressions are:
**
**    *  Any expression that evaluates to two or more opcodes.
**
**    *  Any OP_Integer, OP_Real, OP_String, OP_Blob, OP_Null, 
**       or OP_Variable that does not need to be placed in a 
**       specific register.
**
** There is no point in factoring out single-instruction constant
** expressions that need to be placed in a particular register.  
** We could factor them out, but then we would end up adding an
** OP_SCopy instruction to move the value into the correct register
** later.  We might as well just use the original instruction and
** avoid the OP_SCopy.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>isAppropriateForFactoring</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>  <comment type="block">/* Only constant expressions are appropriate for factoring */</comment>
  }</block></then></if>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name> &amp; <name>EP_FixedDest</name>)==0</expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>  <comment type="block">/* Any constant without a fixed destination is appropriate */</comment>
  }</block></then></if>
  <while>while<condition>( <expr><name>p</name>-&gt;<name>op</name>==<name>TK_UPLUS</name></expr> )</condition> <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pLeft</name></expr>;</expr_stmt></while>
  <switch>switch<condition>( <expr><name>p</name>-&gt;<name>op</name></expr> )</condition><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
    <case>case <expr><name>TK_BLOB</name></expr>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>TK_VARIABLE</name></expr>:
    </case><case>case <expr><name>TK_INTEGER</name></expr>:
    </case><case>case <expr><name>TK_FLOAT</name></expr>:
    </case><case>case <expr><name>TK_NULL</name></expr>:
    </case><case>case <expr><name>TK_STRING</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_BLOB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_VARIABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_INTEGER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_FLOAT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Single-instruction constants with a fixed destination are
      ** better done in-line.  If we factor them, they will just end
      ** up generating an OP_SCopy to move the value to the destination
      ** register. */</comment>
      <return>return <expr>0</expr>;</return>
    }</block>
    </case><case>case <expr><name>TK_UMINUS</name></expr>: <block>{
       <if>if<condition>( <expr><name>p</name>-&gt;<name>pLeft</name>-&gt;<name>op</name>==<name>TK_FLOAT</name> || <name>p</name>-&gt;<name>pLeft</name>-&gt;<name>op</name>==<name>TK_INTEGER</name></expr> )</condition><then><block>{
         <return>return <expr>0</expr>;</return>
       }</block></then></if>
       <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** If pExpr is a constant expression that is appropriate for
** factoring out of a loop, then evaluate the expression
** into a register and convert the expression into a TK_REGISTER
** expression.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>evalConstExpr</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWalker</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_REGISTER</name></expr>: <block>{
      <return>return <expr>1</expr>;</return>
    }</block>
    </case><case>case <expr><name>TK_FUNCTION</name></expr>:
    </case><case>case <expr><name>TK_AGG_FUNCTION</name></expr>:
    </case><case>case <expr><name>TK_CONST_FUNC</name></expr>: <block>{
      <comment type="block">/* The arguments to a function have a fixed destination.
      ** Mark them this way to avoid generated unneeded OP_SCopy
      ** instructions. 
      */</comment>
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pList</name>-&gt;<name>nExpr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name> =<init> <expr><name>pList</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
        <for>for(<init>;</init> <condition><expr><name>i</name>&gt;0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><name>pItem</name>-&gt;<name>pExpr</name></expr> )</condition><then> <expr_stmt><expr><name>pItem</name>-&gt;<name>pExpr</name>-&gt;<name>flags</name> |= <name>EP_FixedDest</name></expr>;</expr_stmt></then></if>
        }</block></for>
      }</block></then></if>
      <break>break;</break>
    }</block>
  </case>}</block></switch>
  <if>if<condition>( <expr><call><name>isAppropriateForFactoring</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>r2</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>r1</name>!=<name>r2</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>TK_REGISTER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>r2</name></expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Preevaluate constant subexpressions within pExpr and store the
** results in registers.  Modify pExpr so that the constant subexpresions
** are TK_REGISTER opcodes that refer to the precomputed values.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprCodeConstants</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>w</name>.<name>xExprCallback</name> = <name>evalConstExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xSelectCallback</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Generate code that pushes the value of every element of the given
** expression list into a sequence of registers beginning at target.
**
** Return the number of elements evaluated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCodeExprList</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,   <comment type="block">/* The expression list to be coded */</comment>
  <param><decl><type><name>int</name></type> <name>target</name></decl></param>,        <comment type="block">/* Where to write results */</comment>
  <param><decl><type><name>int</name></type> <name>doHardCopy</name></decl></param>     <comment type="block">/* Make a hard copy of every element */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>target</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pItem</name>-&gt;<name>iAlias</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iReg</name> =<init> <expr><call><name>codeAlias</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>iAlias</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>target</name>+<name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>iReg</name>!=<name>target</name>+<name>i</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>target</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>target</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>doHardCopy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprHardCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is true but execution
** continues straight thru if the expression is false.
**
** If the expression evaluates to NULL (neither true nor false), then
** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.
**
** This code depends on the fact that certain token values (ex: TK_EQ)
** are the same as opcode values (ex: OP_Eq) that implement the corresponding
** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in
** the make process cause these values to align.  Assert()s in the code
** below verify that the numbers are aligned correctly.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfTrue</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>dest</name></decl></param>, <param><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name>, <name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name>==<name>SQLITE_JUMPIFNULL</name> || <name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0 || <name>pExpr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>op</name> = <name>pExpr</name>-&gt;<name>op</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_AND</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>d2</name> =<init> <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>,<argument><expr><name>jumpIfNull</name>^<name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_OR</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_NOT</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_LT</name></expr>:
    </case><case>case <expr><name>TK_LE</name></expr>:
    </case><case>case <expr><name>TK_GT</name></expr>:
    </case><case>case <expr><name>TK_GE</name></expr>:
    </case><case>case <expr><name>TK_NE</name></expr>:
    </case><case>case <expr><name>TK_EQ</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name>==<name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name>==<name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name>==<name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name>==<name>OP_Ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_EQ</name>==<name>OP_Eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NE</name>==<name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompareOperands</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>r1</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>,
                                  <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>r2</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_ISNULL</name></expr>:
    </case><case>case <expr><name>TK_NOTNULL</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_ISNULL</name>==<name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_NOTNULL</name>==<name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_BETWEEN</name></expr>: <block>{
      <comment type="block">/*    x BETWEEN y AND z
      **
      ** Is equivalent to 
      **
      **    x&gt;=y AND x&lt;=z
      **
      ** Code it as such, taking care to do the common subexpression
      ** elementation of x.
      */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>exprAnd</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>compLeft</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>compRight</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>exprX</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>exprX</name> = *<name>pExpr</name>-&gt;<name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>op</name> = <name>TK_AND</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>pLeft</name> = &amp;<name>compLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>pRight</name> = &amp;<name>compRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>op</name> = <name>TK_GE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>pLeft</name> = &amp;<name>exprX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>op</name> = <name>TK_LE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>pLeft</name> = &amp;<name>exprX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprX</name>.<name>iTable</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>exprX</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprX</name>.<name>op</name> = <name>TK_REGISTER</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name>!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
}</block></function>

<comment type="block">/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is false but execution
** continues straight thru if the expression is true.
**
** If the expression evaluates to NULL (neither true nor false) then
** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull
** is 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprIfFalse</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>dest</name></decl></param>, <param><decl><type><name>int</name></type> <name>jumpIfNull</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regFree2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name>, <name>r2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>jumpIfNull</name>==<name>SQLITE_JUMPIFNULL</name> || <name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0 || <name>pExpr</name>==0</expr> )</condition><then> <return>return;</return></then></if>

  <comment type="block">/* The value of pExpr-&gt;op and op are related as follows:
  **
  **       pExpr-&gt;op            op
  **       ---------          ----------
  **       TK_ISNULL          OP_NotNull
  **       TK_NOTNULL         OP_IsNull
  **       TK_NE              OP_Eq
  **       TK_EQ              OP_Ne
  **       TK_GT              OP_Le
  **       TK_LE              OP_Gt
  **       TK_GE              OP_Lt
  **       TK_LT              OP_Ge
  **
  ** For other values of pExpr-&gt;op, op is undefined and unused.
  ** The value of TK_ and OP_ constants are arranged such that we
  ** can compute the mapping above using the following expression.
  ** Assert()s verify that the computation is correct.
  */</comment>
  <expr_stmt><expr><name>op</name> = ((<name>pExpr</name>-&gt;<name>op</name>+(<name>TK_ISNULL</name>&amp;1))^1)-(<name>TK_ISNULL</name>&amp;1)</expr>;</expr_stmt>

  <comment type="block">/* Verify correct alignment of TK_ and OP_ constants
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_ISNULL</name> || <name>op</name>==<name>OP_NotNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_NOTNULL</name> || <name>op</name>==<name>OP_IsNull</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_NE</name> || <name>op</name>==<name>OP_Eq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_EQ</name> || <name>op</name>==<name>OP_Ne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_LT</name> || <name>op</name>==<name>OP_Ge</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_LE</name> || <name>op</name>==<name>OP_Gt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_GT</name> || <name>op</name>==<name>OP_Le</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_GE</name> || <name>op</name>==<name>OP_Lt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_AND</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_OR</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>d2</name> =<init> <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>, <argument><expr><name>jumpIfNull</name>^<name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_NOT</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3ExprIfTrue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_LT</name></expr>:
    </case><case>case <expr><name>TK_LE</name></expr>:
    </case><case>case <expr><name>TK_GT</name></expr>:
    </case><case>case <expr><name>TK_GE</name></expr>:
    </case><case>case <expr><name>TK_NE</name></expr>:
    </case><case>case <expr><name>TK_EQ</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompareOperands</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>r1</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>,
                                  <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>r2</name></expr></argument>, <argument><expr>&amp;<name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeCompare</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>op</name></expr></argument>,
                  <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_ISNULL</name></expr>:
    </case><case>case <expr><name>TK_NOTNULL</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>TK_NOTNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_BETWEEN</name></expr>: <block>{
      <comment type="block">/*    x BETWEEN y AND z
      **
      ** Is equivalent to 
      **
      **    x&gt;=y AND x&lt;=z
      **
      ** Code it as such, taking care to do the common subexpression
      ** elementation of x.
      */</comment>
      <decl_stmt><decl><type><name>Expr</name></type> <name>exprAnd</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>compLeft</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>compRight</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name></type> <name>exprX</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>exprX</name> = *<name>pExpr</name>-&gt;<name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>op</name> = <name>TK_AND</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>pLeft</name> = &amp;<name>compLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprAnd</name>.<name>pRight</name> = &amp;<name>compRight</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>op</name> = <name>TK_GE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>pLeft</name> = &amp;<name>exprX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compLeft</name>.<name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>op</name> = <name>TK_LE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>pLeft</name> = &amp;<name>exprX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compRight</name>.<name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprX</name>.<name>iTable</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>exprX</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>exprX</name>.<name>op</name> = <name>TK_REGISTER</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>exprAnd</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>jumpIfNull</name>!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>regFree1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>jumpIfNull</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Do a deep comparison of two expression trees.  Return TRUE (non-zero)
** if they are identical and return FALSE if they differ in any way.
**
** Sometimes this routine will return FALSE even if the two expressions
** really are equivalent.  If we cannot prove that the expressions are
** identical, we return FALSE just to be safe.  So if this routine
** returns false, then you do not really know for certain if the two
** expressions are the same.  But if you get a TRUE return, then you
** can be sure the expressions are the same.  In the places where
** this routine is used, it does not hurt to get an extra FALSE - that
** just might result in some slightly slower code.  But returning
** an incorrect TRUE could lead to a malfunction.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ExprCompare</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pA</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pB</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pA</name>==0||<name>pB</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>pB</name>==<name>pA</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pA</name>-&gt;<name>op</name>!=<name>pB</name>-&gt;<name>op</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr>(<name>pA</name>-&gt;<name>flags</name> &amp; <name>EP_Distinct</name>)!=(<name>pB</name>-&gt;<name>flags</name> &amp; <name>EP_Distinct</name>)</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr>!<call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pA</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pB</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr>!<call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pA</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>pB</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>pA</name>-&gt;<name>pList</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pB</name>-&gt;<name>pList</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <if>if<condition>( <expr><name>pA</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name>!=<name>pB</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pA</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr>!<call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pA</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>pB</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></for>
  }</block></then><else>else <if>if<condition>( <expr><name>pB</name>-&gt;<name>pList</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>pA</name>-&gt;<name>pSelect</name> || <name>pB</name>-&gt;<name>pSelect</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>pA</name>-&gt;<name>iTable</name>!=<name>pB</name>-&gt;<name>iTable</name> || <name>pA</name>-&gt;<name>iColumn</name>!=<name>pB</name>-&gt;<name>iColumn</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>pA</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name> &amp;&amp; <name>pA</name>-&gt;<name>token</name>.<name>z</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pB</name>-&gt;<name>token</name>.<name>z</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <if>if<condition>( <expr><name>pB</name>-&gt;<name>token</name>.<name>n</name>!=<name>pA</name>-&gt;<name>token</name>.<name>n</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pA</name>-&gt;<name>token</name>.<name>z</name></expr></argument>,<argument><expr>(<name>char</name>*)<name>pB</name>-&gt;<name>token</name>.<name>z</name></expr></argument>,<argument><expr><name>pB</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aCol[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>addAggInfoColumn</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>AggInfo</name> *</type><name>pInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pInfo</name>-&gt;<name>aCol</name> = <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>,
       <argument><expr><name>pInfo</name>-&gt;<name>aCol</name></expr></argument>,
       <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pInfo</name>-&gt;<name><name>aCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr>3</expr></argument>,
       <argument><expr>&amp;<name>pInfo</name>-&gt;<name>nColumn</name></expr></argument>,
       <argument><expr>&amp;<name>pInfo</name>-&gt;<name>nColumnAlloc</name></expr></argument>,
       <argument><expr>&amp;<name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
}</block></function>    

<comment type="block">/*
** Add a new element to the pAggInfo-&gt;aFunc[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>addAggInfoFunc</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>AggInfo</name> *</type><name>pInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pInfo</name>-&gt;<name>aFunc</name> = <call><name>sqlite3ArrayAllocate</name><argument_list>(
       <argument><expr><name>db</name></expr></argument>, 
       <argument><expr><name>pInfo</name>-&gt;<name>aFunc</name></expr></argument>,
       <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pInfo</name>-&gt;<name><name>aFunc</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr>3</expr></argument>,
       <argument><expr>&amp;<name>pInfo</name>-&gt;<name>nFunc</name></expr></argument>,
       <argument><expr>&amp;<name>pInfo</name>-&gt;<name>nFuncAlloc</name></expr></argument>,
       <argument><expr>&amp;<name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>i</name></expr>;</return>
}</block></function>    

<comment type="block">/*
** This is the xExprCallback for a tree walker.  It is used to
** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates
** for additional information.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>analyzeAggregate</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name> *</type><name>pNC</name> =<init> <expr><name>pWalker</name>-&gt;<name>u</name>.<name>pNC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pNC</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrcList</name> =<init> <expr><name>pNC</name>-&gt;<name>pSrcList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>AggInfo</name> *</type><name>pAggInfo</name> =<init> <expr><name>pNC</name>-&gt;<name>pAggInfo</name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:
    </case><case>case <expr><name>TK_COLUMN</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_AGG_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Check to see if the column is in one of the tables in the FROM
      ** clause of the aggregate query */</comment>
      <if>if<condition>( <expr><name>pSrcList</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr><name>pSrcList</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pSrcList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type>struct <name>AggInfo_col</name> *</type><name>pCol</name></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iTable</name>==<name>pItem</name>-&gt;<name>iCursor</name></expr> )</condition><then><block>{
            <comment type="block">/* If we reach this point, it means that pExpr refers to a table
            ** that is in the FROM clause of the aggregate query.  
            **
            ** Make an entry for the column in pAggInfo-&gt;aCol[] if there
            ** is not an entry there already.
            */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>pCol</name> = <name>pAggInfo</name>-&gt;<name>aCol</name></expr>;</expr_stmt>
            <for>for(<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>pAggInfo</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>k</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
              <if>if<condition>( <expr><name>pCol</name>-&gt;<name>iTable</name>==<name>pExpr</name>-&gt;<name>iTable</name> &amp;&amp;
                  <name>pCol</name>-&gt;<name>iColumn</name>==<name>pExpr</name>-&gt;<name>iColumn</name></expr> )</condition><then><block>{
                <break>break;</break>
              }</block></then></if>
            }</block></for>
            <if>if<condition>( <expr>(<name>k</name>&gt;=<name>pAggInfo</name>-&gt;<name>nColumn</name>)
             &amp;&amp; (<name>k</name> = <call><name>addAggInfoColumn</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call>)&gt;=0</expr> 
            )</condition><then><block>{
              <expr_stmt><expr><name>pCol</name> = &amp;<name>pAggInfo</name>-&gt;<name><name>aCol</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>pTab</name> = <name>pExpr</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>iTable</name> = <name>pExpr</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>iColumn</name> = <name>pExpr</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>iMem</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>iSorterColumn</name> = -1</expr>;</expr_stmt>
              <expr_stmt><expr><name>pCol</name>-&gt;<name>pExpr</name> = <name>pExpr</name></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>pAggInfo</name>-&gt;<name>pGroupBy</name></expr> )</condition><then><block>{
                <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>n</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExprList</name> *</type><name>pGB</name> =<init> <expr><name>pAggInfo</name>-&gt;<name>pGroupBy</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pTerm</name> =<init> <expr><name>pGB</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>n</name> = <name>pGB</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
                <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
                  <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name> =<init> <expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>
                  <if>if<condition>( <expr><name>pE</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> &amp;&amp; <name>pE</name>-&gt;<name>iTable</name>==<name>pExpr</name>-&gt;<name>iTable</name> &amp;&amp;
                      <name>pE</name>-&gt;<name>iColumn</name>==<name>pExpr</name>-&gt;<name>iColumn</name></expr> )</condition><then><block>{
                    <expr_stmt><expr><name>pCol</name>-&gt;<name>iSorterColumn</name> = <name>j</name></expr>;</expr_stmt>
                    <break>break;</break>
                  }</block></then></if>
                }</block></for>
              }</block></then></if>
              <if>if<condition>( <expr><name>pCol</name>-&gt;<name>iSorterColumn</name>&lt;0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>pCol</name>-&gt;<name>iSorterColumn</name> = <name>pAggInfo</name>-&gt;<name>nSortingColumn</name>++</expr>;</expr_stmt>
              }</block></then></if>
            }</block></then></if>
            <comment type="block">/* There is now an entry for pExpr in pAggInfo-&gt;aCol[] (either
            ** because it was there before or because we just created it).
            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that
            ** pAggInfo-&gt;aCol[] entry.
            */</comment>
            <expr_stmt><expr><name>pExpr</name>-&gt;<name>pAggInfo</name> = <name>pAggInfo</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>TK_AGG_COLUMN</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pExpr</name>-&gt;<name>iAgg</name> = <name>k</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if> <comment type="block">/* endif pExpr-&gt;iTable==pItem-&gt;iCursor */</comment>
        }</block></for> <comment type="block">/* end loop over pSrcList */</comment>
      }</block></then></if>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    }</block>
    </case><case>case <expr><name>TK_AGG_FUNCTION</name></expr>: <block>{
      <comment type="block">/* The pNC-&gt;nDepth==0 test causes aggregate functions in subqueries
      ** to be ignored */</comment>
      <if>if<condition>( <expr><name>pNC</name>-&gt;<name>nDepth</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* Check to see if pExpr is a duplicate of another aggregate 
        ** function that is already in the pAggInfo structure
        */</comment>
        <decl_stmt><decl><type>struct <name>AggInfo_func</name> *</type><name>pItem</name> =<init> <expr><name>pAggInfo</name>-&gt;<name>aFunc</name></expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nFunc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><call><name>sqlite3ExprCompare</name><argument_list>(<argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <break>break;</break>
          }</block></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>i</name>&gt;=<name>pAggInfo</name>-&gt;<name>nFunc</name></expr> )</condition><then><block>{
          <comment type="block">/* pExpr is original.  Make a new entry in pAggInfo-&gt;aFunc[]
          */</comment>
          <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> =<init> <expr><call><name>ENC</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>i</name> = <call><name>addAggInfoFunc</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>i</name>&gt;=0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>pItem</name> = &amp;<name>pAggInfo</name>-&gt;<name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pItem</name>-&gt;<name>pExpr</name> = <name>pExpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pItem</name>-&gt;<name>iMem</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pItem</name>-&gt;<name>pFunc</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>,
                   <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>,
                   <argument><expr><name>pExpr</name>-&gt;<name>pList</name> ? <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name> : 0</expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>flags</name> &amp; <name>EP_Distinct</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>pItem</name>-&gt;<name>iDistinct</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><name>pItem</name>-&gt;<name>iDistinct</name> = -1</expr>;</expr_stmt>
            }</block></else></if>
          }</block></then></if>
        }</block></then></if>
        <comment type="block">/* Make pExpr point to the appropriate pAggInfo-&gt;aFunc[] entry
        */</comment>
        <expr_stmt><expr><name>pExpr</name>-&gt;<name>iAgg</name> = <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pExpr</name>-&gt;<name>pAggInfo</name> = <name>pAggInfo</name></expr>;</expr_stmt>
        <return>return <expr><name>WRC_Prune</name></expr>;</return>
      }</block></then></if>
    }</block>
  </case>}</block></switch>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>analyzeAggregatesInSelect</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>NameContext</name> *</type><name>pNC</name> =<init> <expr><name>pWalker</name>-&gt;<name>u</name>.<name>pNC</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pNC</name>-&gt;<name>nDepth</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pNC</name>-&gt;<name>nDepth</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNC</name>-&gt;<name>nDepth</name>--</expr>;</expr_stmt>
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr><name>WRC_Continue</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Analyze the given expression looking for aggregate functions and
** for variables that need to be added to the pParse-&gt;aAgg[] array.
** Make additional entries to the pParse-&gt;aAgg[] array as necessary.
**
** This routine should only be called after the expression has been
** analyzed by sqlite3ResolveExprNames().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggregates</name><parameter_list>(<param><decl><type><name>NameContext</name> *</type><name>pNC</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>w</name>.<name>xExprCallback</name> = <name>analyzeAggregate</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xSelectCallback</name> = <name>analyzeAggregatesInSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>u</name>.<name>pNC</name> = <name>pNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkExpr</name><argument_list>(<argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Call sqlite3ExprAnalyzeAggregates() for every expression in an
** expression list.  Return the number of errors.
**
** If an error is found, the analysis is cut short.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExprAnalyzeAggList</name><parameter_list>(<param><decl><type><name>NameContext</name> *</type><name>pNC</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr><name>pNC</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Allocate or deallocate temporary use registers during code generation.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempReg</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nTempReg</name>==0</expr> )</condition><then><block>{
    <return>return <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>pParse</name>-&gt;<name><name>aTempReg</name><index>[<expr>--<name>pParse</name>-&gt;<name>nTempReg</name></expr>]</index></name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempReg</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>iReg</name> &amp;&amp; <name>pParse</name>-&gt;<name>nTempReg</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>aTempReg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprWritableRegister</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name><name>aTempReg</name><index>[<expr><name>pParse</name>-&gt;<name>nTempReg</name>++</expr>]</index></name> = <name>iReg</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Allocate or deallocate a block of nReg consecutive registers
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GetTempRange</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> = <name>pParse</name>-&gt;<name>iRangeReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>pParse</name>-&gt;<name>nRangeReg</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nReg</name>&lt;=<name>n</name> &amp;&amp; !<call><name>usedAsColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name>+<name>n</name>-1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>iRangeReg</name> += <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nRangeReg</name> -= <name>nReg</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>i</name> = <name>pParse</name>-&gt;<name>nMem</name>+1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>nReg</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3ReleaseTempRange</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReg</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>nReg</name>&gt;<name>pParse</name>-&gt;<name>nRangeReg</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nRangeReg</name> = <name>nReg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>iRangeReg</name> = <name>iReg</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
</unit>
