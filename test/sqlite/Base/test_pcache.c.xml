<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="test_pcache.c" filename=""><comment type="block">/*
** 2008 November 18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** 
** This file contains code used for testing the SQLite system.
** None of the code in this file goes into a deliverable build.
** 
** This file contains an application-defined pager cache
** implementation that can be plugged in in place of the
** default pcache.  This alternative pager cache will throw
** some errors that the default cache does not.
**
** This pagecache implementation is designed for simplicity
** not speed.  
**
** $Id: test_pcache.c,v 1.2 2009/01/07 03:59:47 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Global data used by this test implementation.  There is no
** mutexing, which means this page cache will not work in a
** multi-threaded test.
*/</comment>
<typedef>typedef <type><struct>struct <name>testpcacheGlobalType</name> testpcacheGlobalType;</struct></type></typedef>
<struct>struct <name>testpcacheGlobalType</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>void</name> *</type><name>pDummy</name></decl>;</decl_stmt>             <comment type="block">/* Dummy allocation to simulate failures */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInstance</name></decl>;</decl_stmt>            <comment type="block">/* Number of current instances */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>discardChance</name></decl>;</decl_stmt>   <comment type="block">/* Chance of discarding on an unpin (0-100) */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>prngSeed</name></decl>;</decl_stmt>        <comment type="block">/* Seed for the PRNG */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>highStress</name></decl>;</decl_stmt>      <comment type="block">/* Call xStress agressively */</comment>
</public>}</block>;</struct>
<decl_stmt><decl><type><name>static</name> <name>testpcacheGlobalType</name></type> <name>testpcacheGlobal</name></decl>;</decl_stmt>

<comment type="block">/*
** Initializer.
**
** Verify that the initializer is only called when the system is
** uninitialized.  Allocate some memory and report SQLITE_NOMEM if
** the allocation fails.  This provides a means to test the recovery
** from a failed initialization attempt.  It also verifies that the
** the destructor always gets call - otherwise there would be a
** memory leak.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>testpcacheInit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArg</name>==(<name>void</name>*)&amp;<name>testpcacheGlobal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>pDummy</name> = <call><name>sqlite3_malloc</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>testpcacheGlobal</name>.<name>pDummy</name>==0 ? <name>SQLITE_NOMEM</name> : <name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Destructor
**
** Verify that this is only called after initialization.
** Free the memory allocated by the initializer.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheShutdown</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArg</name>==(<name>void</name>*)&amp;<name>testpcacheGlobal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>pDummy</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Number of pages in a cache
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TESTPCACHE_NPAGE</name>    217</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TESTPCACHE_RESERVE</name>   17</cpp:define>

<comment type="block">/*
** Magic numbers used to determine validity of the page cache.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TESTPCACHE_VALID</name>  0x364585fd</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TESTPCACHE_CLEAR</name>  0xd42670d4</cpp:define>

<comment type="block">/*
** Private implementation of a page cache.
*/</comment>
<typedef>typedef <type><struct>struct <name>testpcache</name> testpcache;</struct></type></typedef>
<struct>struct <name>testpcache</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>               <comment type="block">/* Size of each page.  Multiple of 8. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPurgeable</name></decl>;</decl_stmt>           <comment type="block">/* True if the page cache is purgeable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name></decl>;</decl_stmt>                <comment type="block">/* Number of unused slots in a[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPinned</name></decl>;</decl_stmt>              <comment type="block">/* Number of pinned slots in a[] */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>iRand</name></decl>;</decl_stmt>           <comment type="block">/* State of the PRNG */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>iMagic</name></decl>;</decl_stmt>          <comment type="block">/* Magic number for sanity checking */</comment>
  <struct>struct <name>testpcachePage</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>unsigned</name></type> <name>key</name></decl>;</decl_stmt>              <comment type="block">/* The key for this page. 0 means unallocated */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>isPinned</name></decl>;</decl_stmt>              <comment type="block">/* True if the page is pinned */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>pData</name></decl>;</decl_stmt>               <comment type="block">/* Data for this page */</comment>
  </public>}</block> <decl><name><name>a</name><index>[<expr><name>TESTPCACHE_NPAGE</name></expr>]</index></name></decl>;</struct>    <comment type="block">/* All pages in the cache */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Get a random number using the PRNG in the given page cache.
*/</comment>
<function><type><name>static</name> <name>unsigned</name></type> <name>testpcacheRandom</name><parameter_list>(<param><decl><type><name>testpcache</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name></type> <name>x</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>iRand</name> = (<name>p</name>-&gt;<name>iRand</name>*69069 + 5)</expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | ((<name>p</name>-&gt;<name>iRand</name>&gt;&gt;16)&amp;0xff)</expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>x</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Allocate a new page cache instance.
*/</comment>
<function><type><name>static</name> <name>sqlite3_pcache</name> *</type><name>testpcacheCreate</name><parameter_list>(<param><decl><type><name>int</name></type> <name>szPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>bPurgeable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>szPage</name> = (<name>szPage</name>+7)&amp;~7</expr>;</expr_stmt>
  <expr_stmt><expr><name>nMem</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>testpcache</name></expr></argument>)</argument_list></call> + <name>TESTPCACHE_NPAGE</name>*<name>szPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>x</name> = (<name>char</name>*)&amp;<name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>szPage</name> = <name>szPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nFree</name> = <name>TESTPCACHE_NPAGE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iRand</name> = <name>testpcacheGlobal</name>.<name>prngSeed</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>bPurgeable</name> = <name>bPurgeable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iMagic</name> = <name>TESTPCACHE_VALID</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>x</name> += <name>szPage</name></expr></incr>)<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pData</name> = (<name>void</name>*)<name>x</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>nInstance</name>++</expr>;</expr_stmt>
  <return>return <expr>(<name>sqlite3_pcache</name>*)<name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set the cache size
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheCachesize</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>, <param><decl><type><name>int</name></type> <name>newSize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>newSize</name>&gt;=1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the number of pages in the cache that are being used.
** This includes both pinned and unpinned pages.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>testpcachePagecount</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TESTPCACHE_NPAGE</name> - <name>p</name>-&gt;<name>nFree</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Fetch a page.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>testpcacheFetch</name><parameter_list>(
  <param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>,
  <param><decl><type><name>unsigned</name></type> <name>key</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>createFlag</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See if the page is already in cache.  Return immediately if it is */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name>==<name>key</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nPinned</name> &lt;= <name>TESTPCACHE_NPAGE</name> - <name>p</name>-&gt;<name>nFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pData</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* If createFlag is 0, never allocate a new page */</comment>
  <if>if<condition>( <expr><name>createFlag</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* If no pages are available, always fail */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nPinned</name>==<name>TESTPCACHE_NPAGE</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2 */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nPinned</name>&gt;=<name>TESTPCACHE_NPAGE</name>-<name>TESTPCACHE_RESERVE</name> &amp;&amp; <name>createFlag</name>&lt;2</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* Do not allocate if highStress is enabled and createFlag is not 2.  
  **
  ** The highStress setting causes pagerStress() to be called much more
  ** often, which exercises the pager logic more intensely.
  */</comment>
  <if>if<condition>( <expr><name>testpcacheGlobal</name>.<name>highStress</name> &amp;&amp; <name>createFlag</name>&lt;2</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* Find a free page to allocate if there are any free pages.
  ** Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nFree</name>&gt;<name>TESTPCACHE_RESERVE</name> || (<name>createFlag</name>==2 &amp;&amp; <name>p</name>-&gt;<name>nFree</name>&gt;0)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>j</name> = <call><name>testpcacheRandom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> % <name>TESTPCACHE_NPAGE</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name> = (<name>j</name>+1)%<name>TESTPCACHE_NPAGE</name></expr></incr>)<block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name> = <name>key</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>isPinned</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name>-&gt;<name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>nFree</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nPinned</name> &lt;= <name>TESTPCACHE_NPAGE</name> - <name>p</name>-&gt;<name>nFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pData</name></expr>;</return>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* The prior loop always finds a freepage to allocate */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If this cache is not purgeable then we have to fail.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>bPurgeable</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* If there are no free pages, recycle a page.  The page to
  ** recycle is selected at random from all unpinned pages.
  */</comment>
  <expr_stmt><expr><name>j</name> = <call><name>testpcacheRandom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> % <name>TESTPCACHE_NPAGE</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name> = (<name>j</name>+1)%<name>TESTPCACHE_NPAGE</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name>&gt;0 &amp;&amp; <name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>isPinned</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>isPinned</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name>-&gt;<name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nPinned</name> &lt;= <name>TESTPCACHE_NPAGE</name> - <name>p</name>-&gt;<name>nFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pData</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* The previous loop always finds a page to recycle. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Unpin a page.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheUnpin</name><parameter_list>(
  <param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pOldPage</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>discard</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Randomly discard pages as they are unpinned according to the
  ** discardChance setting.  If discardChance is 0, the random discard
  ** never happens.  If discardChance is 100, it always happens.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>bPurgeable</name>
  &amp;&amp; (100-<name>testpcacheGlobal</name>.<name>discardChance</name>) &lt;= (<call><name>testpcacheRandom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>%100)</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>discard</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pData</name>==<name>pOldPage</name></expr> )</condition><then><block>{
      <comment type="block">/* The pOldPage pointer always points to a pinned page */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nPinned</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>discard</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>nFree</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nFree</name>&lt;=<name>TESTPCACHE_NPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* The pOldPage pointer always points to a valid page */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Rekey a single page.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheRekey</name><parameter_list>(
  <param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pOldPage</name></decl></param>,
  <param><decl><type><name>unsigned</name></type> <name>oldKey</name></decl></param>,
  <param><decl><type><name>unsigned</name></type> <name>newKey</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there already exists another page at newKey, verify that
  ** the other page is unpinned and discard it.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name>==<name>newKey</name></expr> )</condition><then><block>{
      <comment type="block">/* The new key is never a page that is already pinned */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nFree</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nFree</name>&lt;=<name>TESTPCACHE_NPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Find the page to be rekeyed and rekey it.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name>==<name>oldKey</name></expr> )</condition><then><block>{
      <comment type="block">/* The oldKey and pOldPage parameters match */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pData</name>==<name>pOldPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Page to be rekeyed must be pinned */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = <name>newKey</name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Rekey is always given a valid page to work with */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Truncate the page cache.  Every page with a key of iLimit or larger
** is discarded.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheTruncate</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>iLimit</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>TESTPCACHE_NPAGE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name>&gt;=<name>iLimit</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isPinned</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>nPinned</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nPinned</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>p</name>-&gt;<name>nFree</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nFree</name>&lt;=<name>TESTPCACHE_NPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Destroy a page cache.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testpcacheDestroy</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>testpcache</name> *</type><name>p</name> =<init> <expr>(<name>testpcache</name>*)<name>pCache</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iMagic</name>==<name>TESTPCACHE_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iMagic</name> = <name>TESTPCACHE_CLEAR</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>nInstance</name>--</expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Invoke this routine to register or unregister the testing pager cache
** implemented by this file.
**
** Install the test pager cache if installFlag is 1 and uninstall it if
** installFlag is 0.
**
** When installing, discardChance is a number between 0 and 100 that
** indicates the probability of discarding a page when unpinning the
** page.  0 means never discard (unless the discard flag is set).
** 100 means always discard.
*/</comment>
<function><type><name>void</name></type> <name>installTestPCache</name><parameter_list>(
  <param><decl><type><name>int</name></type> <name>installFlag</name></decl></param>,            <comment type="block">/* True to install.  False to uninstall. */</comment>
  <param><decl><type><name>unsigned</name></type> <name>discardChance</name></decl></param>,     <comment type="block">/* 0-100.  Chance to discard on unpin */</comment>
  <param><decl><type><name>unsigned</name></type> <name>prngSeed</name></decl></param>,          <comment type="block">/* Seed for the PRNG */</comment>
  <param><decl><type><name>unsigned</name></type> <name>highStress</name></decl></param>         <comment type="block">/* Call xStress agressively */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>sqlite3_pcache_methods</name></type> <name>testPcache</name> =<init> <expr><block>{
    <expr>(<name>void</name>*)&amp;<name>testpcacheGlobal</name></expr>,
    <expr><name>testpcacheInit</name></expr>,
    <expr><name>testpcacheShutdown</name></expr>,
    <expr><name>testpcacheCreate</name></expr>,
    <expr><name>testpcacheCachesize</name></expr>,
    <expr><name>testpcachePagecount</name></expr>,
    <expr><name>testpcacheFetch</name></expr>,
    <expr><name>testpcacheUnpin</name></expr>,
    <expr><name>testpcacheRekey</name></expr>,
    <expr><name>testpcacheTruncate</name></expr>,
    <expr><name>testpcacheDestroy</name></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>sqlite3_pcache_methods</name></type> <name>defaultPcache</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>isInstalled</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>nInstance</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>testpcacheGlobal</name>.<name>pDummy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>discardChance</name>&lt;=100</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>discardChance</name> = <name>discardChance</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>prngSeed</name> = <name>prngSeed</name> ^ (<name>prngSeed</name>&lt;&lt;16)</expr>;</expr_stmt>
  <expr_stmt><expr><name>testpcacheGlobal</name>.<name>highStress</name> = <name>highStress</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>installFlag</name>!=<name>isInstalled</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>installFlag</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_GETPCACHE</name></expr></argument>, <argument><expr>&amp;<name>defaultPcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>defaultPcache</name>.<name>xCreate</name>!=<name>testpcacheCreate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_PCACHE</name></expr></argument>, <argument><expr>&amp;<name>testPcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>defaultPcache</name>.<name>xCreate</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_PCACHE</name></expr></argument>, <argument><expr>&amp;<name>defaultPcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>isInstalled</name> = <name>installFlag</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
</unit>
