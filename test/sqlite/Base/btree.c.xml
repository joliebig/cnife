<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="btree.c" filename=""><comment type="block">/*
** 2004 April 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** $Id: btree.c,v 1.558 2009/01/10 16:15:21 drh Exp $
**
** This file implements a external (disk-based) database using BTrees.
** See the header comment on "btreeInt.h" for additional information.
** Including a description of file format and an overview of operation.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btreeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The header string that appears at the beginning of every
** SQLite database.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>zMagicHeader</name><index>[]</index></name> =<init> <expr><name>SQLITE_FILE_HEADER</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Set this global variable to 1 to enable tracing using the TRACE
** macro.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
int sqlite3BtreeTrace=0;  <comment type="block">/* True to enable tracing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <name>TRACE</name>(X)  if(sqlite3BtreeTrace){printf X;fflush(stdout);}</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>TRACE</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** A list of BtShared objects that are eligible for participation
** in shared cache.  This variable has file scope during normal builds,
** but the test harness needs to access it so we make it global for 
** test builds.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>BtShared</name> *<name>SQLITE_WSD</name></type> <name>sqlite3SharedCacheList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>static</name> <name>BtShared</name> *<name>SQLITE_WSD</name></type> <name>sqlite3SharedCacheList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Enable or disable the shared pager and schema features.
**
** This routine has no effect on existing database connections.
** The shared cache setting effects only future calls to
** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_enable_shared_cache</name><parameter_list>(<param><decl><type><name>int</name></type> <name>enable</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>sharedCacheEnabled</name> = <name>enable</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Forward declaration
*/</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>checkReadLocks</name><parameter_list>(<param><decl><type><name>Btree</name>*</type></decl></param>, <param><decl><type><name>Pgno</name></type></decl></param>, <param><decl><type><name>BtCursor</name>*</type></decl></param>, <param><decl><type><name>i64</name></type></decl></param>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifdef>
  <comment type="block">/*
  ** The functions queryTableLock(), lockTable() and unlockAllTables()
  ** manipulate entries in the BtShared.pLock linked list used to store
  ** shared-cache table level locks. If the library is compiled with the
  ** shared-cache feature disabled, then there is only ever one user
  ** of each BtShared structure and so this locking is not necessary. 
  ** So define the lock related functions as no-ops.
  */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>queryTableLock</name>(a,b,c) SQLITE_OK</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>lockTable</name>(a,b,c) SQLITE_OK</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>unlockAllTables</name>(a)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Query to see if btree handle p may obtain a lock of type eLock 
** (READ_LOCK or WRITE_LOCK) on the table with root-page iTab. Return
** SQLITE_OK if the lock may be obtained (by calling lockTable()), or
** SQLITE_LOCKED if not.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>queryTableLock</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iTab</name></decl></param>, <param><decl><type><name>u8</name></type> <name>eLock</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> *</type><name>pIter</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name>==<name>READ_LOCK</name> || <name>eLock</name>==<name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* This is a no-op if the shared-cache is not enabled */</comment>
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* If some other connection is holding an exclusive lock, the
  ** requested lock may not be obtained.
  */</comment>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pExclusive</name> &amp;&amp; <name>pBt</name>-&gt;<name>pExclusive</name>!=<name>p</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* This (along with lockTable()) is where the ReadUncommitted flag is
  ** dealt with. If the caller is querying for a read-lock and the flag is
  ** set, it is unconditionally granted - even if there are write-locks
  ** on the table. If a write-lock is requested, the ReadUncommitted flag
  ** is not considered.
  **
  ** In function lockTable(), if a read-lock is demanded and the 
  ** ReadUncommitted flag is set, no entry is added to the locks list 
  ** (BtShared.pLock).
  **
  ** To summarize: If the ReadUncommitted flag is set, then read cursors do
  ** not create or respect table locks. The locking procedure for a 
  ** write-cursor does not change.
  */</comment>
  <if>if<condition>( 
    <expr>0==(<name>p</name>-&gt;<name>db</name>-&gt;<name>flags</name>&amp;<name>SQLITE_ReadUncommitted</name>) || 
    <name>eLock</name>==<name>WRITE_LOCK</name> ||
    <name>iTab</name>==<name>MASTER_ROOT</name></expr>
  )</condition><then><block>{
    <for>for(<init><expr><name>pIter</name>=<name>pBt</name>-&gt;<name>pLock</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name>=<name>pIter</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <if>if<condition>( <expr><name>pIter</name>-&gt;<name>pBtree</name>!=<name>p</name> &amp;&amp; <name>pIter</name>-&gt;<name>iTable</name>==<name>iTab</name> &amp;&amp; 
          (<name>pIter</name>-&gt;<name>eLock</name>!=<name>eLock</name> || <name>eLock</name>!=<name>READ_LOCK</name>)</expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Add a lock on the table with root-page iTable to the shared-btree used
** by Btree handle p. Parameter eLock must be either READ_LOCK or 
** WRITE_LOCK.
**
** SQLITE_OK is returned if the lock is added successfully. SQLITE_BUSY and
** SQLITE_NOMEM may also be returned.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>lockTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iTable</name></decl></param>, <param><decl><type><name>u8</name></type> <name>eLock</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> *</type><name>pLock</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> *</type><name>pIter</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eLock</name>==<name>READ_LOCK</name> || <name>eLock</name>==<name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This is a no-op if the shared-cache is not enabled */</comment>
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>SQLITE_OK</name>==<call><name>queryTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the read-uncommitted flag is set and a read-lock is requested,
  ** return early without adding an entry to the BtShared.pLock list. See
  ** comment in function queryTableLock() for more info on handling 
  ** the ReadUncommitted flag.
  */</comment>
  <if>if<condition>( 
    <expr>(<name>p</name>-&gt;<name>db</name>-&gt;<name>flags</name>&amp;<name>SQLITE_ReadUncommitted</name>) &amp;&amp; 
    (<name>eLock</name>==<name>READ_LOCK</name>) &amp;&amp;
    <name>iTable</name>!=<name>MASTER_ROOT</name></expr>
  )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* First search the list for an existing lock on this table. */</comment>
  <for>for(<init><expr><name>pIter</name>=<name>pBt</name>-&gt;<name>pLock</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name>=<name>pIter</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>pIter</name>-&gt;<name>iTable</name>==<name>iTable</name> &amp;&amp; <name>pIter</name>-&gt;<name>pBtree</name>==<name>p</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pLock</name> = <name>pIter</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* If the above search did not find a BtLock struct associating Btree p
  ** with table iTable, allocate one and link it into the list.
  */</comment>
  <if>if<condition>( <expr>!<name>pLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLock</name> = (<name>BtLock</name> *)<call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>BtLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pLock</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>iTable</name> = <name>iTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>pBtree</name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>pNext</name> = <name>pBt</name>-&gt;<name>pLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pLock</name> = <name>pLock</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Set the BtLock.eLock variable to the maximum of the current lock
  ** and the requested lock. This means if a write-lock was already held
  ** and a read-lock requested, we don't incorrectly downgrade the lock.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WRITE_LOCK</name>&gt;<name>READ_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eLock</name>&gt;<name>pLock</name>-&gt;<name>eLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLock</name>-&gt;<name>eLock</name> = <name>eLock</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Release all the table locks (locks obtained via calls to the lockTable()
** procedure) held by Btree handle p.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>unlockAllTables</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtLock</name> **</type><name>ppIter</name> =<init> <expr>&amp;<name>pBt</name>-&gt;<name>pLock</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>sharable</name> || 0==*<name>ppIter</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr>*<name>ppIter</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>BtLock</name> *</type><name>pLock</name> =<init> <expr>*<name>ppIter</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pExclusive</name>==0 || <name>pBt</name>-&gt;<name>pExclusive</name>==<name>pLock</name>-&gt;<name>pBtree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLock</name>-&gt;<name>pBtree</name>==<name>p</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>ppIter</name> = <name>pLock</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>ppIter</name> = &amp;<name>pLock</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>

  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pExclusive</name>==<name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pExclusive</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<function_decl><type><name>static</name> <name>void</name></type> <name>releasePage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list>;</function_decl>  <comment type="block">/* Forward reference */</comment>

<comment type="block">/*
** Verify that the cursor holds a mutex on the BtShared
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>static</name> <name>int</name></type> <name>cursorHoldsMutex</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** Invalidate the overflow page-list cache for cursor pCur, if any.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>invalidateOverflowCache</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>aOverflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>aOverflow</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Invalidate the overflow page-list cache for all cursors opened
** on the shared btree structure pBt.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>invalidateAllOverflowCache</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>p</name>=<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><call><name>invalidateOverflowCache</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>invalidateOverflowCache</name>(x)</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>invalidateAllOverflowCache</name>(x)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Save the current cursor position in the variables BtCursor.nKey 
** and BtCursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>saveCursorPosition</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_VALID</name>==<name>pCur</name>-&gt;<name>eState</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==<name>pCur</name>-&gt;<name>pKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is an intKey table, then the above call to BtreeKeySize()
  ** stores the integer key in pCur-&gt;nKey. In this case this value is
  ** all that is required. Otherwise, if pCur is not open on an intKey
  ** table, then malloc space for and store the pCur-&gt;nKey bytes of key 
  ** data.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; 0==<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>intKey</name></expr>)</condition><then><block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>pKey</name> =<init> <expr><call><name>sqlite3Malloc</name><argument_list>( <argument><expr>(<name>int</name>)<name>pCur</name>-&gt;<name>nKey</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>int</name>)<name>pCur</name>-&gt;<name>nKey</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCur</name>-&gt;<name>pKey</name> = <name>pKey</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>intKey</name> || !<name>pCur</name>-&gt;<name>pKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pCur</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_REQUIRESEEK</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>invalidateOverflowCache</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Save the positions of all cursors except pExcept open on the table 
** with root-page iRoot. Usually, this is called just before cursor
** pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>saveAllCursors</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iRoot</name></decl></param>, <param><decl><type><name>BtCursor</name> *</type><name>pExcept</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExcept</name>==0 || <name>pExcept</name>-&gt;<name>pBt</name>==<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>p</name>=<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>!=<name>pExcept</name> &amp;&amp; (0==<name>iRoot</name> || <name>p</name>-&gt;<name>pgnoRoot</name>==<name>iRoot</name>) &amp;&amp; 
        <name>p</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>saveCursorPosition</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>SQLITE_OK</name>!=<name>rc</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Clear the current cursor position.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeClearCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pKey</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Restore the cursor to the position it was in (or as close to as possible)
** when saveCursorPosition() was called. Note that this call deletes the 
** saved position info stored by saveCursorPosition(), so there can be
** at most one effective restoreCursorPosition() call after each 
** saveCursorPosition().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeRestoreCursorPosition</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>&gt;=<name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_FAULT</name></expr> )</condition><then><block>{
    <return>return <expr><name>pCur</name>-&gt;<name>skip</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pKey</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>nKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>pKey</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name> || <name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>restoreCursorPosition</name>(p) \
  (p-&gt;eState&gt;=CURSOR_REQUIRESEEK ? \
         sqlite3BtreeRestoreCursorPosition(p) : \
         SQLITE_OK)</cpp:define>

<comment type="block">/*
** Determine whether or not a cursor has moved from the position it
** was last placed at.  Cursors can move when the row they are pointing
** at is deleted out from under them.
**
** This routine returns an error code if something goes wrong.  The
** integer *pHasMoved is set to one if the cursor has moved and 0 if not.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorHasMoved</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pHasMoved</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pHasMoved</name> = 1</expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>!=<name>CURSOR_VALID</name> || <name>pCur</name>-&gt;<name>skip</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pHasMoved</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr>*<name>pHasMoved</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Given a page number of a regular database page, return the page
** number for the pointer-map page that contains the entry for the
** input page number.
*/</comment>
<function><type><name>static</name> <name>Pgno</name></type> <name>ptrmapPageno</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nPagesPerMapPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrMap</name>, <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nPagesPerMapPage</name> = (<name>pBt</name>-&gt;<name>usableSize</name>/5)+1</expr>;</expr_stmt>
  <expr_stmt><expr><name>iPtrMap</name> = (<name>pgno</name>-2)/<name>nPagesPerMapPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ret</name> = (<name>iPtrMap</name>*<name>nPagesPerMapPage</name>) + 2</expr>;</expr_stmt> 
  <if>if<condition>( <expr><name>ret</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>ret</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Write an entry into the pointer map.
**
** This routine updates the pointer map entry for page number 'key'
** so that it maps to type 'eType' and parent page number 'pgno'.
** An error code is returned if something goes wrong, otherwise SQLITE_OK.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>ptrmapPut</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>key</name></decl></param>, <param><decl><type><name>u8</name></type> <name>eType</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>parent</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>  <comment type="block">/* The pointer map page */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>pPtrmap</name></decl>;</decl_stmt>      <comment type="block">/* The pointer map data */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrmap</name></decl>;</decl_stmt>     <comment type="block">/* The pointer map page number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>       <comment type="block">/* Offset in pointer map page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The master-journal page number must never be used as a pointer map page */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==<call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>key</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>iPtrmap</name> = <call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr>&amp;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>offset</name> = <call><name>PTRMAP_PTROFFSET</name><argument_list>(<argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPtrmap</name> = (<name>u8</name> *)<call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>eType</name>!=<name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name> || <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pPtrmap</name><index>[<expr><name>offset</name>+1</expr>]</index></name></expr></argument>)</argument_list></call>!=<name>parent</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("PTRMAP_UPDATE: %d-&gt;(%d,%d)\n", <name>key</name>, <name>eType</name>, <name>parent</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name> = <name>eType</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>pPtrmap</name><index>[<expr><name>offset</name>+1</expr>]</index></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read an entry from the pointer map.
**
** This routine retrieves the pointer map entry for page 'key', writing
** the type and parent page number to *pEType and *pPgno respectively.
** An error code is returned if something goes wrong, otherwise SQLITE_OK.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>ptrmapGet</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>key</name></decl></param>, <param><decl><type><name>u8</name> *</type><name>pEType</name></decl></param>, <param><decl><type><name>Pgno</name> *</type><name>pPgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>   <comment type="block">/* The pointer map page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPtrmap</name></decl>;</decl_stmt>       <comment type="block">/* Pointer map page index */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>pPtrmap</name></decl>;</decl_stmt>       <comment type="block">/* Pointer map page data */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* Offset of entry in pointer map */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iPtrmap</name> = <call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr>&amp;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pPtrmap</name> = (<name>u8</name> *)<call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>offset</name> = <call><name>PTRMAP_PTROFFSET</name><argument_list>(<argument><expr><name>iPtrmap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEType</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pEType</name> = <name><name>pPtrmap</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPgno</name></expr> )</condition><then> <expr_stmt><expr>*<name>pPgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pPtrmap</name><index>[<expr><name>offset</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>*<name>pEType</name>&lt;1 || *<name>pEType</name>&gt;5</expr> )</condition><then> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if defined SQLITE_OMIT_AUTOVACUUM */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>ptrmapPut</name>(w,x,y,z) SQLITE_OK</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>ptrmapGet</name>(w,x,y,z) SQLITE_OK</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>ptrmapPutOvfl</name>(y,z) SQLITE_OK</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Given a btree page and a cell index (0 means the first cell on
** the page, 1 means the second cell, and so forth) return a pointer
** to the cell content.
**
** This routine works only for pages that do not contain overflow cells.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>findCell</name>(P,I) \
  ((P)-&gt;aData + ((P)-&gt;maskPage &amp; get2byte(&amp;(P)-&gt;aData[(P)-&gt;cellOffset+2*(I)])))</cpp:define>

<comment type="block">/*
** This a more complex version of findCell() that works for
** pages that do contain overflow cells.  See insert
*/</comment>
<function><type><name>static</name> <name>u8</name> *</type><name>findOverflowCell</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>pPage</name>-&gt;<name>nOverflow</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>_OvflCell</name> *</type><name>pOvfl</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOvfl</name> = &amp;<name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> = <name>pOvfl</name>-&gt;<name>idx</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>k</name>&lt;=<name>iCell</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>k</name>==<name>iCell</name></expr> )</condition><then><block>{
        <return>return <expr><name>pOvfl</name>-&gt;<name>pCell</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>iCell</name>--</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <return>return <expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Parse a cell content block and fill in the CellInfo structure.  There
** are two versions of this function.  sqlite3BtreeParseCell() takes a 
** cell index as the second argument and sqlite3BtreeParseCellPtr() 
** takes a pointer to the body of the cell as its second argument.
**
** Within this file, the parseCell() macro can be called instead of
** sqlite3BtreeParseCellPtr(). Using some compilers, this will be faster.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeParseCellPtr</name><parameter_list>(
  <param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>,         <comment type="block">/* Page containing the cell */</comment>
  <param><decl><type><name>u8</name> *</type><name>pCell</name></decl></param>,              <comment type="block">/* Pointer to the cell text. */</comment>
  <param><decl><type><name>CellInfo</name> *</type><name>pInfo</name></decl></param>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>n</name></decl>;</decl_stmt>                  <comment type="block">/* Number bytes in cell content header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPayload</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes of cell payload */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pInfo</name>-&gt;<name>pCell</name> = <name>pCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>leaf</name>==0 || <name>pPage</name>-&gt;<name>leaf</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>pPage</name>-&gt;<name>childPtrSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>==4-4*<name>pPage</name>-&gt;<name>leaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>hasData</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> += <call><name>getVarint32</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nPayload</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>n</name> += <call><name>getVarint</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>(<name>u64</name>*)&amp;<name>pInfo</name>-&gt;<name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nData</name> = <name>nPayload</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nData</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <call><name>getVarint32</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>nPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nKey</name> = <name>nPayload</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pInfo</name>-&gt;<name>nPayload</name> = <name>nPayload</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInfo</name>-&gt;<name>nHeader</name> = <name>n</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>likely</name><argument_list>(<argument><expr><name>nPayload</name>&lt;=<name>pPage</name>-&gt;<name>maxLocal</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* This is the (easy) common case where the entire payload fits
    ** on the local page.  No overflow is required.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSize</name></decl>;</decl_stmt>          <comment type="block">/* Total size of cell content in bytes */</comment>
    <expr_stmt><expr><name>nSize</name> = <name>nPayload</name> + <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nLocal</name> = (<name>u16</name>)<name>nPayload</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>iOverflow</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>nSize</name> &amp; ~3)==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>nSize</name> = 4</expr>;</expr_stmt>        <comment type="block">/* Minimum cell size is 4 */</comment>
    }</block></then></if>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nSize</name> = (<name>u16</name>)<name>nSize</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* If the payload will not fit completely on the local page, we have
    ** to decide how much to store locally and how much to spill onto
    ** overflow pages.  The strategy is to minimize the amount of unused
    ** space on overflow pages while keeping the amount of local storage
    ** in between minLocal and maxLocal.
    **
    ** Warning:  changing the way overflow payload is distributed in any
    ** way will result in an incompatible file format.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>minLocal</name></decl>;</decl_stmt>  <comment type="block">/* Minimum amount of payload held locally */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>maxLocal</name></decl>;</decl_stmt>  <comment type="block">/* Maximum amount of payload held locally */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>surplus</name></decl>;</decl_stmt>   <comment type="block">/* Overflow payload available for local storage */</comment>

    <expr_stmt><expr><name>minLocal</name> = <name>pPage</name>-&gt;<name>minLocal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>maxLocal</name> = <name>pPage</name>-&gt;<name>maxLocal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>surplus</name> = <name>minLocal</name> + (<name>nPayload</name> - <name>minLocal</name>)%(<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name> - 4)</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>surplus</name> &lt;= <name>maxLocal</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pInfo</name>-&gt;<name>nLocal</name> = (<name>u16</name>)<name>surplus</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pInfo</name>-&gt;<name>nLocal</name> = (<name>u16</name>)<name>minLocal</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>iOverflow</name> = (<name>u16</name>)(<name>pInfo</name>-&gt;<name>nLocal</name> + <name>n</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nSize</name> = <name>pInfo</name>-&gt;<name>iOverflow</name> + 4</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>parseCell</name>(pPage, iCell, pInfo) \
  sqlite3BtreeParseCellPtr((pPage), findCell((pPage), (iCell)), (pInfo))</cpp:define>
<function><type><name>void</name></type> <name>sqlite3BtreeParseCell</name><parameter_list>(
  <param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>,         <comment type="block">/* Page containing the cell */</comment>
  <param><decl><type><name>int</name></type> <name>iCell</name></decl></param>,              <comment type="block">/* The cell index.  First cell is 0 */</comment>
  <param><decl><type><name>CellInfo</name> *</type><name>pInfo</name></decl></param>         <comment type="block">/* Fill in this structure */</comment>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>parseCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Compute the total number of bytes that a Cell needs in the cell
** data area of the btree-page.  The return number includes the cell
** data header and the local payload, but not any overflow page or
** the space used by the cell pointer.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>static</name> <name>u16</name></type> <name>cellSize</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeParseCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>info</name>.<name>nSize</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>static</name> <name>u16</name></type> <name>cellSizePtr</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>u8</name> *</type><name>pCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>info</name>.<name>nSize</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** If the cell pCell, part of page pPage contains a pointer
** to an overflow page, insert an entry into the pointer-map
** for the overflow page.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>ptrmapPutOvflPtr</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>u8</name> *</type><name>pCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCell</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>info</name>.<name>nData</name>+(<name>pPage</name>-&gt;<name>intKey</name>?0:<name>info</name>.<name>nKey</name>))==<name>info</name>.<name>nPayload</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>info</name>.<name>nData</name>+(<name>pPage</name>-&gt;<name>intKey</name>?0:<name>info</name>.<name>nKey</name>))&gt;<name>info</name>.<name>nLocal</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>ovfl</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<comment type="block">/*
** If the cell with index iCell on page pPage contains a pointer
** to an overflow page, insert an entry into the pointer-map
** for the overflow page.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>ptrmapPutOvfl</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCell</name> = <call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>iCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Defragment the page given.  All Cells are moved to the
** end of the page and all free space is collected into one
** big FreeBlk that occurs in between the header and cell
** pointer array and the cell content area.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>defragmentPage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>                    <comment type="block">/* Address of a i-th cell */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                  <comment type="block">/* Offset of first byte after cell pointer array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>                   <comment type="block">/* Offset to the page header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>                  <comment type="block">/* Size of a cell */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>            <comment type="block">/* Number of usable bytes on a page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellOffset</name></decl>;</decl_stmt>            <comment type="block">/* Offset to the cell pointer array */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cbrk</name></decl>;</decl_stmt>                  <comment type="block">/* Offset to the cell content area */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                 <comment type="block">/* Number of cells on the page */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>       <comment type="block">/* The page data */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>temp</name></decl>;</decl_stmt>       <comment type="block">/* Temp area for cell content */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name> &lt;= <name>SQLITE_MAX_PAGE_SIZE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>temp</name> = <call><name>sqlite3PagerTempSpace</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellOffset</name> = <name>pPage</name>-&gt;<name>cellOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> = <name>pPage</name>-&gt;<name>nCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name>==<call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> = <name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cbrk</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>temp</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr><name>usableSize</name> - <name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cbrk</name> = <name>usableSize</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>u8</name> *</type><name>pAddr</name></decl>;</decl_stmt>     <comment type="block">/* The i-th cell pointer */</comment>
    <expr_stmt><expr><name>pAddr</name> = &amp;<name><name>data</name><index>[<expr><name>cellOffset</name> + <name>i</name>*2</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> = <call><name>get2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pc</name>&gt;=<name>usableSize</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>size</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr>&amp;<name><name>temp</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cbrk</name> -= <name>size</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>cbrk</name>&lt;<name>cellOffset</name>+2*<name>nCell</name> || <name>pc</name>+<name>size</name>&gt;<name>usableSize</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cbrk</name>+<name>size</name>&lt;=<name>usableSize</name> &amp;&amp; <name>cbrk</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>temp</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr><name>pAddr</name></expr></argument>, <argument><expr><name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cbrk</name>&gt;=<name>cellOffset</name>+2*<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>, <argument><expr><name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name>+2</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <name>cellOffset</name>+2*<name>nCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cbrk</name>-<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>cbrk</name>-<name>addr</name>!=<name>pPage</name>-&gt;<name>nFree</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate nByte bytes of space on a page.
**
** Return the index into pPage-&gt;aData[] of the first byte of
** the new allocation.  The caller guarantees that there is enough
** space.  This routine will never fail.
**
** If the page contains nBytes of free space but does not contain
** nBytes of contiguous free space, then this routine automatically
** calls defragementPage() to consolidate all free space before 
** allocating the new chunk.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>allocateSpace</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name>, <name>pc</name>, <name>hdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFrag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cellOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Minimum cell size is 4 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nFree</name>&gt;=<name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> -= (<name>u16</name>)<name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nFrag</name> = <name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nFrag</name>&lt;60</expr> )</condition><then><block>{
    <comment type="block">/* Search the freelist looking for a slot big enough to satisfy the
    ** space request. */</comment>
    <expr_stmt><expr><name>addr</name> = <name>hdr</name>+1</expr>;</expr_stmt>
    <while>while<condition>( <expr>(<name>pc</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>)</argument_list></call>)&gt;0</expr> )</condition><block>{
      <expr_stmt><expr><name>size</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>size</name>&gt;=<name>nByte</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> =<init> <expr><name>size</name> - <name>nByte</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>size</name>&lt;<name>nByte</name>+4</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name> = (<name>u8</name>)(<name>nFrag</name> + <name>x</name>)</expr>;</expr_stmt>
          <return>return <expr><name>pc</name></expr>;</return>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name>+2</expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>pc</name> + <name>x</name></expr>;</return>
        }</block></else></if>
      }</block></then></if>
      <expr_stmt><expr><name>addr</name> = <name>pc</name></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>

  <comment type="block">/* Allocate memory from the gap in between the cell pointer array
  ** and the cell content area.
  */</comment>
  <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCell</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellOffset</name> = <name>pPage</name>-&gt;<name>cellOffset</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nFrag</name>&gt;=60 || <name>cellOffset</name> + 2*<name>nCell</name> &gt; <name>top</name> - <name>nByte</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>defragmentPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>top</name> -= <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cellOffset</name> + 2*<name>nCell</name> &lt;= <name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>top</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a section of the pPage-&gt;aData to the freelist.
** The first byte of the new free block is pPage-&gt;aDisk[start]
** and the size of the block is "size" bytes.
**
** Most of the effort here is involved in coalesing adjacent
** free blocks into a single big free block.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>freeSpace</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name>, <name>pbegin</name>, <name>hdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name> =<init> <expr><name>pPage</name>-&gt;<name>aData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>start</name>&gt;=<name>pPage</name>-&gt;<name>hdrOffset</name>+6+(<name>pPage</name>-&gt;<name>leaf</name>?0:4)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>start</name> + <name>size</name>)&lt;=<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>size</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Minimum cell size is 4 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SECURE_DELETE</name></cpp:ifdef>
  <comment type="block">/* Overwrite deleted information with zeros when the SECURE_DELETE 
  ** option is enabled at compile-time */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>start</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Add the space back into the linked list of freeblocks */</comment>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <name>hdr</name> + 1</expr>;</expr_stmt>
  <while>while<condition>( <expr>(<name>pbegin</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>)</argument_list></call>)&lt;<name>start</name> &amp;&amp; <name>pbegin</name>&gt;0</expr> )</condition><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbegin</name>&lt;=<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>-4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pbegin</name>&lt;=<name>addr</name></expr> )</condition><then> <block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>addr</name> = <name>pbegin</name></expr>;</expr_stmt>
  }</block></while>
  <if>if <condition>( <expr><name>pbegin</name>&gt;<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>-4</expr> )</condition><then> <block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbegin</name>&gt;<name>addr</name> || <name>pbegin</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>start</name></expr>]</index></name></expr></argument>, <argument><expr><name>pbegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>start</name>+2</expr>]</index></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> += (<name>u16</name>)<name>size</name></expr>;</expr_stmt>

  <comment type="block">/* Coalesce adjacent free blocks */</comment>
  <expr_stmt><expr><name>addr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name> + 1</expr>;</expr_stmt>
  <while>while<condition>( <expr>(<name>pbegin</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>addr</name></expr>]</index></name></expr></argument>)</argument_list></call>)&gt;0</expr> )</condition><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pnext</name>, <name>psize</name>, <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbegin</name>&gt;<name>addr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pbegin</name>&lt;=<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>-4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pnext</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>psize</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pbegin</name> + <name>psize</name> + 3 &gt;= <name>pnext</name> &amp;&amp; <name>pnext</name>&gt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>frag</name> =<init> <expr><name>pnext</name> - (<name>pbegin</name>+<name>psize</name>)</expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>(<name>frag</name>&lt;0) || (<name>frag</name>&gt;(<name>int</name>)<name><name>data</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+7</expr>]</index></name>)</expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>data</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+7</expr>]</index></name> -= (<name>u8</name>)<name>frag</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pnext</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> = <name>pnext</name> + <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pnext</name>+2</expr>]</index></name></expr></argument>)</argument_list></call> - <name>pbegin</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name>+2</expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>addr</name> = <name>pbegin</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>

  <comment type="block">/* If the cell content area begins with a freeblock, remove it. */</comment>
  <if>if<condition>( <expr><name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name>==<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name> &amp;&amp; <name><name>data</name><index>[<expr><name>hdr</name>+2</expr>]</index></name>==<name><name>data</name><index>[<expr><name>hdr</name>+6</expr>]</index></name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pbegin</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name></expr>]</index></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call> + <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pbegin</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Decode the flags byte (the first byte of the header) for a page
** and initialize fields of the MemPage structure accordingly.
**
** Only the following combinations are supported.  Anything different
** indicates a corrupt database files:
**
**         PTF_ZERODATA
**         PTF_ZERODATA | PTF_LEAF
**         PTF_LEAFDATA | PTF_INTKEY
**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>decodeFlags</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>flagByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>     <comment type="block">/* A copy of pPage-&gt;pBt */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>hdrOffset</name>==(<name>pPage</name>-&gt;<name>pgno</name>==1 ? 100 : 0)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>leaf</name> = (<name>u8</name>)(<name>flagByte</name>&gt;&gt;3)</expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PTF_LEAF</name> == 1&lt;&lt;3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flagByte</name> &amp;= ~<name>PTF_LEAF</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>childPtrSize</name> = 4-4*<name>pPage</name>-&gt;<name>leaf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>pPage</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>flagByte</name>==(<name>PTF_LEAFDATA</name> | <name>PTF_INTKEY</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name>-&gt;<name>intKey</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>hasData</name> = <name>pPage</name>-&gt;<name>leaf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>maxLocal</name> = <name>pBt</name>-&gt;<name>maxLeaf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>minLocal</name> = <name>pBt</name>-&gt;<name>minLeaf</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>flagByte</name>==<name>PTF_ZERODATA</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name>-&gt;<name>intKey</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>hasData</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>maxLocal</name> = <name>pBt</name>-&gt;<name>maxLocal</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>minLocal</name> = <name>pBt</name>-&gt;<name>minLocal</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></else></if></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Initialize the auxiliary information for a disk block.
**
** Return SQLITE_OK on success.  If we see that the page does
** not contain a well-formed database page, then return 
** SQLITE_CORRUPT.  Note that a return of SQLITE_OK does not
** guarantee that the page is well-formed.  It only shows that
** we failed to detect any corruption.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeInitPage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pgno</name>==<call><name>sqlite3PagerPagenumber</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name> == <call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>aData</name> == <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>isInit</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u16</name></type> <name>pc</name></decl>;</decl_stmt>            <comment type="block">/* Address of a freeblock within pPage-&gt;aData[] */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>hdr</name></decl>;</decl_stmt>            <comment type="block">/* Offset to beginning of page header */</comment>
    <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>          <comment type="block">/* Equal to pPage-&gt;aData */</comment>
    <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>        <comment type="block">/* The main btree structure */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>usableSize</name></decl>;</decl_stmt>    <comment type="block">/* Amount of usable space on each page */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>cellOffset</name></decl>;</decl_stmt>    <comment type="block">/* Offset from start of page to first cell pointer */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>nFree</name></decl>;</decl_stmt>         <comment type="block">/* Number of unused bytes on the page */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>top</name></decl>;</decl_stmt>           <comment type="block">/* First byte of the cell content area */</comment>

    <expr_stmt><expr><name>pBt</name> = <name>pPage</name>-&gt;<name>pBt</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>decodeFlags</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>hdr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pageSize</name>&gt;=512 &amp;&amp; <name>pBt</name>-&gt;<name>pageSize</name>&lt;=32768</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>maskPage</name> = <name>pBt</name>-&gt;<name>pageSize</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>usableSize</name> = <name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>cellOffset</name> = <name>cellOffset</name> = <name>hdr</name> + 12 - 4*<name>pPage</name>-&gt;<name>leaf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nCell</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>nCell</name>&gt;<call><name>MX_CELL</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* To many cells for a single page.  The page must be corrupt */</comment>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
  
    <comment type="block">/* Compute the total free space on the page */</comment>
    <expr_stmt><expr><name>pc</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nFree</name> = <name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name> + <name>top</name> - (<name>cellOffset</name> + 2*<name>pPage</name>-&gt;<name>nCell</name>)</expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pc</name>&gt;0</expr> )</condition><block>{
      <decl_stmt><decl><type><name>u16</name></type> <name>next</name>, <name>size</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pc</name>&gt;<name>usableSize</name>-4</expr> )</condition><then><block>{
        <comment type="block">/* Free block is off the page */</comment>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return> 
      }</block></then></if>
      <expr_stmt><expr><name>next</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>size</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>next</name>&gt;0 &amp;&amp; <name>next</name>&lt;=<name>pc</name>+<name>size</name>+3</expr> )</condition><then><block>{
        <comment type="block">/* Free blocks must be in accending order */</comment>
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return> 
      }</block></then></if>
      <expr_stmt><expr><name>nFree</name> += <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pc</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> = (<name>u16</name>)<name>nFree</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nFree</name>&gt;=<name>usableSize</name></expr> )</condition><then><block>{
      <comment type="block">/* Free space cannot exceed total page size */</comment>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return> 
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  <comment type="block">/* Check that all the offsets in the cell offset array are within range. 
  ** 
  ** Omitting this consistency check and using the pPage-&gt;maskPage mask
  ** to prevent overrunning the page buffer in findCell() results in a
  ** 2.5% performance gain.
  */</comment>
  {
    u8 *pOff;        <comment type="block">/* Iterator used to check all cell offsets are in range */</comment>
    u8 *pEnd;        <comment type="block">/* Pointer to end of cell offset array */</comment>
    u8 mask;         <comment type="block">/* Mask of bits that must be zero in MSB of cell offsets */</comment>
    mask = ~(((u8)(pBt-&gt;pageSize&gt;&gt;8))-1);
    pEnd = &amp;data[cellOffset + pPage-&gt;nCell*2];
    for(pOff=&amp;data[cellOffset]; pOff!=pEnd &amp;&amp; !((*pOff)&amp;mask); pOff+=2);
    if( pOff!=pEnd ){
      return SQLITE_CORRUPT_BKPT;
    }
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set up a raw page so that it looks like a database page holding
** no entries.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>zeroPage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name> =<init> <expr><name>pPage</name>-&gt;<name>aData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>hdr</name> =<init> <expr><name>pPage</name>-&gt;<name>hdrOffset</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>first</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerPagenumber</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>==<name>pPage</name>-&gt;<name>pgno</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call> == (<name>void</name>*)<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call> == <name>data</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/*memset(&amp;data[hdr], 0, pBt-&gt;usableSize - hdr);*/</comment>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name></expr>]</index></name> = (<name>char</name>)<name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>first</name> = <name>hdr</name> + 8 + 4*((<name>flags</name>&amp;<name>PTF_LEAF</name>)==0 ?1:0)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>, <argument><expr><name>pBt</name>-&gt;<name>usableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> = <name>pBt</name>-&gt;<name>usableSize</name> - <name>first</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decodeFlags</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>hdrOffset</name> = <name>hdr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>cellOffset</name> = <name>first</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pageSize</name>&gt;=512 &amp;&amp; <name>pBt</name>-&gt;<name>pageSize</name>&lt;=32768</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>maskPage</name> = <name>pBt</name>-&gt;<name>pageSize</name> - 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nCell</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 1</expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Convert a DbPage obtained from the pager into a MemPage used by
** the btree layer.
*/</comment>
<function><type><name>static</name> <name>MemPage</name> *</type><name>btreePageFromDbPage</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr>(<name>MemPage</name>*)<call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>aData</name> = <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pDbPage</name> = <name>pDbPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pBt</name> = <name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pgno</name> = <name>pgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>hdrOffset</name> = <name>pPage</name>-&gt;<name>pgno</name>==1 ? 100 : 0</expr>;</expr_stmt>
  <return>return <expr><name>pPage</name></expr>;</return> 
}</block></function>

<comment type="block">/*
** Get a page from the pager.  Initialize the MemPage.pBt and
** MemPage.aData elements if needed.
**
** If the noContent flag is set, it means that we do not care about
** the content of the page at this time.  So do not go to the disk
** to fetch the content.  Just fill in the content with zeros for now.
** If in the future we call sqlite3PagerWrite() on this page, that
** means we have started to be concerned about content and the disk
** read should occur at that point.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetPage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>,       <comment type="block">/* The btree */</comment>
  <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>,           <comment type="block">/* Number of the page to fetch */</comment>
  <param><decl><type><name>MemPage</name> **</type><name>ppPage</name></decl></param>,    <comment type="block">/* Return the page in this parameter */</comment>
  <param><decl><type><name>int</name></type> <name>noContent</name></decl></param>        <comment type="block">/* Do not load page content if true */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerAcquire</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>(<name>DbPage</name>**)&amp;<name>pDbPage</name></expr></argument>, <argument><expr><name>noContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>ppPage</name> = <call><name>btreePageFromDbPage</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the size of the database file in pages. If there is any kind of
** error, return ((unsigned int)-1).
*/</comment>
<function><type><name>static</name> <name>Pgno</name></type> <name>pagerPagecount</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pPage1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name> || <name>nPage</name>==-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name>Pgno</name>)<name>nPage</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Get a page from the pager and initialize it.  This routine
** is just a convenience wrapper around separate calls to
** sqlite3BtreeGetPage() and sqlite3BtreeInitPage().
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getAndInitPage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>,          <comment type="block">/* The database file */</comment>
  <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>,           <comment type="block">/* Number of the page to get */</comment>
  <param><decl><type><name>MemPage</name> **</type><name>ppPage</name></decl></param>     <comment type="block">/* Write the page pointer here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pgno</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return> 
  }</block></then></if>

  <comment type="block">/* It is often the case that the page we want is already in cache.
  ** If so, get it directly.  This saves us from having to call
  ** pagerPagecount() to make sure pgno is within limits, which results
  ** in a measureable performance improvements.
  */</comment>
  <expr_stmt><expr><name>pDbPage</name> = <call><name>sqlite3PagerLookup</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pDbPage</name></expr> )</condition><then><block>{
    <comment type="block">/* Page is already in cache */</comment>
    <expr_stmt><expr>*<name>ppPage</name> = <name>pPage</name> = <call><name>btreePageFromDbPage</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Page not in cache.  Acquire it. */</comment>
    <if>if<condition>( <expr><name>pgno</name>&gt;<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return> 
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pPage</name> = *<name>ppPage</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>isInit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>ppPage</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Release a MemPage.  This should be called once for each prior
** call to sqlite3BtreeGetPage.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>releasePage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 || <call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>&gt;1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call> == (<name>void</name>*)<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>==<name>pPage</name>-&gt;<name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** During a rollback, when the pager reloads information into the cache
** so that the cache is restored to its original state at the start of
** the transaction, for each page restored this routine is called.
**
** This routine needs to reset the extra data section at the end of the
** page to agree with the restored data.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pageReinit</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pData</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pPage</name> = (<name>MemPage</name> *)<call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>isInit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Invoke the busy handler for a btree.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>btreeInvokeBusyHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr>(<name>BtShared</name>*)<name>pArg</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3InvokeBusyHandler</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>db</name>-&gt;<name>busyHandler</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Open a database file.
** 
** zFilename is the name of the database file.  If zFilename is NULL
** a new database with a random name is created.  This randomly named
** database file will be deleted when sqlite3BtreeClose() is called.
** If zFilename is ":memory:" then an in-memory database is created
** that is automatically destroyed when it is closed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeOpen</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,  <comment type="block">/* Name of the file containing the BTree database */</comment>
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,            <comment type="block">/* Associated database handle */</comment>
  <param><decl><type><name>Btree</name> **</type><name>ppBtree</name></decl></param>,        <comment type="block">/* Pointer to new Btree object written here */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,              <comment type="block">/* Options */</comment>
  <param><decl><type><name>int</name></type> <name>vfsFlags</name></decl></param>            <comment type="block">/* Flags passed through to sqlite3_vfs.xOpen() */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl>;</decl_stmt>      <comment type="block">/* The VFS to use for this btree */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* Shared part of btree structure */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name></decl>;</decl_stmt>               <comment type="block">/* Handle to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>nReserve</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zDbHeader</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Set the variable isMemdb to true for an in-memory database, or 
  ** false for a file-based database. This symbol is only required if
  ** either of the shared-data or autovacuum features are compiled 
  ** into the library.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUTOVACUUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifdef>
    <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>isMemdb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>isMemdb</name> =<init> <expr><name>zFilename</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr>":memory:"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pVfs</name> = <name>db</name>-&gt;<name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Btree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>p</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>inTrans</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*
  ** If this Btree is a candidate for shared cache, try to find an
  ** existing BtShared object that we can share with
  */</comment>
  <if>if<condition>( <expr><name>isMemdb</name>==0
   &amp;&amp; (<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_Vtab</name>)==0
   &amp;&amp; <name>zFilename</name> &amp;&amp; <name><name>zFilename</name><index>[<expr>0</expr>]</index></name></expr>
  )</condition><then><block>{
    <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>sharedCacheEnabled</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nFullPathname</name> =<init> <expr><name>pVfs</name>-&gt;<name>mxPathname</name>+1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zFullPathname</name> =<init> <expr><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nFullPathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutexShared</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>sharable</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_SharedCache</name></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>zFullPathname</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3OsFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nFullPathname</name></expr></argument>, <argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mutexShared</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>pBt</name>=<call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pBt</name></expr>;</condition> <incr><expr><name>pBt</name>=<name>pBt</name>-&gt;<name>pNext</name></expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>0==<call><name>strcmp</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>, <argument><expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                 &amp;&amp; <call><name>sqlite3PagerVfs</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call>==<name>pVfs</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>p</name>-&gt;<name>pBt</name> = <name>pBt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pBt</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFullPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <else>else<block>{
      <comment type="block">/* In debug mode, we mark all persistent databases as sharable
      ** even when they are not.  This exercises the locking code and
      ** gives more opportunity for asserts(sqlite3_mutex_held())
      ** statements to find locking problems.
      */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name>sharable</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>pBt</name>==0</expr> )</condition><then><block>{
    <comment type="block">/*
    ** The following asserts make sure that structures used by the btree are
    ** the right size.  This is to guard against size changes that result
    ** when compiling on a different architecture.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call>==8 || <call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u64</name></expr></argument>)</argument_list></call>==8 || <call><name>sizeof</name><argument_list>(<argument><expr><name>u64</name></expr></argument>)</argument_list></call>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></call>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></call>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></call>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <expr_stmt><expr><name>pBt</name> = <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pBt</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>btree_open_out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr>&amp;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>,
                          <argument><expr><name>EXTRA_SIZE</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerReadFileheader</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>,<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zDbHeader</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zDbHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <goto>goto <name>btree_open_out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3PagerSetBusyhandler</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>btreeInvokeBusyHandler</name></expr></argument>, <argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pBt</name> = <name>pBt</name></expr>;</expr_stmt>
  
    <expr_stmt><expr><call><name>sqlite3PagerSetReiniter</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>pageReinit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pCursor</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pPage1</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>readOnly</name> = <call><name>sqlite3PagerIsreadonly</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSize</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>zDbHeader</name><index>[<expr>16</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pageSize</name>&lt;512 || <name>pBt</name>-&gt;<name>pageSize</name>&gt;<name>SQLITE_MAX_PAGE_SIZE</name>
         || ((<name>pBt</name>-&gt;<name>pageSize</name>-1)&amp;<name>pBt</name>-&gt;<name>pageSize</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSize</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <comment type="block">/* If the magic name ":memory:" will create an in-memory database, then
      ** leave the autoVacuum mode at 0 (do not auto-vacuum), even if
      ** SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if
      ** SQLITE_OMIT_MEMORYDB has been defined, then ":memory:" is just a
      ** regular file-name. In this case the auto-vacuum applies as per normal.
      */</comment>
      <if>if<condition>( <expr><name>zFilename</name> &amp;&amp; !<name>isMemdb</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pBt</name>-&gt;<name>autoVacuum</name> = (<name>SQLITE_DEFAULT_AUTOVACUUM</name> ? 1 : 0)</expr>;</expr_stmt>
        <expr_stmt><expr><name>pBt</name>-&gt;<name>incrVacuum</name> = (<name>SQLITE_DEFAULT_AUTOVACUUM</name>==2 ? 1 : 0)</expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>nReserve</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nReserve</name> = <name><name>zDbHeader</name><index>[<expr>20</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSizeFixed</name> = 1</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>autoVacuum</name> = (<call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>zDbHeader</name><index>[<expr>36 + 4*4</expr>]</index></name></expr></argument>)</argument_list></call>?1:0)</expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>incrVacuum</name> = (<call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>zDbHeader</name><index>[<expr>36 + 7*4</expr>]</index></name></expr></argument>)</argument_list></call>?1:0)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>usableSize</name> = <name>pBt</name>-&gt;<name>pageSize</name> - <name>nReserve</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pBt</name>-&gt;<name>pageSize</name> &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 8-byte alignment of pageSize */</comment>
    <expr_stmt><expr><call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Add the new BtShared object to the linked list sharable BtShareds.
    */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutexShared</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>mutexShared</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pBt</name>-&gt;<name>mutex</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pBt</name>-&gt;<name>mutex</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 0</expr>;</expr_stmt>
          <goto>goto <name>btree_open_out</name>;</goto>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pNext</name> = <call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call> = <name>pBt</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutexShared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DISKIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* If the new Btree uses a sharable pBtShared, then link the new
  ** Btree into the list of all sharable Btrees for the same connection.
  ** The list is kept in ascending order by pBt address.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Btree</name> *</type><name>pSib</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr>(<name>pSib</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name>)!=0 &amp;&amp; <name>pSib</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
        <while>while<condition>( <expr><name>pSib</name>-&gt;<name>pPrev</name></expr> )</condition><block>{ <expr_stmt><expr><name>pSib</name> = <name>pSib</name>-&gt;<name>pPrev</name></expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr><name>p</name>-&gt;<name>pBt</name>&lt;<name>pSib</name>-&gt;<name>pBt</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>pSib</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>pSib</name>-&gt;<name>pPrev</name> = <name>p</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <while>while<condition>( <expr><name>pSib</name>-&gt;<name>pNext</name> &amp;&amp; <name>pSib</name>-&gt;<name>pNext</name>-&gt;<name>pBt</name>&lt;<name>p</name>-&gt;<name>pBt</name></expr> )</condition><block>{
            <expr_stmt><expr><name>pSib</name> = <name>pSib</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
          }</block></while>
          <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>pSib</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name> = <name>pSib</name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>p</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>p</name></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>pSib</name>-&gt;<name>pNext</name> = <name>p</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr>*<name>ppBtree</name> = <name>p</name></expr>;</expr_stmt>

<label><name>btree_open_out</name>:</label>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pBt</name> &amp;&amp; <name>pBt</name>-&gt;<name>pPager</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3PagerClose</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>ppBtree</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Decrement the BtShared.nRef counter.  When it reaches zero,
** remove the BtShared structure from the sharing list.  Return
** true if the BtShared.nRef counter reaches zero and return
** false if it is still positive.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>removeFromSharingList</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>pMaster</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>removed</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_notheld</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMaster</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>nRef</name>&lt;=0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call>==<name>pBt</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call> = <name>pBt</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pList</name> = <call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call> &amp;&amp; <name>pList</name>-&gt;<name>pNext</name>!=<name>pBt</name></expr> )</condition><block>{
        <expr_stmt><expr><name>pList</name>=<name>pList</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></while>
      <if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pList</name>-&gt;<name>pNext</name> = <name>pBt</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <if>if<condition>( <expr><name>SQLITE_THREADSAFE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>removed</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>removed</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Make sure pBt-&gt;pTmpSpace points to an allocation of 
** MX_CELL_SIZE(pBt) bytes.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>allocateTempSpace</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>pBt</name>-&gt;<name>pTmpSpace</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pTmpSpace</name> = <call><name>sqlite3PageMalloc</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pageSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Free the pBt-&gt;pTmpSpace allocation
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>freeTempSpace</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>pTmpSpace</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Close an open database and invalidate all cursors.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeClose</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl>;</decl_stmt>

  <comment type="block">/* Close all cursors opened via this handle.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> = <name>pBt</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pCur</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pTmp</name> =<init> <expr><name>pCur</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCur</name> = <name>pCur</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTmp</name>-&gt;<name>pBtree</name>==<name>p</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeCloseCursor</name><argument_list>(<argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>

  <comment type="block">/* Rollback any active transaction and free the handle structure.
  ** The call to sqlite3BtreeRollback() drops any table-locks held by
  ** this handle.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there are still other outstanding references to the shared-btree
  ** structure, return now. The remainder of this procedure cleans 
  ** up the shared-btree.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>==0 &amp;&amp; <name>p</name>-&gt;<name>locked</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>sharable</name> || <call><name>removeFromSharingList</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* The pBt is no longer on the sharing list, so we can access
    ** it without having to hold the mutex.
    **
    ** Clean out and delete the BtShared object.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>pCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerClose</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>xFreeSchema</name> &amp;&amp; <name>pBt</name>-&gt;<name>pSchema</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<call><name>xFreeSchema</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>locked</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrev</name></expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pNext</name></expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>p</name>-&gt;<name>pPrev</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the limit on the number of pages allowed in the cache.
**
** The maximum number of cache pages is set to the absolute
** value of mxPage.  If mxPage is negative, the pager will
** operate asynchronously - it will not stop to do fsync()s
** to insure data is written to the disk surface before
** continuing.  Transactions still work if synchronous is off,
** and the database cannot be corrupted if this program
** crashes.  But if the operating system crashes or there is
** an abrupt power failure when synchronous is off, the database
** could be left in an inconsistent and unrecoverable state.
** Synchronous is on by default so database corruption is not
** normally a worry.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetCacheSize</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>mxPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerSetCachesize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the way data is synced to disk in order to increase or decrease
** how well the database resists damage due to OS crashes and power
** failures.  Level 1 is the same as asynchronous (no syncs() occur and
** there is a high probability of damage)  Level 2 is the default.  There
** is a very low but non-zero probability of damage.  Level 3 reduces the
** probability of damage to near zero but with a write performance reduction.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3BtreeSetSafetyLevel</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><name>int</name></type> <name>fullSync</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerSetSafetyLevel</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return TRUE if the given btree is set to safety level 1.  In other
** words, return TRUE if no sync() occurs on the disk files.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSyncDisabled</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name> &amp;&amp; <name>pBt</name>-&gt;<name>pPager</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerNosync</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_PAGER_PRAGMAS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VACUUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Change the default pages size and the number of reserved bytes per page.
**
** The page size must be a power of 2 between 512 and 65536.  If the page
** size supplied does not meet this constraint then the page size is not
** changed.
**
** Page sizes are constrained to be a power of two so that the region
** of the database file used for locking (beginning at PENDING_BYTE,
** the first byte past the 1GB boundary, 0x40000000) needs to occur
** at the beginning of a page.
**
** If parameter nReserve is less than zero, then the number of reserved
** bytes per page is left unchanged.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetPageSize</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>pageSize</name></decl></param>, <param><decl><type><name>int</name></type> <name>nReserve</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReserve</name>&gt;=-1 &amp;&amp; <name>nReserve</name>&lt;=255</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pageSizeFixed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>nReserve</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>nReserve</name> = <name>pBt</name>-&gt;<name>pageSize</name> - <name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReserve</name>&gt;=0 &amp;&amp; <name>nReserve</name>&lt;=255</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pageSize</name>&gt;=512 &amp;&amp; <name>pageSize</name>&lt;=<name>SQLITE_MAX_PAGE_SIZE</name> &amp;&amp;
        ((<name>pageSize</name>-1)&amp;<name>pageSize</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pageSize</name> &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>pPage1</name> &amp;&amp; !<name>pBt</name>-&gt;<name>pCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSize</name> = (<name>u16</name>)<name>pageSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>usableSize</name> = <name>pBt</name>-&gt;<name>pageSize</name> - (<name>u16</name>)<name>nReserve</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the currently defined page size
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetPageSize</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pageSize</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeGetReserve</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>p</name>-&gt;<name>pBt</name>-&gt;<name>pageSize</name> - <name>p</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set the maximum page count for a database if mxPage is positive.
** No changes are made if mxPage is 0 or negative.
** Regardless of the value of mxPage, return the maximum page count.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeMaxPageCount</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>mxPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3PagerMaxPageCount</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_PAGER_PRAGMAS) || !defined(SQLITE_OMIT_VACUUM) */</comment>

<comment type="block">/*
** Change the 'auto-vacuum' property of the database. If the 'autoVacuum'
** parameter is non-zero, then auto-vacuum mode is enabled. If zero, it
** is disabled. The default value for the auto-vacuum property is 
** determined by the SQLITE_DEFAULT_AUTOVACUUM macro.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSetAutoVacuum</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>autoVacuum</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>av</name> =<init> <expr><name>autoVacuum</name> ?1:0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pageSizeFixed</name> &amp;&amp; <name>av</name>!=<name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_READONLY</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pBt</name>-&gt;<name>autoVacuum</name> = <name>av</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Return the value of the 'auto-vacuum' property. If auto-vacuum is 
** enabled 1 is returned. Otherwise 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetAutoVacuum</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <return>return <expr><name>BTREE_AUTOVACUUM_NONE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = (
    (!<name>p</name>-&gt;<name>pBt</name>-&gt;<name>autoVacuum</name>)?<name>BTREE_AUTOVACUUM_NONE</name>:
    (!<name>p</name>-&gt;<name>pBt</name>-&gt;<name>incrVacuum</name>)?<name>BTREE_AUTOVACUUM_FULL</name>:
    <name>BTREE_AUTOVACUUM_INCR</name>
  )</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/*
** Get a reference to pPage1 of the database file.  This will
** also acquire a readlock on that file.
**
** SQLITE_OK is returned on success.  If the file is not a
** well-formed database file, then SQLITE_CORRUPT is returned.
** SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM
** is returned if we run out of memory. 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>lockBtree</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pPage1</name></expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPage1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <comment type="block">/* Do some checking to help insure the file we opened really is
  ** a valid database file. 
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <goto>goto <name>page1_init_failed</name>;</goto>
  }</block></then><else>else <if>if<condition>( <expr><name>nPage</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pageSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> *</type><name>page1</name> =<init> <expr><name>pPage1</name>-&gt;<name>aData</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOTADB</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>page1</name></expr></argument>, <argument><expr><name>zMagicHeader</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
      <goto>goto <name>page1_init_failed</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name><name>page1</name><index>[<expr>18</expr>]</index></name>&gt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>readOnly</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name><name>page1</name><index>[<expr>19</expr>]</index></name>&gt;1</expr> )</condition><then><block>{
      <goto>goto <name>page1_init_failed</name>;</goto>
    }</block></then></if>

    <comment type="block">/* The maximum embedded fraction must be exactly 25%.  And the minimum
    ** embedded fraction must be 12.5% for both leaf-data and non-leaf-data.
    ** The original design allowed these amounts to vary, but as of
    ** version 3.6.0, we require them to be fixed.
    */</comment>
    <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>page1</name><index>[<expr>21</expr>]</index></name></expr></argument>, <argument><expr>"\100\040\040"</expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
      <goto>goto <name>page1_init_failed</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pageSize</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>page1</name><index>[<expr>16</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>((<name>pageSize</name>-1)&amp;<name>pageSize</name>)!=0 || <name>pageSize</name>&lt;512 ||
        (<name>SQLITE_MAX_PAGE_SIZE</name>&lt;32768 &amp;&amp; <name>pageSize</name>&gt;<name>SQLITE_MAX_PAGE_SIZE</name>)</expr>
    )</condition><then><block>{
      <goto>goto <name>page1_init_failed</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pageSize</name> &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>usableSize</name> = <name>pageSize</name> - <name><name>page1</name><index>[<expr>20</expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pageSize</name>!=<name>pBt</name>-&gt;<name>pageSize</name></expr> )</condition><then><block>{
      <comment type="block">/* After reading the first page of the database assuming a page size
      ** of BtShared.pageSize, we have discovered that the page-size is
      ** actually pageSize. Unlock the database, leave pBt-&gt;pPage1 at
      ** zero and return SQLITE_OK. The caller will call this function
      ** again with the correct page-size.
      */</comment>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>usableSize</name> = (<name>u16</name>)<name>usableSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSize</name> = (<name>u16</name>)<name>pageSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>freeTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>usableSize</name>&lt;500</expr> )</condition><then><block>{
      <goto>goto <name>page1_init_failed</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSize</name> = (<name>u16</name>)<name>pageSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>usableSize</name> = (<name>u16</name>)<name>usableSize</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>autoVacuum</name> = (<call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>page1</name><index>[<expr>36 + 4*4</expr>]</index></name></expr></argument>)</argument_list></call>?1:0)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>incrVacuum</name> = (<call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>page1</name><index>[<expr>36 + 7*4</expr>]</index></name></expr></argument>)</argument_list></call>?1:0)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if></else></if>

  <comment type="block">/* maxLocal is the maximum amount of payload to store locally for
  ** a cell.  Make sure it is small enough so that at least minFanout
  ** cells can will fit on one page.  We assume a 10-byte page header.
  ** Besides the payload, the cell must store:
  **     2-byte pointer to the cell
  **     4-byte child pointer
  **     9-byte nKey value
  **     4-byte nData value
  **     4-byte overflow page pointer
  ** So a cell consists of a 2-byte poiner, a header which is as much as
  ** 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow
  ** page pointer.
  */</comment>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>maxLocal</name> = (<name>pBt</name>-&gt;<name>usableSize</name>-12)*64/255 - 23</expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>minLocal</name> = (<name>pBt</name>-&gt;<name>usableSize</name>-12)*32/255 - 23</expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>maxLeaf</name> = <name>pBt</name>-&gt;<name>usableSize</name> - 35</expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>minLeaf</name> = (<name>pBt</name>-&gt;<name>usableSize</name>-12)*32/255 - 23</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>maxLeaf</name> + 23 &lt;= <call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>pPage1</name> = <name>pPage1</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>page1_init_failed</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>pPage1</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine works like lockBtree() except that it also invokes the
** busy callback if there is lock contention.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>lockBtreeWithRetry</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>pRef</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pRef</name>-&gt;<name>inTrans</name>==<name>TRANS_NONE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>inTransaction</name> =<init> <expr><name>pRef</name>-&gt;<name>pBt</name>-&gt;<name>inTransaction</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRef</name>-&gt;<name>pBt</name>-&gt;<name>inTransaction</name> = <name>inTransaction</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRef</name>-&gt;<name>inTrans</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pRef</name>-&gt;<name>pBt</name>-&gt;<name>nTransaction</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>pRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
       

<comment type="block">/*
** If there are no outstanding cursors and we are not in the middle
** of a transaction but there is a read lock on the database, then
** this routine unrefs the first page of the database file which 
** has the effect of releasing the read lock.
**
** If there are any outstanding cursors, this routine is a no-op.
**
** If there is a transaction in progress, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>unlockBtreeIfUnused</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_NONE</name> &amp;&amp; <name>pBt</name>-&gt;<name>pCursor</name>==0 &amp;&amp; <name>pBt</name>-&gt;<name>pPage1</name>!=0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call>&gt;=1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
      if( pBt-&gt;pPage1-&gt;aData==0 ){
        MemPage *pPage = pBt-&gt;pPage1;
        pPage-&gt;aData = sqlite3PagerGetData(pPage-&gt;pDbPage);
        pPage-&gt;pBt = pBt;
        pPage-&gt;pgno = 1;
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pPage1</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Create a new database by initializing the first page of the
** file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>newDatabase</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pP1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>nPage</name>&gt;0</expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pP1</name> = <name>pBt</name>-&gt;<name>pPage1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pP1</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> = <name>pP1</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pP1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>zMagicHeader</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zMagicHeader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zMagicHeader</name></expr></argument>)</argument_list></call>==16</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr>16</expr>]</index></name></expr></argument>, <argument><expr><name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>18</expr>]</index></name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>19</expr>]</index></name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>usableSize</name>&lt;=<name>pBt</name>-&gt;<name>pageSize</name> &amp;&amp; <name>pBt</name>-&gt;<name>usableSize</name>+255&gt;=<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>20</expr>]</index></name> = (<name>u8</name>)(<name>pBt</name>-&gt;<name>pageSize</name> - <name>pBt</name>-&gt;<name>usableSize</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>21</expr>]</index></name> = 64</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>22</expr>]</index></name> = 32</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>data</name><index>[<expr>23</expr>]</index></name> = 32</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr>24</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>100-24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pP1</name></expr></argument>, <argument><expr><name>PTF_INTKEY</name>|<name>PTF_LEAF</name>|<name>PTF_LEAFDATA</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>pageSizeFixed</name> = 1</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name>==1 || <name>pBt</name>-&gt;<name>autoVacuum</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>incrVacuum</name>==1 || <name>pBt</name>-&gt;<name>incrVacuum</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr>36 + 4*4</expr>]</index></name></expr></argument>, <argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr>36 + 7*4</expr>]</index></name></expr></argument>, <argument><expr><name>pBt</name>-&gt;<name>incrVacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Attempt to start a new transaction. A write-transaction
** is started if the second argument is nonzero, otherwise a read-
** transaction.  If the second argument is 2 or more and exclusive
** transaction is started, meaning that no other process is allowed
** to access the database.  A preexisting transaction may not be
** upgraded to exclusive by calling this routine a second time - the
** exclusivity flag only works for a new transaction.
**
** A write-transaction must be started before attempting any 
** changes to the database.  None of the following routines 
** will work unless a transaction is started first:
**
**      sqlite3BtreeCreateTable()
**      sqlite3BtreeCreateIndex()
**      sqlite3BtreeClearTable()
**      sqlite3BtreeDropTable()
**      sqlite3BtreeInsert()
**      sqlite3BtreeDelete()
**      sqlite3BtreeUpdateMeta()
**
** If an initial attempt to acquire the lock fails because of lock contention
** and the database was previously unlocked, then invoke the busy handler
** if there is one.  But if there was previously a read-lock, do not
** invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is 
** returned when there is already a read-lock in order to avoid a deadlock.
**
** Suppose there are two processes A and B.  A has a read lock and B has
** a reserved lock.  B tries to promote to exclusive but is blocked because
** of A's read lock.  A tries to promote to reserved but is blocked by B.
** One or the other of the two processes must give way or there can be
** no progress.  By returning SQLITE_BUSY and not invoking the busy callback
** when A already has a read lock, we encourage A to give up and let B
** proceed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeBeginTrans</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>wrflag</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the btree is already in a write-transaction, or it
  ** is already in a read-transaction and a read-transaction
  ** is requested, this is a no-op.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name> || (<name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_READ</name> &amp;&amp; !<name>wrflag</name>)</expr> )</condition><then><block>{
    <goto>goto <name>trans_begun</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Write transactions are not possible on a read-only database */</comment>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>readOnly</name> &amp;&amp; <name>wrflag</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_READONLY</name></expr>;</expr_stmt>
    <goto>goto <name>trans_begun</name>;</goto>
  }</block></then></if>

  <comment type="block">/* If another database handle has already opened a write transaction 
  ** on this shared-btree structure and a second write transaction is
  ** requested, return SQLITE_BUSY.
  */</comment>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name> &amp;&amp; <name>wrflag</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>trans_begun</name>;</goto>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <if>if<condition>( <expr><name>wrflag</name>&gt;1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>BtLock</name> *</type><name>pIter</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>pIter</name>=<name>pBt</name>-&gt;<name>pLock</name></expr>;</init> <condition><expr><name>pIter</name></expr>;</condition> <incr><expr><name>pIter</name>=<name>pIter</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <if>if<condition>( <expr><name>pIter</name>-&gt;<name>pBtree</name>!=<name>p</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <goto>goto <name>trans_begun</name>;</goto>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <do>do <block>{
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pPage1</name>==0</expr> )</condition><then><block>{
      <do>do<block>{
        <expr_stmt><expr><name>rc</name> = <call><name>lockBtree</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>while<condition>( <expr><name>pBt</name>-&gt;<name>pPage1</name>==0 &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition>;</do>
    }</block></then></if>

    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>wrflag</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pBt</name>-&gt;<name>readOnly</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_READONLY</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerBegin</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>, <argument><expr><name>wrflag</name>&gt;1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>newDatabase</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
    }</block></then></if>
  
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>wrflag</name></expr> )</condition><then> <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block>while<condition>( <expr><name>rc</name>==<name>SQLITE_BUSY</name> &amp;&amp; <name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_NONE</name> &amp;&amp;
          <call><name>btreeInvokeBusyHandler</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_NONE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>nTransaction</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>inTrans</name> = (<name>wrflag</name>?<name>TRANS_WRITE</name>:<name>TRANS_READ</name>)</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>&gt;<name>pBt</name>-&gt;<name>inTransaction</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>inTransaction</name> = <name>p</name>-&gt;<name>inTrans</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
    <if>if<condition>( <expr><name>wrflag</name>&gt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>pExclusive</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pExclusive</name> = <name>p</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>


<label><name>trans_begun</name>:</label>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>wrflag</name></expr> )</condition><then><block>{
    <comment type="block">/* This call makes sure that the pager has the correct number of
    ** open savepoints. If the second parameter is greater than 0 and
    ** the sub-journal is not already open, then it will be opened here.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerOpenSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>nSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>

<comment type="block">/*
** Set the pointer-map entries for all children of page pPage. Also, if
** pPage contains cells that point to overflow pages, set the pointer
** map entries for the overflow pages as well.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>setChildPtrmaps</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                             <comment type="block">/* Counter variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>                         <comment type="block">/* Number of cells in page pPage */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                            <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>isInitOrig</name> =<init> <expr><name>pPage</name>-&gt;<name>isInit</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> =<init> <expr><name>pPage</name>-&gt;<name>pgno</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <goto>goto <name>set_child_ptrmaps_out</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>nCell</name> = <name>pPage</name>-&gt;<name>nCell</name></expr>;</expr_stmt>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name> =<init> <expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPutOvflPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <goto>goto <name>set_child_ptrmaps_out</name>;</goto>
    }</block></then></if>

    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Pgno</name></type> <name>childPgno</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>childPgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>set_child_ptrmaps_out</name>;</goto></then></if>
    }</block></then></if>
  }</block></for>

  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>childPgno</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>childPgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<label><name>set_child_ptrmaps_out</name>:</label>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = <name>isInitOrig</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Somewhere on pPage, which is guarenteed to be a btree page, not an overflow
** page, is a pointer to page iFrom. Modify this pointer so that it points to
** iTo. Parameter eType describes the type of pointer to be modified, as 
** follows:
**
** PTRMAP_BTREE:     pPage is a btree-page. The pointer points at a child 
**                   page of pPage.
**
** PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow
**                   page pointed to by one of the cells on pPage.
**
** PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next
**                   overflow page in the list.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>modifyPagePointer</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iFrom</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iTo</name></decl></param>, <param><decl><type><name>u8</name></type> <name>eType</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_OVERFLOW2</name></expr> )</condition><then><block>{
    <comment type="block">/* The pointer is always the first 4 bytes of the page in this case.  */</comment>
    <if>if<condition>( <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>)</argument_list></call>!=<name>iFrom</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>isInitOrig</name> =<init> <expr><name>pPage</name>-&gt;<name>isInit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCell</name> = <name>pPage</name>-&gt;<name>nCell</name></expr>;</expr_stmt>

    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name> =<init> <expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_OVERFLOW1</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>info</name>.<name>iOverflow</name></expr> )</condition><then><block>{
          <if>if<condition>( <expr><name>iFrom</name>==<call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>
      }</block></then><else>else<block>{
        <if>if<condition>( <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call>==<name>iFrom</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></else></if>
    }</block></for>
  
    <if>if<condition>( <expr><name>i</name>==<name>nCell</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>eType</name>!=<name>PTRMAP_BTREE</name> || 
          <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call>!=<name>iFrom</name></expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, <argument><expr><name>iTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = <name>isInitOrig</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Move the open database page pDbPage to location iFreePage in the 
** database. The pDbPage reference remains valid.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>relocatePage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>,           <comment type="block">/* Btree */</comment>
  <param><decl><type><name>MemPage</name> *</type><name>pDbPage</name></decl></param>,        <comment type="block">/* Open page to move */</comment>
  <param><decl><type><name>u8</name></type> <name>eType</name></decl></param>,                <comment type="block">/* Pointer map 'type' entry for pDbPage */</comment>
  <param><decl><type><name>Pgno</name></type> <name>iPtrPage</name></decl></param>,           <comment type="block">/* Pointer map 'page-no' entry for pDbPage */</comment>
  <param><decl><type><name>Pgno</name></type> <name>iFreePage</name></decl></param>,          <comment type="block">/* The location to move pDbPage to */</comment>
  <param><decl><type><name>int</name></type> <name>isCommit</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPtrPage</name></decl>;</decl_stmt>   <comment type="block">/* The page that contains a pointer to pDbPage */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iDbPage</name> =<init> <expr><name>pDbPage</name>-&gt;<name>pgno</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pBt</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>==<name>PTRMAP_OVERFLOW2</name> || <name>eType</name>==<name>PTRMAP_OVERFLOW1</name> || 
      <name>eType</name>==<name>PTRMAP_BTREE</name> || <name>eType</name>==<name>PTRMAP_ROOTPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDbPage</name>-&gt;<name>pBt</name>==<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Move page iDbPage from its current location to page number iFreePage */</comment>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n", 
      <name>iDbPage</name>, <name>iFreePage</name>, <name>iPtrPage</name>, <name>eType</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerMovepage</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pDbPage</name>-&gt;<name>pDbPage</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pDbPage</name>-&gt;<name>pgno</name> = <name>iFreePage</name></expr>;</expr_stmt>

  <comment type="block">/* If pDbPage was a btree-page, then it may have child pages and/or cells
  ** that point to overflow pages. The pointer map entries for all these
  ** pages need to be changed.
  **
  ** If pDbPage is an overflow page, then the first 4 bytes may store a
  ** pointer to a subsequent overflow page. If this is the case, then
  ** the pointer map needs to be updated for the subsequent overflow page.
  */</comment>
  <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_BTREE</name> || <name>eType</name>==<name>PTRMAP_ROOTPAGE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>setChildPtrmaps</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nextOvfl</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pDbPage</name>-&gt;<name>aData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>nextOvfl</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nextOvfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW2</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* Fix the database pointer on page iPtrPage that pointed at iDbPage so
  ** that it points at iFreePage. Also fix the pointer map entry for
  ** iPtrPage.
  */</comment>
  <if>if<condition>( <expr><name>eType</name>!=<name>PTRMAP_ROOTPAGE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr>&amp;<name>pPtrPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPtrPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>modifyPagePointer</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>, <argument><expr><name>iDbPage</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* Forward declaration required by incrVacuumStep(). */</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>allocateBtreePage</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type></decl></param>, <param><decl><type><name>MemPage</name> **</type></decl></param>, <param><decl><type><name>Pgno</name> *</type></decl></param>, <param><decl><type><name>Pgno</name></type></decl></param>, <param><decl><type><name>u8</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Perform a single step of an incremental-vacuum. If successful,
** return SQLITE_OK. If there is no work to do (and therefore no
** point in calling this function again), return SQLITE_DONE.
**
** More specificly, this function attempts to re-organize the 
** database so that the last page of the file currently in use
** is no longer in use.
**
** If the nFin parameter is non-zero, the implementation assumes
** that the caller will keep calling incrVacuumStep() until
** it returns SQLITE_DONE or an error, and that nFin is the
** number of pages the database file will contain after this 
** process is complete.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>incrVacuumStep</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>nFin</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iLastPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nFreeList</name></decl>;</decl_stmt>           <comment type="block">/* Number of pages still on the free-list */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>)</argument_list></call> &amp;&amp; <name>iLastPg</name>!=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrPage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nFreeList</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nFreeList</name>==0 || <name>nFin</name>==<name>iLastPg</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rc</name> = <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr>&amp;<name>eType</name></expr></argument>, <argument><expr>&amp;<name>iPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_ROOTPAGE</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>

    <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_FREEPAGE</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>nFin</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* Remove the page from the files free-list. This is not required
        ** if nFin is non-zero. In that case, the free-list will be
        ** truncated to zero after this function returns, so it doesn't 
        ** matter if it still contains some garbage entries.
        */</comment>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemPage</name> *</type><name>pFreePg</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pFreePg</name></expr></argument>, <argument><expr>&amp;<name>iFreePg</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFreePg</name>==<name>iLastPg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pFreePg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePg</name></decl>;</decl_stmt>             <comment type="block">/* Index of free page to move pLastPg to */</comment>
      <decl_stmt><decl><type><name>MemPage</name> *</type><name>pLastPg</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>, <argument><expr>&amp;<name>pLastPg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>

      <comment type="block">/* If nFin is zero, this loop runs exactly once and page pLastPg
      ** is swapped with the first free page pulled off the free list.
      **
      ** On the other hand, if nFin is greater than zero, then keep
      ** looping until a free-page located within the first nFin pages
      ** of the file is found.
      */</comment>
      <do>do <block>{
        <decl_stmt><decl><type><name>MemPage</name> *</type><name>pFreePg</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pFreePg</name></expr></argument>, <argument><expr>&amp;<name>iFreePg</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pFreePg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>while<condition>( <expr><name>nFin</name>!=0 &amp;&amp; <name>iFreePg</name>&gt;<name>nFin</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFreePg</name>&lt;<name>iLastPg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pLastPg</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pLastPg</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><name>iFreePg</name></expr></argument>, <argument><expr><name>nFin</name>!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>nFin</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>iLastPg</name>--</expr>;</expr_stmt>
    <while>while<condition>( <expr><name>iLastPg</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call>||<call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>iLastPg</name>--</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>sqlite3PagerTruncateImage</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>iLastPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** A write-transaction must be opened before calling this function.
** It performs a single unit of work towards an incremental vacuum.
**
** If the incremental vacuum is finished after this function has run,
** SQLITE_DONE is returned. If it is not finished, but no error occured,
** SQLITE_OK is returned. Otherwise an SQLite error code. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIncrVacuum</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name> &amp;&amp; <name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_DONE</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>incrVacuumStep</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sqlite3PagerImageSize</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called prior to sqlite3PagerCommit when a transaction
** is commited for an auto-vacuum database.
**
** If SQLITE_OK is returned, then *pnTrunc is set to the number of pages
** the database file should be truncated to during the commit process. 
** i.e. the database has been reorganized so that only the first *pnTrunc
** pages are in use.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>autoVacuumCommit</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pBt</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <macro><name>VVA_ONLY</name><argument_list>( <argument>int nRef = sqlite3PagerRefcount(pPager)</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pBt</name>-&gt;<name>incrVacuum</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nFree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nPtrmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iFree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>pgsz</name> =<init> <expr><name>pBt</name>-&gt;<name>pageSize</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nOrig</name> =<init> <expr><call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>nOrig</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nOrig</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>nFree</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nPtrmap</name> = (<name>nFree</name>-<name>nOrig</name>+<call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nOrig</name></expr></argument>)</argument_list></call>+<name>pgsz</name>/5)/(<name>pgsz</name>/5)</expr>;</expr_stmt>
    <expr_stmt><expr><name>nFin</name> = <name>nOrig</name> - <name>nFree</name> - <name>nPtrmap</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nOrig</name>&gt;<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call> &amp;&amp; <name>nFin</name>&lt;=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nFin</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <while>while<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>)</argument_list></call> || <name>nFin</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>nFin</name>--</expr>;</expr_stmt>
    }</block></while>

    <for>for(<init><expr><name>iFree</name>=<name>nOrig</name></expr>;</init> <condition><expr><name>iFree</name>&gt;<name>nFin</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>iFree</name>--</expr></incr>)<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>incrVacuumStep</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>, <argument><expr><name>iFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr>(<name>rc</name>==<name>SQLITE_DONE</name> || <name>rc</name>==<name>SQLITE_OK</name>) &amp;&amp; <name>nFree</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerTruncateImage</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>nFin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRef</name>==<call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifndef SQLITE_OMIT_AUTOVACUUM */</comment>

<comment type="block">/*
** This routine does the first phase of a two-phase commit.  This routine
** causes a rollback journal to be created (if it does not already exist)
** and populated with enough information so that if a power loss occurs
** the database can be restored to its original state by playing back
** the journal.  Then the contents of the journal are flushed out to
** the disk.  After the journal is safely on oxide, the changes to the
** database are written into the database file and flushed to oxide.
** At the end of this call, the rollback journal still exists on the
** disk and we are still holding all locks, so the transaction has not
** committed.  See sqlite3BtreeCommit() for the second phase of the
** commit process.
**
** This call is a no-op if no write-transaction is currently active on pBt.
**
** Otherwise, sync the database file for the btree pBt. zMaster points to
** the name of a master journal file that should be written into the
** individual journal file, or is NULL, indicating no master journal file 
** (single database transaction).
**
** When this is called, the master journal should already have been
** created, populated with this journal pointer and synced to disk.
**
** Once this is routine has returned, the only thing required to commit
** the write-transaction for this database file is to delete the journal.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommitPhaseOne</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zMaster</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>autoVacuumCommit</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Commit the transaction currently in progress.
**
** This routine implements the second phase of a 2-phase commit.  The
** sqlite3BtreeSync() routine does the first phase and should be invoked
** prior to calling this routine.  The sqlite3BtreeSync() routine did
** all the work of writing information out to disk and flushing the
** contents so that they are written onto the disk platter.  All this
** routine has to do is delete or truncate the rollback journal
** (which causes the transaction to commit) and drop locks.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommitPhaseTwo</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the handle has a write-transaction open, commit the shared-btrees 
  ** transaction and set the shared state to TRANS_READ.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>nTransaction</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inTransaction</name> = <name>TRANS_READ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>unlockAllTables</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the handle has any kind of transaction open, decrement the transaction
  ** count of the shared btree. If the transaction count reaches 0, set
  ** the shared state to TRANS_NONE. The unlockBtreeIfUnused() call below
  ** will unlock the pager.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>!=<name>TRANS_NONE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pBt</name>-&gt;<name>nTransaction</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr>0==<name>pBt</name>-&gt;<name>nTransaction</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>inTransaction</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Set the handles current transaction state to TRANS_NONE and unlock
  ** the pager if this call closed the only read or write transaction.
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>inTrans</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Do both phases of a commit.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommit</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return the number of write-cursors open on this handle. This is for use
** in assert() expressions, so it is only compiled if NDEBUG is not
** defined.
**
** For the purposes of this routine, a write-cursor is any cursor that
** is capable of writing to the databse.  That means the cursor was
** originally opened for writing and the cursor has not be disabled
** by having its state changed to CURSOR_FAULT.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>countWriteCursors</name><parameter_list>(<param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>pCur</name>=<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>pCur</name></expr>;</condition> <incr><expr><name>pCur</name>=<name>pCur</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>wrFlag</name> &amp;&amp; <name>pCur</name>-&gt;<name>eState</name>!=<name>CURSOR_FAULT</name></expr> )</condition><then> <expr_stmt><expr><name>r</name>++</expr>;</expr_stmt></then></if> 
  }</block></for>
  <return>return <expr><name>r</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine sets the state to CURSOR_FAULT and the error
** code to errCode for every cursor on BtShared that pBtree
** references.
**
** Every cursor is tripped, including cursors that belong
** to other database connections that happen to be sharing
** the cache with pBtree.
**
** This routine gets called when a rollback occurs.
** All cursors using the same cache must be tripped
** to prevent them from trying to use the btree after
** the rollback.  The rollback may have deleted tables
** or moved root pages, so it is not sufficient to
** save the state of the cursor.  The cursor must be
** invalidated.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeTripAllCursors</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>pBtree</name></decl></param>, <param><decl><type><name>int</name></type> <name>errCode</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>p</name>=<name>pBtree</name>-&gt;<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>eState</name> = <name>CURSOR_FAULT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>skip</name> = <name>errCode</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>p</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></for>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Rollback the transaction in progress.  All cursors will be
** invalided by this operation.  Any attempt to use a cursor
** that was open at the beginning of this operation will result
** in an error.
**
** This will release the write lock on the database file.  If there
** are no active cursors, it also releases the read lock.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeRollback</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage1</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* This is a horrible situation. An IO or malloc() error occured whilst
    ** trying to save cursor positions. If this is an automatic rollback (as
    ** the result of a constraint, malloc() failure or IO error) then 
    ** the cache may be internally inconsistent (not contain valid trees) so
    ** we cannot simply return the error to the caller. Instead, abort 
    ** all queries that may be using any of the cursors that failed to save.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlockAllTables</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TRANS_WRITE</name>==<name>pBt</name>-&gt;<name>inTransaction</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc2</name> = <call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc2</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>rc2</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* The rollback may have destroyed the pPage1-&gt;aData value.  So
    ** call sqlite3BtreeGetPage() on page 1 again to make
    ** sure pPage1-&gt;aData is set correctly. */</comment>
    <if>if<condition>( <expr><call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPage1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>countWriteCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inTransaction</name> = <name>TRANS_READ</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>inTrans</name>!=<name>TRANS_NONE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>nTransaction</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>nTransaction</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr>0==<name>pBt</name>-&gt;<name>nTransaction</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>inTransaction</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>p</name>-&gt;<name>inTrans</name> = <name>TRANS_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>btreeIntegrity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Start a statement subtransaction.  The subtransaction can
** can be rolled back independently of the main transaction.
** You must start a transaction before starting a subtransaction.
** The subtransaction is ended automatically if the main transaction
** commits or rolls back.
**
** Only one subtransaction may be active at a time.  It is an error to try
** to start a new subtransaction if another subtransaction is already active.
**
** Statement subtransactions are used around individual SQL statements
** that are contained within a BEGIN...COMMIT block.  If a constraint
** error occurs within the statement, the effect of that one statement
** can be rolled back without having to rollback the entire transaction.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeBeginStmt</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>inStmt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>readOnly</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>inTrans</name>!=<name>TRANS_WRITE</name> || <name>pBt</name>-&gt;<name>inStmt</name> || <name>pBt</name>-&gt;<name>readOnly</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_INTERNAL</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* At the pager level, a statement transaction is a savepoint with
    ** an index greater than all savepoints created explicitly using
    ** SQL statements. It is illegal to open, release or rollback any
    ** such savepoints while the statement transaction savepoint is active.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerOpenSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>nSavepoint</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Commit the statment subtransaction currently in progress.  If no
** subtransaction is active, this is a no-op.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCommitStmt</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>readOnly</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>inStmt</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iStmtpoint</name> =<init> <expr><name>p</name>-&gt;<name>db</name>-&gt;<name>nSavepoint</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iStmtpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Rollback the active statement subtransaction.  If no subtransaction
** is active this routine is a no-op.
**
** All cursors will be invalidated by this operation.  Any attempt
** to use a cursor that was open at the beginning of this operation
** will result in an error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeRollbackStmt</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>readOnly</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>inStmt</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iStmtpoint</name> =<init> <expr><name>p</name>-&gt;<name>db</name>-&gt;<name>nSavepoint</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>SAVEPOINT_ROLLBACK</name></expr></argument>, <argument><expr><name>iStmtpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>SAVEPOINT_RELEASE</name></expr></argument>, <argument><expr><name>iStmtpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>inStmt</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The second argument to this function, op, is always SAVEPOINT_ROLLBACK
** or SAVEPOINT_RELEASE. This function either releases or rolls back the
** savepoint identified by parameter iSavepoint, depending on the value 
** of op.
**
** Normally, iSavepoint is greater than or equal to zero. However, if op is
** SAVEPOINT_ROLLBACK, then iSavepoint may also be -1. In this case the 
** contents of the entire transaction are rolled back. This is different
** from a normal transaction rollback, as no locks are released and the
** transaction remains open.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSavepoint</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>iSavepoint</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inStmt</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>==<name>SAVEPOINT_RELEASE</name> || <name>op</name>==<name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSavepoint</name>&gt;=0 || (<name>iSavepoint</name>==-1 &amp;&amp; <name>op</name>==<name>SAVEPOINT_ROLLBACK</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSavepoint</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>newDatabase</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new cursor for the BTree whose root is on the page
** iTable.  The act of acquiring a cursor gets a read lock on 
** the database file.
**
** If wrFlag==0, then the cursor can only be used for reading.
** If wrFlag==1, then the cursor can be used for reading or for
** writing if other conditions for writing are also met.  These
** are the conditions that must be met in order for writing to
** be allowed:
**
** 1:  The cursor must have been opened with wrFlag==1
**
** 2:  Other database connections that share the same pager cache
**     but which are not in the READ_UNCOMMITTED state may not have
**     cursors open with wrFlag==0 on the same table.  Otherwise
**     the changes made by this write cursor would be visible to
**     the read cursors in the other database connection.
**
** 3:  The database must be writable (not on read-only media)
**
** 4:  There must be an active transaction.
**
** No checking is done to make sure that page iTable really is the
** root page of a b-tree.  If it is not, then the cursor acquired
** will not work correctly.
**
** It is assumed that the sqlite3BtreeCursorSize() bytes of memory 
** pointed to by pCur have been zeroed by the caller.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>btreeCursor</name><parameter_list>(
  <param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>,                              <comment type="block">/* The btree */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,                            <comment type="block">/* Root page of table to open */</comment>
  <param><decl><type><name>int</name></type> <name>wrFlag</name></decl></param>,                            <comment type="block">/* 1 to write. 0 read-only */</comment>
  <param><decl><type>struct <name>KeyInfo</name> *</type><name>pKeyInfo</name></decl></param>,              <comment type="block">/* First arg to comparison function */</comment>
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>                         <comment type="block">/* Space for new cursor */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>wrFlag</name>==0 || <name>wrFlag</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>wrFlag</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>readOnly</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>readOnly</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>checkReadLocks</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pPage1</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>lockBtreeWithRetry</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pgnoRoot</name> = (<name>Pgno</name>)<name>iTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>(<name>int</name> *)&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>iTable</name>==1 &amp;&amp; <name>nPage</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_EMPTY</name></expr>;</expr_stmt>
    <goto>goto <name>create_cursor_exception</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <goto>goto <name>create_cursor_exception</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Now that no other errors can occur, finish filling in the BtCursor
  ** variables, link the cursor into the BtShared list and set *ppCur (the
  ** output argument to this function).
  */</comment>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pKeyInfo</name> = <name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pBtree</name> = <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pBt</name> = <name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>wrFlag</name> = (<name>u8</name>)<name>wrFlag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>pNext</name> = <name>pBt</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>pCur</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>pCursor</name> = <name>pCur</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>create_cursor_exception</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCursor</name><parameter_list>(
  <param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>,                                   <comment type="block">/* The btree */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,                                 <comment type="block">/* Root page of table to open */</comment>
  <param><decl><type><name>int</name></type> <name>wrFlag</name></decl></param>,                                 <comment type="block">/* 1 to write. 0 read-only */</comment>
  <param><decl><type>struct <name>KeyInfo</name> *</type><name>pKeyInfo</name></decl></param>,                   <comment type="block">/* First arg to xCompare() */</comment>
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>                              <comment type="block">/* Write new cursor here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>btreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorSize</name><parameter_list>()</parameter_list><block>{
  <return>return <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>BtCursor</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<comment type="block">/*
** Close a cursor.  The read lock on the database file is released
** when the last cursor is closed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCloseCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBtree</name> =<init> <expr><name>pCur</name>-&gt;<name>pBtree</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pBtree</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pCur</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>pBtree</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>pCur</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pBt</name>-&gt;<name>pCursor</name> = <name>pCur</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>pCur</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pCur</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>invalidateOverflowCache</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* sqlite3_free(pCur); */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Make a temporary cursor by filling in the fields of pTempCur.
** The temporary cursor is not on the cursor list for the Btree.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeGetTempCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>BtCursor</name> *</type><name>pTempCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTempCur</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>BtCursor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTempCur</name>-&gt;<name>pNext</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTempCur</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pTempCur</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3PagerRef</name><argument_list>(<argument><expr><name>pTempCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTempCur</name>-&gt;<name>pKey</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Delete a temporary cursor such as was made by the CreateTemporaryCursor()
** function above.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeReleaseTempCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pCur</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Make sure the BtCursor* given in the argument has a valid
** BtCursor.info structure.  If it is not already valid, call
** sqlite3BtreeParseCell() to fill it in.
**
** BtCursor.info is a cache of the information in the current cell.
** Using this cache reduces the number of calls to sqlite3BtreeParseCell().
**
** 2007-06-25:  There is a bug in some versions of MSVC that cause the
** compiler to crash when getCellInfo() is implemented as a macro.
** But there is a measureable speed advantage to using the macro on gcc
** (when less compiler optimizations like -Os or -O0 are used and the
** compiler is not doing agressive inlining.)  So we use a real function
** for MSVC and a macro for everything else.  Ticket #2457.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <function><type><name>static</name> <name>void</name></type> <name>assertCellInfo</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPage</name> =<init> <expr><name>pCur</name>-&gt;<name>iPage</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeParseCell</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>iPage</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>iPage</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name>info</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>assertCellInfo</name>(x)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
  <comment type="block">/* Use a real function in MSVC to work around bugs in that compiler. */</comment>
  <function><type><name>static</name> <name>void</name></type> <name>getCellInfo</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iPage</name> =<init> <expr><name>pCur</name>-&gt;<name>iPage</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeParseCell</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>iPage</name></expr>]</index></name></expr></argument>,<argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>iPage</name></expr>]</index></name></expr></argument>,<argument><expr>&amp;<name>pCur</name>-&gt;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assertCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if not _MSC_VER */</comment>
  <comment type="block">/* Use a macro in all other compilers so that the function is inlined */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>getCellInfo</name>(pCur)                                                      \
  if( pCur-&gt;info.nSize==0 ){                                                   \
    int iPage = pCur-&gt;iPage;                                                   \
    sqlite3BtreeParseCell(pCur-&gt;apPage[iPage],pCur-&gt;aiIdx[iPage],&amp;pCur-&gt;info); \
    pCur-&gt;validNKey = 1;                                                       \
  }else{                                                                       \
    assertCellInfo(pCur);                                                      \
  }</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _MSC_VER */</comment>

<comment type="block">/*
** Set *pSize to the size of the buffer needed to hold the value of
** the key for the current entry.  If the cursor is not pointing
** to a valid entry, *pSize is set to 0. 
**
** For a table with the INTKEY flag set, this routine returns the key
** itself, not the number of bytes in the key.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeKeySize</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>i64</name> *</type><name>pSize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name> || <name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pSize</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pSize</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nKey</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set *pSize to the number of bytes of data in the entry the
** cursor currently points to.  Always return SQLITE_OK.
** Failure is not possible.  If the cursor is not currently
** pointing to an entry (which can happen, for example, if
** the database is empty) then *pSize is set to 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeDataSize</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>u32</name> *</type><name>pSize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name> || <name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr> )</condition><then><block>{
      <comment type="block">/* Not pointing at a valid entry - set *pSize to 0. */</comment>
      <expr_stmt><expr>*<name>pSize</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pSize</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nData</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Given the page number of an overflow page in the database (parameter
** ovfl), this function finds the page number of the next page in the 
** linked list of overflow pages. If possible, it uses the auto-vacuum
** pointer-map data instead of reading the content of page ovfl to do so. 
**
** If an error occurs an SQLite error code is returned. Otherwise:
**
** Unless pPgnoNext is NULL, the page number of the next overflow 
** page in the linked list is written to *pPgnoNext. If page ovfl
** is the last page in its linked list, *pPgnoNext is set to zero. 
**
** If ppPage is not NULL, *ppPage is set to the MemPage* handle
** for page ovfl. The underlying pager page may have been requested
** with the noContent flag set, so the page data accessable via
** this handle may not be trusted.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getOverflowPage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, 
  <param><decl><type><name>Pgno</name></type> <name>ovfl</name></decl></param>,                   <comment type="block">/* Overflow page */</comment>
  <param><decl><type><name>MemPage</name> **</type><name>ppPage</name></decl></param>,            <comment type="block">/* OUT: MemPage handle */</comment>
  <param><decl><type><name>Pgno</name> *</type><name>pPgnoNext</name></decl></param>              <comment type="block">/* OUT: Next overflow page number */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>next</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* One of these must not be NULL. Otherwise, why call this function? */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ppPage</name> || <name>pPgnoNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pPgnoNext is NULL, then this function is being called to obtain
  ** a MemPage* reference only. No page-data is required in this case.
  */</comment>
  <if>if<condition>( <expr>!<name>pPgnoNext</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <comment type="block">/* Try to find the next page in the overflow list using the
  ** autovacuum pointer-map pages. Guess that the next page in 
  ** the overflow list is page number (ovfl+1). If that guess turns 
  ** out to be wrong, fall back to loading the data of page 
  ** number ovfl to determine the next page number.
  */</comment>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iGuess</name> =<init> <expr><name>ovfl</name>+1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>

    <while>while<condition>( <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iGuess</name></expr></argument>)</argument_list></call> || <name>iGuess</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>iGuess</name>++</expr>;</expr_stmt>
    }</block></while>

    <if>if<condition>( <expr><name>iGuess</name>&lt;=<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iGuess</name></expr></argument>, <argument><expr>&amp;<name>eType</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_OVERFLOW2</name> &amp;&amp; <name>pgno</name>==<name>ovfl</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>next</name> = <name>iGuess</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>next</name>==0 || <name>ppPage</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovfl</name></expr></argument>, <argument><expr>&amp;<name>pPage</name></expr></argument>, <argument><expr><name>next</name>!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name>==<name>SQLITE_OK</name> || <name>pPage</name>==0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>next</name>==0 &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>next</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr><name>ppPage</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>ppPage</name> = <name>pPage</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr>*<name>pPgnoNext</name> = <name>next</name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Copy data from a buffer to a page, or from a page to a buffer.
**
** pPayload is a pointer to data stored on database page pDbPage.
** If argument eOp is false, then nByte bytes of data are copied
** from pPayload to the buffer pointed at by pBuf. If eOp is true,
** then sqlite3PagerWrite() is called on pDbPage and nByte bytes
** of data are copied from the buffer pBuf to pPayload.
**
** SQLITE_OK is returned on success, otherwise an error code.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>copyPayload</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>pPayload</name></decl></param>,           <comment type="block">/* Pointer to page data */</comment>
  <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>,               <comment type="block">/* Pointer to buffer */</comment>
  <param><decl><type><name>int</name></type> <name>nByte</name></decl></param>,                <comment type="block">/* Number of bytes to copy */</comment>
  <param><decl><type><name>int</name></type> <name>eOp</name></decl></param>,                  <comment type="block">/* 0 -&gt; copy from page, 1 -&gt; copy to page */</comment>
  <param><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl></param>           <comment type="block">/* Page containing pPayload */</comment>
)</parameter_list><block>{
  <if>if<condition>( <expr><name>eOp</name></expr> )</condition><then><block>{
    <comment type="block">/* Copy data from buffer to page (a write operation) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Copy data from page to buffer (a read operation) */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is used to read or overwrite payload information
** for the entry that the pCur cursor is pointing to. If the eOp
** parameter is 0, this is a read operation (data copied into
** buffer pBuf). If it is non-zero, a write (data copied from
** buffer pBuf).
**
** A total of "amt" bytes are read or written beginning at "offset".
** Data is read to or from the buffer pBuf.
**
** This routine does not make a distinction between key and data.
** It just reads or writes bytes from the payload area.  Data might 
** appear on the main page or be scattered out on multiple overflow 
** pages.
**
** If the BtCursor.isIncrblobHandle flag is set, and the current
** cursor entry uses one or more overflow pages, this function
** allocates space for and lazily popluates the overflow page-list 
** cache array (BtCursor.aOverflow). Subsequent calls use this
** cache to make seeking to the supplied offset more efficient.
**
** Once an overflow page-list cache has been allocated, it may be
** invalidated if some other cursor writes to the same table, or if
** the cursor is moved to a different row. Additionally, in auto-vacuum
** mode, the following events may invalidate an overflow page-list cache.
**
**   * An incremental vacuum,
**   * A commit in auto_vacuum="full" mode,
**   * Creating a table (may require moving an overflow page).
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>accessPayload</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,      <comment type="block">/* Cursor pointing to entry to read from */</comment>
  <param><decl><type><name>u32</name></type> <name>offset</name></decl></param>,          <comment type="block">/* Begin reading this far into payload */</comment>
  <param><decl><type><name>u32</name></type> <name>amt</name></decl></param>,             <comment type="block">/* Read this many bytes */</comment>
  <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>pBuf</name></decl></param>, <comment type="block">/* Write the bytes into this buffer */</comment> 
  <param><decl><type><name>int</name></type> <name>skipKey</name></decl></param>,         <comment type="block">/* offset begins at data if this is true */</comment>
  <param><decl><type><name>int</name></type> <name>eOp</name></decl></param>              <comment type="block">/* zero to read. non-zero to write. */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>aPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Btree page of current entry */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pCur</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>                  <comment type="block">/* Btree this cursor belongs to */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPayload</name> = <name>pCur</name>-&gt;<name>info</name>.<name>pCell</name> + <name>pCur</name>-&gt;<name>info</name>.<name>nHeader</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nKey</name> = (<name>pPage</name>-&gt;<name>intKey</name> ? 0 : (<name>int</name>)<name>pCur</name>-&gt;<name>info</name>.<name>nKey</name>)</expr>;</expr_stmt>

  <if>if<condition>( <expr><name>skipKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>offset</name> += <name>nKey</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>offset</name>+<name>amt</name> &gt; <name>nKey</name>+<name>pCur</name>-&gt;<name>info</name>.<name>nData</name> 
   || &amp;<name><name>aPayload</name><index>[<expr><name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr>]</index></name> &gt; &amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pBt</name>-&gt;<name>usableSize</name></expr>]</index></name></expr>
  )</condition><then><block>{
    <comment type="block">/* Trying to read or write past the end of the data is an error */</comment>
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Check if data must be read/written to/from the btree page itself. */</comment>
  <if>if<condition>( <expr><name>offset</name>&lt;<name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>a</name> =<init> <expr><name>amt</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>a</name>+<name>offset</name>&gt;<name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>a</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name> - <name>offset</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>copyPayload</name><argument_list>(<argument><expr>&amp;<name><name>aPayload</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> += <name>a</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>amt</name> -= <name>a</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>offset</name> -= <name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>amt</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>u32</name></type> <name>ovflSize</name> =<init> <expr><name>pBt</name>-&gt;<name>usableSize</name> - 4</expr></init></decl>;</decl_stmt>  <comment type="block">/* Bytes content per ovfl page */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nextPage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nextPage</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>aPayload</name><index>[<expr><name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
    <comment type="block">/* If the isIncrblobHandle flag is set and the BtCursor.aOverflow[]
    ** has not been allocated, allocate it now. The array is sized at
    ** one entry for each overflow page in the overflow chain. The
    ** page number of the first overflow page is stored in aOverflow[0],
    ** etc. A value of 0 in the aOverflow[] array means "not yet known"
    ** (the cache is lazily populated).
    */</comment>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>isIncrblobHandle</name> &amp;&amp; !<name>pCur</name>-&gt;<name>aOverflow</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name> =<init> <expr>(<name>pCur</name>-&gt;<name>info</name>.<name>nPayload</name>-<name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name>+<name>ovflSize</name>-1)/<name>ovflSize</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>aOverflow</name> = (<name>Pgno</name> *)<call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Pgno</name></expr></argument>)</argument_list></call>*<name>nOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nOvfl</name> &amp;&amp; !<name>pCur</name>-&gt;<name>aOverflow</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If the overflow page-list cache has been allocated and the
    ** entry for the first required overflow page is valid, skip
    ** directly to it.
    */</comment>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>aOverflow</name> &amp;&amp; <name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>offset</name>/<name>ovflSize</name></expr>]</index></name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>iIdx</name> = (<name>offset</name>/<name>ovflSize</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>nextPage</name> = <name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> = (<name>offset</name>%<name>ovflSize</name>)</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for( <init>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>amt</name>&gt;0 &amp;&amp; <name>nextPage</name></expr>;</condition> <incr><expr><name>iIdx</name>++</expr></incr>)<block>{

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
      <comment type="block">/* If required, populate the overflow page-list cache. */</comment>
      <if>if<condition>( <expr><name>pCur</name>-&gt;<name>aOverflow</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name> || <name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name>==<name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name></expr>]</index></name> = <name>nextPage</name></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>( <expr><name>offset</name>&gt;=<name>ovflSize</name></expr> )</condition><then><block>{
        <comment type="block">/* The only reason to read this page is to obtain the page
        ** number for the next page in the overflow chain. The page
        ** data is not required. So first try to lookup the overflow
        ** page-list cache, if any, then fall back to the getOverflowPage()
        ** function.
        */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
        <if>if<condition>( <expr><name>pCur</name>-&gt;<name>aOverflow</name> &amp;&amp; <name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name>+1</expr>]</index></name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>nextPage</name> = <name>pCur</name>-&gt;<name><name>aOverflow</name><index>[<expr><name>iIdx</name>+1</expr>]</index></name></expr>;</expr_stmt>
        }</block></then> <else>else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>rc</name> = <call><name>getOverflowPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nextPage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <expr_stmt><expr><name>offset</name> -= <name>ovflSize</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* Need to read this page properly. It contains some of the
        ** range of data that is being read (eOp==0) or written (eOp!=0).
        */</comment>
        <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>a</name> =<init> <expr><name>amt</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>nextPage</name></expr></argument>, <argument><expr>&amp;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>aPayload</name> = <call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nextPage</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>aPayload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>a</name> + <name>offset</name> &gt; <name>ovflSize</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>a</name> = <name>ovflSize</name> - <name>offset</name></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>rc</name> = <call><name>copyPayload</name><argument_list>(<argument><expr>&amp;<name><name>aPayload</name><index>[<expr><name>offset</name>+4</expr>]</index></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>eOp</name></expr></argument>, <argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>amt</name> -= <name>a</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pBuf</name> += <name>a</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
    }</block></for>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>amt</name>&gt;0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read part of the key associated with cursor pCur.  Exactly
** "amt" bytes will be transfered into pBuf[].  The transfer
** begins at "offset".
**
** Return SQLITE_OK on success or an error code if anything goes
** wrong.  An error is returned if "offset+amt" is larger than
** the available payload.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeKey</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>u32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>u32</name></type> <name>amt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>&gt;=0 &amp;&amp; <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>*)<name>pBuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read part of the data associated with cursor pCur.  Exactly
** "amt" bytes will be transfered into pBuf[].  The transfer
** begins at "offset".
**
** Return SQLITE_OK on success or an error code if anything goes
** wrong.  An error is returned if "offset+amt" is larger than
** the available payload.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeData</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>u32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>u32</name></type> <name>amt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
  <if>if <condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ABORT</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>&gt;=0 &amp;&amp; <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>accessPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a pointer to payload information from the entry that the 
** pCur cursor is pointing to.  The pointer is to the beginning of
** the key if skipKey==0 and it points to the beginning of data if
** skipKey==1.  The number of bytes of available key/data is written
** into *pAmt.  If *pAmt==0, then the value returned will not be
** a valid pointer.
**
** This routine is an optimization.  It is common for the entire key
** and data to fit on the local page and for there to be no overflow
** pages.  When that is so, this routine can be used to access the
** key and data without making a copy.  If the key and/or data spills
** onto overflow pages, then accessPayload() must be used to reassembly
** the key/data and copy it into a preallocated buffer.
**
** The pointer returned by this routine looks directly into the cached
** page of the database.  The data might change or move the next time
** any btree routine is called.
*/</comment>
<function><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name> *</type><name>fetchPayload</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,      <comment type="block">/* Cursor pointing to entry to read from */</comment>
  <param><decl><type><name>int</name> *</type><name>pAmt</name></decl></param>,           <comment type="block">/* Write the number of available bytes here */</comment>
  <param><decl><type><name>int</name></type> <name>skipKey</name></decl></param>          <comment type="block">/* read beginning at data if this is true */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>aPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nLocal</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>!=0 &amp;&amp; <name>pCur</name>-&gt;<name>iPage</name>&gt;=0 &amp;&amp; <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPayload</name> = <name>pCur</name>-&gt;<name>info</name>.<name>pCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPayload</name> += <name>pCur</name>-&gt;<name>info</name>.<name>nHeader</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nKey</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>nKey</name> = (<name>int</name>)<name>pCur</name>-&gt;<name>info</name>.<name>nKey</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>skipKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aPayload</name> += <name>nKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLocal</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name> - <name>nKey</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>nLocal</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nLocal</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nLocal</name>&gt;<name>nKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nLocal</name> = <name>nKey</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <expr_stmt><expr>*<name>pAmt</name> = <name>nLocal</name></expr>;</expr_stmt>
  <return>return <expr><name>aPayload</name></expr>;</return>
}</block></function>


<comment type="block">/*
** For the entry that cursor pCur is point to, return as
** many bytes of the key or data as are available on the local
** b-tree page.  Write the number of available bytes into *pAmt.
**
** The pointer returned is ephemeral.  The key/data may move
** or be destroyed on the next call to any Btree routine,
** including calls from other threads against the same cache.
** Hence, a mutex on the BtShared should be held prior to calling
** this routine.
**
** These routines is used to get quick access to key and data
** in the common case where no overflow pages are used.
*/</comment>
<function><type><name>const</name> <name>void</name> *</type><name>sqlite3BtreeKeyFetch</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pAmt</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr> )</condition><then><block>{
    <return>return <expr>(<name>const</name> <name>void</name>*)<call><name>fetchPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pAmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>const</name> <name>void</name> *</type><name>sqlite3BtreeDataFetch</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pAmt</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr> )</condition><then><block>{
    <return>return <expr>(<name>const</name> <name>void</name>*)<call><name>fetchPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pAmt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Move the cursor down to a new child page.  The newPgno argument is the
** page number of the child page to move to.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>moveToChild</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>u32</name></type> <name>newPgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pCur</name>-&gt;<name>iPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pNewPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pCur</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>&lt;<name>BTCURSOR_MAX_DEPTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>iPage</name>&gt;=(<name>BTCURSOR_MAX_DEPTH</name>-1)</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>newPgno</name></expr></argument>, <argument><expr>&amp;<name>pNewPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name>+1</expr>]</index></name> = <name>pNewPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>i</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name>++</expr>;</expr_stmt>

  <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNewPage</name>-&gt;<name>nCell</name>&lt;1</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Page pParent is an internal (non-leaf) tree page. This function 
** asserts that page number iChild is the left-child if the iIdx'th
** cell in page pParent. Or, if iIdx is equal to the total number of
** cells in pParent, that page number iChild is the right-child of
** the page.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>assertParentIndex</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pParent</name></decl></param>, <param><decl><type><name>int</name></type> <name>iIdx</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iChild</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdx</name>&lt;=<name>pParent</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iIdx</name>==<name>pParent</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pParent</name>-&gt;<name><name>aData</name><index>[<expr><name>pParent</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call>==<name>iChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==<name>iChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>assertParentIndex</name>(x,y,z)</cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Move the cursor up to the parent page.
**
** pCur-&gt;idx is set to the cell index that contains the pointer
** to the page we are coming from.  If we are coming from the
** right-most child page then pCur-&gt;idx is set to one more than
** the largest cell index.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeMoveToParent</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assertParentIndex</name><argument_list>(
    <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name>-1</expr>]</index></name></expr></argument>, 
    <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name>-1</expr>]</index></name></expr></argument>, 
    <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>pgno</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Move the cursor to the root page
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>moveToRoot</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>pCur</name>-&gt;<name>pBtree</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_INVALID</name> &lt; <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_VALID</name>   &lt; <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>CURSOR_FAULT</name>   &gt; <name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>&gt;=<name>CURSOR_REQUIRESEEK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_FAULT</name></expr> )</condition><then><block>{
      <return>return <expr><name>pCur</name>-&gt;<name>skip</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>iPage</name>&gt;=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pCur</name>-&gt;<name>iPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then><else>else<block>{
    <if>if<condition>( 
      <expr><name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr>&amp;<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>
    )</condition><then><block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></else></if>

  <expr_stmt><expr><name>pRoot</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRoot</name>-&gt;<name>pgno</name>==<name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>atLast</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pRoot</name>-&gt;<name>nCell</name>==0 &amp;&amp; !<name>pRoot</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>subpage</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRoot</name>-&gt;<name>pgno</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subpage</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pRoot</name>-&gt;<name><name>aData</name><index>[<expr><name>pRoot</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>subpage</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_VALID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>subpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = ((<name>pRoot</name>-&gt;<name>nCell</name>&gt;0)?<name>CURSOR_VALID</name>:<name>CURSOR_INVALID</name>)</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Move the cursor down to the left-most leaf entry beneath the
** entry to which it is currently pointing.
**
** The left-most leaf is the one with the smallest key - the first
** in ascending order.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>moveToLeftmost</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !(<name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>)-&gt;<name>leaf</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Move the cursor down to the right-most leaf entry beneath the
** page to which it is currently pointing.  Notice the difference
** between moveToLeftmost() and moveToRightmost().  moveToLeftmost()
** finds the left-most entry beneath the *entry* whereas moveToRightmost()
** finds the right-most entry beneath the *page*.
**
** The right-most entry is the one with the largest key - the last
** key in ascending order.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>moveToRightmost</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !(<name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>)-&gt;<name>leaf</name></expr> )</condition><block>{
    <expr_stmt><expr><name>pgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = <name>pPage</name>-&gt;<name>nCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = <name>pPage</name>-&gt;<name>nCell</name>-1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* Move the cursor to the first entry in the table.  Return SQLITE_OK
** on success.  Set *pRes to 0 if the cursor actually points to something
** or set *pRes to 1 if the table is empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeFirst</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* Move the cursor to the last entry in the table.  Return SQLITE_OK
** on success.  Set *pRes to 0 if the cursor actually points to something
** or set *pRes to 1 if the table is empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeLast</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>CURSOR_INVALID</name>==<name>pCur</name>-&gt;<name>eState</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>moveToRightmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>getCellInfo</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>atLast</name> = <name>rc</name>==<name>SQLITE_OK</name> ?1:0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* Move the cursor so that it points to an entry near the key 
** specified by pIdxKey or intKey.   Return a success code.
**
** For INTKEY tables, the intKey parameter is used.  pIdxKey 
** must be NULL.  For index tables, pIdxKey is used and intKey
** is ignored.
**
** If an exact match is not found, then the cursor is always
** left pointing at a leaf page which would hold the entry if it
** were present.  The cursor might point to an entry that comes
** before or after the key.
**
** An integer is written into *pRes which is the result of
** comparing the key with the entry to which the cursor is 
** pointing.  The meaning of the integer written into
** *pRes is as follows:
**
**     *pRes&lt;0      The cursor is left pointing at an entry that
**                  is smaller than intKey/pIdxKey or if the table is empty
**                  and the cursor is therefore left point to nothing.
**
**     *pRes==0     The cursor is left pointing at an entry that
**                  exactly matches intKey/pIdxKey.
**
**     *pRes&gt;0      The cursor is left pointing at an entry that
**                  is larger than intKey/pIdxKey.
**
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeMovetoUnpacked</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,          <comment type="block">/* The cursor to be moved */</comment>
  <param><decl><type><name>UnpackedRecord</name> *</type><name>pIdxKey</name></decl></param>, <comment type="block">/* Unpacked index key */</comment>
  <param><decl><type><name>i64</name></type> <name>intKey</name></decl></param>,              <comment type="block">/* The table key */</comment>
  <param><decl><type><name>int</name></type> <name>biasRight</name></decl></param>,           <comment type="block">/* If true, bias the search to the high end */</comment>
  <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>                <comment type="block">/* Write search results here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the cursor is already positioned at the point we are trying
  ** to move to, then just return without doing any work */</comment>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name> &amp;&amp; <name>pCur</name>-&gt;<name>validNKey</name> 
   &amp;&amp; <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>intKey</name></expr> 
  )</condition><then><block>{
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>info</name>.<name>nKey</name>==<name>intKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>pCur</name>-&gt;<name>atLast</name> &amp;&amp; <name>pCur</name>-&gt;<name>info</name>.<name>nKey</name>&lt;<name>intKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pRes</name> = -1</expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRes</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>intKey</name> || <name>pIdxKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init>;</init><condition>;</condition><incr/>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>lwr</name>, <name>upr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>chldPg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>  <comment type="block">/* pRes return if table is empty must be -1 */</comment>
    <expr_stmt><expr><name>lwr</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>upr</name> = <name>pPage</name>-&gt;<name>nCell</name>-1</expr>;</expr_stmt>
    <if>if<condition>( <expr>(!<name>pPage</name>-&gt;<name>intKey</name> &amp;&amp; <name>pIdxKey</name>==0) || <name>upr</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>moveto_finish</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>biasRight</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = (<name>u16</name>)<name>upr</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = (<name>u16</name>)((<name>upr</name>+<name>lwr</name>)/2)</expr>;</expr_stmt>
    }</block></else></if>
    <for>for(<init>;</init><condition>;</condition><incr/>)<block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>pCellKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>idx</name> =<init> <expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> + <name>pPage</name>-&gt;<name>childPtrSize</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pPage</name>-&gt;<name>hasData</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>u32</name></type> <name>dummy</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>pCell</name> += <call><name>getVarint32</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>getVarint</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>, <argument><expr>(<name>u64</name>*)&amp;<name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>nCellKey</name>==<name>intKey</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>c</name> = 0</expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>nCellKey</name>&lt;<name>intKey</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>c</name> = -1</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCellKey</name>&gt;<name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> = +1</expr>;</expr_stmt>
        }</block></else></if></else></if>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>available</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pCellKey</name> = (<name>void</name> *)<call><name>fetchPayload</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>available</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCellKey</name> = <name>pCur</name>-&gt;<name>info</name>.<name>nKey</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>available</name>&gt;=<name>nCellKey</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>c</name> = <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument>, <argument><expr><name>pCellKey</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>pCellKey</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>pCellKey</name>==0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <goto>goto <name>moveto_finish</name>;</goto>
          }</block></then></if>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>pCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> = <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument>, <argument><expr><name>pCellKey</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>moveto_finish</name>;</goto></then></if>
        }</block></else></if>
      }</block></else></if>
      <if>if<condition>( <expr><name>c</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nKey</name> = <name>nCellKey</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name> &amp;&amp; !<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>lwr</name> = <name>idx</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>upr</name> = <name>lwr</name> - 1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then><else>else<block>{
          <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
          <goto>goto <name>moveto_finish</name>;</goto>
        }</block></else></if>
      }</block></then></if>
      <if>if<condition>( <expr><name>c</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>lwr</name> = <name>idx</name>+1</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>upr</name> = <name>idx</name>-1</expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>lwr</name>&gt;<name>upr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nKey</name> = <name>nCellKey</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = (<name>u16</name>)((<name>lwr</name>+<name>upr</name>)/2)</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lwr</name>==<name>upr</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>chldPg</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>lwr</name>&gt;=<name>pPage</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>chldPg</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>chldPg</name> = <call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>lwr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <if>if<condition>( <expr><name>chldPg</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&lt;<name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pRes</name></expr> )</condition><then> <expr_stmt><expr>*<name>pRes</name> = <name>c</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
      <goto>goto <name>moveto_finish</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name> = (<name>u16</name>)<name>lwr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>chldPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>moveto_finish</name>;</goto></then></if>
  }</block></for>
<label><name>moveto_finish</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** In this version of BtreeMoveto, pKey is a packed index record
** such as is generated by the OP_MakeRecord opcode.  Unpack the
** record and then call BtreeMovetoUnpacked() to do the work.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeMoveto</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,     <comment type="block">/* Cursor open on the btree to be searched */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey</name></decl></param>,   <comment type="block">/* Packed key if the btree is an index */</comment>
  <param><decl><type><name>i64</name></type> <name>nKey</name></decl></param>,           <comment type="block">/* Integer key for tables.  Size of pKey for indices */</comment>
  <param><decl><type><name>int</name></type> <name>bias</name></decl></param>,           <comment type="block">/* Bias search to the high end */</comment>
  <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>           <comment type="block">/* Write search results here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Status code */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name> *</type><name>pIdxKey</name></decl>;</decl_stmt>   <comment type="block">/* Unpacked index key */</comment>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name><name>aSpace</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Temp space for pIdxKey - to avoid a malloc */</comment>

  <if>if<condition>( <expr><name>pKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nKey</name>==(<name>i64</name>)(<name>int</name>)<name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxKey</name> = <call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pKeyInfo</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nKey</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>,
                                      <argument><expr><name>aSpace</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aSpace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIdxKey</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pIdxKey</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>bias</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteUnpackedRecord</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Return TRUE if the cursor is not pointing at an entry of the table.
**
** TRUE will be returned after a call to sqlite3BtreeNext() moves
** past the last entry in the table or sqlite3BtreePrev() moves past
** the first entry.  TRUE is also returned if the table is empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeEof</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries
  ** have been deleted? This API will need to change to return an error code
  ** as well as the boolean result value.
  */</comment>
  <return>return <expr>(<name>CURSOR_VALID</name>!=<name>pCur</name>-&gt;<name>eState</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Return the database connection handle for a cursor.
*/</comment>
<function><type><name>sqlite3</name> *</type><name>sqlite3BtreeCursorDb</name><parameter_list>(<param><decl><type><name>const</name> <name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Advance the cursor to the next entry in the database.  If
** successful then set *pRes=0.  If the cursor
** was already pointing to the last entry in the database before
** this routine was called, then set *pRes=1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeNext</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRes</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>CURSOR_INVALID</name>==<name>pCur</name>-&gt;<name>eState</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>skip</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>skip</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>skip</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> = ++<name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&lt;=<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>idx</name>&gt;=<name>pPage</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <do>do<block>{
      <if>if<condition>( <expr><name>pCur</name>-&gt;<name>iPage</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3BtreeMoveToParent</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
    }</block>while<condition>( <expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&gt;=<name>pPage</name>-&gt;<name>nCell</name></expr> )</condition>;</do>
    <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>moveToLeftmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Step the cursor to the back to the previous entry in the database.  If
** successful then set *pRes=0.  If the cursor
** was already pointing to the first entry in the database before
** this routine was called, then set *pRes=1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreePrevious</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pRes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>atLast</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>CURSOR_INVALID</name>==<name>pCur</name>-&gt;<name>eState</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>skip</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>skip</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>skip</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> =<init> <expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToChild</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>moveToRightmost</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <while>while<condition>( <expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>==0</expr> )</condition><block>{
      <if>if<condition>( <expr><name>pCur</name>-&gt;<name>iPage</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCur</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>pRes</name> = 1</expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3BtreeMoveToParent</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>--</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name> &amp;&amp; !<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <expr_stmt><expr>*<name>pRes</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate a new page from the database file.
**
** The new page is marked as dirty.  (In other words, sqlite3PagerWrite()
** has already been called on the new page.)  The new page has also
** been referenced and the calling routine is responsible for calling
** sqlite3PagerUnref() on the new page when it is done.
**
** SQLITE_OK is returned on success.  Any other return value indicates
** an error.  *ppPage and *pPgno are undefined in the event of an error.
** Do not invoke sqlite3PagerUnref() on *ppPage if an error is returned.
**
** If the "nearby" parameter is not 0, then a (feeble) effort is made to 
** locate a page close to the page number "nearby".  This can be used in an
** attempt to keep related pages close to each other in the database file,
** which in turn can make database access faster.
**
** If the "exact" parameter is not 0, and the page-number nearby exists 
** anywhere on the free-list, then it is guarenteed to be returned. This
** is only used by auto-vacuum databases when allocating a new table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>allocateBtreePage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>, 
  <param><decl><type><name>MemPage</name> **</type><name>ppPage</name></decl></param>, 
  <param><decl><type><name>Pgno</name> *</type><name>pPgno</name></decl></param>, 
  <param><decl><type><name>Pgno</name></type> <name>nearby</name></decl></param>,
  <param><decl><type><name>u8</name></type> <name>exact</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>     <comment type="block">/* Number of pages on the freelist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>     <comment type="block">/* Number of leaves on the trunk of the freelist */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pTrunk</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPrevTrunk</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage1</name> = <name>pBt</name>-&gt;<name>pPage1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>&gt;0</expr> )</condition><then><block>{
    <comment type="block">/* There are pages on the freelist.  Reuse one of those pages. */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>iTrunk</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>searchList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* If the free-list must be searched for 'nearby' */</comment>
    
    <comment type="block">/* If the 'exact' parameter was true and a query of the pointer-map
    ** shows that the page 'nearby' is somewhere on the free-list, then
    ** the entire-list will be searched for that page.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>exact</name> &amp;&amp; <name>nearby</name>&lt;=<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nearby</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>nearby</name></expr></argument>, <argument><expr>&amp;<name>eType</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <if>if<condition>( <expr><name>eType</name>==<name>PTRMAP_FREEPAGE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>searchList</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr>*<name>pPgno</name> = <name>nearby</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Decrement the free-list count by 1. Set iTrunk to the index of the
    ** first free-list trunk page. iPrevTrunk is initially 1.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The code within this loop is run only once if the 'searchList' variable
    ** is not true. Otherwise, it runs once for each trunk-page on the
    ** free-list until the page 'nearby' is located.
    */</comment>
    <do>do <block>{
      <expr_stmt><expr><name>pPrevTrunk</name> = <name>pTrunk</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pPrevTrunk</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>iTrunk</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPrevTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>iTrunk</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iTrunk</name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pTrunk</name> = 0</expr>;</expr_stmt>
        <goto>goto <name>end_allocate_page</name>;</goto>
      }</block></then></if>

      <expr_stmt><expr><name>k</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>k</name>==0 &amp;&amp; !<name>searchList</name></expr> )</condition><then><block>{
        <comment type="block">/* The trunk has no leaves and the list is not being searched. 
        ** So extract the trunk page itself and use it as the newly 
        ** allocated page */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrevTrunk</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
          <goto>goto <name>end_allocate_page</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr>*<name>pPgno</name> = <name>iTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>ppPage</name> = <name>pTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTrunk</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALLOCATE: %d trunk - %d free pages left\n", *<name>pPgno</name>, <name>n</name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>k</name>&gt;<name>pBt</name>-&gt;<name>usableSize</name>/4 - 2</expr> )</condition><then><block>{
        <comment type="block">/* Value of k is out of range.  Database corruption */</comment>
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>end_allocate_page</name>;</goto>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      }</block></then><else>else <if>if<condition>( <expr><name>searchList</name> &amp;&amp; <name>nearby</name>==<name>iTrunk</name></expr> )</condition><then><block>{
        <comment type="block">/* The list is being searched and this trunk page is the page
        ** to allocate, regardless of whether it has leaves.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>pPgno</name>==<name>iTrunk</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>ppPage</name> = <name>pTrunk</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>searchList</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
          <goto>goto <name>end_allocate_page</name>;</goto>
        }</block></then></if>
        <if>if<condition>( <expr><name>k</name>==0</expr> )</condition><then><block>{
          <if>if<condition>( <expr>!<name>pPrevTrunk</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPrevTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then><else>else<block>{
          <comment type="block">/* The trunk page is required by the caller but it contains 
          ** pointers to free-list leaves. The first leaf becomes a trunk
          ** page in this case.
          */</comment>
          <decl_stmt><decl><type><name>MemPage</name> *</type><name>pNewTrunk</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>iNewTrunk</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>, <argument><expr>&amp;<name>pNewTrunk</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <goto>goto <name>end_allocate_page</name>;</goto>
          }</block></then></if>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pNewTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>end_allocate_page</name>;</goto>
          }</block></then></if>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pNewTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pNewTrunk</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name>k</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pNewTrunk</name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>12</expr>]</index></name></expr></argument>, <argument><expr>(<name>k</name>-1)*4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr>!<name>pPrevTrunk</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPrevTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
              <goto>goto <name>end_allocate_page</name>;</goto>
            }</block></then></if>
            <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPrevTrunk</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>iNewTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></else></if>
        <expr_stmt><expr><name>pTrunk</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALLOCATE: %d trunk - %d free pages left\n", *<name>pPgno</name>, <name>n</name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then><else>else<block>{
        <comment type="block">/* Extract a leaf from the trunk */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>closest</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iPage</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>aData</name> =<init> <expr><name>pTrunk</name>-&gt;<name>aData</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
          <goto>goto <name>end_allocate_page</name>;</goto>
        }</block></then></if>
        <if>if<condition>( <expr><name>nearby</name>&gt;0</expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>dist</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>closest</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>dist</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>)</argument_list></call> - <name>nearby</name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>dist</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>dist</name> = -<name>dist</name></expr>;</expr_stmt></then></if>
          <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>k</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
            <decl_stmt><decl><type><name>int</name></type> <name>d2</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>aData</name><index>[<expr>8+<name>i</name>*4</expr>]</index></name></expr></argument>)</argument_list></call> - <name>nearby</name></expr></init></decl>;</decl_stmt>
            <if>if<condition>( <expr><name>d2</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>d2</name> = -<name>d2</name></expr>;</expr_stmt></then></if>
            <if>if<condition>( <expr><name>d2</name>&lt;<name>dist</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>closest</name> = <name>i</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>dist</name> = <name>d2</name></expr>;</expr_stmt>
            }</block></then></if>
          }</block></for>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>closest</name> = 0</expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>iPage</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>aData</name><index>[<expr>8+<name>closest</name>*4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<name>searchList</name> || <name>iPage</name>==<name>nearby</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>
          <expr_stmt><expr>*<name>pPgno</name> = <name>iPage</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nPage</name> = <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr>*<name>pPgno</name>&gt;<name>nPage</name></expr> )</condition><then><block>{
            <comment type="block">/* Free page off the end of the file */</comment>
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
            <goto>goto <name>end_allocate_page</name>;</goto>
          }</block></then></if>
          <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALLOCATE: %d was leaf %d of %d on trunk %d"
                 ": %d more free pages\n",
                 *<name>pPgno</name>, <name>closest</name>+1, <name>k</name>, <name>pTrunk</name>-&gt;<name>pgno</name>, <name>n</name>-1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>closest</name>&lt;<name>k</name>-1</expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>aData</name><index>[<expr>8+<name>closest</name>*4</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>aData</name><index>[<expr>4+<name>k</name>*4</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name>k</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>*<name>pPgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3PagerDontRollback</name><argument_list>(<argument><expr>(*<name>ppPage</name>)-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr>(*<name>ppPage</name>)-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
              <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr>*<name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then></if>
          <expr_stmt><expr><name>searchList</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if></else></if></else></if>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPrevTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrevTrunk</name> = 0</expr>;</expr_stmt>
    }</block>while<condition>( <expr><name>searchList</name></expr> )</condition>;</do>
  }</block></then><else>else<block>{
    <comment type="block">/* There are no pages on the freelist, so create a new page at the
    ** end of the file */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> =<init> <expr><call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>pPgno</name> = <name>nPage</name> + 1</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name> &amp;&amp; <call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>*<name>pPgno</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* If *pPgno refers to a pointer-map page, allocate two new pages
      ** at the end of the file instead of one. The first allocated page
      ** becomes a new pointer-map page, the second is used by the caller.
      */</comment>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALLOCATE: %d from end of file (pointer-map page)\n", *<name>pPgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>pPgno</name>!=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>(*<name>pPgno</name>)++</expr>;</expr_stmt>
      <if>if<condition>( <expr>*<name>pPgno</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{ <expr_stmt><expr>(*<name>pPgno</name>)++</expr>;</expr_stmt> }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>pPgno</name>!=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>*<name>pPgno</name></expr></argument>, <argument><expr><name>ppPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr>(*<name>ppPage</name>)-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr>*<name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("ALLOCATE: %d from end of file\n", *<name>pPgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>pPgno</name>!=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>end_allocate_page</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPrevTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>sqlite3PagerPageRefcount</name><argument_list>(<argument><expr>(*<name>ppPage</name>)-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>&gt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr>*<name>ppPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>(*<name>ppPage</name>)-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add a page of the database file to the freelist.
**
** sqlite3PagerUnref() is NOT called for pPage.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>freePage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage1</name> =<init> <expr><name>pBt</name>-&gt;<name>pPage1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name>, <name>n</name>, <name>k</name></decl>;</decl_stmt>

  <comment type="block">/* Prepare the page for freeing */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pgno</name>&gt;1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Increment the free page count on pPage1 */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>n</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SECURE_DELETE</name></cpp:ifdef>
  <comment type="block">/* If the SQLITE_SECURE_DELETE compile-time option is enabled, then
  ** always fully overwrite deleted information with zeros.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the database supports auto-vacuum, write an entry in the pointer-map
  ** to indicate that the page is free.
  */</comment>
  <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>n</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* This is the first free page */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FREE-PAGE: %d first\n", <name>pPage</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Other free pages already exist.  Retrive the first trunk page
    ** of the freelist and find out how many leaves it has. */</comment>
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pTrunk</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>pTrunk</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>k</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>k</name>&gt;=<name>pBt</name>-&gt;<name>usableSize</name>/4 - 8</expr> )</condition><then><block>{
      <comment type="block">/* The trunk is full.  Turn the page being freed into a new
      ** trunk page with no leaves.
      **
      ** Note that the trunk page is not really full until it contains
      ** usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have
      ** coded.  But due to a coding error in versions of SQLite prior to
      ** 3.6.0, databases with freelist trunk pages holding more than
      ** usableSize/4 - 8 entries will be reported as corrupt.  In order
      ** to maintain backwards compatibility with older versions of SQLite,
      ** we will contain to restrict the number of entries to usableSize/4 - 8
      ** for now.  At some point in the future (once everyone has upgraded
      ** to 3.6.0 or later) we should consider fixing the conditional above
      ** to read "usableSize/4-2" instead of "usableSize/4-8".
      */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name>pTrunk</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FREE-PAGE: %d new trunk page replacing %d\n",
                <name>pPage</name>-&gt;<name>pgno</name>, <name>pTrunk</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>k</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* Add the newly freed page as a leaf on the current trunk */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pTrunk</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name>k</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pTrunk</name>-&gt;<name><name>aData</name><index>[<expr>8+<name>k</name>*4</expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_SECURE_DELETE</name></cpp:ifndef>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerDontWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("FREE-PAGE: %d leaf on trunk page %d\n",<name>pPage</name>-&gt;<name>pgno</name>,<name>pTrunk</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pTrunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Free any overflow pages associated with the given Cell.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>clearCell</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>pCell</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>ovflPgno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOvfl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ovflPageSize</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>info</name>.<name>iOverflow</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>  <comment type="block">/* No overflow pages. Return without doing anything */</comment>
  }</block></then></if>
  <expr_stmt><expr><name>ovflPgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ovflPageSize</name> = <name>pBt</name>-&gt;<name>usableSize</name> - 4</expr>;</expr_stmt>
  <expr_stmt><expr><name>nOvfl</name> = (<name>info</name>.<name>nPayload</name> - <name>info</name>.<name>nLocal</name> + <name>ovflPageSize</name> - 1)/<name>ovflPageSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ovflPgno</name>==0 || <name>nOvfl</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nOvfl</name>--</expr> )</condition><block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pOvfl</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>ovflPgno</name>==0 || <name>ovflPgno</name>&gt;<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rc</name> = <call><name>getOverflowPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>ovflPgno</name></expr></argument>, <argument><expr>&amp;<name>pOvfl</name></expr></argument>, <argument><expr>(<name>nOvfl</name>==0)?0:&amp;<name>ovflPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pOvfl</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  }</block></while>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create the byte sequence used to represent a cell on page pPage
** and write that byte sequence into pCell[].  Overflow pages are
** allocated and filled in as necessary.  The calling procedure
** is responsible for making sure sufficient space has been allocated
** for pCell[].
**
** Note that pCell does not necessary need to point to the pPage-&gt;aData
** area.  pCell might point to some temporary storage.  The cell will
** be constructed in this temporary area then copied into pPage-&gt;aData
** later.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>fillInCell</name><parameter_list>(
  <param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>,                <comment type="block">/* The page that contains the cell */</comment>
  <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>pCell</name></decl></param>,          <comment type="block">/* Complete text of the cell */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey</name></decl></param>, <param><decl><type><name>i64</name></type> <name>nKey</name></decl></param>,    <comment type="block">/* The key */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pData</name></decl></param>,<param><decl><type><name>int</name></type> <name>nData</name></decl></param>,   <comment type="block">/* The data */</comment>
  <param><decl><type><name>int</name></type> <name>nZero</name></decl></param>,                     <comment type="block">/* Extra zero bytes to append to pData */</comment>
  <param><decl><type><name>int</name> *</type><name>pnSize</name></decl></param>                    <comment type="block">/* Write cell size here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>u8</name> *</type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSrc</name>, <name>n</name>, <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>spaceLeft</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pOvfl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pToRelease</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pPrior</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pPayload</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoOvfl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHeader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* pPage is not necessarily writeable since pCell might be auxiliary
  ** buffer space that is separate from the pPage buffer area */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCell</name>&lt;<name>pPage</name>-&gt;<name>aData</name> || <name>pCell</name>&gt;=&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name></expr>]</index></name>
            || <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fill in the header. */</comment>
  <expr_stmt><expr><name>nHeader</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nHeader</name> += 4</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>hasData</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nHeader</name> += <call><name>putVarint</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr></argument>, <argument><expr><name>nData</name>+<name>nZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>nData</name> = <name>nZero</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>nHeader</name> += <call><name>putVarint</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr></argument>, <argument><expr>*(<name>u64</name>*)&amp;<name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>info</name>.<name>nHeader</name>==<name>nHeader</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>info</name>.<name>nKey</name>==<name>nKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>info</name>.<name>nData</name>==(<name>u32</name>)(<name>nData</name>+<name>nZero</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Fill in the payload */</comment>
  <expr_stmt><expr><name>nPayload</name> = <name>nData</name> + <name>nZero</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pSrc</name> = <name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> = <name>nData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{ 
    <comment type="block">/* TBD:  Perhaps raise SQLITE_CORRUPT if nKey is larger than 31 bits? */</comment>
    <expr_stmt><expr><name>nPayload</name> += (<name>int</name>)<name>nKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> = <name>pKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> = (<name>int</name>)<name>nKey</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr>*<name>pnSize</name> = <name>info</name>.<name>nSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>spaceLeft</name> = <name>info</name>.<name>nLocal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPayload</name> = &amp;<name><name>pCell</name><index>[<expr><name>nHeader</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name> = &amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>nPayload</name>&gt;0</expr> )</condition><block>{
    <if>if<condition>( <expr><name>spaceLeft</name>==0</expr> )</condition><then><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoPtrmap</name> =<init> <expr><name>pgnoOvfl</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Overflow page pointer-map entry page */</comment>
      <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
        <do>do<block>{
          <expr_stmt><expr><name>pgnoOvfl</name>++</expr>;</expr_stmt>
        }</block> while<condition>( 
          <expr><call><name>PTRMAP_ISPAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>)</argument_list></call> || <name>pgnoOvfl</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> 
        )</condition>;</do>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pOvfl</name></expr></argument>, <argument><expr>&amp;<name>pgnoOvfl</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <comment type="block">/* If the database supports auto-vacuum, and the second or subsequent
      ** overflow page is being allocated, add an entry to the pointer-map
      ** for that page now. 
      **
      ** If this is the first overflow page, then write a partial entry 
      ** to the pointer-map. If we write nothing to this pointer-map slot,
      ** then the optimistic overflow chain processing in clearCell()
      ** may misinterpret the uninitialised values and delete the
      ** wrong pages from the database.
      */</comment>
      <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>u8</name></type> <name>eType</name> =<init> <expr>(<name>pgnoPtrmap</name>?<name>PTRMAP_OVERFLOW2</name>:<name>PTRMAP_OVERFLOW1</name>)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>pgnoPtrmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>

      <comment type="block">/* If pToRelease is not zero than pPrior points into the data area
      ** of pToRelease.  Make sure pToRelease is still writeable. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToRelease</name>==0 || <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pToRelease</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If pPrior is part of the data area of pPage, then make sure pPage
      ** is still writeable */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name>&lt;<name>pPage</name>-&gt;<name>aData</name> || <name>pPrior</name>&gt;=&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name></expr>]</index></name>
            || <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pToRelease</name> = <name>pOvfl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrior</name> = <name>pOvfl</name>-&gt;<name>aData</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPayload</name> = &amp;<name>pOvfl</name>-&gt;<name><name>aData</name><index>[<expr>4</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>spaceLeft</name> = <name>pBt</name>-&gt;<name>usableSize</name> - 4</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>n</name> = <name>nPayload</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>n</name>&gt;<name>spaceLeft</name></expr> )</condition><then> <expr_stmt><expr><name>n</name> = <name>spaceLeft</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* If pToRelease is not zero than pPayload points into the data area
    ** of pToRelease.  Make sure pToRelease is still writeable. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pToRelease</name>==0 || <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pToRelease</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If pPayload is part of the data area of pPage, then make sure pPage
    ** is still writeable */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPayload</name>&lt;<name>pPage</name>-&gt;<name>aData</name> || <name>pPayload</name>&gt;=&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name></expr>]</index></name>
            || <call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>nSrc</name>&gt;0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>n</name>&gt;<name>nSrc</name></expr> )</condition><then> <expr_stmt><expr><name>n</name> = <name>nSrc</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPayload</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>nPayload</name> -= <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPayload</name> += <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> += <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSrc</name> -= <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>spaceLeft</name> -= <name>n</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nSrc</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>nSrc</name> = <name>nData</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSrc</name> = <name>pData</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pToRelease</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Remove the i-th cell from pPage.  This routine effects pPage only.
** The cell content is not freed or deallocated.  It is assumed that
** the cell content has been copied someplace else.  This routine just
** removes the reference to the cell from pPage.
**
** "sz" must be the number of bytes in the cell.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dropCell</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>idx</name></decl></param>, <param><decl><type><name>int</name></type> <name>sz</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>         <comment type="block">/* Offset to cell content of cell being deleted */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>       <comment type="block">/* pPage-&gt;aData */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>ptr</name></decl>;</decl_stmt>        <comment type="block">/* Used to move bytes around within data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>         <comment type="block">/* The return code */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&gt;=0 &amp;&amp; <name>idx</name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name>==<call><name>cellSize</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ptr</name> = &amp;<name><name>data</name><index>[<expr><name>pPage</name>-&gt;<name>cellOffset</name> + 2*<name>idx</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> = <call><name>get2byte</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pc</name>&lt;<name>pPage</name>-&gt;<name>hdrOffset</name>+6+(<name>pPage</name>-&gt;<name>leaf</name>?0:4))
     || (<name>pc</name>+<name>sz</name>&gt;<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>)</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>freeSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=<name>idx</name>+1</expr>;</init> <condition><expr><name>i</name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>ptr</name>+=2</expr></incr>)<block>{
    <expr_stmt><expr><name><name>ptr</name><index>[<expr>0</expr>]</index></name> = <name><name>ptr</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ptr</name><index>[<expr>1</expr>]</index></name> = <name><name>ptr</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nCell</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+3</expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>nCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> += 2</expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Insert a new cell on pPage at cell index "i".  pCell points to the
** content of the cell.
**
** If the cell content will fit on the page, then put it there.  If it
** will not fit, then make a copy of the cell content into pTemp if
** pTemp is not null.  Regardless of pTemp, allocate a new entry
** in pPage-&gt;aOvfl[] and make it point to the cell content (either
** in pTemp or the original pCell) and also record its index. 
** Allocating a new entry in pPage-&gt;aCell[] implies that 
** pPage-&gt;nOverflow is incremented.
**
** If nSkip is non-zero, then do not copy the first nSkip bytes of the
** cell. The caller will overwrite them after this function returns. If
** nSkip is non-zero, then pCell may not point to an invalid memory location 
** (but pCell+nSkip is always valid).
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>insertCell</name><parameter_list>(
  <param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>,   <comment type="block">/* Page into which we are copying */</comment>
  <param><decl><type><name>int</name></type> <name>i</name></decl></param>,            <comment type="block">/* New cell becomes the i-th cell of the page */</comment>
  <param><decl><type><name>u8</name> *</type><name>pCell</name></decl></param>,        <comment type="block">/* Content of the new cell */</comment>
  <param><decl><type><name>int</name></type> <name>sz</name></decl></param>,           <comment type="block">/* Bytes of content in pCell */</comment>
  <param><decl><type><name>u8</name> *</type><name>pTemp</name></decl></param>,        <comment type="block">/* Temp storage space for pCell, if needed */</comment>
  <param><decl><type><name>u8</name></type> <name>nSkip</name></decl></param>          <comment type="block">/* Do not write the first nSkip bytes of the cell */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>          <comment type="block">/* Where to write new cell content in data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>top</name></decl>;</decl_stmt>          <comment type="block">/* First byte of content for any cell in data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>          <comment type="block">/* First byte past the last cell pointer in data[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ins</name></decl>;</decl_stmt>          <comment type="block">/* Index in data[] where new cell pointer is inserted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>          <comment type="block">/* Offset into data[] of the page header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellOffset</name></decl>;</decl_stmt>   <comment type="block">/* Address of first cell pointer in data[] */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>         <comment type="block">/* The content of the whole page */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>ptr</name></decl>;</decl_stmt>          <comment type="block">/* Used for moving information around in data[] */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;=<name>pPage</name>-&gt;<name>nCell</name>+<name>pPage</name>-&gt;<name>nOverflow</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nCell</name>&lt;=<call><name>MX_CELL</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>MX_CELL</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call>&lt;=5460</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>&lt;=<call><name>ArraySize</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aOvfl</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name>==<call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>nOverflow</name> || <name>sz</name>+2&gt;<name>pPage</name>-&gt;<name>nFree</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pTemp</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTemp</name>+<name>nSkip</name></expr></argument>, <argument><expr><name>pCell</name>+<name>nSkip</name></expr></argument>, <argument><expr><name>sz</name>-<name>nSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCell</name> = <name>pTemp</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>j</name> = <name>pPage</name>-&gt;<name>nOverflow</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&lt;(<name>int</name>)(<call><name>sizeof</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aOvfl</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pCell</name> = <name>pCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr><name>j</name></expr>]</index></name>.<name>idx</name> = (<name>u16</name>)<name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cellOffset</name> = <name>pPage</name>-&gt;<name>cellOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> = <name>cellOffset</name> + 2*<name>pPage</name>-&gt;<name>nCell</name> + 2</expr>;</expr_stmt>
    <expr_stmt><expr><name>ins</name> = <name>cellOffset</name> + 2*<name>i</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>end</name> &gt; <name>top</name> - <name>sz</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>defragmentPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>top</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>end</name> + <name>sz</name> &lt;= <name>top</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>idx</name> = <call><name>allocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>end</name> &lt;= <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>idx</name>+<name>sz</name> &gt; <name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr>)</condition><then> <block>{
      <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nCell</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> -= 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>idx</name>+<name>nSkip</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name>+<name>nSkip</name></expr></argument>, <argument><expr><name>sz</name>-<name>nSkip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=<name>end</name>-2</expr>, <expr><name>ptr</name>=&amp;<name><name>data</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name>&gt;<name>ins</name></expr>;</condition> <incr><expr><name>j</name>-=2</expr>, <expr><name>ptr</name>-=2</expr></incr>)<block>{
      <expr_stmt><expr><name><name>ptr</name><index>[<expr>0</expr>]</index></name> = <name><name>ptr</name><index>[<expr>-2</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ptr</name><index>[<expr>1</expr>]</index></name> = <name><name>ptr</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>ins</name></expr>]</index></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>nCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
      <comment type="block">/* The cell may contain a pointer to an overflow page. If so, write
      ** the entry for the overflow page into the pointer map.
      */</comment>
      <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>info</name>.<name>nData</name>+(<name>pPage</name>-&gt;<name>intKey</name>?0:<name>info</name>.<name>nKey</name>))==<name>info</name>.<name>nPayload</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>info</name>.<name>nData</name>+(<name>pPage</name>-&gt;<name>intKey</name>?0:<name>info</name>.<name>nKey</name>))&gt;<name>info</name>.<name>nLocal</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoOvfl</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add a list of cells to a page.  The page should be initially empty.
** The cells are guaranteed to fit on the page.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>assemblePage</name><parameter_list>(
  <param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>,   <comment type="block">/* The page to be assemblied */</comment>
  <param><decl><type><name>int</name></type> <name>nCell</name></decl></param>,        <comment type="block">/* The number of cells to add to this page */</comment>
  <param><decl><type><name>u8</name> **</type><name>apCell</name></decl></param>,      <comment type="block">/* Pointers to cell bodies */</comment>
  <param><decl><type><name>u16</name> *</type><name>aSize</name></decl></param>        <comment type="block">/* Sizes of the cells */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>totalSize</name></decl>;</decl_stmt>    <comment type="block">/* Total size of all cells */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>          <comment type="block">/* Index of page header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellptr</name></decl>;</decl_stmt>      <comment type="block">/* Address of next cell pointer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cellbody</name></decl>;</decl_stmt>     <comment type="block">/* Address of next cell body */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>         <comment type="block">/* Data for the page */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name>&gt;=0 &amp;&amp; <name>nCell</name>&lt;=<call><name>MX_CELL</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>MX_CELL</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call>&lt;=5460</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>totalSize</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>totalSize</name> += <name><name>aSize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>totalSize</name>+2*<name>nCell</name>&lt;=<name>pPage</name>-&gt;<name>nFree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nCell</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cellptr</name> = <name>pPage</name>-&gt;<name>cellOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>, <argument><expr><name>nCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nCell</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>cellbody</name> = <call><name>allocateSpace</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>totalSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cellbody</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nFree</name> &gt;= 2*<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nFree</name> -= 2*<name>nCell</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>put2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>cellptr</name></expr>]</index></name></expr></argument>, <argument><expr><name>cellbody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>cellbody</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aSize</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cellptr</name> += 2</expr>;</expr_stmt>
      <expr_stmt><expr><name>cellbody</name> += <name><name>aSize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cellbody</name>==<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nCell</name> = (<name>u16</name>)<name>nCell</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The following parameters determine how many adjacent pages get involved
** in a balancing operation.  NN is the number of neighbors on either side
** of the page that participate in the balancing operation.  NB is the
** total number of pages that participate, including the target page and
** NN neighbors on either side.
**
** The minimum value of NN is 1 (of course).  Increasing NN above 1
** (to 2 or 3) gives a modest improvement in SELECT and DELETE performance
** in exchange for a larger degradation in INSERT and UPDATE performance.
** The value of NN appears to give the best results overall.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>NN</name> 1</cpp:define>             <comment type="block">/* Number of neighbors on either side of pPage */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>NB</name> (NN*2+1)</cpp:define>      <comment type="block">/* Total pages involved in the balance */</comment>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>balance</name><parameter_list>(<param><decl><type><name>BtCursor</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_QUICKBALANCE</name></cpp:ifndef>
<comment type="block">/*
** This version of balance() handles the common special case where
** a new entry is being inserted on the extreme right-end of the
** tree, in other words, when the new entry will become the largest
** entry in the tree.
**
** Instead of trying balance the 3 right-most leaf pages, just add
** a new page to the right-hand side and put the one new entry in
** that page.  This leaves the right side of the tree somewhat
** unbalanced.  But odds are that we will be inserting new entries
** at the end soon afterwards so the nearly empty page will quickly
** fill up.  On average.
**
** pPage is the leaf page which is the right-most page in the tree.
** pParent is its parent.  pPage must have a single overflow entry
** which is also the right-most entry on the page.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>balance_quick</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pNew</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>szCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pParent</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pPage</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>parentIdx</name> =<init> <expr><name>pParent</name>-&gt;<name>nCell</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* pParent new divider cell index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>parentSize</name></decl>;</decl_stmt>                   <comment type="block">/* Size of new divider cell */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name><name>parentCell</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Space for the new divider cell */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a new page. Insert the overflow cell from pPage
  ** into it. Then remove the overflow cell from pPage.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pNew</name></expr></argument>, <argument><expr>&amp;<name>pgnoNew</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCell</name> = <name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr>0</expr>]</index></name>.<name>pCell</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>szCell</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assemblePage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pCell</name></expr></argument>, <argument><expr>&amp;<name>szCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>
  
    <comment type="block">/* pPage is currently the right-child of pParent. Change this
    ** so that the right-child is the new page allocated above and
    ** pPage is the next-to-right child. 
    **
    ** Ignore the return value of the call to fillInCell(). fillInCell()
    ** may only return other than SQLITE_OK if it is required to allocate
    ** one or more overflow pages. Since an internal table B-Tree cell 
    ** may never spill over onto an overflow page (it is a maximum of 
    ** 13 bytes in size), it is not neccessary to check the return code.
    **
    ** Similarly, the insertCell() function cannot fail if the page
    ** being inserted into is already writable and the cell does not 
    ** contain an overflow pointer. So ignore this return code too.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nCell</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>nCell</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fillInCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>parentCell</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>info</name>.<name>nKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>parentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>parentSize</name>&lt;64</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pParent</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>insertCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentCell</name></expr></argument>, <argument><expr><name>parentSize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>,<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pParent</name>-&gt;<name><name>aData</name><index>[<expr><name>pParent</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* If this is an auto-vacuum database, update the pointer map
    ** with entries for the new page, and any pointer from the 
    ** cell on the page to an overflow page.
    */</comment>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoNew</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPutOvfl</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Release the reference to the new page. */</comment>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* At this point the pPage-&gt;nFree variable is not set correctly with
  ** respect to the content of the page (because it was set to 0 by 
  ** insertCell). So call sqlite3BtreeInitPage() to make sure it is
  ** correct.
  **
  ** This has to be done even if an error will be returned. Normally, if
  ** an error occurs during tree balancing, the contents of MemPage are
  ** not important, as they will be recalculated when the page is rolled
  ** back. But here, in balance_quick(), it is possible that pPage has 
  ** not yet been marked dirty or written into the journal file. Therefore
  ** it will not be rolled back and so it is important to make sure that
  ** the page data and contents of MemPage are consistent.
  */</comment>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If everything else succeeded, balance the parent page, in 
  ** case the divider cell inserted caused it to become overfull.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name>--</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_QUICKBALANCE */</comment>

<comment type="block">/*
** This routine redistributes Cells on pPage and up to NN*2 siblings
** of pPage so that all pages have about the same amount of free space.
** Usually NN siblings on either side of pPage is used in the balancing,
** though more siblings might come from one side if pPage is the first
** or last child of its parent.  If pPage has fewer than 2*NN siblings
** (something which can only happen if pPage is the root page or a 
** child of root) then all available siblings participate in the balancing.
**
** The number of siblings of pPage might be increased or decreased by one or
** two in an effort to keep pages nearly full but not over full. The root page
** is special and is allowed to be nearly empty. If pPage is 
** the root page, then the depth of the tree might be increased
** or decreased by one, as necessary, to keep the root page from being
** overfull or completely empty.
**
** Note that when this routine is called, some of the Cells on pPage
** might not actually be stored in pPage-&gt;aData[].  This can happen
** if the page is overfull.  Part of the job of this routine is to
** make sure all Cells for pPage once again fit in pPage-&gt;aData[].
**
** In the course of balancing the siblings of pPage, the parent of pPage
** might become overfull or underfull.  If that happens, then this routine
** is called recursively on the parent.
**
** If this routine fails for any reason, it might leave the database
** in a corrupted state.  So if this routine fails, the database should
** be rolled back.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>balance_nonroot</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>              <comment type="block">/* The over or underfull page to balance */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pParent</name></decl>;</decl_stmt>            <comment type="block">/* The parent of pPage */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>               <comment type="block">/* The whole database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of cells in apCell[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxCells</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>           <comment type="block">/* Allocated size of apCell, szCell, aFrom. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOld</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of pages in apOld[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                <comment type="block">/* Number of pages in apNew[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nDiv</name></decl>;</decl_stmt>                    <comment type="block">/* Number of cells in apDiv[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                     <comment type="block">/* Index of pPage in pParent-&gt;aCell[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nxDiv</name></decl>;</decl_stmt>                   <comment type="block">/* Next divider slot in pParent-&gt;aCell[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                      <comment type="block">/* The return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>leafCorrection</name></decl>;</decl_stmt>          <comment type="block">/* 4 if pPage is a leaf.  0 if not */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>leafData</name></decl>;</decl_stmt>                <comment type="block">/* True if pPage is a leaf of a LEAFDATA tree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSpace</name></decl>;</decl_stmt>             <comment type="block">/* Bytes in pPage beyond the header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pageFlags</name></decl>;</decl_stmt>               <comment type="block">/* Value of pPage-&gt;aData[0] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>subtotal</name></decl>;</decl_stmt>                <comment type="block">/* Subtotal of bytes in cells on one page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSpace1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* First unused byte of aSpace1[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSpace2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* First unused byte of aSpace2[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szScratch</name></decl>;</decl_stmt>               <comment type="block">/* Size of scratch memory requested */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name><name>apOld</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* pPage and up to two siblings */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name><name>pgnoOld</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* Page numbers for each page in apOld[] */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name><name>apCopy</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* Private copies of apOld[] pages */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name><name>apNew</name><index>[<expr><name>NB</name>+2</expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* pPage and up to NB siblings after balancing */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name><name>pgnoNew</name><index>[<expr><name>NB</name>+2</expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* Page numbers for each page in apNew[] */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name><name>apDiv</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>               <comment type="block">/* Divider cells in pParent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>cntNew</name><index>[<expr><name>NB</name>+2</expr>]</index></name></decl>;</decl_stmt>            <comment type="block">/* Index in aCell[] of cell after i-th page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>szNew</name><index>[<expr><name>NB</name>+2</expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* Combined size of cells place on i-th page */</comment>
  <decl_stmt><decl><type><name>u8</name> **</type><name>apCell</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* All cells begin balanced */</comment>
  <decl_stmt><decl><type><name>u16</name> *</type><name>szCell</name></decl>;</decl_stmt>                 <comment type="block">/* Local size of all cells in apCell[] */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name><name>aCopy</name><index>[<expr><name>NB</name></expr>]</index></name></decl>;</decl_stmt>         <comment type="block">/* Space for holding data of apCopy[] */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aSpace1</name></decl>;</decl_stmt>           <comment type="block">/* Space for copies of dividers cells before balance */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aSpace2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* Space for overflow dividers cells after balance */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aFrom</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pagesShuffled</name> = 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* 
  ** Find the parent page.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call> || <name>pPage</name>-&gt;<name>nOverflow</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>pPage</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParent</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pParent</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <goto>goto <name>balance_cleanup</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: begin page %d child of %d\n", <name>pPage</name>-&gt;<name>pgno</name>, <name>pParent</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_QUICKBALANCE</name></cpp:ifndef>
  <comment type="block">/*
  ** A special case:  If a new entry has just been inserted into a
  ** table (that is, a btree with integer keys and all data at the leaves)
  ** and the new entry is the right-most entry in the tree (it has the
  ** largest key) then use the special balance_quick() routine for
  ** balancing.  balance_quick() is much faster and results in a tighter
  ** packing of data in the common case.
  */</comment>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>leaf</name> &amp;&amp;
      <name>pPage</name>-&gt;<name>intKey</name> &amp;&amp;
      <name>pPage</name>-&gt;<name>nOverflow</name>==1 &amp;&amp;
      <name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr>0</expr>]</index></name>.<name>idx</name>==<name>pPage</name>-&gt;<name>nCell</name> &amp;&amp;
      <name>pParent</name>-&gt;<name>pgno</name>!=1 &amp;&amp;
      <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pParent</name>-&gt;<name><name>aData</name><index>[<expr><name>pParent</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call>==<name>pPage</name>-&gt;<name>pgno</name></expr>
  )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
    ** TODO: Check the siblings to the left of pPage. It may be that
    ** they are not full and no new page is required.
    */</comment>
    <return>return <expr><call><name>balance_quick</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <goto>goto <name>balance_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/*
  ** Find the cell in the parent page whose left child points back
  ** to pPage.  The "idx" variable is the index of that cell.  If pPage
  ** is the rightmost child of pParent then set idx to pParent-&gt;nCell 
  */</comment>
  <expr_stmt><expr><name>idx</name> = <name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assertParentIndex</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Find sibling pages to pPage and the cells in pParent that divide
  ** the siblings.  An attempt is made to find NN siblings on either
  ** side of pPage.  More siblings are taken from one side, however, if
  ** pPage there are fewer than NN siblings on the other side.  If pParent
  ** has NB or fewer children then all children of pParent are taken.
  */</comment>
  <expr_stmt><expr><name>nxDiv</name> = <name>idx</name> - <name>NN</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nxDiv</name> + <name>NB</name> &gt; <name>pParent</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nxDiv</name> = <name>pParent</name>-&gt;<name>nCell</name> - <name>NB</name> + 1</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>nxDiv</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>nxDiv</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>nDiv</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>k</name>=<name>nxDiv</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>NB</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>k</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>k</name>&lt;<name>pParent</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nDiv</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pParent</name>-&gt;<name>leaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pgnoOld</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>get4byte</name><argument_list>(<argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>k</name>==<name>pParent</name>-&gt;<name>nCell</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>pgnoOld</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pParent</name>-&gt;<name><name>aData</name><index>[<expr><name>pParent</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <break>break;</break>
    }</block></else></if></else></if>
    <expr_stmt><expr><name>rc</name> = <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name><name>pgnoOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>balance_cleanup</name>;</goto></then></if>
    <comment type="block">/* apOld[i]-&gt;idxParent = k; */</comment>
    <expr_stmt><expr><name><name>apCopy</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>==<name>nOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nOld</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>nMaxCells</name> += 1+<name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>nCell</name>+<name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>nOverflow</name></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Make nMaxCells a multiple of 4 in order to preserve 8-byte
  ** alignment */</comment>
  <expr_stmt><expr><name>nMaxCells</name> = (<name>nMaxCells</name> + 3)&amp;~3</expr>;</expr_stmt>

  <comment type="block">/*
  ** Allocate space for memory structures
  */</comment>
  <expr_stmt><expr><name>szScratch</name> =
       <name>nMaxCells</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>u8</name>*</expr></argument>)</argument_list></call>                       <comment type="block">/* apCell */</comment>
     + <name>nMaxCells</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></call>                       <comment type="block">/* szCell */</comment>
     + (<call><name>ROUND8</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>+<name>pBt</name>-&gt;<name>pageSize</name>)*<name>NB</name>  <comment type="block">/* aCopy */</comment>
     + <name>pBt</name>-&gt;<name>pageSize</name>                               <comment type="block">/* aSpace1 */</comment>
     + (<name>ISAUTOVACUUM</name> ? <name>nMaxCells</name> : 0)</expr>;</expr_stmt>             <comment type="block">/* aFrom */</comment>
  <expr_stmt><expr><name>apCell</name> = <call><name>sqlite3ScratchMalloc</name><argument_list>( <argument><expr><name>szScratch</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> 
  <if>if<condition>( <expr><name>apCell</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>balance_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>szCell</name> = (<name>u16</name>*)&amp;<name><name>apCell</name><index>[<expr><name>nMaxCells</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>aCopy</name><index>[<expr>0</expr>]</index></name> = (<name>u8</name>*)&amp;<name><name>szCell</name><index>[<expr><name>nMaxCells</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>((<name><name>aCopy</name><index>[<expr>0</expr>]</index></name> - (<name>u8</name>*)0) &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 8-byte alignment required */</comment>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>NB</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>aCopy</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>aCopy</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name>+<call><name>ROUND8</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>((<name><name>aCopy</name><index>[<expr><name>i</name></expr>]</index></name> - (<name>u8</name>*)0) &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 8-byte alignment required */</comment>
  }</block></for>
  <expr_stmt><expr><name>aSpace1</name> = &amp;<name><name>aCopy</name><index>[<expr><name>NB</name>-1</expr>]</index><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name>+<call><name>ROUND8</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>((<name>aSpace1</name> - (<name>u8</name>*)0) &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 8-byte alignment required */</comment>
  <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aFrom</name> = &amp;<name><name>aSpace1</name><index>[<expr><name>pBt</name>-&gt;<name>pageSize</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>aSpace2</name> = <call><name>sqlite3PageMalloc</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>aSpace2</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>balance_cleanup</name>;</goto>
  }</block></then></if>
  
  <comment type="block">/*
  ** Make copies of the content of pPage and its siblings into aOld[].
  ** The rest of this function will use data from the copies rather
  ** that the original pages since the original pages will be in the
  ** process of being overwritten.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOld</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>p</name> =<init> <expr><name><name>apCopy</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>MemPage</name>*)<name><name>aCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>MemPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>aData</name> = (<name>void</name>*)&amp;<name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name>pBt</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/*
  ** Load pointers to all cells on sibling pages and the divider cells
  ** into the local apCell[] array.  Make copies of the divider cells
  ** into space obtained form aSpace1[] and remove the the divider Cells
  ** from pParent.
  **
  ** If the siblings are on leaf pages, then the child pointers of the
  ** divider cells are stripped from the cells before they are copied
  ** into aSpace1[].  In this way, all cells in apCell[] are without
  ** child pointers.  If siblings are not leaves, then all cell in
  ** apCell[] include child pointers.  Either way, all cells in apCell[]
  ** are alike.
  **
  ** leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.
  **       leafData:  1 if pPage holds key+data and pParent holds only keys.
  */</comment>
  <expr_stmt><expr><name>nCell</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>leafCorrection</name> = <name>pPage</name>-&gt;<name>leaf</name>*4</expr>;</expr_stmt>
  <expr_stmt><expr><name>leafData</name> = <name>pPage</name>-&gt;<name>hasData</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOld</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pOld</name> =<init> <expr><name><name>apCopy</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>limit</name> =<init> <expr><name>pOld</name>-&gt;<name>nCell</name>+<name>pOld</name>-&gt;<name>nOverflow</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>limit</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apCell</name><index>[<expr><name>nCell</name></expr>]</index></name> = <call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>nCell</name></expr>]</index></name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name><name>apCell</name><index>[<expr><name>nCell</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>aFrom</name><index>[<expr><name>nCell</name></expr>]</index></name> = (<name>u8</name>)<name>i</name></expr>;</expr_stmt>   <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;6</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><expr><name>a</name>=0</expr>;</init> <condition><expr><name>a</name>&lt;<name>pOld</name>-&gt;<name>nOverflow</name></expr>;</condition> <incr><expr><name>a</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><name>pOld</name>-&gt;<name><name>aOvfl</name><index>[<expr><name>a</name></expr>]</index></name>.<name>pCell</name>==<name><name>apCell</name><index>[<expr><name>nCell</name></expr>]</index></name></expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>aFrom</name><index>[<expr><name>nCell</name></expr>]</index></name> = 0xFF</expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
      }</block></then></if>
      <expr_stmt><expr><name>nCell</name>++</expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr><name>i</name>&lt;<name>nOld</name>-1</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u16</name></type> <name>sz</name> =<init> <expr><call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>leafData</name></expr> )</condition><then><block>{
        <comment type="block">/* With the LEAFDATA flag, pParent cells hold only INTKEYs that
        ** are duplicates of keys on the child pages.  We need to remove
        ** the divider cells from pParent, but the dividers cells are not
        ** added to apCell[] because they are duplicates of child cells.
        */</comment>
        <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>u8</name> *</type><name>pTemp</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCell</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>nCell</name></expr>]</index></name> = <name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTemp</name> = &amp;<name><name>aSpace1</name><index>[<expr><name>iSpace1</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iSpace1</name> += <name>sz</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name>&lt;=<name>pBt</name>-&gt;<name>pageSize</name>/4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSpace1</name>&lt;=<name>pBt</name>-&gt;<name>pageSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTemp</name></expr></argument>, <argument><expr><name><name>apDiv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apCell</name><index>[<expr><name>nCell</name></expr>]</index></name> = <name>pTemp</name>+<name>leafCorrection</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name><name>aFrom</name><index>[<expr><name>nCell</name></expr>]</index></name> = 0xFF</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name>==0 || <name>leafCorrection</name>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>nCell</name></expr>]</index></name> -= (<name>u16</name>)<name>leafCorrection</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pTemp</name></expr></argument>)</argument_list></call>==<name><name>pgnoOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<name>pOld</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* The right pointer of the child page pOld becomes the left
          ** pointer of the divider cell */</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>apCell</name><index>[<expr><name>nCell</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pOld</name>-&gt;<name><name>aData</name><index>[<expr><name>pOld</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCorrection</name>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name><name>szCell</name><index>[<expr><name>nCell</name></expr>]</index></name>&lt;4</expr> )</condition><then><block>{
            <comment type="block">/* Do not allow any cells smaller than 4 bytes. */</comment>
            <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>nCell</name></expr>]</index></name> = 4</expr>;</expr_stmt>
          }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>nCell</name>++</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></for>

  <comment type="block">/*
  ** Figure out the number of pages needed to hold all nCell cells.
  ** Store this number in "k".  Also compute szNew[] which is the total
  ** size of all cells on the i-th page and cntNew[] which is the index
  ** in apCell[] of the cell that divides page i from page i+1.  
  ** cntNew[k] should equal nCell.
  **
  ** Values computed by this block:
  **
  **           k: The total number of sibling pages
  **    szNew[i]: Spaced used on the i-th sibling page.
  **   cntNew[i]: Index in apCell[] and szCell[] for the first cell to
  **              the right of the i-th sibling page.
  ** usableSpace: Number of bytes of space available on each sibling.
  ** 
  */</comment>
  <expr_stmt><expr><name>usableSpace</name> = <name>pBt</name>-&gt;<name>usableSize</name> - 12 + <name>leafCorrection</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>subtotal</name>=<name>k</name>=<name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subtotal</name> += <name><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name> + 2</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>subtotal</name> &gt; <name>usableSpace</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>k</name></expr>]</index></name> = <name>subtotal</name> - <name><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>k</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>leafData</name></expr> )</condition><then><block>{ <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt> }</block></then></if>
      <expr_stmt><expr><name>subtotal</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name>++</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>k</name></expr>]</index></name> = <name>subtotal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>k</name></expr>]</index></name> = <name>nCell</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name>++</expr>;</expr_stmt>

  <comment type="block">/*
  ** The packing computed by the previous block is biased toward the siblings
  ** on the left side.  The left siblings are always nearly full, while the
  ** right-most sibling might be nearly empty.  This block of code attempts
  ** to adjust the packing of siblings to get a better balance.
  **
  ** This adjustment is more than an optimization.  The packing above might
  ** be so out of balance as to be illegal.  For example, the right-most
  ** sibling might be completely empty.  This adjustment is not optional.
  */</comment>
  <for>for(<init><expr><name>i</name>=<name>k</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>szRight</name> =<init> <expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Size of sibling on the right */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>szLeft</name> =<init> <expr><name><name>szNew</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="block">/* Size of sibling on the left */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>              <comment type="block">/* Index of right-most cell in left sibling */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>              <comment type="block">/* Index of first cell to the left of right sibling */</comment>

    <expr_stmt><expr><name>r</name> = <name><name>cntNew</name><index>[<expr><name>i</name>-1</expr>]</index></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <name>r</name> + 1 - <name>leafData</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>d</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>szRight</name>==0 || <name>szRight</name>+<name><name>szCell</name><index>[<expr><name>d</name></expr>]</index></name>+2&lt;=<name>szLeft</name>-(<name><name>szCell</name><index>[<expr><name>r</name></expr>]</index></name>+2)</expr> )</condition><block>{
      <expr_stmt><expr><name>szRight</name> += <name><name>szCell</name><index>[<expr><name>d</name></expr>]</index></name> + 2</expr>;</expr_stmt>
      <expr_stmt><expr><name>szLeft</name> -= <name><name>szCell</name><index>[<expr><name>r</name></expr>]</index></name> + 2</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cntNew</name><index>[<expr><name>i</name>-1</expr>]</index></name>--</expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> = <name><name>cntNew</name><index>[<expr><name>i</name>-1</expr>]</index></name> - 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>d</name> = <name>r</name> + 1 - <name>leafData</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name>szRight</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>szNew</name><index>[<expr><name>i</name>-1</expr>]</index></name> = <name>szLeft</name></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Either we found one or more cells (cntnew[0])&gt;0) or we are the
  ** a virtual root page.  A virtual root page is when the real root
  ** page is page 1 and we are the only child of that page.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>cntNew</name><index>[<expr>0</expr>]</index></name>&gt;0 || (<name>pParent</name>-&gt;<name>pgno</name>==1 &amp;&amp; <name>pParent</name>-&gt;<name>nCell</name>==0)</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Allocate k new pages.  Reuse old pages where possible.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pgno</name>&gt;1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pageFlags</name> = <name>pPage</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>k</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pNew</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>i</name>&lt;<name>nOld</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pNew</name> = <name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>pgnoOld</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNew</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>balance_cleanup</name>;</goto></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pNew</name></expr></argument>, <argument><expr>&amp;<name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pgnoNew</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>balance_cleanup</name>;</goto></then></if>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pNew</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nNew</name>++</expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>

  <comment type="block">/* Free any old pages that were not reused as new pages.
  */</comment>
  <while>while<condition>( <expr><name>i</name>&lt;<name>nOld</name></expr> )</condition><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>balance_cleanup</name>;</goto></then></if>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
  }</block></while>

  <comment type="block">/*
  ** Put the new pages in accending order.  This helps to
  ** keep entries in the disk file in order so that a scan
  ** of the table is a linear scan through the file.  That
  ** in turn helps the operating system to deliver pages
  ** from the disk more rapidly.
  **
  ** An O(n^2) insertion sort algorithm is used, but since
  ** n is never more than NB (a small constant), that should
  ** not be a problem.
  **
  ** When NB==3, this one optimization makes the database
  ** about 25% faster for large insertions and deletions.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>k</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>minV</name> =<init> <expr><name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>minI</name> =<init> <expr><name>i</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>j</name>=<name>i</name>+1</expr>;</init> <condition><expr><name>j</name>&lt;<name>k</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>pgnoNew</name><index>[<expr><name>j</name></expr>]</index></name>&lt;(<name>unsigned</name>)<name>minV</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>minI</name> = <name>j</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>minV</name> = <name><name>pgnoNew</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>minI</name>&gt;<name>i</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MemPage</name> *</type><name>pT</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>t</name> = <name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pT</name> = <name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>pgnoNew</name><index>[<expr><name>minI</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>apNew</name><index>[<expr><name>minI</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pgnoNew</name><index>[<expr><name>minI</name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>minI</name></expr>]</index></name> = <name>pT</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: old: %d %d %d  new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\n",
    <name><name>pgnoOld</name><index>[<expr>0</expr>]</index></name>, 
    <name>nOld</name>&gt;=2 ? <name><name>pgnoOld</name><index>[<expr>1</expr>]</index></name> : 0,
    <name>nOld</name>&gt;=3 ? <name><name>pgnoOld</name><index>[<expr>2</expr>]</index></name> : 0,
    <name><name>pgnoNew</name><index>[<expr>0</expr>]</index></name>, <name><name>szNew</name><index>[<expr>0</expr>]</index></name>,
    <name>nNew</name>&gt;=2 ? <name><name>pgnoNew</name><index>[<expr>1</expr>]</index></name> : 0, <name>nNew</name>&gt;=2 ? <name><name>szNew</name><index>[<expr>1</expr>]</index></name> : 0,
    <name>nNew</name>&gt;=3 ? <name><name>pgnoNew</name><index>[<expr>2</expr>]</index></name> : 0, <name>nNew</name>&gt;=3 ? <name><name>szNew</name><index>[<expr>2</expr>]</index></name> : 0,
    <name>nNew</name>&gt;=4 ? <name><name>pgnoNew</name><index>[<expr>3</expr>]</index></name> : 0, <name>nNew</name>&gt;=4 ? <name><name>szNew</name><index>[<expr>3</expr>]</index></name> : 0,
    <name>nNew</name>&gt;=5 ? <name><name>pgnoNew</name><index>[<expr>4</expr>]</index></name> : 0, <name>nNew</name>&gt;=5 ? <name><name>szNew</name><index>[<expr>4</expr>]</index></name> : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Evenly distribute the data in apCell[] across the new pages.
  ** Insert divider cells into pParent as necessary.
  */</comment>
  <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nNew</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <comment type="block">/* Assemble the new sibling page. */</comment>
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pNew</name> =<init> <expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>pgno</name>==<name><name>pgnoNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pageFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assemblePage</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name>-<name>j</name></expr></argument>, <argument><expr>&amp;<name><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>szCell</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>nCell</name>&gt;0 || (<name>nNew</name>==1 &amp;&amp; <name><name>cntNew</name><index>[<expr>0</expr>]</index></name>==0)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this is an auto-vacuum database, update the pointer map entries
    ** that point to the siblings that were rearranged. These can be: left
    ** children of cells, the right-child of the page, or overflow pages
    ** pointed to by cells.
    */</comment>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
      <for>for(<init><expr><name>k</name>=<name>j</name></expr>;</init> <condition><expr><name>k</name>&lt;<name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>k</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name><name>aFrom</name><index>[<expr><name>k</name></expr>]</index></name>==0xFF || <name><name>apCopy</name><index>[<expr><name><name>aFrom</name><index>[<expr><name>k</name></expr>]</index></name></expr>]</index></name>-&gt;<name>pgno</name>!=<name>pNew</name>-&gt;<name>pgno</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPutOvfl</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>k</name>-<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>leafCorrection</name>==0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name><name>apCell</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <goto>goto <name>balance_cleanup</name>;</goto>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
    }</block></then></if>

    <expr_stmt><expr><name>j</name> = <name><name>cntNew</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* If the sibling page assembled above was not the right-most sibling,
    ** insert a divider cell into the parent page.
    */</comment>
    <if>if<condition>( <expr><name>i</name>&lt;<name>nNew</name>-1 &amp;&amp; <name>j</name>&lt;<name>nCell</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name> *</type><name>pTemp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&lt;<name>nMaxCells</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCell</name> = <name><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sz</name> = <name><name>szCell</name><index>[<expr><name>j</name></expr>]</index></name> + <name>leafCorrection</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTemp</name> = &amp;<name><name>aSpace2</name><index>[<expr><name>iSpace2</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pNew</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pNew</name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>ISAUTOVACUUM</name> 
         &amp;&amp; (<name><name>aFrom</name><index>[<expr><name>j</name></expr>]</index></name>==0xFF || <name><name>apCopy</name><index>[<expr><name><name>aFrom</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name>-&gt;<name>pgno</name>!=<name>pNew</name>-&gt;<name>pgno</name>)</expr>
        )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <goto>goto <name>balance_cleanup</name>;</goto>
          }</block></then></if>
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr><name>leafData</name></expr> )</condition><then><block>{
        <comment type="block">/* If the tree is a leaf-data tree, and the siblings are leaves, 
        ** then there is no divider cell in apCell[]. Instead, the divider 
        ** cell consists of the integer key for the right-most cell of 
        ** the sibling-page assembled above only.
        */</comment>
        <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>apCell</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCell</name> = <name>pTemp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fillInCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>info</name>.<name>nKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTemp</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pCell</name> -= 4</expr>;</expr_stmt>
        <comment type="block">/* Obscure case for non-leaf-data trees: If the cell at pCell was
        ** previously stored on a leaf node, and its reported size was 4
        ** bytes, then it may actually be smaller than this 
        ** (see sqlite3BtreeParseCellPtr(), 4 bytes is the minimum size of
        ** any cell). But it is important to pass the correct size to 
        ** insertCell(), so reparse the cell now.
        **
        ** Note that this can never happen in an SQLite data file, as all
        ** cells are at least 4 bytes. It only happens in b-trees used
        ** to evaluate "IN (SELECT ...)" and similar clauses.
        */</comment>
        <if>if<condition>( <expr><name><name>szCell</name><index>[<expr><name>j</name></expr>]</index></name>==4</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>leafCorrection</name>==4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>sz</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if></else></if>
      <expr_stmt><expr><name>iSpace2</name> += <name>sz</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name>&lt;=<name>pBt</name>-&gt;<name>pageSize</name>/4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSpace2</name>&lt;=<name>pBt</name>-&gt;<name>pageSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>insertCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>pTemp</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>balance_cleanup</name>;</goto></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pParent</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>,<argument><expr><name>nxDiv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is an auto-vacuum database, and not a leaf-data tree,
      ** then update the pointer map with an entry for the overflow page
      ** that the cell just inserted points to (if any).
      */</comment>
      <if>if<condition>( <expr><name>ISAUTOVACUUM</name> &amp;&amp; !<name>leafData</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPutOvfl</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <goto>goto <name>balance_cleanup</name>;</goto>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>nxDiv</name>++</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Set the pointer-map entry for the new sibling page. */</comment>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>balance_cleanup</name>;</goto>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>==<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOld</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nNew</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pageFlags</name> &amp; <name>PTF_LEAF</name>)==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u8</name> *</type><name>zChild</name> =<init> <expr>&amp;<name><name>apCopy</name><index>[<expr><name>nOld</name>-1</expr>]</index></name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>apNew</name><index>[<expr><name>nNew</name>-1</expr>]</index></name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>, <argument><expr><name>zChild</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>zChild</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name><name>apNew</name><index>[<expr><name>nNew</name>-1</expr>]</index></name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>balance_cleanup</name>;</goto>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pParent</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nxDiv</name>==<name>pParent</name>-&gt;<name>nCell</name>+<name>pParent</name>-&gt;<name>nOverflow</name></expr> )</condition><then><block>{
    <comment type="block">/* Right-most sibling is the right-most child of pParent */</comment>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pParent</name>-&gt;<name><name>aData</name><index>[<expr><name>pParent</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, <argument><expr><name><name>pgnoNew</name><index>[<expr><name>nNew</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Right-most sibling is the left child of the first entry in pParent
    ** past the right-most divider entry */</comment>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pParent</name></expr></argument>, <argument><expr><name>nxDiv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pgnoNew</name><index>[<expr><name>nNew</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/*
  ** Balance the parent page.  Note that the current page (pPage) might
  ** have been added to the freelist so it might no longer be initialized.
  ** But the parent page will always be initialized.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ScratchFree</name><argument_list>(<argument><expr><name>apCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>apCell</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: finished with %d: old=%d new=%d cells=%d\n",
          <name>pPage</name>-&gt;<name>pgno</name>, <name>nOld</name>, <name>nNew</name>, <name>nCell</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/*
  ** Cleanup before returning.
  */</comment>
<label><name>balance_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>aSpace2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ScratchFree</name><argument_list>(<argument><expr><name>apCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOld</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>apOld</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nNew</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called for the root page of a btree when the root
** page contains no cells.  This is an opportunity to make the tree
** shallower by one level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>balance_shallower</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>              <comment type="block">/* Root page of B-Tree */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pChild</name></decl>;</decl_stmt>             <comment type="block">/* The only child page of pPage */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoChild</name></decl>;</decl_stmt>              <comment type="block">/* Page number for pChild */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Return code from subprocedures */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>                  <comment type="block">/* The main BTree structure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxCellPerPage</name></decl>;</decl_stmt>           <comment type="block">/* Maximum number of cells per page */</comment>
  <decl_stmt><decl><type><name>u8</name> **</type><name>apCell</name></decl>;</decl_stmt>                 <comment type="block">/* All cells from pages being balanced */</comment>
  <decl_stmt><decl><type><name>u16</name> *</type><name>szCell</name></decl>;</decl_stmt>                 <comment type="block">/* Local size of all cells */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nCell</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>pPage</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxCellPerPage</name> = <call><name>MX_CELL</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>apCell</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>mxCellPerPage</name>*(<call><name>sizeof</name><argument_list>(<argument><expr><name>u8</name>*</expr></argument>)</argument_list></call>+<call><name>sizeof</name><argument_list>(<argument><expr><name>u16</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>apCell</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  <expr_stmt><expr><name>szCell</name> = (<name>u16</name>*)&amp;<name><name>apCell</name><index>[<expr><name>mxCellPerPage</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <comment type="block">/* The table is completely empty */</comment>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: empty table %d\n", <name>pPage</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* The root page is empty but has one child.  Transfer the
    ** information from that one child into the root page if it 
    ** will fit.  This reduces the depth of the tree by one.
    **
    ** If the root page is page 1, it has less space available than
    ** its child (due to the 100 byte header that occurs at the beginning
    ** of the database fle), so it might not be able to hold all of the 
    ** information currently contained in the child.  If this is the 
    ** case, then do not do the transfer.  Leave page 1 empty except
    ** for the right-pointer to the child page.  The child page becomes
    ** the virtual root of the tree.
    */</comment>
    <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pagesShuffled</name> = 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pgnoChild</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgnoChild</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgnoChild</name>&lt;=<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>pgnoChild</name></expr></argument>, <argument><expr>&amp;<name>pChild</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>end_shallow_balance</name>;</goto></then></if>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pgno</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>end_shallow_balance</name>;</goto></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChild</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pChild</name>-&gt;<name>nFree</name>&gt;=100</expr> )</condition><then><block>{
        <comment type="block">/* The child information will fit on the root page, so do the
        ** copy */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pChild</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pChild</name>-&gt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>szCell</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>, <argument><expr><name><name>apCell</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>assemblePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pChild</name>-&gt;<name>nCell</name></expr></argument>, <argument><expr><name>apCell</name></expr></argument>, <argument><expr><name>szCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Copy the right-pointer of the child to the parent. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, 
            <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pChild</name>-&gt;<name><name>aData</name><index>[<expr><name>pChild</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: child %d transfer to page 1\n", <name>pChild</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* The child has more information that will fit on the root.
        ** The tree is already balanced.  Do nothing. */</comment>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: child %d will not fit on page 1\n", <name>pChild</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name>pChild</name>-&gt;<name>aData</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name>-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>freePage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: transfer child %d into root %d\n",
              <name>pChild</name>-&gt;<name>pgno</name>, <name>pPage</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>setChildPtrmaps</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<label><name>end_shallow_balance</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>apCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** The root page is overfull
**
** When this happens, Create a new child page and copy the
** contents of the root into the child.  Then make the root
** page an empty page with rightChild pointing to the new
** child.   Finally, call balance_internal() on the new child
** to cause it to split.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>balance_deeper</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>             <comment type="block">/* Return value from subprocedures */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>     <comment type="block">/* Pointer to the root page */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pChild</name></decl>;</decl_stmt>    <comment type="block">/* Pointer to a new child page */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoChild</name></decl>;</decl_stmt>     <comment type="block">/* Page number of the new child page */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>         <comment type="block">/* The BTree */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>     <comment type="block">/* Total usable size of a page */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>           <comment type="block">/* Content of the parent page */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>cdata</name></decl>;</decl_stmt>          <comment type="block">/* Content of the child page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name></decl>;</decl_stmt>            <comment type="block">/* Offset to page header in parent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cbrk</name></decl>;</decl_stmt>           <comment type="block">/* Offset to content of first cell in parent */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>iPage</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>-&gt;<name>nOverflow</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pagesShuffled</name> = 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>pPage</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pChild</name></expr></argument>, <argument><expr>&amp;<name>pgnoChild</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pChild</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> = <name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cbrk</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cdata</name> = <name>pChild</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cdata</name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name></expr>]</index></name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>cellOffset</name>+2*<name>pPage</name>-&gt;<name>nCell</name>-<name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>cdata</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>cbrk</name></expr>]</index></name></expr></argument>, <argument><expr><name>usableSize</name>-<name>cbrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChild</name>-&gt;<name>isInit</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> =<init> <expr><name>pPage</name>-&gt;<name>nOverflow</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name><name>aOvfl</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pChild</name>-&gt;<name>aOvfl</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>aOvfl</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pChild</name>-&gt;<name>nOverflow</name> = <name>pPage</name>-&gt;<name>nOverflow</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pChild</name>-&gt;<name>nOverflow</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pChild</name>-&gt;<name>nFree</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pChild</name>-&gt;<name>nCell</name>==<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pChild</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name> &amp; ~<name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>, <argument><expr><name>pgnoChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("BALANCE: copy root %d into %d\n", <name>pPage</name>-&gt;<name>pgno</name>, <name>pChild</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>ISAUTOVACUUM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pChild</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>setChildPtrmaps</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pChild</name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>iPage</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>1</expr>]</index></name> = <name>pChild</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>balance_nonroot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The page that pCur currently points to has just been modified in
** some way. This function figures out if this modification means the
** tree needs to be balanced, and if so calls the appropriate balancing 
** routine.
** 
** Parameter isInsert is true if a new cell was just inserted into the
** page, or false otherwise.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>balance</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name></type> <name>isInsert</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>iPage</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pPage</name>-&gt;<name>nOverflow</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>balance_deeper</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>==<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 || <name>rc</name>!=<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pPage</name>-&gt;<name>nCell</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>balance_shallower</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr>0</expr>]</index></name>==<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 || <name>rc</name>!=<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>nOverflow</name>&gt;0 || 
        (!<name>isInsert</name> &amp;&amp; <name>pPage</name>-&gt;<name>nFree</name>&gt;<name>pPage</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>*2/3)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>balance_nonroot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine checks all cursors that point to table pgnoRoot.
** If any of those cursors were opened with wrFlag==0 in a different
** database connection (a database connection that shares the pager
** cache with the current connection) and that other connection 
** is not in the ReadUncommmitted state, then this routine returns 
** SQLITE_LOCKED.
**
** As well as cursors with wrFlag==0, cursors with wrFlag==1 and 
** isIncrblobHandle==1 are also considered 'read' cursors. Incremental 
** blob cursors are used for both reading and writing.
**
** When pgnoRoot is the root page of an intkey table, this function is also
** responsible for invalidating incremental blob cursors when the table row
** on which they are opened is deleted or modified. Cursors are invalidated
** according to the following rules:
**
**   1) When BtreeClearTable() is called to completely delete the contents
**      of a B-Tree table, pExclude is set to zero and parameter iRow is 
**      set to non-zero. In this case all incremental blob cursors open
**      on the table rooted at pgnoRoot are invalidated.
**
**   2) When BtreeInsert(), BtreeDelete() or BtreePutData() is called to 
**      modify a table row via an SQL statement, pExclude is set to the 
**      write cursor used to do the modification and parameter iRow is set
**      to the integer row id of the B-Tree entry being modified. Unless
**      pExclude is itself an incremental blob cursor, then all incremental
**      blob cursors open on row iRow of the B-Tree are invalidated.
**
**   3) If both pExclude and iRow are set to zero, no incremental blob 
**      cursors are invalidated.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkReadLocks</name><parameter_list>(
  <param><decl><type><name>Btree</name> *</type><name>pBtree</name></decl></param>, 
  <param><decl><type><name>Pgno</name></type> <name>pgnoRoot</name></decl></param>, 
  <param><decl><type><name>BtCursor</name> *</type><name>pExclude</name></decl></param>,
  <param><decl><type><name>i64</name></type> <name>iRow</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>pBtree</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pBtree</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>p</name>=<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>p</name>==<name>pExclude</name></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pgnoRoot</name>!=<name>pgnoRoot</name></expr> )</condition><then> <continue>continue;</continue></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>isIncrblobHandle</name> &amp;&amp; ( 
         (!<name>pExclude</name> &amp;&amp; <name>iRow</name>)
      || (<name>pExclude</name> &amp;&amp; !<name>pExclude</name>-&gt;<name>isIncrblobHandle</name> &amp;&amp; <name>p</name>-&gt;<name>info</name>.<name>nKey</name>==<name>iRow</name>)
    )</expr>)</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>eState</name> = <name>CURSOR_INVALID</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>eState</name>!=<name>CURSOR_VALID</name></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>wrFlag</name>==0 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
     || <name>p</name>-&gt;<name>isIncrblobHandle</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</condition><then><block>{
      <decl_stmt><decl><type><name>sqlite3</name> *</type><name>dbOther</name> =<init> <expr><name>p</name>-&gt;<name>pBtree</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>dbOther</name>==0 ||
         (<name>dbOther</name>!=<name>db</name> &amp;&amp; (<name>dbOther</name>-&gt;<name>flags</name> &amp; <name>SQLITE_ReadUncommitted</name>)==0)</expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Insert a new record into the BTree.  The key is given by (pKey,nKey)
** and the data is given by (pData,nData).  The cursor is used only to
** define what table the record should be inserted into.  The cursor
** is left pointing at a random location.
**
** For an INTKEY table, only the nKey value of the key is used.  pKey is
** ignored.  For a ZERODATA table, the pData and nData are both ignored.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeInsert</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,                <comment type="block">/* Insert data into the table of this cursor */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey</name></decl></param>, <param><decl><type><name>i64</name></type> <name>nKey</name></decl></param>,    <comment type="block">/* The key of the new record */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pData</name></decl></param>, <param><decl><type><name>int</name></type> <name>nData</name></decl></param>,  <comment type="block">/* The data of the new record */</comment>
  <param><decl><type><name>int</name></type> <name>nZero</name></decl></param>,                     <comment type="block">/* Number of extra 0 bytes to append to data */</comment>
  <param><decl><type><name>int</name></type> <name>appendBias</name></decl></param>                 <comment type="block">/* True if this is likely an append */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>loc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>szNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>pCur</name>-&gt;<name>pBtree</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>oldCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>newCell</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>readOnly</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>wrFlag</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>checkReadLocks</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return> <comment type="block">/* The table pCur points to has a read lock */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_FAULT</name></expr> )</condition><then><block>{
    <return>return <expr><name>pCur</name>-&gt;<name>skip</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Save the positions of any other cursors open on this table */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( 
    <expr><name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call>) ||
    <name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>sqlite3BtreeMoveto</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>appendBias</name></expr></argument>, <argument><expr>&amp;<name>loc</name></expr></argument>)</argument_list></call>)</expr>
  )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>intKey</name> || <name>nKey</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>leaf</name> || !<name>pPage</name>-&gt;<name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n",
          <name>pCur</name>-&gt;<name>pgnoRoot</name>, <name>nKey</name>, <name>nData</name>, <name>pPage</name>-&gt;<name>pgno</name>,
          <name>loc</name>==0 ? "overwrite" : "new entry")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>allocateTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>newCell</name> = <name>pBt</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>newCell</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>fillInCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>nZero</name></expr></argument>, <argument><expr>&amp;<name>szNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>end_insert</name>;</goto></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szNew</name>==<call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szNew</name>&lt;=<call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> = <name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>loc</name>==0 &amp;&amp; <name>CURSOR_VALID</name>==<name>pCur</name>-&gt;<name>eState</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u16</name></type> <name>szOld</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <goto>goto <name>end_insert</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>oldCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>oldCell</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>szOld</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>oldCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>clearCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>oldCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>end_insert</name>;</goto></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>dropCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>szOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <block>{
      <goto>goto <name>end_insert</name>;</goto>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>loc</name>&lt;0 &amp;&amp; <name>pPage</name>-&gt;<name>nCell</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>leaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idx</name> = ++<name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>info</name>.<name>nSize</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>validNKey</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>leaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><name>rc</name> = <call><name>insertCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>newCell</name></expr></argument>, <argument><expr><name>szNew</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Must make sure nOverflow is reset to zero even if the balance()
  ** fails.  Internal data structure corruption will result otherwise. */</comment>
  <expr_stmt><expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>nOverflow</name> = 0</expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<label><name>end_insert</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete the entry that the cursor is pointing to.  The cursor
** is left pointing at a arbitrary location.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeDelete</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoChild</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>pCur</name>-&gt;<name>pBtree</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>isInit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>readOnly</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_FAULT</name></expr> )</condition><then><block>{
    <return>return <expr><name>pCur</name>-&gt;<name>skip</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name>&gt;=<name>pPage</name>-&gt;<name>nCell</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>  <comment type="block">/* The cursor is not pointing to anything */</comment>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>wrFlag</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>checkReadLocks</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>info</name>.<name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return> <comment type="block">/* The table pCur points to has a read lock */</comment>
  }</block></then></if>

  <comment type="block">/* Restore the current cursor position (a no-op if the cursor is not in 
  ** CURSOR_REQUIRESEEK state) and save the positions of any other cursors 
  ** open on the same table. Then call sqlite3PagerWrite() on the page
  ** that the entry will be deleted from.
  */</comment>
  <if>if<condition>( 
    <expr>(<name>rc</name> = <call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call>)!=0 ||
    (<name>rc</name> = <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>pCur</name></expr></argument>)</argument_list></call>)!=0 ||
    (<name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>)!=0</expr>
  )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Locate the cell within its page and leave pCell pointing to the
  ** data. The clearCell() call frees any overflow pages associated with the
  ** cell. The cell itself is still intact.
  */</comment>
  <expr_stmt><expr><name>idx</name> = <name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pgnoChild</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>clearCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <comment type="block">/*
    ** The entry we are about to delete is not a leaf so if we do not
    ** do something we will leave a hole on an internal page.
    ** We have to fill the hole by moving in a cell from a leaf.  The
    ** next Cell after the one to be deleted is guaranteed to exist and
    ** to be a leaf so we can use it.
    */</comment>
    <decl_stmt><decl><type><name>BtCursor</name></type> <name>leafCur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pLeafPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pNext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>notUsed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>tempCell</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPage</name>-&gt;<name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeGetTempCursor</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>leafCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr>&amp;<name>leafCur</name></expr></argument>, <argument><expr>&amp;<name>notUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCur</name>.<name><name>aiIdx</name><index>[<expr><name>leafCur</name>.<name>iPage</name></expr>]</index></name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeafPage</name> = <name>leafCur</name>.<name><name>apPage</name><index>[<expr><name>leafCur</name>.<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pLeafPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>leafCursorInvalid</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>szNext</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DELETE: table=%d delete internal from %d replace from leaf %d\n",
         <name>pCur</name>-&gt;<name>pgnoRoot</name>, <name>pPage</name>-&gt;<name>pgno</name>, <name>pLeafPage</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNext</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pLeafPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>szNext</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pLeafPage</name></expr></argument>, <argument><expr><name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>MX_CELL_SIZE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call>&gt;=<name>szNext</name>+4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>allocateTempSpace</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tempCell</name> = <name>pBt</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>tempCell</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>insertCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>pNext</name>-4</expr></argument>, <argument><expr><name>szNext</name>+4</expr></argument>, <argument><expr><name>tempCell</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>


      <comment type="block">/* The "if" statement in the next code block is critical.  The
      ** slightest error in that statement would allow SQLite to operate
      ** correctly most of the time but produce very rare failures.  To
      ** guard against this, the following macros help to verify that
      ** the "if" statement is well tested.
      */</comment>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 &amp;&amp; <name>pPage</name>-&gt;<name>nFree</name>&lt;<name>pBt</name>-&gt;<name>usableSize</name>*2/3 
                 &amp;&amp; <name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 &amp;&amp; <name>pPage</name>-&gt;<name>nFree</name>==<name>pBt</name>-&gt;<name>usableSize</name>*2/3 
                 &amp;&amp; <name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>==0 &amp;&amp; <name>pPage</name>-&gt;<name>nFree</name>==<name>pBt</name>-&gt;<name>usableSize</name>*2/3+1 
                 &amp;&amp; <name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nOverflow</name>&gt;0 &amp;&amp; <name>pPage</name>-&gt;<name>nFree</name>&lt;=<name>pBt</name>-&gt;<name>usableSize</name>*2/3
                 &amp;&amp; <name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr>(<name>pPage</name>-&gt;<name>nOverflow</name>&gt;0 || (<name>pPage</name>-&gt;<name>nFree</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3))
                 &amp;&amp; <name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> == <name>pBt</name>-&gt;<name>usableSize</name>*2/3</expr></argument> )</argument_list></call></expr>;</expr_stmt>


      <if>if<condition>( <expr>(<name>pPage</name>-&gt;<name>nOverflow</name>&gt;0 || (<name>pPage</name>-&gt;<name>nFree</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3)) &amp;&amp;
          (<name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name> &gt; <name>pBt</name>-&gt;<name>usableSize</name>*2/3)</expr>
      )</condition><then><block>{
        <comment type="block">/* This branch is taken if the internal node is now either overflowing
        ** or underfull and the leaf node will be underfull after the just cell 
        ** copied to the internal node is deleted from it. This is a special
        ** case because the call to balance() to correct the internal node
        ** may change the tree structure and invalidate the contents of
        ** the leafCur.apPage[] and leafCur.aiIdx[] arrays, which will be
        ** used by the balance() required to correct the underfull leaf
        ** node.
        **
        ** The formula used in the expression above are based on facets of
        ** the SQLite file-format that do not change over time.
        */</comment>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>nFree</name>==<name>pBt</name>-&gt;<name>usableSize</name>*2/3+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pLeafPage</name>-&gt;<name>nFree</name>+2+<name>szNext</name>==<name>pBt</name>-&gt;<name>usableSize</name>*2/3+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>leafCursorInvalid</name> = 1</expr>;</expr_stmt>
      }</block></then></if>        

      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr><call><name>findOverflowCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgnoChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pagesShuffled</name> = 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>leafCursorInvalid</name></expr> )</condition><then><block>{
        <comment type="block">/* The leaf-node is now underfull and so the tree needs to be 
        ** rebalanced. However, the balance() operation on the internal
        ** node above may have modified the structure of the B-Tree and
        ** so the current contents of leafCur.apPage[] and leafCur.aiIdx[]
        ** may not be trusted.
        **
        ** It is not possible to copy the ancestry from pCur, as the same
        ** balance() call has invalidated the pCur-&gt;apPage[] and aiIdx[]
        ** arrays. 
        **
        ** The call to saveCursorPosition() below internally saves the 
        ** key that leafCur is currently pointing to. Currently, there
        ** are two copies of that key in the tree - one here on the leaf
        ** page and one on some internal node in the tree. The copy on
        ** the leaf node is always the next key in tree-order after the 
        ** copy on the internal node. So, the call to sqlite3BtreeNext()
        ** calls restoreCursorPosition() to point the cursor to the copy
        ** stored on the internal node, then advances to the next entry,
        ** which happens to be the copy of the key on the internal node.
        ** Net effect: leafCur is pointing back to the duplicate cell
        ** that needs to be removed, and the leafCur.apPage[] and
        ** leafCur.aiIdx[] arrays are correct.
        */</comment>
        <macro><name>VVA_ONLY</name><argument_list>( <argument>Pgno leafPgno = pLeafPage-&gt;pgno</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>saveCursorPosition</name><argument_list>(<argument><expr>&amp;<name>leafCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr>&amp;<name>leafCur</name></expr></argument>, <argument><expr>&amp;<name>notUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>pLeafPage</name> = <name>leafCur</name>.<name><name>apPage</name><index>[<expr><name>leafCur</name>.<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeafPage</name>-&gt;<name>pgno</name>==<name>leafPgno</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCur</name>.<name><name>aiIdx</name><index>[<expr><name>leafCur</name>.<name>iPage</name></expr>]</index></name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <if>if<condition>( <expr><name>SQLITE_OK</name>==<name>rc</name>
       &amp;&amp; <name>SQLITE_OK</name>==(<name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pLeafPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>)</expr> 
      )</condition><then><block>{
        <expr_stmt><expr><call><name>dropCell</name><argument_list>(<argument><expr><name>pLeafPage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>szNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VVA_ONLY</name><argument_list>( <argument><expr><name>leafCur</name>.<name>pagesShuffled</name> = 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr>&amp;<name>leafCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>leafCursorInvalid</name> || !<name>leafCur</name>.<name>pagesShuffled</name>
                                   || !<name>pCur</name>-&gt;<name>pagesShuffled</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3BtreeReleaseTempCursor</name><argument_list>(<argument><expr>&amp;<name>leafCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr>("DELETE: table=%d delete from leaf %d\n",
       <name>pCur</name>-&gt;<name>pgnoRoot</name>, <name>pPage</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>dropCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>balance</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>moveToRoot</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new BTree table.  Write into *piTable the page
** number for the root page of the new table.
**
** The type of type is determined by the flags parameter.  Only the
** following values of flags are currently in use.  Other values for
** flags might not work:
**
**     BTREE_INTKEY|BTREE_LEAFDATA     Used for SQL tables with rowid keys
**     BTREE_ZERODATA                  Used for SQL indices
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>btreeCreateTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>piTable</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoRoot</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pBt</name>-&gt;<name>readOnly</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pRoot</name></expr></argument>, <argument><expr>&amp;<name>pgnoRoot</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoMove</name></decl>;</decl_stmt>      <comment type="block">/* Move a page here to make room for the root-page */</comment>
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPageMove</name></decl>;</decl_stmt> <comment type="block">/* The page to move to. */</comment>

    <comment type="block">/* Creating a new table may probably require moving an existing database
    ** to make room for the new tables root page. In case this page turns
    ** out to be an overflow page, delete all overflow page-map caches
    ** held by open cursors.
    */</comment>
    <expr_stmt><expr><call><name>invalidateAllOverflowCache</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Read the value of meta[3] from the database to determine where the
    ** root page of the new table should go. meta[3] is the largest root-page
    ** created so far, so the new root-page is (meta[3]+1).
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>&amp;<name>pgnoRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pgnoRoot</name>++</expr>;</expr_stmt>

    <comment type="block">/* The new root-page may not be allocated on a pointer-map page, or the
    ** PENDING_BYTE page.
    */</comment>
    <while>while<condition>( <expr><name>pgnoRoot</name>==<call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>)</argument_list></call> ||
        <name>pgnoRoot</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>pgnoRoot</name>++</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgnoRoot</name>&gt;=3</expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate a page. The page that currently resides at pgnoRoot will
    ** be moved to the allocated page (unless the allocated page happens
    ** to reside at pgnoRoot).
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pPageMove</name></expr></argument>, <argument><expr>&amp;<name>pgnoMove</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <if>if<condition>( <expr><name>pgnoMove</name>!=<name>pgnoRoot</name></expr> )</condition><then><block>{
      <comment type="block">/* pgnoRoot is the page that will be used for the root-page of
      ** the new table (assuming an error did not occur). But we were
      ** allocated pgnoMove. If required (i.e. if it was not allocated
      ** by extending the file), the current page at position pgnoMove
      ** is already journaled.
      */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrPage</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPageMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Move the page currently at pgnoRoot to pgnoMove. */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr>&amp;<name>pRoot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr>&amp;<name>eType</name></expr></argument>, <argument><expr>&amp;<name>iPtrPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>eType</name>==<name>PTRMAP_ROOTPAGE</name> || <name>eType</name>==<name>PTRMAP_FREEPAGE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>!=<name>PTRMAP_ROOTPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>!=<name>PTRMAP_FREEPAGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pRoot</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iPtrPage</name></expr></argument>, <argument><expr><name>pgnoMove</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Obtain the page at pgnoRoot */</comment>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr>&amp;<name>pRoot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pRoot</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pRoot</name> = <name>pPageMove</name></expr>;</expr_stmt>
    }</block></else></if> 

    <comment type="block">/* Update the pointer-map and meta-data with the new root-page number. */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>ptrmapPut</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>pgnoRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>allocateBtreePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pRoot</name></expr></argument>, <argument><expr>&amp;<name>pgnoRoot</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PagerIswriteable</name><argument_list>(<argument><expr><name>pRoot</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pRoot</name></expr></argument>, <argument><expr><name>flags</name> | <name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pRoot</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>piTable</name> = (<name>int</name>)<name>pgnoRoot</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCreateTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>piTable</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>btreeCreateTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>piTable</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Erase the given database page and all its children.  Return
** the page to the freelist.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>clearDatabasePage</name><parameter_list>(
  <param><decl><type><name>BtShared</name> *</type><name>pBt</name></decl></param>,           <comment type="block">/* The BTree that contains the table */</comment>
  <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>,            <comment type="block">/* Page number to clear */</comment>
  <param><decl><type><name>int</name></type> <name>freePageFlag</name></decl></param>,     <comment type="block">/* Deallocate page if true */</comment>
  <param><decl><type><name>int</name> *</type><name>pnChange</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pgno</name>&gt;<call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>getAndInitPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>cleardatabasepage_out</name>;</goto></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pPage</name>-&gt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>pCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>cleardatabasepage_out</name>;</goto></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>clearCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>cleardatabasepage_out</name>;</goto></then></if>
  }</block></for>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr>8</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>cleardatabasepage_out</name>;</goto></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>pnChange</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>intKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pnChange</name> += <name>pPage</name>-&gt;<name>nCell</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>freePageFlag</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr>(<name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPage</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pPage</name>-&gt;<name><name>aData</name><index>[<expr>0</expr>]</index></name> | <name>PTF_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>

<label><name>cleardatabasepage_out</name>:</label>
  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete all information from a single table in the database.  iTable is
** the page number of the root of the table.  After this routine returns,
** the root page is empty, but still exists.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** read cursors on the table.  Open write cursors are moved to the
** root of the table.
**
** If pnChange is not NULL, then table iTable must be an intkey table. The
** integer value pointed to by pnChange is incremented by the number of
** entries in the table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeClearTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pnChange</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>rc</name> = <call><name>checkReadLocks</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* nothing to do */</comment>
  }</block></then><else>else <if>if<condition>( <expr><name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>saveAllCursors</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <comment type="block">/* nothing to do */</comment>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>clearDatabasePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>(<name>Pgno</name>)<name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pnChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Erase all information in a table and add the root of the table to
** the freelist.  Except, the root of the principle table (the one on
** page 1) is never added to the freelist.
**
** This routine will fail with SQLITE_LOCKED if there are any open
** cursors on the table.
**
** If AUTOVACUUM is enabled and the page at iTable is not the last
** root page in the database file, then the last root page 
** in the database file is moved into the slot formerly occupied by
** iTable and that last slot formerly occupied by the last root page
** is added to the freelist instead of iTable.  In this say, all
** root pages are kept at the beginning of the database file, which
** is necessary for AUTOVACUUM to work right.  *piMoved is set to the 
** page number that used to be the last root page in the file before
** the move.  If no page gets moved, *piMoved is set to 0.
** The last root page is recorded in meta[3] and the value of
** meta[3] is updated by this procedure.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>btreeDropTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iTable</name></decl></param>, <param><decl><type><name>int</name> *</type><name>piMoved</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is illegal to drop a table if any cursors are open on the
  ** database. This is because in auto-vacuum mode the backend may
  ** need to move another root-page to fill a gap left by the deleted
  ** root page. If an open cursor was using this page a problem would 
  ** occur.
  */</comment>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pCursor</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>(<name>Pgno</name>)<name>iTable</name></expr></argument>, <argument><expr>&amp;<name>pPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeClearTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr>*<name>piMoved</name> = 0</expr>;</expr_stmt>

  <if>if<condition>( <expr><name>iTable</name>&gt;1</expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
    <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Pgno</name></type> <name>maxRootPgno</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>&amp;<name>maxRootPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>

      <if>if<condition>( <expr><name>iTable</name>==<name>maxRootPgno</name></expr> )</condition><then><block>{
        <comment type="block">/* If the table being dropped is the table with the largest root-page
        ** number in the database, put the root page on the free list. 
        */</comment>
        <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
      }</block></then><else>else<block>{
        <comment type="block">/* The table being dropped does not have the largest root-page
        ** number in the database. So move the page that does into the 
        ** gap left by the deleted root-page.
        */</comment>
        <decl_stmt><decl><type><name>MemPage</name> *</type><name>pMove</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>, <argument><expr>&amp;<name>pMove</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>relocatePage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pMove</name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>, <argument><expr>&amp;<name>pMove</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pMove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr>*<name>piMoved</name> = <name>maxRootPgno</name></expr>;</expr_stmt>
      }</block></else></if>

      <comment type="block">/* Set the new 'max-root-page' value in the database header. This
      ** is the old value less one, less one more if that happens to
      ** be a root-page number, less one again if that is the
      ** PENDING_BYTE_PAGE.
      */</comment>
      <expr_stmt><expr><name>maxRootPgno</name>--</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>maxRootPgno</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>maxRootPgno</name>--</expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>maxRootPgno</name>==<call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>maxRootPgno</name>--</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>maxRootPgno</name>!=<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>maxRootPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>freePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then><else>else<block>{
    <comment type="block">/* If sqlite3BtreeDropTable was called on page 1. */</comment>
    <expr_stmt><expr><call><name>zeroPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>PTF_INTKEY</name>|<name>PTF_LEAF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>  
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeDropTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>, <param><decl><type><name>int</name> *</type><name>piMoved</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>btreeDropTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>piMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Read the meta-information out of a database file.  Meta[0]
** is the number of free pages currently in the database.  Meta[1]
** through meta[15] are available for use by higher layers.  Meta[0]
** is read-only, the others are read/write.
** 
** The schema layer numbers meta values differently.  At the schema
** layer (and the SetCookie and ReadCookie opcodes) the number of
** free pages is not visible.  So Cookie[0] is the same as Meta[1].
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeGetMeta</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>idx</name></decl></param>, <param><decl><type><name>u32</name> *</type><name>pMeta</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pP1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>

  <comment type="block">/* Reading a meta-data value requires a read-lock on page 1 (and hence
  ** the sqlite_master table. We grab this lock regardless of whether or
  ** not the SQLITE_ReadUncommitted flag is set (the table rooted at page
  ** 1 is treated as a special case by queryTableLock() and lockTable()).
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>queryTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&gt;=0 &amp;&amp; <name>idx</name>&lt;=15</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name>-&gt;<name>pPage1</name></expr> )</condition><then><block>{
    <comment type="block">/* The b-tree is already holding a reference to page 1 of the database
    ** file. In this case the required meta-data value can be read directly
    ** from the page data of this reference. This is slightly faster than
    ** requesting a new reference from the pager layer.
    */</comment>
    <expr_stmt><expr><name>pP1</name> = (<name>unsigned</name> <name>char</name> *)<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* The b-tree does not have a reference to page 1 of the database file.
    ** Obtain one from the pager layer.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pP1</name> = (<name>unsigned</name> <name>char</name> *)<call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr>*<name>pMeta</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pP1</name><index>[<expr>36 + <name>idx</name>*4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the b-tree is not holding a reference to page 1, then one was 
  ** requested from the pager layer in the above block. Release it now.
  */</comment>
  <if>if<condition>( <expr>!<name>pBt</name>-&gt;<name>pPage1</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If autovacuumed is disabled in this build but we are trying to 
  ** access an autovacuumed database, then make the database readonly. 
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <if>if<condition>( <expr><name>idx</name>==4 &amp;&amp; *<name>pMeta</name>&gt;0</expr> )</condition><then> <expr_stmt><expr><name>pBt</name>-&gt;<name>readOnly</name> = 1</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Grab the read-lock on page 1. */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>lockTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Write meta-information back into the database.  Meta[0] is
** read-only and may not be written.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeUpdateMeta</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>idx</name></decl></param>, <param><decl><type><name>u32</name></type> <name>iMeta</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pP1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&gt;=1 &amp;&amp; <name>idx</name>&lt;=15</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pPage1</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pP1</name> = <name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>put4byte</name><argument_list>(<argument><expr>&amp;<name><name>pP1</name><index>[<expr>36 + <name>idx</name>*4</expr>]</index></name></expr></argument>, <argument><expr><name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>idx</name>==7</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>autoVacuum</name> || <name>iMeta</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iMeta</name>==0 || <name>iMeta</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBt</name>-&gt;<name>incrVacuum</name> = (<name>u8</name>)<name>iMeta</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the flag byte at the beginning of the page that the cursor
** is currently pointing to.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeFlags</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* TODO: What about CURSOR_REQUIRESEEK state? Probably need to call
  ** restoreCursorPosition() here.
  */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name> = <name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pBt</name>==<name>pCur</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name></expr>]</index></name></expr>;</return>
}</block></function>


<comment type="block">/*
** Return the pager associated with a BTree.  This routine is used for
** testing and debugging only.
*/</comment>
<function><type><name>Pager</name> *</type><name>sqlite3BtreePager</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** Append a message to the error message string.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>checkAppendMsg</name><parameter_list>(
  <param><decl><type><name>IntegrityCk</name> *</type><name>pCheck</name></decl></param>,
  <param><decl><type><name>char</name> *</type><name>zMsg1</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>,
  <param>...</param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>pCheck</name>-&gt;<name>mxErr</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pCheck</name>-&gt;<name>mxErr</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCheck</name>-&gt;<name>nErr</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCheck</name>-&gt;<name>errMsg</name>.<name>nChar</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr>&amp;<name>pCheck</name>-&gt;<name>errMsg</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>zMsg1</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr>&amp;<name>pCheck</name>-&gt;<name>errMsg</name></expr></argument>, <argument><expr><name>zMsg1</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VXPrintf</name><argument_list>(<argument><expr>&amp;<name>pCheck</name>-&gt;<name>errMsg</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCheck</name>-&gt;<name>errMsg</name>.<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCheck</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** Add 1 to the reference count for page iPage.  If this is the second
** reference to the page, add an error message to pCheck-&gt;zErrMsg.
** Return 1 if there are 2 ore more references to the page and 0 if
** if this is the first reference to the page.
**
** Also check that the page number is in bounds.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkRef</name><parameter_list>(<param><decl><type><name>IntegrityCk</name> *</type><name>pCheck</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>iPage</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zContext</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>iPage</name>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <if>if<condition>( <expr><name>iPage</name>&gt;<name>pCheck</name>-&gt;<name>nPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"invalid page number %d"</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCheck</name>-&gt;<name><name>anRef</name><index>[<expr><name>iPage</name></expr>]</index></name>==1</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"2nd reference to page %d"</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <return>return  <expr>(<name>pCheck</name>-&gt;<name><name>anRef</name><index>[<expr><name>iPage</name></expr>]</index></name>++)&gt;1</expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Check that the entry in the pointer-map for page iChild maps to 
** page iParent, pointer type ptrType. If not, append an error message
** to pCheck.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>checkPtrmap</name><parameter_list>(
  <param><decl><type><name>IntegrityCk</name> *</type><name>pCheck</name></decl></param>,   <comment type="block">/* Integrity check context */</comment>
  <param><decl><type><name>Pgno</name></type> <name>iChild</name></decl></param>,           <comment type="block">/* Child page number */</comment>
  <param><decl><type><name>u8</name></type> <name>eType</name></decl></param>,              <comment type="block">/* Expected pointer map type */</comment>
  <param><decl><type><name>Pgno</name></type> <name>iParent</name></decl></param>,          <comment type="block">/* Expected pointer map parent page number */</comment>
  <param><decl><type><name>char</name> *</type><name>zContext</name></decl></param>         <comment type="block">/* Context description (used for error msg) */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>ePtrmapType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iPtrmapParent</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>ptrmapGet</name><argument_list>(<argument><expr><name>pCheck</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>iChild</name></expr></argument>, <argument><expr>&amp;<name>ePtrmapType</name></expr></argument>, <argument><expr>&amp;<name>iPtrmapParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then> <expr_stmt><expr><name>pCheck</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"Failed to read ptrmap key=%d"</expr></argument>, <argument><expr><name>iChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>ePtrmapType</name>!=<name>eType</name> || <name>iPtrmapParent</name>!=<name>iParent</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, 
      <argument><expr>"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"</expr></argument>, 
      <argument><expr><name>iChild</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>ePtrmapType</name></expr></argument>, <argument><expr><name>iPtrmapParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Check the integrity of the freelist or of an overflow page list.
** Verify that the number of pages on the list is N.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>checkList</name><parameter_list>(
  <param><decl><type><name>IntegrityCk</name> *</type><name>pCheck</name></decl></param>,  <comment type="block">/* Integrity checking context */</comment>
  <param><decl><type><name>int</name></type> <name>isFreeList</name></decl></param>,       <comment type="block">/* True for a freelist.  False for overflow page list */</comment>
  <param><decl><type><name>int</name></type> <name>iPage</name></decl></param>,            <comment type="block">/* Page number for first page in the list */</comment>
  <param><decl><type><name>int</name></type> <name>N</name></decl></param>,                <comment type="block">/* Expected number of pages in the list */</comment>
  <param><decl><type><name>char</name> *</type><name>zContext</name></decl></param>        <comment type="block">/* Context for error messages */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>expected</name> =<init> <expr><name>N</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> =<init> <expr><name>iPage</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>N</name>-- &gt; 0 &amp;&amp; <name>pCheck</name>-&gt;<name>mxErr</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>DbPage</name> *</type><name>pOvflPage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pOvflData</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>iPage</name>&lt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>,
         <argument><expr>"%d of %d pages missing from overflow list starting at %d"</expr></argument>,
          <argument><expr><name>N</name>+1</expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr> )</condition><then> <break>break;</break></then></if>
    <if>if<condition>( <expr><call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pCheck</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>(<name>Pgno</name>)<name>iPage</name></expr></argument>, <argument><expr>&amp;<name>pOvflPage</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"failed to get page %d"</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>pOvflData</name> = (<name>unsigned</name> <name>char</name> *)<call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pOvflPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>isFreeList</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pOvflData</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pCheck</name>-&gt;<name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if<condition>( <expr><name>n</name>&gt;<name>pCheck</name>-&gt;<name>pBt</name>-&gt;<name>usableSize</name>/4-2</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>,
           <argument><expr>"freelist leaf count too big on page %d"</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>N</name>--</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>Pgno</name></type> <name>iFreePage</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pOvflData</name><index>[<expr>8+<name>i</name>*4</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
          <if>if<condition>( <expr><name>pCheck</name>-&gt;<name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>PTRMAP_FREEPAGE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iFreePage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>N</name> -= <name>n</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <else>else<block>{
      <comment type="block">/* If this database supports auto-vacuum and iPage is not the last
      ** page in this overflow list, check that the pointer-map entry for
      ** the following page matches iPage.
      */</comment>
      <if>if<condition>( <expr><name>pCheck</name>-&gt;<name>pBt</name>-&gt;<name>autoVacuum</name> &amp;&amp; <name>N</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>i</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>pOvflData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW2</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>iPage</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>pOvflData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pOvflPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** Do various sanity checks on a single page of a tree.  Return
** the tree depth.  Root pages return 0.  Parents of root pages
** return 1, and so forth.
** 
** These checks are done:
**
**      1.  Make sure that cells and freeblocks do not overlap
**          but combine to completely cover the page.
**  NO  2.  Make sure cell keys are in order.
**  NO  3.  Make sure no key is less than or equal to zLowerBound.
**  NO  4.  Make sure no key is greater than or equal to zUpperBound.
**      5.  Check the integrity of overflow pages.
**      6.  Recursively call checkTreePage on all children.
**      7.  Verify that the depth of all children is the same.
**      8.  Make sure this page is at least 33% full or else it is
**          the root of the tree.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkTreePage</name><parameter_list>(
  <param><decl><type><name>IntegrityCk</name> *</type><name>pCheck</name></decl></param>,  <comment type="block">/* Context for the sanity check */</comment>
  <param><decl><type><name>int</name></type> <name>iPage</name></decl></param>,            <comment type="block">/* Page number of the page to check */</comment>
  <param><decl><type><name>char</name> *</type><name>zParentContext</name></decl></param>  <comment type="block">/* Parent context */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>rc</name>, <name>depth</name>, <name>d2</name>, <name>pgno</name>, <name>cnt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hdr</name>, <name>cellStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCell</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>usableSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zContext</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>hit</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"Page %d: "</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that the page exists
  */</comment>
  <expr_stmt><expr><name>pBt</name> = <name>pCheck</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>usableSize</name> = <name>pBt</name>-&gt;<name>usableSize</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iPage</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><call><name>checkRef</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>zParentContext</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr>(<name>rc</name> = <call><name>sqlite3BtreeGetPage</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>(<name>Pgno</name>)<name>iPage</name></expr></argument>, <argument><expr>&amp;<name>pPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then> <expr_stmt><expr><name>pCheck</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>,
       <argument><expr>"unable to get the page. error code=%d"</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>(<name>rc</name> = <call><name>sqlite3BtreeInitPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_CORRUPT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The only possible error from InitPage */</comment>
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, 
                   <argument><expr>"sqlite3BtreeInitPage() returns error code %d"</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* Check out all the cells.
  */</comment>
  <expr_stmt><expr><name>depth</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pPage</name>-&gt;<name>nCell</name> &amp;&amp; <name>pCheck</name>-&gt;<name>mxErr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>

    <comment type="block">/* Check payload overflow pages
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zContext</name></expr></argument>,
             <argument><expr>"On tree page %d cell %d: "</expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCell</name> = <call><name>findCell</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeParseCellPtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr><name>pCell</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sz</name> = <name>info</name>.<name>nData</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>intKey</name></expr> )</condition><then> <expr_stmt><expr><name>sz</name> += (<name>int</name>)<name>info</name>.<name>nKey</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sz</name>==<name>info</name>.<name>nPayload</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>sz</name>&gt;<name>info</name>.<name>nLocal</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> =<init> <expr>(<name>sz</name> - <name>info</name>.<name>nLocal</name> + <name>usableSize</name> - 5)/(<name>usableSize</name> - 4)</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoOvfl</name> =<init> <expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name><name>pCell</name><index>[<expr><name>info</name>.<name>iOverflow</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>PTRMAP_OVERFLOW1</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>checkList</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pgnoOvfl</name></expr></argument>, <argument><expr><name>nPage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Check sanity of left child page.
    */</comment>
    <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr><name>pCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>d2</name> = <call><name>checkTreePage</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>i</name>&gt;0 &amp;&amp; <name>d2</name>!=<name>depth</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, <argument><expr>"Child page depth differs"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>depth</name> = <name>d2</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <if>if<condition>( <expr>!<name>pPage</name>-&gt;<name>leaf</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pgno</name> = <call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pPage</name>-&gt;<name><name>aData</name><index>[<expr><name>pPage</name>-&gt;<name>hdrOffset</name>+8</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zContext</name></expr></argument>, 
                     <argument><expr>"On page %d at right child: "</expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>PTRMAP_BTREE</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>checkTreePage</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>zContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
 
  <comment type="block">/* Check for complete coverage of the page
  */</comment>
  <expr_stmt><expr><name>data</name> = <name>pPage</name>-&gt;<name>aData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hdr</name> = <name>pPage</name>-&gt;<name>hdrOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hit</name> = <call><name>sqlite3PageMalloc</name><argument_list>( <argument><expr><name>pBt</name>-&gt;<name>pageSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>hit</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCheck</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>u16</name></type> <name>contentOffset</name> =<init> <expr><call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+5</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>contentOffset</name> &gt; <name>usableSize</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>, 
                     <argument><expr>"Corruption detected in header on page %d"</expr></argument>,<argument><expr><name>iPage</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>check_page_abort</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hit</name>+<name>contentOffset</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>usableSize</name>-<name>contentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hit</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>contentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCell</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cellStart</name> = <name>hdr</name> + 12 - 4*<name>pPage</name>-&gt;<name>leaf</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCell</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>pc</name> =<init> <expr><call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>cellStart</name>+<name>i</name>*2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u16</name></type> <name>size</name> =<init> <expr>1024</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pc</name>&lt;=<name>usableSize</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>size</name> = <call><name>cellSizePtr</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr>&amp;<name><name>data</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr>(<name>pc</name>+<name>size</name>-1)&gt;=<name>usableSize</name> || <name>pc</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>, 
            <argument><expr>"Corruption detected in cell %d on page %d"</expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>iPage</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <for>for(<init><expr><name>j</name>=<name>pc</name>+<name>size</name>-1</expr>;</init> <condition><expr><name>j</name>&gt;=<name>pc</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <expr_stmt><expr><name><name>hit</name><index>[<expr><name>j</name></expr>]</index></name>++</expr>;</expr_stmt></for>
      }</block></else></if>
    }</block></for>
    <for>for(<init><expr><name>cnt</name>=0</expr>, <expr><name>i</name>=<call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>hdr</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name>&gt;0 &amp;&amp; <name>i</name>&lt;<name>usableSize</name> &amp;&amp; <name>cnt</name>&lt;10000</expr>;</condition> 
           <incr><expr><name>cnt</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>size</name> =<init> <expr><call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>i</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <if>if<condition>( <expr>(<name>i</name>+<name>size</name>-1)&gt;=<name>usableSize</name> || <name>i</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>,  
            <argument><expr>"Corruption detected in cell %d on page %d"</expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>iPage</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <for>for(<init><expr><name>j</name>=<name>i</name>+<name>size</name>-1</expr>;</init> <condition><expr><name>j</name>&gt;=<name>i</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>) <expr_stmt><expr><name><name>hit</name><index>[<expr><name>j</name></expr>]</index></name>++</expr>;</expr_stmt></for>
      }</block></else></if>
      <expr_stmt><expr><name>i</name> = <call><name>get2byte</name><argument_list>(<argument><expr>&amp;<name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <for>for(<init><expr><name>i</name>=<name>cnt</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>usableSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>hit</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name><name>hit</name><index>[<expr><name>i</name></expr>]</index></name>&gt;1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>,
          <argument><expr>"Multiple uses for byte %d of page %d"</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if></else></if>
    }</block></for>
    <if>if<condition>( <expr><name>cnt</name>!=<name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr><name>pCheck</name></expr></argument>, <argument><expr>0</expr></argument>, 
          <argument><expr>"Fragmented space is %d byte reported as %d on page %d"</expr></argument>,
          <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>hdr</name>+7</expr>]</index></name></expr></argument>, <argument><expr><name>iPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
<label><name>check_page_abort</name>:</label>
  <if>if <condition>(<expr><name>hit</name></expr>)</condition><then> <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>releasePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>depth</name>+1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/*
** This routine does a complete check of the given BTree file.  aRoot[] is
** an array of pages numbers were each page number is the root page of
** a table.  nRoot is the number of entries in aRoot.
**
** Write the number of error seen in *pnErr.  Except for some memory
** allocation errors,  an error message held in memory obtained from
** malloc is returned if *pnErr is non-zero.  If *pnErr==0 then NULL is
** returned.  If a memory allocation error occurs, NULL is returned.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3BtreeIntegrityCheck</name><parameter_list>(
  <param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>,     <comment type="block">/* The btree to be checked */</comment>
  <param><decl><type><name>int</name> *</type><name>aRoot</name></decl></param>,   <comment type="block">/* An array of root pages numbers for individual trees */</comment>
  <param><decl><type><name>int</name></type> <name>nRoot</name></decl></param>,    <comment type="block">/* Number of entries in aRoot[] */</comment>
  <param><decl><type><name>int</name></type> <name>mxErr</name></decl></param>,    <comment type="block">/* Stop reporting errors after this many */</comment>
  <param><decl><type><name>int</name> *</type><name>pnErr</name></decl></param>    <comment type="block">/* Write number of errors seen to this variable */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IntegrityCk</name></type> <name>sCheck</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zErr</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nRef</name> = <call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>lockBtreeWithRetry</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pnErr</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>"cannot acquire a read lock on the database"</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>sCheck</name>.<name>pBt</name> = <name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sCheck</name>.<name>pPager</name> = <name>pBt</name>-&gt;<name>pPager</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sCheck</name>.<name>nPage</name> = <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>sCheck</name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sCheck</name>.<name>mxErr</name> = <name>mxErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sCheck</name>.<name>nErr</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>sCheck</name>.<name>mallocFailed</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnErr</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sCheck</name>.<name>nPage</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>sCheck</name>.<name>anRef</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr>(<name>sCheck</name>.<name>nPage</name>+1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>sCheck</name>.<name>anRef</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pnErr</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>sCheck</name>.<name>nPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ <expr_stmt><expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt> }</block></for>
  <expr_stmt><expr><name>i</name> = <call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>i</name>&lt;=<name>sCheck</name>.<name>nPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr>&amp;<name>sCheck</name>.<name>errMsg</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>20000</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the integrity of the freelist
  */</comment>
  <expr_stmt><expr><call><name>checkList</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>32</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>get4byte</name><argument_list>(<argument><expr>&amp;<name>pBt</name>-&gt;<name>pPage1</name>-&gt;<name><name>aData</name><index>[<expr>36</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"Main freelist: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check all the tables.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr>(<name>int</name>)<name>i</name>&lt;<name>nRoot</name> &amp;&amp; <name>sCheck</name>.<name>mxErr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pBt</name>-&gt;<name>autoVacuum</name> &amp;&amp; <name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name>&gt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkPtrmap</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>PTRMAP_ROOTPAGE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>checkTreePage</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr><name><name>aRoot</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>"List of tree roots: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Make sure every page in the file is referenced
  */</comment>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>sCheck</name>.<name>nPage</name> &amp;&amp; <name>sCheck</name>.<name>mxErr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
    <if>if<condition>( <expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>"Page %d is never used"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* If the database supports auto-vacuum, make sure no tables contain
    ** references to pointer-map pages.
    */</comment>
    <if>if<condition>( <expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name>==0 &amp;&amp; 
       (<call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>!=<name>i</name> || !<name>pBt</name>-&gt;<name>autoVacuum</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>"Page %d is never used"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>sCheck</name>.<name><name>anRef</name><index>[<expr><name>i</name></expr>]</index></name>!=0 &amp;&amp; 
       (<call><name>PTRMAP_PAGENO</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>==<name>i</name> &amp;&amp; <name>pBt</name>-&gt;<name>autoVacuum</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>"Pointer map page %d is referenced"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></for>

  <comment type="block">/* Make sure this analysis did not leave any unref() pages.
  ** This is an internal consistency check; an integrity check
  ** of the integrity check.
  */</comment>
  <expr_stmt><expr><call><name>unlockBtreeIfUnused</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>nRef</name> != <call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>checkAppendMsg</name><argument_list>(<argument><expr>&amp;<name>sCheck</name></expr></argument>, <argument><expr>0</expr></argument>, 
      <argument><expr>"Outstanding page count goes from %d to %d during this analysis"</expr></argument>,
      <argument><expr><name>nRef</name></expr></argument>, <argument><expr><call><name>sqlite3PagerRefcount</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Clean  up and report errors.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>sCheck</name>.<name>anRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sCheck</name>.<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3StrAccumReset</name><argument_list>(<argument><expr>&amp;<name>sCheck</name>.<name>errMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pnErr</name> = <name>sCheck</name>.<name>nErr</name>+1</expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pnErr</name> = <name>sCheck</name>.<name>nErr</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sCheck</name>.<name>nErr</name>==0</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3StrAccumReset</name><argument_list>(<argument><expr>&amp;<name>sCheck</name>.<name>errMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr>&amp;<name>sCheck</name>.<name>errMsg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/*
** Return the full pathname of the underlying database file.
**
** The pager filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3BtreeGetFilename</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the pathname of the directory that contains the database file.
**
** The pager directory name is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3BtreeGetDirname</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PagerDirname</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the pathname of the journal file for this database. The return
** value of this routine is the same regardless of whether the journal file
** has been created or not.
**
** The pager journal filename is invariant as long as the pager is
** open so it is safe to access without the BtShared mutex.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3BtreeGetJournalname</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PagerJournalname</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VACUUM</name></cpp:ifndef>
<comment type="block">/*
** Copy the complete content of pBtFrom into pBtTo.  A transaction
** must be active for both files.
**
** The size of file pTo may be reduced by this operation.
** If anything goes wrong, the transaction on pTo is rolled back. 
**
** If successful, CommitPhaseOne() may be called on pTo before returning. 
** The caller should finish committing the transaction on pTo by calling
** sqlite3BtreeCommit().
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>btreeCopyFile</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>Btree</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>i</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>Pgno</name></type> <name>nFromPage</name></decl>;</decl_stmt>     <comment type="block">/* Number of pages in pFrom */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nToPage</name></decl>;</decl_stmt>       <comment type="block">/* Number of pages in pTo */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nNewPage</name></decl>;</decl_stmt>      <comment type="block">/* Number of pages in pTo after the copy */</comment>

  <decl_stmt><decl><type><name>Pgno</name></type> <name>iSkip</name></decl>;</decl_stmt>         <comment type="block">/* Pending byte page in pTo */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToPageSize</name></decl>;</decl_stmt>    <comment type="block">/* Page size of pTo in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nFromPageSize</name></decl>;</decl_stmt>  <comment type="block">/* Page size of pFrom in bytes */</comment>

  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBtTo</name> =<init> <expr><name>pTo</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBtFrom</name> =<init> <expr><name>pFrom</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pBtTo</name>-&gt;<name>db</name> = <name>pTo</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBtFrom</name>-&gt;<name>db</name> = <name>pFrom</name>-&gt;<name>db</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>nToPageSize</name> = <name>pBtTo</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFromPageSize</name> = <name>pBtFrom</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTo</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFrom</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>nToPage</name> = <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBtTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFromPage</name> = <call><name>pagerPagecount</name><argument_list>(<argument><expr><name>pBtFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSkip</name> = <call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBtTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Variable nNewPage is the number of pages required to store the
  ** contents of pFrom using the current page-size of pTo.
  */</comment>
  <expr_stmt><expr><name>nNewPage</name> = (<name>Pgno</name>)
     (((<name>i64</name>)<name>nFromPage</name>*(<name>i64</name>)<name>nFromPageSize</name>+(<name>i64</name>)<name>nToPageSize</name>-1)/(<name>i64</name>)<name>nToPageSize</name>)</expr>;</expr_stmt>

  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; (<name>i</name>&lt;=<name>nToPage</name> || <name>i</name>&lt;=<name>nNewPage</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{

    <comment type="block">/* Journal the original page.
    **
    ** iSkip is the page number of the locking page (PENDING_BYTE_PAGE)
    ** in database *pTo (before the copy). This page is never written 
    ** into the journal file. Unless i==iSkip or the page was not
    ** present in pTo before the copy operation, journal page i from pTo.
    */</comment>
    <if>if<condition>( <expr><name>i</name>!=<name>iSkip</name> &amp;&amp; <name>i</name>&lt;=<name>nToPage</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&gt;<name>nFromPage</name></expr> )</condition><then><block>{
          <comment type="block">/* Yeah.  It seems wierd to call DontWrite() right after Write(). But
          ** that is because the names of those procedures do not exactly 
          ** represent what they do.  Write() really means "put this page in the
          ** rollback journal and mark it as dirty so that it will be written
          ** to the database file later."  DontWrite() undoes the second part of
          ** that and prevents the page from being written to the database. The
          ** page is still on the rollback journal, though.  And that is the 
          ** whole point of this block: to put pages on the rollback journal. 
          */</comment>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerDontWrite</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Overwrite the data in page i of the target database */</comment>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>!=<name>iSkip</name> &amp;&amp; <name>i</name>&lt;=<name>nNewPage</name></expr> )</condition><then><block>{

      <decl_stmt><decl><type><name>DbPage</name> *</type><name>pToPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iOff</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>pToPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pToPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <for>for(
        <init><expr><name>iOff</name>=(<name>i</name>-1)*<name>nToPageSize</name></expr>;</init> 
        <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>iOff</name>&lt;<name>i</name>*<name>nToPageSize</name></expr>;</condition> 
        <incr><expr><name>iOff</name> += <name>nFromPageSize</name></expr></incr>
      )<block>{
        <decl_stmt><decl><type><name>DbPage</name> *</type><name>pFromPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iFrom</name> =<init> <expr>(<name>Pgno</name>)(<name>iOff</name>/<name>nFromPageSize</name>)+1</expr></init></decl>;</decl_stmt>

        <if>if<condition>( <expr><name>iFrom</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBtFrom</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBtFrom</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr>&amp;<name>pFromPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>zTo</name> =<init> <expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pToPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> *</type><name>zFrom</name> =<init> <expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pFromPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name></decl>;</decl_stmt>

          <if>if<condition>( <expr><name>nFromPageSize</name>&gt;=<name>nToPageSize</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>zFrom</name> += ((<name>i</name>-1)*<name>nToPageSize</name> - ((<name>iFrom</name>-1)*<name>nFromPageSize</name>))</expr>;</expr_stmt>
            <expr_stmt><expr><name>nCopy</name> = <name>nToPageSize</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>zTo</name> += (((<name>iFrom</name>-1)*<name>nFromPageSize</name>) - (<name>i</name>-1)*<name>nToPageSize</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>nCopy</name> = <name>nFromPageSize</name></expr>;</expr_stmt>
          }</block></else></if>

          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zTo</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pFromPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>

      <if>if<condition>( <expr><name>pToPage</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>MemPage</name> *</type><name>p</name> =<init> <expr>(<name>MemPage</name> *)<call><name>sqlite3PagerGetExtra</name><argument_list>(<argument><expr><name>pToPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>isInit</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pToPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* If things have worked so far, the database file may need to be 
  ** truncated. The complex part is that it may need to be truncated to
  ** a size that is not an integer multiple of nToPageSize - the current
  ** page size used by the pager associated with B-Tree pTo.
  **
  ** For example, say the page-size of pTo is 2048 bytes and the original 
  ** number of pages is 5 (10 KB file). If pFrom has a page size of 1024 
  ** bytes and 9 pages, then the file needs to be truncated to 9KB.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>pFile</name> =<init> <expr><call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iSize</name> =<init> <expr>(<name>i64</name>)<name>nFromPageSize</name> * (<name>i64</name>)<name>nFromPage</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>iNow</name> =<init> <expr>(<name>i64</name>)((<name>nToPage</name>&gt;<name>nNewPage</name>)?<name>nToPage</name>:<name>nNewPage</name>) * (<name>i64</name>)<name>nToPageSize</name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>i64</name></type> <name>iPending</name> =<init> <expr>((<name>i64</name>)<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBtTo</name></expr></argument>)</argument_list></call>-1) *(<name>i64</name>)<name>nToPageSize</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSize</name>&lt;=<name>iNow</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Commit phase one syncs the journal file associated with pTo 
    ** containing the original data. It does not sync the database file
    ** itself. After doing this it is safe to use OsTruncate() and other
    ** file APIs on the database file directly.
    */</comment>
    <expr_stmt><expr><name>pBtTo</name>-&gt;<name>db</name> = <name>pTo</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerCommitPhaseOne</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iSize</name>&lt;<name>iNow</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* The loop that copied data from database pFrom to pTo did not
    ** populate the locking page of database pTo. If the page-size of
    ** pFrom is smaller than that of pTo, this means some data will
    ** not have been copied. 
    **
    ** This block copies the missing data from database pFrom to pTo 
    ** using file APIs. This is safe because at this point we know that
    ** all of the original data from pTo has been synced into the 
    ** journal file. At this point it would be safe to do anything at
    ** all to the database file except truncate it to zero bytes.
    */</comment>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>nFromPageSize</name>&lt;<name>nToPageSize</name> &amp;&amp; <name>iSize</name>&gt;<name>iPending</name></expr>)</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>iOff</name></decl>;</decl_stmt>
      <for>for(
        <init><expr><name>iOff</name>=<name>iPending</name></expr>;</init> 
        <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>iOff</name>&lt;(<name>iPending</name>+<name>nToPageSize</name>)</expr>;</condition> 
        <incr><expr><name>iOff</name> += <name>nFromPageSize</name></expr></incr>
      )<block>{
        <decl_stmt><decl><type><name>DbPage</name> *</type><name>pFromPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Pgno</name></type> <name>iFrom</name> =<init> <expr>(<name>Pgno</name>)(<name>iOff</name>/<name>nFromPageSize</name>)+1</expr></init></decl>;</decl_stmt>

        <if>if<condition>( <expr><name>iFrom</name>==<call><name>PENDING_BYTE_PAGE</name><argument_list>(<argument><expr><name>pBtFrom</name></expr></argument>)</argument_list></call> || <name>iFrom</name>&gt;<name>nFromPage</name></expr> )</condition><then><block>{
          <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pBtFrom</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>iFrom</name></expr></argument>, <argument><expr>&amp;<name>pFromPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>zFrom</name> =<init> <expr><call><name>sqlite3PagerGetData</name><argument_list>(<argument><expr><name>pFromPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFromPageSize</name></expr></argument>, <argument><expr><name>iOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pFromPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Sync the database file */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSync</name><argument_list>(<argument><expr><name>pBtTo</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pBtTo</name>-&gt;<name>pageSizeFixed</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3BtreeCopyFile</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>Btree</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>btreeCopyFile</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VACUUM */</comment>

<comment type="block">/*
** Return non-zero if a transaction is active.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIsInTrans</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name>p</name> &amp;&amp; (<name>p</name>-&gt;<name>inTrans</name>==<name>TRANS_WRITE</name>))</expr>;</return>
}</block></function>

<comment type="block">/*
** Return non-zero if a statement transaction is active.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIsInStmt</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call> &amp;&amp; <name>p</name>-&gt;<name>pBt</name>-&gt;<name>inStmt</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return non-zero if a read (or write) transaction is active.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeIsInReadTrans</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name>-&gt;<name>inTrans</name>!=<name>TRANS_NONE</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function returns a pointer to a blob of memory associated with
** a single shared-btree. The memory is used by client code for its own
** purposes (for example, to store a high-level schema associated with 
** the shared-btree). The btree layer manages reference counting issues.
**
** The first time this is called on a shared-btree, nBytes bytes of memory
** are allocated, zeroed, and returned to the caller. For each subsequent 
** call the nBytes parameter is ignored and a pointer to the same blob
** of memory returned. 
**
** If the nBytes parameter is 0 and the blob of memory has not yet been
** allocated, a null pointer is returned. If the blob has already been
** allocated, it is returned as normal.
**
** Just before the shared-btree is closed, the function passed as the 
** xFree argument when the memory allocation was made is invoked on the 
** blob of allocated memory. This function should not call sqlite3_free()
** on the memory, the btree layer does that.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3BtreeSchema</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBytes</name></decl></param>, <param><function_decl><type><name>void</name></type>(*<name>xFree</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pBt</name>-&gt;<name>pSchema</name> &amp;&amp; <name>nBytes</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pBt</name>-&gt;<name>pSchema</name> = <call><name>sqlite3MallocZero</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name>-&gt;<name>xFreeSchema</name> = <name>xFree</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pBt</name>-&gt;<name>pSchema</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return true if another user of the same shared btree as the argument
** handle holds an exclusive lock on the sqlite_master table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSchemaLocked</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = (<call><name>queryTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MASTER_ROOT</name></expr></argument>, <argument><expr><name>READ_LOCK</name></expr></argument>)</argument_list></call>!=<name>SQLITE_OK</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** Obtain a lock on the table whose root page is iTab.  The
** lock is a write lock if isWritelock is true or a read lock
** if it is false.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeLockTable</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTab</name></decl></param>, <param><decl><type><name>u8</name></type> <name>isWriteLock</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>lockType</name> =<init> <expr><name>READ_LOCK</name> + <name>isWriteLock</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>READ_LOCK</name>+1==<name>WRITE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isWriteLock</name>==0 || <name>isWriteLock</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>queryTableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>lockTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>lockType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** Argument pCsr must be a cursor opened for writing on an 
** INTKEY table currently pointing at a valid table entry. 
** This function modifies the data stored as part of that entry.
** Only the data content may only be modified, it is not possible
** to change the length of the data stored.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreePutData</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCsr</name></decl></param>, <param><decl><type><name>u32</name></type> <name>offset</name></decl></param>, <param><decl><type><name>u32</name></type> <name>amt</name></decl></param>, <param><decl><type><name>void</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCsr</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pCsr</name>-&gt;<name>isIncrblobHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>restoreCursorPosition</name><argument_list>(<argument><expr><name>pCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCsr</name>-&gt;<name>eState</name>!=<name>CURSOR_REQUIRESEEK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCsr</name>-&gt;<name>eState</name>!=<name>CURSOR_VALID</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ABORT</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Check some preconditions: 
  **   (a) the cursor is open for writing,
  **   (b) there is no read-lock on the table being modified and
  **   (c) the cursor points at a valid row of an intKey table.
  */</comment>
  <if>if<condition>( <expr>!<name>pCsr</name>-&gt;<name>wrFlag</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_READONLY</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pCsr</name>-&gt;<name>pBt</name>-&gt;<name>readOnly</name> 
          &amp;&amp; <name>pCsr</name>-&gt;<name>pBt</name>-&gt;<name>inTransaction</name>==<name>TRANS_WRITE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>checkReadLocks</name><argument_list>(<argument><expr><name>pCsr</name>-&gt;<name>pBtree</name></expr></argument>, <argument><expr><name>pCsr</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>pCsr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return> <comment type="block">/* The table pCur points to has a read lock */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCsr</name>-&gt;<name>eState</name>==<name>CURSOR_INVALID</name> || !<name>pCsr</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCsr</name>-&gt;<name>iPage</name></expr>]</index></name>-&gt;<name>intKey</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <return>return <macro><name>accessPayload</name><argument_list>(<argument>pCsr</argument>, <argument>offset</argument>, <argument>amt</argument>, <argument>(unsigned char *)z</argument>, <argument>0</argument>, <argument>1</argument>)</argument_list></macro>;</return>
}</block></function>

<comment type="block">/* 
** Set a flag on this cursor to cache the locations of pages from the 
** overflow list for the current row. This is used by cursors opened
** for incremental blob IO only.
**
** This function sets a flag only. The actual page location cache
** (stored in BtCursor.aOverflow[]) is allocated and used by function
** accessPayload() (the worker function for sqlite3BtreeData() and
** sqlite3BtreePutData()).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCacheOverflow</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>cursorHoldsMutex</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>pCur</name>-&gt;<name>isIncrblobHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>pCur</name>-&gt;<name>aOverflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>isIncrblobHandle</name> = 1</expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
