<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="vdbe.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** The code in this file implements execution method of the 
** Virtual Database Engine (VDBE).  A separate file ("vdbeaux.c")
** handles housekeeping details such as creating and deleting
** VDBE instances.  This file is solely interested in executing
** the VDBE program.
**
** In the external interface, an "sqlite3_stmt*" is an opaque pointer
** to a VDBE.
**
** The SQL parser generates a program which is then executed by
** the VDBE to do the work of the SQL statement.  VDBE programs are 
** similar in form to assembly language.  The program consists of
** a linear sequence of operations.  Each operation has an opcode 
** and 5 operands.  Operands P1, P2, and P3 are integers.  Operand P4 
** is a null-terminated string.  Operand P5 is an unsigned character.
** Few opcodes use all 5 operands.
**
** Computation results are stored on a set of registers numbered beginning
** with 1 and going up to Vdbe.nMem.  Each register can store
** either an integer, a null-terminated string, a floating point
** number, or the SQL "NULL" value.  An implicit conversion from one
** type to the other occurs as necessary.
** 
** Most of the code in this file is taken up by the sqlite3VdbeExec()
** function which does the work of interpreting a VDBE program.
** But other routines are also provided to help in building up
** a program instruction by instruction.
**
** Various scripts scan this source file in order to generate HTML
** documentation, headers files, or other derived files.  The formatting
** of the code in this file is, therefore, important.  See other comments
** in this file for details.  If in doubt, do not deviate from existing
** commenting and indentation practices when changing or adding code.
**
** $Id: vdbe.c,v 1.811 2009/01/14 00:55:10 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The following global variable is incremented every time a cursor
** moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test
** procedures use this information to make sure that indices are
** working correctly.  This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_search_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** When this global variable is positive, it gets decremented once before
** each instruction in the VDBE.  When reaches zero, the u1.isInterrupted
** field of the sqlite3 structure is set in order to simulate and interrupt.
**
** This facility is used for testing purposes only.  It does not function
** in an ordinary build.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_interrupt_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable is incremented each type the OP_Sort opcode
** is executed.  The test procedures use this information to make sure that
** sorting is occurring or not occurring at appropriate times.   This variable
** has no function other than to help verify the correct operation of the
** library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sort_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The next global variable records the size of the largest MEM_Blob
** or MEM_Str that has been used by a VDBE opcode.  The test procedures
** use this information to make sure that the zero-blob functionality
** is working correctly.   This variable has no function other than to
** help verify the correct operation of the library.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_max_blobsize</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>static</name> <name>void</name></type> <name>updateMaxBlobsize</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name> &amp; (<name>MEM_Str</name>|<name>MEM_Blob</name>))!=0 &amp;&amp; <name>p</name>-&gt;<name>n</name>&gt;<name>sqlite3_max_blobsize</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3_max_blobsize</name> = <name>p</name>-&gt;<name>n</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test a register to see if it exceeds the current maximum blob size.
** If it does, record the new maximum blob size.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_BUILTIN_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>UPDATE_MAX_BLOBSIZE</name>(P)  updateMaxBlobsize(P)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>UPDATE_MAX_BLOBSIZE</name>(P)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert the given register into a string if it isn't one
** already. Return non-zero if a malloc() fails.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Stringify</name>(P, enc) \
   if(((P)-&gt;flags&amp;(MEM_Str|MEM_Blob))==0 &amp;&amp; sqlite3VdbeMemStringify(P,enc)) \
     { goto no_mem; }</cpp:define>

<comment type="block">/*
** An ephemeral string value (signified by the MEM_Ephem flag) contains
** a pointer to a dynamically allocated string where some other entity
** is responsible for deallocating that string.  Because the register
** does not control the string, it might be deleted without the register
** knowing it.
**
** This routine converts an ephemeral string into a dynamically allocated
** string that the register itself controls.  In other words, it
** converts an MEM_Ephem string into an MEM_Dyn string.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>Deephemeralize</name>(P) \
   if( ((P)-&gt;flags&amp;MEM_Ephem)!=0 \
       &amp;&amp; sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}</cpp:define>

<comment type="block">/*
** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)
** P if required.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ExpandBlob</name>(P) (((P)-&gt;flags&amp;MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)</cpp:define>

<comment type="block">/*
** Argument pMem points at a register that will be passed to a
** user-defined function or returned to the user as the result of a query.
** The second argument, 'db_enc' is the text encoding used by the vdbe for
** register variables.  This routine sets the pMem-&gt;enc and pMem-&gt;type
** variables used by the sqlite3_value_*() routines.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>storeTypeInfo</name>(A,B) _storeTypeInfo(A)</cpp:define>
<function><type><name>static</name> <name>void</name></type> <name>_storeTypeInfo</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><name>pMem</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_NULL</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_FLOAT</name></expr>;</expr_stmt>
  }</block></then>
  <else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Str</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_TEXT</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_BLOB</name></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if>
}</block></function>

<comment type="block">/*
** Properties of opcodes.  The OPFLG_INITIALIZER macro is
** created by mkopcodeh.awk during compilation.  Data is obtained
** from the comments following the "case OP_xxxx:" statements in
** this file.  
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>opcodeProperty</name><index>[]</index></name> =<init> <expr><name>OPFLG_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Return true if an opcode has any of the OPFLG_xxx properties
** specified by mask.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeOpcodeHasProperty</name><parameter_list>(<param><decl><type><name>int</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>int</name></type> <name>mask</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>opcode</name>&gt;0 &amp;&amp; <name>opcode</name>&lt;(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>opcodeProperty</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name><name>opcodeProperty</name><index>[<expr><name>opcode</name></expr>]</index></name>&amp;<name>mask</name>)!=0</expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL
** if we run out of memory.
*/</comment>
<function><type><name>static</name> <name>VdbeCursor</name> *</type><name>allocateCursor</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>,              <comment type="block">/* The virtual machine */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,             <comment type="block">/* Index of the new VdbeCursor */</comment>
  <param><decl><type><name>Op</name> *</type><name>pOp</name></decl></param>,              <comment type="block">/* */</comment>
  <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>,              <comment type="block">/* When database the cursor belongs to, or -1 */</comment>
  <param><decl><type><name>int</name></type> <name>isBtreeCursor</name></decl></param>     <comment type="block">/* */</comment>
)</parameter_list><block>{
  <comment type="block">/* Find the memory cell that will be used to store the blob of memory
  ** required for this VdbeCursor structure. It is convenient to use a 
  ** vdbe memory cell to manage the memory allocation required for a
  ** VdbeCursor structure for the following reasons:
  **
  **   * Sometimes cursor numbers are used for a couple of different
  **     purposes in a vdbe program. The different uses might require
  **     different sized allocations. Memory cells provide growable
  **     allocations.
  **
  **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can
  **     be freed lazily via the sqlite3_release_memory() API. This
  **     minimizes the number of malloc calls made by the system.
  **
  ** Memory cells for cursors are allocated at the top of the address
  ** space. Memory cell (p-&gt;nMem) corresponds to cursor 0. Space for
  ** cursor 1 is managed by memory cell (p-&gt;nMem-1), etc.
  */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p</name>-&gt;<name>nMem</name>-<name>iCur</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCx</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <comment type="block">/* If the opcode of pOp is OP_SetNumColumns, then pOp-&gt;p2 contains
  ** the number of fields in the records contained in the table or
  ** index being opened. Use this to reserve space for the 
  ** VdbeCursor.aType[] array.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_SetNumColumns</name> || <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_OpenEphemeral</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nField</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>nByte</name> = 
      <call><name>sizeof</name><argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></call> + 
      (<name>isBtreeCursor</name>?<call><name>sqlite3BtreeCursorSize</name><argument_list>()</argument_list></call>:0) + 
      2*<name>nField</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>SQLITE_OK</name>==<call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>iCur</name></expr>]</index></name> = <name>pCx</name> = (<name>VdbeCursor</name>*)<name>pMem</name>-&gt;<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCx</name>-&gt;<name>iDb</name> = <name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCx</name>-&gt;<name>nField</name> = <name>nField</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nField</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCx</name>-&gt;<name>aType</name> = (<name>u32</name> *)&amp;<name>pMem</name>-&gt;<name><name>z</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>isBtreeCursor</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCx</name>-&gt;<name>pCursor</name> = (<name>BtCursor</name>*)
          &amp;<name>pMem</name>-&gt;<name><name>z</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>VdbeCursor</name></expr></argument>)</argument_list></call>+2*<name>nField</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>pCx</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Try to convert a value into a numeric representation if we can
** do so without loss of information.  In other words, if the string
** looks like a number, convert it into a number.  If it does not
** look like a number, leave it alone.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>applyNumericAffinity</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pRec</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>(<name>pRec</name>-&gt;<name>flags</name> &amp; (<name>MEM_Real</name>|<name>MEM_Int</name>))==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>realnum</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pRec</name>-&gt;<name>flags</name>&amp;<name>MEM_Str</name>)
         &amp;&amp; <call><name>sqlite3IsNumber</name><argument_list>(<argument><expr><name>pRec</name>-&gt;<name>z</name></expr></argument>, <argument><expr>&amp;<name>realnum</name></expr></argument>, <argument><expr><name>pRec</name>-&gt;<name>enc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>value</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>realnum</name> &amp;&amp; <call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>pRec</name>-&gt;<name>z</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pRec</name>-&gt;<name>u</name>.<name>i</name> = <name>value</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Processing is determine by the affinity parameter:
**
** SQLITE_AFF_INTEGER:
** SQLITE_AFF_REAL:
** SQLITE_AFF_NUMERIC:
**    Try to convert pRec to an integer representation or a 
**    floating-point representation if an integer representation
**    is not possible.  Note that the integer representation is
**    always preferred, even if the affinity is REAL, because
**    an integer representation is more space efficient on disk.
**
** SQLITE_AFF_TEXT:
**    Convert pRec to a text representation.
**
** SQLITE_AFF_NONE:
**    No-op.  pRec is unchanged.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>applyAffinity</name><parameter_list>(
  <param><decl><type><name>Mem</name> *</type><name>pRec</name></decl></param>,          <comment type="block">/* The value to apply affinity to */</comment>
  <param><decl><type><name>char</name></type> <name>affinity</name></decl></param>,      <comment type="block">/* The affinity to be applied */</comment>
  <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>              <comment type="block">/* Use this text encoding */</comment>
)</parameter_list><block>{
  <if>if<condition>( <expr><name>affinity</name>==<name>SQLITE_AFF_TEXT</name></expr> )</condition><then><block>{
    <comment type="block">/* Only attempt the conversion to TEXT if there is an integer or real
    ** representation (blob and NULL do not get converted) but no string
    ** representation.
    */</comment>
    <if>if<condition>( <expr>0==(<name>pRec</name>-&gt;<name>flags</name>&amp;<name>MEM_Str</name>) &amp;&amp; (<name>pRec</name>-&gt;<name>flags</name>&amp;(<name>MEM_Real</name>|<name>MEM_Int</name>))</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pRec</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Real</name>|<name>MEM_Int</name>)</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>affinity</name>!=<name>SQLITE_AFF_NONE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>affinity</name>==<name>SQLITE_AFF_INTEGER</name> || <name>affinity</name>==<name>SQLITE_AFF_REAL</name>
             || <name>affinity</name>==<name>SQLITE_AFF_NUMERIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pRec</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if>
}</block></function>

<comment type="block">/*
** Try to convert the type of a function argument or a result column
** into a numeric representation.  Use either INTEGER or REAL whichever
** is appropriate.  But only do the conversion if it is possible without
** loss of information and return the revised type of the argument.
**
** This is an EXPERIMENTAL api and is subject to change or removal.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_value_numeric_type</name><parameter_list>(<param><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name> =<init> <expr>(<name>Mem</name>*)<name>pVal</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pMem</name>-&gt;<name>type</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Exported version of applyAffinity(). This one works on sqlite3_value*, 
** not the internal Mem* type.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueApplyAffinity</name><parameter_list>(
  <param><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl></param>, 
  <param><decl><type><name>u8</name></type> <name>affinity</name></decl></param>, 
  <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr>(<name>Mem</name> *)<name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Write a nice string representation of the contents of cell pMem
** into buffer zBuf, length nBuf.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemPrettyPrint</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zCsr</name> =<init> <expr><name>zBuf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>f</name> =<init> <expr><name>pMem</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *<name>const</name></type> <name><name>encnames</name><index>[]</index></name> =<init> <expr><block>{<expr>"(X)"</expr>, <expr>"(8)"</expr>, <expr>"(16LE)"</expr>, <expr>"(16BE)"</expr>}</block></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>f</name>&amp;<name>MEM_Blob</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Dyn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>c</name> = 'z'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Static</name>|<name>MEM_Ephem</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Static</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>c</name> = 't'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Dyn</name>|<name>MEM_Ephem</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Ephem</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>c</name> = 'e'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Static</name>|<name>MEM_Dyn</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>c</name> = 's'</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr>"%d["</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;16 &amp;&amp; <name>i</name>&lt;<name>pMem</name>-&gt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr>"%02X"</expr></argument>, <argument><expr>((<name>int</name>)<name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xFF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCsr</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;16 &amp;&amp; <name>i</name>&lt;<name>pMem</name>-&gt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>char</name></type> <name>z</name> =<init> <expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>z</name>&lt;32 || <name>z</name>&gt;126</expr> )</condition><then> <expr_stmt><expr>*<name>zCsr</name>++ = '.'</expr>;</expr_stmt></then>
      <else>else <expr_stmt><expr>*<name>zCsr</name>++ = <name>z</name></expr>;</expr_stmt></else></if>
    }</block></for>

    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr><name>zCsr</name></expr></argument>, <argument><expr>"]%s"</expr></argument>, <argument><expr><name><name>encnames</name><index>[<expr><name>pMem</name>-&gt;<name>enc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCsr</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr><name>zCsr</name></expr></argument>,<argument><expr>"+%dz"</expr></argument>,<argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zCsr</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>zCsr</name> = '\0'</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Str</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr>0</expr>]</index></name> = ' '</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Dyn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr>1</expr>]</index></name> = 'z'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Static</name>|<name>MEM_Ephem</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Static</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr>1</expr>]</index></name> = 't'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Dyn</name>|<name>MEM_Ephem</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>f</name> &amp; <name>MEM_Ephem</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr>1</expr>]</index></name> = 'e'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>f</name> &amp; (<name>MEM_Static</name>|<name>MEM_Dyn</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr>1</expr>]</index></name> = 's'</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><name>k</name> = 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>, <argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name>++</expr>]</index></name> = '['</expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;15 &amp;&amp; <name>j</name>&lt;<name>pMem</name>-&gt;<name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>u8</name></type> <name>c</name> =<init> <expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>c</name>&gt;=0x20 &amp;&amp; <name>c</name>&lt;0x7f</expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name>++</expr>]</index></name> = '.'</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name>++</expr>]</index></name> = ']'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>100</expr></argument>,<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>encnames</name><index>[<expr><name>pMem</name>-&gt;<name>enc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>k</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block></then></if></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the value of a register for tracing purposes:
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memTracePrint</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name> &amp; (<name>MEM_Int</name>|<name>MEM_Str</name>))==(<name>MEM_Int</name>|<name>MEM_Str</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" si:%lld"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" i:%lld"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" r:%g"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr>200</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemPrettyPrint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>registerTrace</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>int</name></type> <name>iReg</name></decl></param>, <param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"REG[%d] = "</expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memTracePrint</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>REGISTER_TRACE</name>(R,M) if(p-&gt;trace)registerTrace(p-&gt;trace,R,M)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>REGISTER_TRACE</name>(R,M)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>

<comment type="block">/* 
** hwtime.h contains inline assembler code for implementing 
** high-performance timing routines.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hwtime.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The CHECK_FOR_INTERRUPT macro defined here looks to see if the
** sqlite3_interrupt() routine has been called.  If it has been, then
** processing of the VDBE program is interrupted.
**
** This macro added to every instruction that does a jump in order to
** implement a loop.  This test used to be on every single instruction,
** but that meant we more testing that we needed.  By only testing the
** flag on jump instructions, we get a (small) speed improvement.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CHECK_FOR_INTERRUPT</name> \
   if( db-&gt;u1.isInterrupted ) goto abort_due_to_interrupt;</cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<function><type><name>static</name> <name>int</name></type> <name>fileExists</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFile</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <comment type="block">/* If we are currently testing IO errors, then do not call OsAccess() to
  ** test for the presence of zFile. This is because any IO error that
  ** occurs here will not be reported, causing the test to fail.
  */</comment>
  <decl_stmt><decl><type><name>extern</name> <name>int</name></type> <name>sqlite3_io_error_pending</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>sqlite3_io_error_pending</name>&lt;=0</expr> )</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr>(<name>res</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name>)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** This function is only called from within an assert() expression. It
** checks that the sqlite3.nTransaction variable is correctly set to
** the number of non-transaction savepoints currently in the 
** linked list starting at sqlite3.pSavepoint.
** 
** Usage:
**
**     assert( checkSavepointCount(db) );
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkSavepointCount</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Savepoint</name> *</type><name>p</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name>=<name>db</name>-&gt;<name>pSavepoint</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>) <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>==(<name>db</name>-&gt;<name>nSavepoint</name> + <name>db</name>-&gt;<name>isTransactionSavepoint</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Execute as much of a VDBE program as we can then return.
**
** sqlite3VdbeMakeReady() must be called before this routine in order to
** close the program with a final OP_Halt and to set up the callbacks
** and the error message pointer.
**
** Whenever a row or result data is available, this routine will either
** invoke the result callback (if there is one) or return with
** SQLITE_ROW.
**
** If an attempt is made to open a locked database, then this routine
** will either invoke the busy callback (if there is one) or it will
** return SQLITE_BUSY.
**
** If an error occurs, an error message is written to memory obtained
** from sqlite3_malloc() and p-&gt;zErrMsg is made to point to that memory.
** The error code is stored in p-&gt;rc and this routine returns SQLITE_ERROR.
**
** If the callback ever returns non-zero, then the program exits
** immediately.  There will be no error message but the p-&gt;rc field is
** set to SQLITE_ABORT and this routine will return SQLITE_ERROR.
**
** A memory allocation error causes p-&gt;rc to be set to SQLITE_NOMEM and this
** routine to return SQLITE_ERROR.
**
** Other fatal errors return SQLITE_ERROR.
**
** After this routine has finished, sqlite3VdbeFinalize() should be
** used to clean up the mess that was left behind.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeExec</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>                    <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>                    <comment type="block">/* The program counter */</comment>
  <decl_stmt><decl><type><name>Op</name> *</type><name>pOp</name></decl>;</decl_stmt>                   <comment type="block">/* Current operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>encoding</name> =<init> <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* The database encoding */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pIn1</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* 1st input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pIn2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* 2nd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pIn3</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* 3rd input operand */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pOut</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* Output operand */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>opProperty</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCompare</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* Result of last OP_Compare operation */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aPermute</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* Permuation of columns for OP_Compare */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>u64</name></type> <name>start</name></decl>;</decl_stmt>                 <comment type="block">/* CPU clock count at start of opcode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>origPc</name></decl>;</decl_stmt>                <comment type="block">/* Program counter at start of opcode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>nProgressOps</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* Opcodes executed since progress callback. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name><name>aTempRec</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Space to hold a transient UnpackedRecord */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_RUN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3_step() verifies this */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>magic</name>==<name>SQLITE_MAGIC_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayEnter</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name> || <name>p</name>-&gt;<name>rc</name>==<name>SQLITE_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>explain</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pResultSet</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>busyHandler</name>.<name>nBusy</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>CHECK_FOR_INTERRUPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeIOTraceSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pc</name>==0 
   &amp;&amp; ((<name>p</name>-&gt;<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_VdbeListing</name>) || <call><name>fileExists</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"vdbe_explain"</expr></argument>)</argument_list></call>)</expr>
  )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"VDBE Program Listing:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbePrintSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>fileExists</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"vdbe_trace"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>trace</name> = <name>stdout</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for(<init><expr><name>pc</name>=<name>p</name>-&gt;<name>pc</name></expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>pc</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pc</name>&gt;=0 &amp;&amp; <name>pc</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <expr_stmt><expr><name>origPc</name> = <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> = <call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pOp</name> = &amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>pc</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Only allow tracing if SQLITE_DEBUG is defined.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>trace</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pc</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"VDBE Execution Trace:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbePrintSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>trace</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>trace</name>==0 &amp;&amp; <name>pc</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>fileExists</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"vdbe_sqltrace"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbePrintSql</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      

    <comment type="block">/* Check to see if we need to simulate an interrupt.  This only happens
    ** if we have a special test build.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <if>if<condition>( <expr><name>sqlite3_interrupt_count</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>sqlite3_interrupt_count</name>--</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>sqlite3_interrupt_count</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
    <comment type="block">/* Call the progress callback if it is configured and the required number
    ** of VDBE ops have been executed (either since this invocation of
    ** sqlite3VdbeExec() or since last time the progress callback was called).
    ** If the progress callback returns non-zero, exit the virtual machine with
    ** a return code SQLITE_ABORT.
    */</comment>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>xProgress</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>db</name>-&gt;<name>nProgressOps</name>==<name>nProgressOps</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>prc</name></decl>;</decl_stmt>
        <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
        <expr_stmt><expr><name>prc</name> =<name>db</name>-&gt;<call><name>xProgress</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pProgressArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
        <if>if<condition>( <expr><name>prc</name>!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
          <goto>goto <name>vdbe_error_halt</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>nProgressOps</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>nProgressOps</name>++</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Do common setup processing for any opcode that is marked
    ** with the "out2-prerelease" tag.  Such opcodes have a single
    ** output which is specified by the P2 parameter.  The P2 register
    ** is initialized to a NULL.
    */</comment>
    <expr_stmt><expr><name>opProperty</name> = <name><name>opcodeProperty</name><index>[<expr><name>pOp</name>-&gt;<name>opcode</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_OUT2_PRERELEASE</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseExternal</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
    }</block></then><else>else
 
    <comment type="block">/* Do common setup for opcodes marked with one of the following
    ** combinations of properties.
    **
    **           in1
    **           in1 in2
    **           in1 in2 out3
    **           in1 in3
    **
    ** Variables pIn1, pIn2, and pIn3 are made to point to appropriate
    ** registers for inputs.  Variable pOut points to the output register.
    */</comment>
    <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_IN1</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pIn1</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_IN2</name>)!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pIn2</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_OUT3</name>)!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_IN3</name>)!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pIn3</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></then><else>else <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_IN2</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pIn2</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>(<name>opProperty</name> &amp; <name>OPFLG_IN3</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pIn3</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if></else></if>

    <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name></expr> )</condition><block>{

<comment type="block">/*****************************************************************************
** What follows is a massive switch statement where each case implements a
** separate instruction in the virtual machine.  If we follow the usual
** indentation conventions, each case should be indented by 6 spaces.  But
** that is a lot of wasted space on the left margin.  So the code within
** the switch statement will break with convention and be flush-left. Another
** big comment (similar to this one) will mark the point in the code where
** we transition back to normal indentation.
**
** The formatting of each case is important.  The makefile for SQLite
** generates two C files "opcodes.h" and "opcodes.c" by scanning this
** file looking for lines that begin with "case OP_".  The opcodes.h files
** will be filled with #defines that give unique integer values to each
** opcode and the opcodes.c file is filled with an array of strings where
** each string is the symbolic name for the corresponding opcode.  If the
** case statement is followed by a comment of the form "/# same as ... #/"
** that comment is used to determine the particular value of the opcode.
**
** Other keywords in the comment that follows each case are used to
** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].
** Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See
** the mkopcodeh.awk script for additional information.
**
** Documentation about VDBE opcodes is generated by scanning this file
** for lines of that contain "Opcode:".  That line and all subsequent
** comment lines are used in the generation of the opcode.html documentation
** file.
**
** SUMMARY:
**
**     Formatting is important to scripts that scan this file.
**     Do not deviate from the formatting style currently in use.
**
*****************************************************************************/</comment>

<comment type="block">/* Opcode:  Goto * P2 * * *
**
** An unconditional jump to address P2.
** The next instruction executed will be 
** the one at index P2 from the beginning of
** the program.
*/</comment>
<case>case <expr><name>OP_Goto</name></expr>: <block>{             <comment type="block">/* jump */</comment>
  <expr_stmt><expr><name>CHECK_FOR_INTERRUPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode:  Gosub P1 P2 * * *
**
** Write the current address onto register P1
** and then jump to address P2.
*/</comment>
</case><case>case <expr><name>OP_Gosub</name></expr>: <block>{            <comment type="block">/* jump */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Dyn</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name> = <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode:  Return P1 * * * *
**
** Jump to the next instruction after the address in register P1.
*/</comment>
</case><case>case <expr><name>OP_Return</name></expr>: <block>{           <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> = (<name>int</name>)<name>pIn1</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode:  Yield P1 * * * *
**
** Swap the program counter with the value in register P1.
*/</comment>
</case><case>case <expr><name>OP_Yield</name></expr>: <block>{            <comment type="block">/* in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pcDest</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Dyn</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcDest</name> = (<name>int</name>)<name>pIn1</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name> = <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> = <name>pcDest</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>


<comment type="block">/* Opcode:  Halt P1 P2 * P4 *
**
** Exit immediately.  All open cursors, etc are closed
** automatically.
**
** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).
** For errors, it can be some other value.  If P1!=0 then P2 will determine
** whether or not to rollback the current transaction.  Do not rollback
** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,
** then back out all changes that have occurred during this execution of the
** VDBE, but do not rollback the transaction. 
**
** If P4 is not null then it is an error message string.
**
** There is an implied "Halt 0 0 0" instruction inserted at the very end of
** every program.  So a jump past the last instruction of the program
** is the same as executing Halt.
*/</comment>
</case><case>case <expr><name>OP_Halt</name></expr>: <block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>errorAction</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_BUSY</name> || <name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <name>p</name>-&gt;<name>rc</name> ? <name>SQLITE_ERROR</name> : <name>SQLITE_DONE</name></expr>;</expr_stmt>
  }</block></else></if>
  <goto>goto <name>vdbe_return</name>;</goto>
}</block>

<comment type="block">/* Opcode: Integer P1 P2 * * *
**
** The 32-bit integer value P1 is written into register P2.
*/</comment>
</case><case>case <expr><name>OP_Integer</name></expr>: <block>{         <comment type="block">/* out2-prerelease */</comment>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Int64 * P2 * P4 *
**
** P4 is a pointer to a 64-bit integer value.
** Write that value into register P2.
*/</comment>
</case><case>case <expr><name>OP_Int64</name></expr>: <block>{           <comment type="block">/* out2-prerelease */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pI64</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = *<name>pOp</name>-&gt;<name>p4</name>.<name>pI64</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Real * P2 * P4 *
**
** P4 is a pointer to a 64-bit floating point value.
** Write that value into register P2.
*/</comment>
</case><case>case <expr><name>OP_Real</name></expr>: <block>{            <comment type="block">/* same as TK_FLOAT, out2-prerelease */</comment>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Real</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<call><name>sqlite3IsNaN</name><argument_list>(<argument><expr>*<name>pOp</name>-&gt;<name>p4</name>.<name>pReal</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>r</name> = *<name>pOp</name>-&gt;<name>p4</name>.<name>pReal</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: String8 * P2 * P4 *
**
** P4 points to a nul terminated UTF-8 string. This opcode is transformed 
** into an OP_String before it is executed for the first time.
*/</comment>
</case><case>case <expr><name>OP_String8</name></expr>: <block>{         <comment type="block">/* same as TK_STRING, out2-prerelease */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_String</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p1</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if>if<condition>( <expr><name>encoding</name>!=<name>SQLITE_UTF8</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
    <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> |= <name>MEM_Static</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> &amp;= ~<name>MEM_Dyn</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_DYNAMIC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_DYNAMIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name> = <name>pOut</name>-&gt;<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p1</name> = <name>pOut</name>-&gt;<name>n</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
      <goto>goto <name>too_big</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <comment type="block">/* Fall through to the next case, OP_String */</comment>
}</block>
  
<comment type="block">/* Opcode: String P1 P2 * P4 *
**
** The string value P4 of length P1 (bytes) is stored in register P2.
*/</comment>
</case><case>case <expr><name>OP_String</name></expr>: <block>{          <comment type="block">/* out2-prerelease */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Str</name>|<name>MEM_Static</name>|<name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>z</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>n</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Null * P2 * * *
**
** Write a NULL into register P2.
*/</comment>
</case><case>case <expr><name>OP_Null</name></expr>: <block>{           <comment type="block">/* out2-prerelease */</comment>
  <break>break;</break>
}</block>


<comment type="block">/* Opcode: Blob P1 P2 * P4
**
** P4 points to a blob of data P1 bytes long.  Store this
** blob in register P2. This instruction is not coded directly
** by the compiler. Instead, the compiler layer specifies
** an OP_HexBlob opcode, with the hex string representation of
** the blob as P4. This opcode is transformed to an OP_Blob
** the first time it is executed.
*/</comment>
</case><case>case <expr><name>OP_Blob</name></expr>: <block>{                <comment type="block">/* out2-prerelease */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name> &lt;= <name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Variable P1 P2 * * *
**
** The value of variable P1 is written into register P2. A variable is
** an unknown in the original SQL string as handed to sqlite3_compile().
** Any occurrence of the '?' character in the original SQL is considered
** a variable.  Variables in the SQL string are number from left to
** right beginning with 1.  The values of variables are set using the
** sqlite3_bind() API.
*/</comment>
</case><case>case <expr><name>OP_Variable</name></expr>: <block>{           <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name> - 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pVar</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&gt;=0 &amp;&amp; <name>j</name>&lt;<name>p</name>-&gt;<name>nVar</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pVar</name> = &amp;<name>p</name>-&gt;<name><name>aVar</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aVar</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>MEM_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Move P1 P2 P3 * *
**
** Move the values in register P1..P1+P3-1 over into
** registers P2..P2+P3-1.  Registers P1..P1+P1-1 are
** left holding a NULL.  It is an error for register ranges
** P1..P1+P3-1 and P2..P2+P3-1 to overlap.
*/</comment>
</case><case>case <expr><name>OP_Move</name></expr>: <block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zMalloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name> =<init> <expr><name>pOp</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>+<name>n</name>&lt;<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>+<name>n</name>&lt;<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>+<name>n</name>&lt;=<name>p2</name> || <name>p2</name>+<name>n</name>&lt;=<name>p1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name>--</expr> )</condition><block>{
    <expr_stmt><expr><name>zMalloc</name> = <name>pOut</name>-&gt;<name>zMalloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name>-&gt;<name>zMalloc</name> = <name>zMalloc</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name>++</expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn1</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>++</expr>;</expr_stmt>
  }</block></while>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Copy P1 P2 * * *
**
** Make a copy of register P1 into register P2.
**
** This instruction makes a deep copy of the value.  A duplicate
** is made of any string or blob constant.  See also OP_SCopy.
*/</comment>
</case><case>case <expr><name>OP_Copy</name></expr>: <block>{             <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name>!=<name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Deephemeralize</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: SCopy P1 P2 * * *
**
** Make a shallow copy of register P1 into register P2.
**
** This instruction makes a shallow copy of the value.  If the value
** is a string or blob, then the copy is only a pointer to the
** original and hence if the original changes so will the copy.
** Worse, if the original is deallocated, the copy becomes invalid.
** Thus the program must guarantee that the original will not change
** during the lifetime of the copy.  Use OP_Copy to make a complete
** copy.
*/</comment>
</case><case>case <expr><name>OP_SCopy</name></expr>: <block>{            <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOut</name>!=<name>pIn1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ResultRow P1 P2 * * *
**
** The registers P1 through P1+P2-1 contain a single row of
** results. This opcode causes the sqlite3_step() call to terminate
** with an SQLITE_ROW return code and it sets up the sqlite3_stmt
** structure to provide access to the top P1 values as the result
** row.
*/</comment>
</case><case>case <expr><name>OP_ResultRow</name></expr>: <block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nResColumn</name>==<name>pOp</name>-&gt;<name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>+<name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invalidate all ephemeral cursor row caches */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>cacheCtr</name> = (<name>p</name>-&gt;<name>cacheCtr</name> + 2)|1</expr>;</expr_stmt>

  <comment type="block">/* Make sure the results of the current row are \000 terminated
  ** and have an assigned type.  The results are de-ephemeralized as
  ** as side effect.
  */</comment>
  <expr_stmt><expr><name>pMem</name> = <name>p</name>-&gt;<name>pResultSet</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pOp</name>-&gt;<name>p2</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr>&amp;<name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr>&amp;<name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name>+<name>i</name></expr></argument>, <argument><expr>&amp;<name><name>pMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>

  <comment type="block">/* Return SQLITE_ROW
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>nCallback</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name> + 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_ROW</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_return</name>;</goto>
}</block>

<comment type="block">/* Opcode: Concat P1 P2 P3 * *
**
** Add the text in register P1 onto the end of the text in
** register P2 and store the result in register P3.
** If either the P1 or P2 text are NULL then store NULL in P3.
**
**   P3 = P2 || P1
**
** It is illegal for P1 and P3 to be the same register. Sometimes,
** if P3 is the same register as P2, the implementation is able
** to avoid a memcpy().
*/</comment>
</case><case>case <expr><name>OP_Concat</name></expr>: <block>{           <comment type="block">/* same as TK_CONCAT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>!=<name>pOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> | <name>pIn2</name>-&gt;<name>flags</name>) &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Stringify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Stringify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> = <name>pIn1</name>-&gt;<name>n</name> + <name>pIn2</name>-&gt;<name>n</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nByte</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nByte</name>+2</expr></argument>, <argument><expr><name>pOut</name>==<name>pIn2</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>pOut</name>!=<name>pIn2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pOut</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pIn2</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pIn2</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pOut</name>-&gt;<name><name>z</name><index>[<expr><name>pIn2</name>-&gt;<name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>pIn1</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pIn1</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name><name>z</name><index>[<expr><name>nByte</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> |= <name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>n</name> = (<name>int</name>)<name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Add P1 P2 P3 * *
**
** Add the value in register P1 to the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Multiply P1 P2 P3 * *
**
**
** Multiply the value in register P1 by the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Subtract P1 P2 P3 * *
**
** Subtract the value in register P1 from the value in register P2
** and store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Divide P1 P2 P3 * *
**
** Divide the value in register P1 by the value in register P2
** and store the result in register P3.  If the value in register P2
** is zero, then the result is NULL.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: Remainder P1 P2 P3 * *
**
** Compute the remainder after integer division of the value in
** register P1 by the value in register P2 and store the result in P3. 
** If the value in register P2 is zero the result is NULL.
** If either operand is NULL, the result is NULL.
*/</comment>
</case><case>case <expr><name>OP_Add</name></expr>:                   <comment type="block">/* same as TK_PLUS, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_Subtract</name></expr>:              <comment type="block">/* same as TK_MINUS, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_Multiply</name></expr>:              <comment type="block">/* same as TK_STAR, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_Divide</name></expr>:                <comment type="block">/* same as TK_SLASH, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_Remainder</name></expr>: <block>{           <comment type="block">/* same as TK_REM, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags</name> = <name>pIn1</name>-&gt;<name>flags</name> | <name>pIn2</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>flags</name> &amp; <name>MEM_Null</name>)!=0</expr> )</condition><then> <goto>goto <name>arithmetic_result_is_null</name>;</goto></then></if>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>pIn2</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)==<name>MEM_Int</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>a</name>, <name>b</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> = <name>pIn1</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <name>pIn2</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name></expr> )</condition><block>{
      <case>case <expr><name>OP_Add</name></expr>:         <expr_stmt><expr><name>b</name> += <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Subtract</name></expr>:    <expr_stmt><expr><name>b</name> -= <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Multiply</name></expr>:    <expr_stmt><expr><name>b</name> *= <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Divide</name></expr>: <block>{
        <if>if<condition>( <expr><name>a</name>==0</expr> )</condition><then> <goto>goto <name>arithmetic_result_is_null</name>;</goto></then></if>
        <comment type="block">/* Dividing the largest possible negative 64-bit integer (1&lt;&lt;63) by 
        ** -1 returns an integer too large to store in a 64-bit data-type. On
        ** some architectures, the value overflows to (1&lt;&lt;63). On others,
        ** a SIGFPE is issued. The following statement normalizes this
        ** behavior so that all architectures behave as if integer 
        ** overflow occurred.
        */</comment>
        <if>if<condition>( <expr><name>a</name>==-1 &amp;&amp; <name>b</name>==<name>SMALLEST_INT64</name></expr> )</condition><then> <expr_stmt><expr><name>a</name> = 1</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>b</name> /= <name>a</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><default>default: <block>{
        <if>if<condition>( <expr><name>a</name>==0</expr> )</condition><then> <goto>goto <name>arithmetic_result_is_null</name>;</goto></then></if>
        <if>if<condition>( <expr><name>a</name>==-1</expr> )</condition><then> <expr_stmt><expr><name>a</name> = 1</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>b</name> %= <name>a</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
    </default>}</block></switch>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>a</name>, <name>b</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>a</name> = <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name></expr> )</condition><block>{
      <case>case <expr><name>OP_Add</name></expr>:         <expr_stmt><expr><name>b</name> += <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Subtract</name></expr>:    <expr_stmt><expr><name>b</name> -= <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Multiply</name></expr>:    <expr_stmt><expr><name>b</name> *= <name>a</name></expr>;</expr_stmt>       <break>break;</break>
      </case><case>case <expr><name>OP_Divide</name></expr>: <block>{
        <if>if<condition>( <expr><name>a</name>==0.0</expr> )</condition><then> <goto>goto <name>arithmetic_result_is_null</name>;</goto></then></if>
        <expr_stmt><expr><name>b</name> /= <name>a</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><default>default: <block>{
        <decl_stmt><decl><type><name>i64</name></type> <name>ia</name> =<init> <expr>(<name>i64</name>)<name>a</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>i64</name></type> <name>ib</name> =<init> <expr>(<name>i64</name>)<name>b</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>ia</name>==0</expr> )</condition><then> <goto>goto <name>arithmetic_result_is_null</name>;</goto></then></if>
        <if>if<condition>( <expr><name>ia</name>==-1</expr> )</condition><then> <expr_stmt><expr><name>ia</name> = 1</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>b</name> = (<name>double</name>)(<name>ib</name> % <name>ia</name>)</expr>;</expr_stmt>
        <break>break;</break>
      }</block>
    </default>}</block></switch>
    <if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>arithmetic_result_is_null</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>r</name> = <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>flags</name> &amp; <name>MEM_Real</name>)==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeIntegerAffinity</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <break>break;</break>

<label><name>arithmetic_result_is_null</name>:</label>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: CollSeq * * P4
**
** P4 is a pointer to a CollSeq struct. If the next call to a user function
** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will
** be returned. This is used by the built-in min(), max() and nullif()
** functions.
**
** The interface used by the implementation of the aforementioned functions
** to retrieve the collation sequence set by this opcode is not available
** publicly, only to user functions defined in func.c.
*/</comment>
</case><case>case <expr><name>OP_CollSeq</name></expr>: <block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Function P1 P2 P3 P4 P5
**
** Invoke a user function (P4 is a pointer to a Function structure that
** defines the function) with P5 arguments taken from register P2 and
** successors.  The result of the function is stored in register P3.
** Register P3 must not be one of the function inputs.
**
** P1 is a 32-bit bitmask indicating whether or not each argument to the 
** function was determined to be constant at compile time. If the first
** argument was constant then bit 0 of P1 is set. This is used to determine
** whether meta data associated with a user function argument using the
** sqlite3_set_auxdata() API may be safely retained until the next
** invocation of this opcode.
**
** See also: AggStep and AggFinal
*/</comment>
</case><case>case <expr><name>OP_Function</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> **</type><name>apVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pOp</name>-&gt;<name>p5</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>apVal</name> = <name>p</name>-&gt;<name>apArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>apVal</name> || <name>n</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>==0 || (<name>pOp</name>-&gt;<name>p2</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>+<name>n</name>&lt;=<name>p</name>-&gt;<name>nMem</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;<name>pOp</name>-&gt;<name>p2</name> || <name>pOp</name>-&gt;<name>p3</name>&gt;=<name>pOp</name>-&gt;<name>p2</name>+<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pArg</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pArg</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_FUNCDEF</name> || <name>pOp</name>-&gt;<name>p4type</name>==<name>P4_VDBEFUNC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_FUNCDEF</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>ctx</name>.<name>pFunc</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>pFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pVdbeFunc</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>ctx</name>.<name>pVdbeFunc</name> = (<name>VdbeFunc</name>*)<name>pOp</name>-&gt;<name>p4</name>.<name>pVdbeFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pFunc</name> = <name>ctx</name>.<name>pVdbeFunc</name>-&gt;<name>pFunc</name></expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>xDel</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>zMalloc</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* The output cell may already have a buffer allocated. Move
  ** the pointer to ctx.s so in case the user-function can use
  ** the already allocated buffer instead of allocating a new one.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>ctx</name>.<name>isError</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>ctx</name>.<name>pFunc</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>&gt;<name>p</name>-&gt;<name>aOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>p4type</name>==<name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>opcode</name>==<name>OP_CollSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pColl</name> = <name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>p4</name>.<name>pColl</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr>(*<name>ctx</name>.<name>pFunc</name>-&gt;<name>xFunc</name>)(&amp;<name>ctx</name>, <name>n</name>, <name>apVal</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>abort_due_to_misuse</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <comment type="block">/* Even though a malloc() has failed, the implementation of the
    ** user function may have called an sqlite3_result_XXX() function
    ** to return a value. The following call releases any resources
    ** associated with such a value.
    **
    ** Note: Maybe MemRelease() should be called if sqlite3SafetyOn()
    ** fails also (the if(...) statement above). But if people are
    ** misusing sqlite, they have bigger problems than a leaked value.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>

  <comment type="block">/* If any auxiliary data functions have been called by this user function,
  ** immediately call the destructor for any non-static values.
  */</comment>
  <if>if<condition>( <expr><name>ctx</name>.<name>pVdbeFunc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name>ctx</name>.<name>pVdbeFunc</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVdbeFunc</name> = <name>ctx</name>.<name>pVdbeFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_VDBEFUNC</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the function returned an error, throw an exception */</comment>
  <if>if<condition>( <expr><name>ctx</name>.<name>isError</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>ctx</name>.<name>isError</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Copy the result of the function into register P3 */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: BitAnd P1 P2 P3 * *
**
** Take the bit-wise AND of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: BitOr P1 P2 P3 * *
**
** Take the bit-wise OR of the values in register P1 and P2 and
** store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftLeft P1 P2 P3 * *
**
** Shift the integer value in register P2 to the left by the
** number of bits specified by the integer in regiser P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
<comment type="block">/* Opcode: ShiftRight P1 P2 P3 * *
**
** Shift the integer value in register P2 to the right by the
** number of bits specified by the integer in register P1.
** Store the result in register P3.
** If either input is NULL, the result is NULL.
*/</comment>
</case><case>case <expr><name>OP_BitAnd</name></expr>:                 <comment type="block">/* same as TK_BITAND, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_BitOr</name></expr>:                  <comment type="block">/* same as TK_BITOR, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_ShiftLeft</name></expr>:              <comment type="block">/* same as TK_LSHIFT, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_ShiftRight</name></expr>: <block>{           <comment type="block">/* same as TK_RSHIFT, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>a</name>, <name>b</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> | <name>pIn2</name>-&gt;<name>flags</name>) &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><name>a</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name></expr> )</condition><block>{
    <case>case <expr><name>OP_BitAnd</name></expr>:      <expr_stmt><expr><name>a</name> &amp;= <name>b</name></expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>OP_BitOr</name></expr>:       <expr_stmt><expr><name>a</name> |= <name>b</name></expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>OP_ShiftLeft</name></expr>:   <expr_stmt><expr><name>a</name> &lt;&lt;= <name>b</name></expr>;</expr_stmt>    <break>break;</break>
    </case><default>default:  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_ShiftRight</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><name>a</name> &gt;&gt;= <name>b</name></expr>;</expr_stmt>    <break>break;</break>
  </default>}</block></switch>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>a</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: AddImm  P1 P2 * * *
** 
** Add the constant P2 to the value in register P1.
** The result is always an integer.
**
** To force any register to be an integer, just add 0.
*/</comment>
</case><case>case <expr><name>OP_AddImm</name></expr>: <block>{            <comment type="block">/* in1 */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name> += <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: MustBeInt P1 P2 * * *
** 
** Force the value in register P1 to be an integer.  If the value
** in P1 is not an integer and cannot be converted into an integer
** without data loss, then jump immediately to P2, or if P2==0
** raise an SQLITE_MISMATCH exception.
*/</comment>
</case><case>case <expr><name>OP_MustBeInt</name></expr>: <block>{            <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_MISMATCH</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: RealAffinity P1 * * * *
**
** If register P1 holds an integer convert it to a real value.
**
** This opcode is used when extracting information from a column that
** has REAL affinity.  Such column values may still be stored as
** integers, for space efficiency, but after extraction we want them
** to have only a real value.
*/</comment>
</case><case>case <expr><name>OP_RealAffinity</name></expr>: <block>{                  <comment type="block">/* in1 */</comment>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
<comment type="block">/* Opcode: ToText P1 * * * *
**
** Force the value in register P1 to be text.
** If the value is numeric, convert it to a string using the
** equivalent of printf().  Blob values are unchanged and
** are afterwards simply interpreted as text.
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
</case><case>case <expr><name>OP_ToText</name></expr>: <block>{                  <comment type="block">/* same as TK_TO_TEXT, in1 */</comment>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then> <break>break;</break></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEM_Str</name>==(<name>MEM_Blob</name>&gt;&gt;3)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>flags</name> |= (<name>pIn1</name>-&gt;<name>flags</name>&amp;<name>MEM_Blob</name>)&gt;&gt;3</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>SQLITE_AFF_TEXT</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Str</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Int</name>|<name>MEM_Real</name>|<name>MEM_Blob</name>|<name>MEM_Zero</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ToBlob P1 * * * *
**
** Force the value in register P1 to be a BLOB.
** If the value is numeric, convert it to a string first.
** Strings are simply reinterpreted as blobs with no change
** to the underlying data.
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
</case><case>case <expr><name>OP_ToBlob</name></expr>: <block>{                  <comment type="block">/* same as TK_TO_BLOB, in1 */</comment>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then> <break>break;</break></then></if>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>SQLITE_AFF_TEXT</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Str</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pIn1</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_TypeMask</name>&amp;~<name>MEM_Blob</name>)</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ToNumeric P1 * * * *
**
** Force the value in register P1 to be numeric (either an
** integer or a floating-point number.)
** If the value is text or blob, try to convert it to an using the
** equivalent of atoi() or atof() and store 0 if no such conversion 
** is possible.
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
</case><case>case <expr><name>OP_ToNumeric</name></expr>: <block>{                  <comment type="block">/* same as TK_TO_NUMERIC, in1 */</comment>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; (<name>MEM_Null</name>|<name>MEM_Int</name>|<name>MEM_Real</name>))==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemNumerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>

<comment type="block">/* Opcode: ToInt P1 * * * *
**
** Force the value in register P1 be an integer.  If
** The value is currently a real number, drop its fractional part.
** If the value is text or blob, try to convert it to an integer using the
** equivalent of atoi() and store 0 if no such conversion is possible.
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
</case><case>case <expr><name>OP_ToInt</name></expr>: <block>{                  <comment type="block">/* same as TK_TO_INT, in1 */</comment>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CAST</name></cpp:ifndef>
<comment type="block">/* Opcode: ToReal P1 * * * *
**
** Force the value in register P1 to be a floating point number.
** If The value is currently an integer, convert it.
** If the value is text or blob, try to convert it to an integer using the
** equivalent of atoi() and store 0.0 if no such conversion is possible.
**
** A NULL value is not changed by this routine.  It remains NULL.
*/</comment>
</case><case>case <expr><name>OP_ToReal</name></expr>: <block>{                  <comment type="block">/* same as TK_TO_REAL, in1 */</comment>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRealify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_CAST */</comment>

<comment type="block">/* Opcode: Lt P1 P2 P3 P4 P5
**
** Compare the values in register P1 and P3.  If reg(P3)&lt;reg(P1) then
** jump to address P2.  
**
** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or
** reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL 
** bit is clear then fall thru if either operand is NULL.
**
** The SQLITE_AFF_MASK portion of P5 must be an affinity character -
** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made 
** to coerce both inputs according to this affinity before the
** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric
** affinity is used. Note that the affinity conversions are stored
** back into the input registers P1 and P3.  So this opcode can cause
** persistent changes to registers P1 and P3.
**
** Once any conversions have taken place, and neither value is NULL, 
** the values are compared. If both values are blobs then memcmp() is
** used to determine the results of the comparison.  If both values
** are text, then the appropriate collating function specified in
** P4 is  used to do the comparison.  If P4 is not specified then
** memcmp() is used to compare text string.  If both values are
** numeric, then a numeric comparison is used. If the two values
** are of different types, then numbers are considered less than
** strings and strings are considered less than blobs.
**
** If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,
** store a boolean result (either 0, or 1, or NULL) in register P2.
*/</comment>
<comment type="block">/* Opcode: Ne P1 P2 P3 P4 P5
**
** This works just like the Lt opcode except that the jump is taken if
** the operands in registers P1 and P3 are not equal.  See the Lt opcode for
** additional information.
*/</comment>
<comment type="block">/* Opcode: Eq P1 P2 P3 P4 P5
**
** This works just like the Lt opcode except that the jump is taken if
** the operands in registers P1 and P3 are equal.
** See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Le P1 P2 P3 P4 P5
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is less than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Gt P1 P2 P3 P4 P5
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
<comment type="block">/* Opcode: Ge P1 P2 P3 P4 P5
**
** This works just like the Lt opcode except that the jump is taken if
** the content of register P3 is greater than or equal to the content of
** register P1.  See the Lt opcode for additional information.
*/</comment>
</case><case>case <expr><name>OP_Eq</name></expr>:               <comment type="block">/* same as TK_EQ, jump, in1, in3 */</comment>
</case><case>case <expr><name>OP_Ne</name></expr>:               <comment type="block">/* same as TK_NE, jump, in1, in3 */</comment>
</case><case>case <expr><name>OP_Lt</name></expr>:               <comment type="block">/* same as TK_LT, jump, in1, in3 */</comment>
</case><case>case <expr><name>OP_Le</name></expr>:               <comment type="block">/* same as TK_LE, jump, in1, in3 */</comment>
</case><case>case <expr><name>OP_Gt</name></expr>:               <comment type="block">/* same as TK_GT, jump, in1, in3 */</comment>
</case><case>case <expr><name>OP_Ge</name></expr>: <block>{             <comment type="block">/* same as TK_GE, jump, in1, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>affinity</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>flags</name> = <name>pIn1</name>-&gt;<name>flags</name>|<name>pIn3</name>-&gt;<name>flags</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>flags</name>&amp;<name>MEM_Null</name></expr> )</condition><then><block>{
    <comment type="block">/* If either operand is NULL then the result is always NULL.
    ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.
    */</comment>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>SQLITE_STOREP2</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>SQLITE_JUMPIFNULL</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name>-1</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <break>break;</break>
  }</block></then></if>

  <expr_stmt><expr><name>affinity</name> = <name>pOp</name>-&gt;<name>p5</name> &amp; <name>SQLITE_AFF_MASK</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>affinity</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_COLLSEQ</name> || <name>pOp</name>-&gt;<name>p4</name>.<name>pColl</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>, <argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name></expr> )</condition><block>{
    <case>case <expr><name>OP_Eq</name></expr>:    <expr_stmt><expr><name>res</name> = <name>res</name>==0</expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>OP_Ne</name></expr>:    <expr_stmt><expr><name>res</name> = <name>res</name>!=0</expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>OP_Lt</name></expr>:    <expr_stmt><expr><name>res</name> = <name>res</name>&lt;0</expr>;</expr_stmt>      <break>break;</break>
    </case><case>case <expr><name>OP_Le</name></expr>:    <expr_stmt><expr><name>res</name> = <name>res</name>&lt;=0</expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>OP_Gt</name></expr>:    <expr_stmt><expr><name>res</name> = <name>res</name>&gt;0</expr>;</expr_stmt>      <break>break;</break>
    </case><default>default:       <expr_stmt><expr><name>res</name> = <name>res</name>&gt;=0</expr>;</expr_stmt>     <break>break;</break>
  </default>}</block></switch>

  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>SQLITE_STOREP2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>res</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name>-1</expr>;</expr_stmt>
  }</block></then></if></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Permutation * * * P4 *
**
** Set the permuation used by the OP_Compare operator to be the array
** of integers in P4.
**
** The permutation is only valid until the next OP_Permutation, OP_Compare,
** OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur
** immediately prior to the OP_Compare.
*/</comment>
</case><case>case <expr><name>OP_Permutation</name></expr>: <block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_INTARRAY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>ai</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aPermute</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>ai</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Compare P1 P2 P3 P4 *
**
** Compare to vectors of registers in reg(P1)..reg(P1+P3-1) (all this
** one "A") and in reg(P2)..reg(P2+P3-1) ("B").  Save the result of
** the comparison for use by the next OP_Jump instruct.
**
** P4 is a KeyInfo structure that defines collating sequences and sort
** orders for the comparison.  The permutation applies to registers
** only.  The KeyInfo elements are used sequentially.
**
** The comparison is a sort comparison, so NULLs compare equal,
** NULLs are less than numbers, numbers are less than strings,
** and strings are less than blobs.
*/</comment>
</case><case>case <expr><name>OP_Compare</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>p1</name>, <name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>KeyInfo</name> *</type><name>pKeyInfo</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyInfo</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>&gt;0 &amp;&amp; <name>p1</name>+<name>n</name>-1&lt;<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p2</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>&gt;0 &amp;&amp; <name>p2</name>+<name>n</name>-1&lt;<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> =<init> <expr><name>aPermute</name> ? <name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name> : <name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>    <comment type="block">/* Collating sequence to use on this term */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>          <comment type="block">/* True for DESCENDING sort order */</comment>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p1</name>+<name>idx</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p1</name>+<name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>p2</name>+<name>idx</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p2</name>+<name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&lt;<name>pKeyInfo</name>-&gt;<name>nField</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> = <name>pKeyInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>bRev</name> = <name>pKeyInfo</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCompare</name> = <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p1</name>+<name>idx</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p2</name>+<name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iCompare</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>bRev</name></expr> )</condition><then> <expr_stmt><expr><name>iCompare</name> = -<name>iCompare</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>aPermute</name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Jump P1 P2 P3 * *
**
** Jump to the instruction at address P1, P2, or P3 depending on whether
** in the most recent OP_Compare instruction the P1 vector was less than
** equal to, or greater than the P2 vector, respectively.
*/</comment>
</case><case>case <expr><name>OP_Jump</name></expr>: <block>{             <comment type="block">/* jump */</comment>
  <if>if<condition>( <expr><name>iCompare</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p1</name> - 1</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>iCompare</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p3</name> - 1</expr>;</expr_stmt>
  }</block></else></if></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: And P1 P2 P3 * *
**
** Take the logical AND of the values in registers P1 and P2 and
** write the result into register P3.
**
** If either P1 or P2 is 0 (false) then the result is 0 even if
** the other input is NULL.  A NULL and true or two NULLs give
** a NULL output.
*/</comment>
<comment type="block">/* Opcode: Or P1 P2 P3 * *
**
** Take the logical OR of the values in register P1 and P2 and
** store the answer in register P3.
**
** If either P1 or P2 is nonzero (true) then the result is 1 (true)
** even if the other input is NULL.  A NULL and false or two NULLs
** give a NULL output.
*/</comment>
</case><case>case <expr><name>OP_And</name></expr>:              <comment type="block">/* same as TK_AND, in1, in2, out3 */</comment>
</case><case>case <expr><name>OP_Or</name></expr>: <block>{             <comment type="block">/* same as TK_OR, in1, in2, out3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>v1</name>, <name>v2</name></decl>;</decl_stmt>    <comment type="block">/* 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */</comment>

  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>v1</name> = 2</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>v1</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call>!=0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pIn2</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>v2</name> = 2</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>v2</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call>!=0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_And</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>and_logic</name><index>[]</index></name> =<init> <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>0</expr>, <expr>2</expr>, <expr>2</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> = <name><name>and_logic</name><index>[<expr><name>v1</name>*3+<name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>or_logic</name><index>[]</index></name> =<init> <expr><block>{ <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>2</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>v1</name> = <name><name>or_logic</name><index>[<expr><name>v1</name>*3+<name>v2</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>v1</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>v1</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Not P1 P2 * * *
**
** Interpret the value in register P1 as a boolean value.  Store the
** boolean complement in register P2.  If the value in register P1 is 
** NULL, then a NULL is stored in P2.
*/</comment>
</case><case>case <expr><name>OP_Not</name></expr>: <block>{                <comment type="block">/* same as TK_NOT, in1 */</comment>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>!<call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: BitNot P1 P2 * * *
**
** Interpret the content of register P1 as an integer.  Store the
** ones-complement of the P1 value into register P2.  If P1 holds
** a NULL then store a NULL in P2.
*/</comment>
</case><case>case <expr><name>OP_BitNot</name></expr>: <block>{             <comment type="block">/* same as TK_BITNOT, in1 */</comment>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>~<call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: If P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is true.  The value is
** is considered true if it is numeric and non-zero.  If the value
** in P1 is NULL then take the jump if P3 is true.
*/</comment>
<comment type="block">/* Opcode: IfNot P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is False.  The value is
** is considered true if it has a numeric value of zero.  If the value
** in P1 is NULL then take the jump if P3 is true.
*/</comment>
</case><case>case <expr><name>OP_If</name></expr>:                 <comment type="block">/* jump, in1 */</comment>
</case><case>case <expr><name>OP_IfNot</name></expr>: <block>{            <comment type="block">/* jump, in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>c</name> = <name>pOp</name>-&gt;<name>p3</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifdef>
    <expr_stmt><expr><name>c</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>c</name> = <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call>!=0.0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_IfNot</name></expr> )</condition><then> <expr_stmt><expr><name>c</name> = !<name>c</name></expr>;</expr_stmt></then></if>
  }</block></else></if>
  <if>if<condition>( <expr><name>c</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name>-1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IsNull P1 P2 P3 * *
**
** Jump to P2 if the value in register P1 is NULL.  If P3 is greater
** than zero, then check all values reg(P1), reg(P1+1), 
** reg(P1+2), ..., reg(P1+P3-1).
*/</comment>
</case><case>case <expr><name>OP_IsNull</name></expr>: <block>{            <comment type="block">/* same as TK_ISNULL, jump, in1 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>==0 || <name>pOp</name>-&gt;<name>p1</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <do>do<block>{
    <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>pIn1</name>++</expr>;</expr_stmt>
  }</block>while<condition>( <expr>--<name>n</name> &gt; 0</expr> )</condition>;</do>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: NotNull P1 P2 * * *
**
** Jump to P2 if the value in register P1 is not NULL.  
*/</comment>
</case><case>case <expr><name>OP_NotNull</name></expr>: <block>{            <comment type="block">/* same as TK_NOTNULL, jump, in1 */</comment>
  <if>if<condition>( <expr>(<name>pIn1</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: SetNumColumns * P2 * * *
**
** This opcode sets the number of columns for the cursor opened by the
** following instruction to P2.
**
** An OP_SetNumColumns is only useful if it occurs immediately before 
** one of the following opcodes:
**
**     OpenRead
**     OpenWrite
**     OpenPseudo
**
** If the OP_Column opcode is to be executed on a cursor, then
** this opcode must be present immediately before the opcode that
** opens the cursor.
*/</comment>
</case><case>case <expr><name>OP_SetNumColumns</name></expr>: <block>{
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Column P1 P2 P3 P4 *
**
** Interpret the data that cursor P1 points to as a structure built using
** the MakeRecord instruction.  (See the MakeRecord opcode for additional
** information about the format of the data.)  Extract the P2-th column
** from this record.  If there are less that (P2+1) 
** values in the record, extract a NULL.
**
** The value extracted is stored in register P3.
**
** If the column contains fewer than P2 fields, then extract a NULL.  Or,
** if the P4 argument is a P4_MEM use the value of the P4 argument as
** the result.
*/</comment>
</case><case>case <expr><name>OP_Column</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>payloadSize</name></decl>;</decl_stmt>   <comment type="block">/* Number of bytes in the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* P1 value of the opcode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name> =<init> <expr><name>pOp</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* column number to retrieve */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name> =<init> <expr>0</expr></init></decl>;</decl_stmt><comment type="block">/* The VDBE cursor */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zRec</name></decl>;</decl_stmt>        <comment type="block">/* Pointer to complete record-data */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>   <comment type="block">/* The BTree cursor */</comment>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aType</name></decl>;</decl_stmt>        <comment type="block">/* aType[i] holds the numeric type of the i-th column */</comment>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aOffset</name></decl>;</decl_stmt>      <comment type="block">/* aOffset[i] is offset to start of data for i-th column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>        <comment type="block">/* number of fields in the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>           <comment type="block">/* The length of the serialized data for the column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zData</name></decl>;</decl_stmt>       <comment type="block">/* Part of the record being decoded */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pDest</name></decl>;</decl_stmt>        <comment type="block">/* Where to write the extracted value */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>sMem</name></decl>;</decl_stmt>          <comment type="block">/* For storing the record being decoded */</comment>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sMem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sMem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This block sets the variable payloadSize to be the total number of
  ** bytes in the record.
  **
  ** zRec is set to be the complete text of the record if it is available.
  ** The complete record text is always available for pseudo-tables
  ** If the record is stored in a cursor, the complete record text
  ** might be available in the  pC-&gt;aRow cache.  Or it might not be.
  ** If the data is unavailable,  zRec is set to NULL.
  **
  ** We also compute the number of columns in the record.  For cursors,
  ** the number of columns is stored in the VdbeCursor.nField element.
  */</comment>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pVtabCursor</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr> )</condition><then><block>{
    <comment type="block">/* The record is stored in a B-Tree */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeCursorMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
    <expr_stmt><expr><name>zRec</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCrsr</name> = <name>pC</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pC</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>payloadSize</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pC</name>-&gt;<name>cacheStatus</name>==<name>p</name>-&gt;<name>cacheCtr</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>payloadSize</name> = <name>pC</name>-&gt;<name>payloadSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zRec</name> = (<name>char</name>*)<name>pC</name>-&gt;<name>aRow</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pC</name>-&gt;<name>isIndex</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>payloadSize64</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>payloadSize64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>payloadSize</name> = (<name>int</name>)<name>payloadSize64</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3BtreeDataSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>(<name>u32</name> *)&amp;<name>payloadSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><name>nField</name> = <name>pC</name>-&gt;<name>nField</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pseudoTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The record is the sole entry of a pseudo-table */</comment>
    <expr_stmt><expr><name>payloadSize</name> = <name>pC</name>-&gt;<name>nData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zRec</name> = <name>pC</name>-&gt;<name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>payloadSize</name>==0 || <name>zRec</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nField</name> = <name>pC</name>-&gt;<name>nField</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCrsr</name> = 0</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* If payloadSize is 0, then just store a NULL */</comment>
  <if>if<condition>( <expr><name>payloadSize</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDest</name>-&gt;<name>flags</name>&amp;<name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>op_column_out</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>payloadSize</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>&lt;<name>nField</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read and parse the table header.  Store the results of the parse
  ** into the record header cache fields of the cursor.
  */</comment>
  <expr_stmt><expr><name>aType</name> = <name>pC</name>-&gt;<name>aType</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>cacheStatus</name>==<name>p</name>-&gt;<name>cacheCtr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>aOffset</name> = <name>pC</name>-&gt;<name>aOffset</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>u8</name> *</type><name>zIdx</name></decl>;</decl_stmt>        <comment type="block">/* Index into header */</comment>
    <decl_stmt><decl><type><name>u8</name> *</type><name>zEndHdr</name></decl>;</decl_stmt>     <comment type="block">/* Pointer to first byte after the header */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>      <comment type="block">/* Offset into the data */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>szHdrSz</name></decl>;</decl_stmt>     <comment type="block">/* Size of the header size field at start of record */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>avail</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of bytes of available data */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>aOffset</name> = <name>aOffset</name> = &amp;<name><name>aType</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>payloadSize</name> = <name>payloadSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>p</name>-&gt;<name>cacheCtr</name></expr>;</expr_stmt>

    <comment type="block">/* Figure out how many bytes are in the header */</comment>
    <if>if<condition>( <expr><name>zRec</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zData</name> = <name>zRec</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr><name>pC</name>-&gt;<name>isIndex</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zData</name> = (<name>char</name>*)<call><name>sqlite3BtreeKeyFetch</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zData</name> = (<name>char</name>*)<call><name>sqlite3BtreeDataFetch</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <comment type="block">/* If KeyFetch()/DataFetch() managed to get the entire payload,
      ** save the payload in the pC-&gt;aRow cache.  That will save us from
      ** having to make additional calls to fetch the content portion of
      ** the record.
      */</comment>
      <if>if<condition>( <expr><name>avail</name>&gt;=<name>payloadSize</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zRec</name> = <name>zData</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pC</name>-&gt;<name>aRow</name> = (<name>u8</name>*)<name>zData</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pC</name>-&gt;<name>aRow</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <comment type="block">/* The following assert is true in all cases accept when
    ** the database file has been corrupted externally.
    **    assert( zRec!=0 || avail&gt;=payloadSize || avail&gt;=9 ); */</comment>
    <expr_stmt><expr><name>szHdrSz</name> = <call><name>getVarint32</name><argument_list>(<argument><expr>(<name>u8</name>*)<name>zData</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The KeyFetch() or DataFetch() above are fast and will get the entire
    ** record header in most cases.  But they will fail to get the complete
    ** record header if the record header does not fit on a single page
    ** in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to
    ** acquire the complete header text.
    */</comment>
    <if>if<condition>( <expr>!<name>zRec</name> &amp;&amp; <name>avail</name>&lt;<name>offset</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>sMem</name>.<name>flags</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>sMem</name>.<name>db</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>isIndex</name></expr></argument>, <argument><expr>&amp;<name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>op_column_out</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>zData</name> = <name>sMem</name>.<name>z</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zEndHdr</name> = (<name>u8</name> *)&amp;<name><name>zData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIdx</name> = (<name>u8</name> *)&amp;<name><name>zData</name><index>[<expr><name>szHdrSz</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Scan the header and use it to fill in the aType[] and aOffset[]
    ** arrays.  aType[i] will contain the type integer for the i-th
    ** column and aOffset[i] will contain the offset from the beginning
    ** of the record to the start of the data for the i-th column
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nField</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>zIdx</name>&lt;<name>zEndHdr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>aOffset</name><index>[<expr><name>i</name></expr>]</index></name> = <name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zIdx</name> += <call><name>getVarint32</name><argument_list>(<argument><expr><name>zIdx</name></expr></argument>, <argument><expr><name><name>aType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> += <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name><name>aType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* If i is less that nField, then there are less fields in this
        ** record than SetNumColumns indicated there are columns in the
        ** table. Set the offset for any extra columns not present in
        ** the record to 0. This tells code below to store a NULL
        ** instead of deserializing a value from the record.
        */</comment>
        <expr_stmt><expr><name><name>aOffset</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sMem</name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>

    <comment type="block">/* If we have read more header data than was contained in the header,
    ** or if the end of the last field appears to be past the end of the
    ** record, or if the end of the last field appears to be before the end
    ** of the record (when all fields present), then we must be dealing 
    ** with a corrupt database.
    */</comment>
    <if>if<condition>( <expr><name>zIdx</name>&gt;<name>zEndHdr</name> || <name>offset</name>&gt;<name>payloadSize</name> 
     || (<name>zIdx</name>==<name>zEndHdr</name> &amp;&amp; <name>offset</name>!=<name>payloadSize</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>op_column_out</name>;</goto>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* Get the column information. If aOffset[p2] is non-zero, then 
  ** deserialize the value from the record. If aOffset[p2] is zero,
  ** then there are not enough fields in the record to satisfy the
  ** request.  In this case, set the value NULL or to P4 if P4 is
  ** a pointer to a Mem object.
  */</comment>
  <if>if<condition>( <expr><name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zRec</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseExternal</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr>(<name>u8</name> *)&amp;<name><name>zRec</name><index>[<expr><name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>len</name> = <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr>&amp;<name>sMem</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name><name>aOffset</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>isIndex</name></expr></argument>, <argument><expr>&amp;<name>sMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>op_column_out</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>zData</name> = <name>sMem</name>.<name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr>(<name>u8</name>*)<name>zData</name></expr></argument>, <argument><expr><name><name>aType</name><index>[<expr><name>p2</name></expr>]</index></name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_MEM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pMem</name></expr></argument>, <argument><expr><name>MEM_Static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDest</name>-&gt;<name>flags</name>&amp;<name>MEM_Null</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>

  <comment type="block">/* If we dynamically allocated space to hold the data (in the
  ** sqlite3VdbeMemFromBtree() call above) then transfer control of that
  ** dynamically allocated space over to the pDest structure.
  ** This prevents a memory copy.
  */</comment>
  <if>if<condition>( <expr><name>sMem</name>.<name>zMalloc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sMem</name>.<name>z</name>==<name>sMem</name>.<name>zMalloc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(<name>pDest</name>-&gt;<name>flags</name> &amp; <name>MEM_Dyn</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(<name>pDest</name>-&gt;<name>flags</name> &amp; (<name>MEM_Blob</name>|<name>MEM_Str</name>)) || <name>pDest</name>-&gt;<name>z</name>==<name>sMem</name>.<name>z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Ephem</name>|<name>MEM_Static</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>flags</name> |= <name>MEM_Term</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>z</name> = <name>sMem</name>.<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>zMalloc</name> = <name>sMem</name>.<name>zMalloc</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>op_column_out</name>:</label>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Affinity P1 P2 * P4 *
**
** Apply affinities to a range of P2 registers starting with P1.
**
** P4 is a string that is P2 characters long. The nth character of the
** string indicates the column affinity that should be used for the nth
** memory cell in the range.
*/</comment>
</case><case>case <expr><name>OP_Affinity</name></expr>: <block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zAffinity</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pData0</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pLast</name> =<init> <expr>&amp;<name><name>pData0</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pRec</name></decl>;</decl_stmt>

  <for>for(<init><expr><name>pRec</name>=<name>pData0</name></expr>;</init> <condition><expr><name>pRec</name>&lt;=<name>pLast</name></expr>;</condition> <incr><expr><name>pRec</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name><name>zAffinity</name><index>[<expr><name>pRec</name>-<name>pData0</name></expr>]</index></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: MakeRecord P1 P2 P3 P4 *
**
** Convert P2 registers beginning with P1 into a single entry
** suitable for use as a data record in a database table or as a key
** in an index.  The details of the format are irrelevant as long as
** the OP_Column opcode can decode the record later.
** Refer to source code comments for the details of the record
** format.
**
** P4 may be a string that is P2 characters long.  The nth character of the
** string indicates the column affinity that should be used for the nth
** field of the index key.
**
** The mapping from character to affinity is given by the SQLITE_AFF_
** macros defined in sqliteInt.h.
**
** If P4 is NULL then all index fields have the affinity NONE.
*/</comment>
</case><case>case <expr><name>OP_MakeRecord</name></expr>: <block>{
  <comment type="block">/* Assuming the record contains N fields, the record format looks
  ** like this:
  **
  ** ------------------------------------------------------------------------
  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 | 
  ** ------------------------------------------------------------------------
  **
  ** Data(0) is taken from register P1.  Data(1) comes from register P1+1
  ** and so froth.
  **
  ** Each type field is a varint representing the serial type of the 
  ** corresponding data element (see sqlite3VdbeSerialType()). The
  ** hdr-size field is also a varint which is the offset from the beginning
  ** of the record to data0.
  */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>zNewRecord</name></decl>;</decl_stmt>        <comment type="block">/* A buffer to hold the data for the new record */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pRec</name></decl>;</decl_stmt>             <comment type="block">/* The new record */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nData</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* Number of bytes of data space */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nHdr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* Number of bytes of header space */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nByte</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* Data space required for this record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nZero</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* Number of zero bytes at the end of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVarint</name></decl>;</decl_stmt>           <comment type="block">/* Number of bytes in a varint */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>       <comment type="block">/* Type field */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pData0</name></decl>;</decl_stmt>           <comment type="block">/* First field to be combined into the record */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pLast</name></decl>;</decl_stmt>            <comment type="block">/* Last field of the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>            <comment type="block">/* Number of fields in the record */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zAffinity</name></decl>;</decl_stmt>       <comment type="block">/* The affinity string for the record */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>file_format</name></decl>;</decl_stmt>       <comment type="block">/* File format to use for encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Space used in zNewRecord[] */</comment>

  <expr_stmt><expr><name>nField</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zAffinity</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>+<name>nField</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData0</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nField</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> = &amp;<name><name>pData0</name><index>[<expr><name>nField</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>file_format</name> = <name>p</name>-&gt;<name>minWriteFileFormat</name></expr>;</expr_stmt>

  <comment type="block">/* Loop through the elements that will make up the record to figure
  ** out how much space is required for the new record.
  */</comment>
  <for>for(<init><expr><name>pRec</name>=<name>pData0</name></expr>;</init> <condition><expr><name>pRec</name>&lt;=<name>pLast</name></expr>;</condition> <incr><expr><name>pRec</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>zAffinity</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>applyAffinity</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name><name>zAffinity</name><index>[<expr><name>pRec</name>-<name>pData0</name></expr>]</index></name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pRec</name>-&gt;<name>flags</name>&amp;<name>MEM_Zero</name> &amp;&amp; <name>pRec</name>-&gt;<name>n</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>serial_type</name> = <call><name>sqlite3VdbeSerialType</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>file_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nHdr</name> += <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pRec</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <comment type="block">/* Only pure zero-filled BLOBs can be input to this Opcode.
      ** We do not allow blobs with a prefix and a zero-filled tail. */</comment>
      <expr_stmt><expr><name>nZero</name> += <name>pRec</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>len</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nZero</name> = 0</expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>

  <comment type="block">/* Add the initial header varint and total the size */</comment>
  <expr_stmt><expr><name>nHdr</name> += <name>nVarint</name> = <call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nVarint</name>&lt;<call><name>sqlite3VarintLen</name><argument_list>(<argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nHdr</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>nByte</name> = <name>nHdr</name>+<name>nData</name>-<name>nZero</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nByte</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Make sure the output register has a buffer large enough to store 
  ** the new record. The output register (pOp-&gt;p3) is not allowed to
  ** be one of the input registers (because the following call to
  ** sqlite3VdbeMemGrow() could clobber the value before it is used).
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;<name>pOp</name>-&gt;<name>p1</name> || <name>pOp</name>-&gt;<name>p3</name>&gt;=<name>pOp</name>-&gt;<name>p1</name>+<name>pOp</name>-&gt;<name>p2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nByte</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>zNewRecord</name> = (<name>u8</name> *)<name>pOut</name>-&gt;<name>z</name></expr>;</expr_stmt>

  <comment type="block">/* Write the record */</comment>
  <expr_stmt><expr><name>i</name> = <call><name>putVarint32</name><argument_list>(<argument><expr><name>zNewRecord</name></expr></argument>, <argument><expr><name>nHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>pRec</name>=<name>pData0</name></expr>;</init> <condition><expr><name>pRec</name>&lt;=<name>pLast</name></expr>;</condition> <incr><expr><name>pRec</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>serial_type</name> = <call><name>sqlite3VdbeSerialType</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>file_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> += <call><name>putVarint32</name><argument_list>(<argument><expr>&amp;<name><name>zNewRecord</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* serial type */</comment>
  }</block></for>
  <for>for(<init><expr><name>pRec</name>=<name>pData0</name></expr>;</init> <condition><expr><name>pRec</name>&lt;=<name>pLast</name></expr>;</condition> <incr><expr><name>pRec</name>++</expr></incr>)<block>{  <comment type="block">/* serial data */</comment>
    <expr_stmt><expr><name>i</name> += <call><name>sqlite3VdbeSerialPut</name><argument_list>(<argument><expr>&amp;<name><name>zNewRecord</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>(<name>int</name>)(<name>nByte</name>-<name>i</name>)</expr></argument>, <argument><expr><name>pRec</name></expr></argument>,<argument><expr><name>file_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>==<name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>n</name> = (<name>int</name>)<name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Blob</name> | <name>MEM_Dyn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nZero</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>nZero</name> = <name>nZero</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> |= <name>MEM_Zero</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>  <comment type="block">/* In case the blob is ever converted to text */</comment>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Statement P1 * * * *
**
** Begin an individual statement transaction which is part of a larger
** transaction.  This is needed so that the statement
** can be rolled back after an error without having to roll back the
** entire transaction.  The statement transaction will automatically
** commit when the VDBE halts.
**
** If the database connection is currently in autocommit mode (that 
** is to say, if it is in between BEGIN and COMMIT)
** and if there are no other active statements on the same database
** connection, then this operation is a no-op.  No statement transaction
** is needed since any error can use the normal ROLLBACK process to
** undo changes.
**
** If a statement transaction is started, then a statement journal file
** will be allocated and initialized.
**
** The statement is begun on the database file with index P1.  The main
** database file has an index of 0 and the file used for temporary tables
** has an index of 1.
*/</comment>
</case><case>case <expr><name>OP_Statement</name></expr>: <block>{
  <if>if<condition>( <expr><name>db</name>-&gt;<name>autoCommit</name>==0 || <name>db</name>-&gt;<name>activeVdbeCnt</name>&gt;1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBt</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>i</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<call><name>sqlite3BtreeIsInStmt</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeBeginStmt</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>openedStatement</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Savepoint P1 * * P4 *
**
** Open, release or rollback the savepoint named by parameter P4, depending
** on the value of P1. To open a new savepoint, P1==0. To release (commit) an
** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.
*/</comment>
</case><case>case <expr><name>OP_Savepoint</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Name of savepoint */</comment>

  <comment type="block">/* Assert that the p1 parameter is valid. Also that if there is no open
  ** transaction, then there cannot be any savepoints. 
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>pSavepoint</name>==0 || <name>db</name>-&gt;<name>autoCommit</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>==<name>SAVEPOINT_BEGIN</name>||<name>p1</name>==<name>SAVEPOINT_RELEASE</name>||<name>p1</name>==<name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>pSavepoint</name> || <name>db</name>-&gt;<name>isTransactionSavepoint</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>checkSavepointCount</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>p1</name>==<name>SAVEPOINT_BEGIN</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>writeVdbeCnt</name>&gt;0</expr> )</condition><then><block>{
      <comment type="block">/* A new savepoint cannot be created if there are active write 
      ** statements (i.e. open read/write incremental blob handles).
      */</comment>
      <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"cannot open savepoint - "
        "SQL statements in progress"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nName</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Savepoint</name> *</type><name>pNew</name></decl>;</decl_stmt>

      <comment type="block">/* Create a new savepoint structure. */</comment>
      <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Savepoint</name></expr></argument>)</argument_list></call>+<name>nName</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pNew</name>-&gt;<name>zName</name> = (<name>char</name> *)&amp;<name><name>pNew</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
        <comment type="block">/* If there is no open transaction, then mark this as a special
        ** "transaction savepoint". */</comment>
        <if>if<condition>( <expr><name>db</name>-&gt;<name>autoCommit</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>db</name>-&gt;<name>isTransactionSavepoint</name> = 1</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>db</name>-&gt;<name>nSavepoint</name>++</expr>;</expr_stmt>
	}</block></else></if>
    
        <comment type="block">/* Link the new savepoint into the database handle's list. */</comment>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>pNext</name> = <name>db</name>-&gt;<name>pSavepoint</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>pSavepoint</name> = <name>pNew</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>Savepoint</name> *</type><name>pSavepoint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iSavepoint</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Find the named savepoint. If there is no such savepoint, then an
    ** an error is returned to the user.  */</comment>
    <for>for(
      <init><expr><name>pSavepoint</name>=<name>db</name>-&gt;<name>pSavepoint</name></expr>;</init> 
      <condition><expr><name>pSavepoint</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pSavepoint</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</condition>
      <incr><expr><name>pSavepoint</name>=<name>pSavepoint</name>-&gt;<name>pNext</name></expr></incr>
    )<block>{
      <expr_stmt><expr><name>iSavepoint</name>++</expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr>!<name>pSavepoint</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"no such savepoint: %s"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( 
        <expr><name>db</name>-&gt;<name>writeVdbeCnt</name>&gt;0 || (<name>p1</name>==<name>SAVEPOINT_ROLLBACK</name> &amp;&amp; <name>db</name>-&gt;<name>activeVdbeCnt</name>&gt;1)</expr> 
    )</condition><then><block>{
      <comment type="block">/* It is not possible to release (commit) a savepoint if there are 
      ** active write statements. It is not possible to rollback a savepoint
      ** if there are any active statements at all.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, 
        <argument><expr>"cannot %s savepoint - SQL statements in progress"</expr></argument>,
        <argument><expr>(<name>p1</name>==<name>SAVEPOINT_ROLLBACK</name> ? "rollback": "release")</expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{

      <comment type="block">/* Determine whether or not this is a transaction savepoint. If so,
      ** and this is a RELEASE command, then the current transaction 
      ** is committed. 
      */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>isTransaction</name> =<init> <expr><name>pSavepoint</name>-&gt;<name>pNext</name>==0 &amp;&amp; <name>db</name>-&gt;<name>isTransactionSavepoint</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>isTransaction</name> &amp;&amp; <name>p1</name>==<name>SAVEPOINT_RELEASE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 1</expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>==<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
          <goto>goto <name>vdbe_return</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>db</name>-&gt;<name>isTransactionSavepoint</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>p</name>-&gt;<name>rc</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>iSavepoint</name> = <name>db</name>-&gt;<name>nSavepoint</name> - <name>iSavepoint</name> - 1</expr>;</expr_stmt>
        <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeSavepoint</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <goto>goto <name>abort_due_to_error</name>;</goto>
	  }</block></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>p1</name>==<name>SAVEPOINT_ROLLBACK</name> &amp;&amp; (<name>db</name>-&gt;<name>flags</name>&amp;<name>SQLITE_InternChanges</name>)!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
  
      <comment type="block">/* Regardless of whether this is a RELEASE or ROLLBACK, destroy all 
      ** savepoints nested inside of the savepoint being operated on. */</comment>
      <while>while<condition>( <expr><name>db</name>-&gt;<name>pSavepoint</name>!=<name>pSavepoint</name></expr> )</condition><block>{
        <decl_stmt><decl><type><name>Savepoint</name> *</type><name>pTmp</name> =<init> <expr><name>db</name>-&gt;<name>pSavepoint</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>pSavepoint</name> = <name>pTmp</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>nSavepoint</name>--</expr>;</expr_stmt>
      }</block></while>

      <comment type="block">/* If it is a RELEASE, then destroy the savepoint being operated on too */</comment>
      <if>if<condition>( <expr><name>p1</name>==<name>SAVEPOINT_RELEASE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSavepoint</name>==<name>db</name>-&gt;<name>pSavepoint</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>pSavepoint</name> = <name>pSavepoint</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<name>isTransaction</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>db</name>-&gt;<name>nSavepoint</name>--</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></else></if></else></if>
  }</block></else></if>

  <break>break;</break>
}</block>

<comment type="block">/* Opcode: AutoCommit P1 P2 * * *
**
** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll
** back any currently active btree transactions. If there are any active
** VMs (apart from this one), then the COMMIT or ROLLBACK statement fails.
**
** This instruction causes the VM to halt.
*/</comment>
</case><case>case <expr><name>OP_AutoCommit</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>desiredAutoCommit</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rollback</name> =<init> <expr><name>pOp</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>turnOnAC</name> =<init> <expr><name>desiredAutoCommit</name> &amp;&amp; !<name>db</name>-&gt;<name>autoCommit</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name>==1 || <name>desiredAutoCommit</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name>==1 || <name>rollback</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>activeVdbeCnt</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* At least this one VM is active */</comment>

  <if>if<condition>( <expr><name>turnOnAC</name> &amp;&amp; <name>rollback</name> &amp;&amp; <name>db</name>-&gt;<name>activeVdbeCnt</name>&gt;1</expr> )</condition><then><block>{
    <comment type="block">/* If this instruction implements a ROLLBACK and other VMs are
    ** still running, and a transaction is active, return an error indicating
    ** that the other VMs must complete first. 
    */</comment>
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"cannot rollback transaction - "
        "SQL statements in progress"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>turnOnAC</name> &amp;&amp; !<name>rollback</name> &amp;&amp; <name>db</name>-&gt;<name>writeVdbeCnt</name>&gt;1</expr> )</condition><then><block>{
    <comment type="block">/* If this instruction implements a COMMIT and other VMs are writing
    ** return an error indicating that the other VMs must complete first. 
    */</comment>
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"cannot commit transaction - "
        "SQL statements in progress"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>desiredAutoCommit</name>!=<name>db</name>-&gt;<name>autoCommit</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>rollback</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredAutoCommit</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = (<name>u8</name>)<name>desiredAutoCommit</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>==<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = (<name>u8</name>)(1-<name>desiredAutoCommit</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <goto>goto <name>vdbe_return</name>;</goto>
      }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_DONE</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    }</block></else></if>
    <goto>goto <name>vdbe_return</name>;</goto>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>,
        <argument><expr>(!<name>desiredAutoCommit</name>)?"cannot start a transaction within a transaction":(
        (<name>rollback</name>)?"cannot rollback - no transaction is active":
                   "cannot commit - no transaction is active")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Transaction P1 P2 * * *
**
** Begin a transaction.  The transaction ends when a Commit or Rollback
** opcode is encountered.  Depending on the ON CONFLICT setting, the
** transaction might also be rolled back if an error is encountered.
**
** P1 is the index of the database file on which the transaction is
** started.  Index 0 is the main database file and index 1 is the
** file used for temporary tables.  Indices of 2 or more are used for
** attached databases.
**
** If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is
** obtained on the database file when a write-transaction is started.  No
** other process can start another write transaction while this transaction is
** underway.  Starting a write transaction also creates a rollback journal. A
** write transaction must be started before any changes can be made to the
** database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained
** on the file.
**
** If P2 is zero, then a read-lock is obtained on the database file.
*/</comment>
</case><case>case <expr><name>OP_Transaction</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>i</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_return</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_READONLY</name></expr> <comment type="block">/* &amp;&amp; rc!=SQLITE_BUSY */</comment> )</condition><then><block>{
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ReadCookie P1 P2 P3 * *
**
** Read cookie number P3 from database P1 and write it into register P2.
** P3==0 is the schema version.  P3==1 is the database format.
** P3==2 is the recommended pager cache size, and so forth.  P1==0 is
** the main database file and P1==1 is the database file used to store
** temporary tables.
**
** If P1 is negative, then this is a request to read the size of a
** databases free-list. P3 must be set to 1 in this case. The actual
** database accessed is ((P1+1)*-1). For example, a P1 parameter of -1
** corresponds to database 0 ("main"), a P1 of -2 is database 1 ("temp").
**
** There must be a read-lock on the database (either a transaction
** must be started or there must be an open cursor) before
** executing this instruction.
*/</comment>
</case><case>case <expr><name>OP_ReadCookie</name></expr>: <block>{               <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCookie</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&lt;<name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>iDb</name> = (-1*(<name>iDb</name>+1))</expr>;</expr_stmt>
    <expr_stmt><expr><name>iCookie</name> *= -1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>iDb</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The indexing of meta values at the schema layer is off by one from
  ** the indexing in the btree layer.  The btree considers meta[0] to
  ** be the number of free pages in the database (a read-only value)
  ** and meta[1] to be the schema cookie.  The schema layer considers
  ** meta[1] to be the schema cookie.  So we have to shift the index
  ** by one in the following statement.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr>1 + <name>iCookie</name></expr></argument>, <argument><expr>(<name>u32</name> *)&amp;<name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>iMeta</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: SetCookie P1 P2 P3 * *
**
** Write the content of register P3 (interpreted as an integer)
** into cookie number P2 of database P1.
** P2==0 is the schema version.  P2==1 is the database format.
** P2==2 is the recommended pager cache size, and so forth.  P1==0 is
** the main database file and P1==1 is the database file used to store
** temporary tables.
**
** A transaction must be started before executing this opcode.
*/</comment>
</case><case>case <expr><name>OP_SetCookie</name></expr>: <block>{       <comment type="block">/* in3 */</comment>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&lt;<name>SQLITE_N_BTREE_META</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;=0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p1</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> = &amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* See note about index shifting on OP_ReadCookie */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeUpdateMeta</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr>1+<name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr>(<name>int</name>)<name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* When the schema cookie changes, record the new cookie internally */</comment>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>schema_cookie</name> = (<name>int</name>)<name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name>==1</expr> )</condition><then><block>{
    <comment type="block">/* Record changes in the file format */</comment>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>file_format</name> = (<name>u8</name>)<name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name>==1</expr> )</condition><then><block>{
    <comment type="block">/* Invalidate all prepared statements whenever the TEMP database
    ** schema is changed.  Ticket #1644 */</comment>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: VerifyCookie P1 P2 *
**
** Check the value of global database parameter number 0 (the
** schema version) and make sure it is equal to P2.  
** P1 is the database number which is 0 for the main database file
** and 1 for the file holding temporary tables and some higher number
** for auxiliary databases.
**
** The cookie changes its value whenever the database schema changes.
** This operation is used to detect when that the cookie has changed
** and that the current process needs to reread the schema.
**
** Either a transaction needs to have been started or an OP_Open needs
** to be executed (to establish a read lock) before this opcode is
** invoked.
*/</comment>
</case><case>case <expr><name>OP_VerifyCookie</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iMeta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;=0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p1</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeGetMeta</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>u32</name> *)&amp;<name>iMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iMeta</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>iMeta</name>!=<name>pOp</name>-&gt;<name>p2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"database schema has changed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the schema-cookie from the database file matches the cookie 
    ** stored with the in-memory representation of the schema, do
    ** not reload the schema from the database file.
    **
    ** If virtual-tables are in use, this is not just an optimization.
    ** Often, v-tables store their data in other SQLite tables, which
    ** are queried from within xNext() and other v-table methods using
    ** prepared queries. If such a query is out-of-date, we do not want to
    ** discard the database schema, as the user code implementing the
    ** v-table would have to be ready for the sqlite3_vtab structure itself
    ** to be invalidated whenever sqlite3_step() is called from within 
    ** a v-table method.
    */</comment>
    <if>if<condition>( <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>schema_cookie</name>!=<name>iMeta</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: OpenRead P1 P2 P3 P4 P5
**
** Open a read-only cursor for the database table whose root page is
** P2 in a database file.  The database file is determined by P3. 
** P3==0 means the main database, P3==1 means the database used for 
** temporary tables, and P3&gt;1 means used the corresponding attached
** database.  Give the new cursor an identifier of P1.  The P1
** values need not be contiguous but all P1 values should be small integers.
** It is an error for P1 to be negative.
**
** If P5!=0 then use the content of register P2 as the root page, not
** the value of P2 itself.
**
** There will be a read lock on the database whenever there is an
** open cursor.  If the database was unlocked prior to this instruction
** then a read lock is acquired as part of this instruction.  A read
** lock allows other processes to read the database but prohibits
** any other process from modifying the database.  The read lock is
** released when all cursors are closed.  If this instruction attempts
** to get a read lock but fails, the script terminates with an
** SQLITE_BUSY error code.
**
** The P4 value is a pointer to a KeyInfo structure that defines the
** content and collating sequence of indices.  P4 is NULL for cursors
** that are not pointing to indices.
**
** See also OpenWrite.
*/</comment>
<comment type="block">/* Opcode: OpenWrite P1 P2 P3 P4 P5
**
** Open a read/write cursor named P1 on the table or index whose root
** page is P2.  Or if P5!=0 use the content of register P2 to find the
** root page.
**
** The P4 value is a pointer to a KeyInfo structure that defines the
** content and collating sequence of indices.  P4 is NULL for cursors
** that are not pointing to indices.
**
** This instruction works just like OpenRead except that it opens the cursor
** in read/write mode.  For a given table, there can be one or more read-only
** cursors or a single read/write cursor but not both.
**
** See also OpenRead.
*/</comment>
</case><case>case <expr><name>OP_OpenRead</name></expr>:
</case><case>case <expr><name>OP_OpenWrite</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p2</name> =<init> <expr><name>pOp</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wrFlag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pX</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>iDb</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> = &amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pX</name> = <name>pDb</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_OpenWrite</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>wrFlag</name> = 1</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>file_format</name> &lt; <name>p</name>-&gt;<name>minWriteFileFormat</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>minWriteFileFormat</name> = <name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>file_format</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>wrFlag</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn2</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p2</name> = (<name>int</name>)<name>pIn2</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p2</name>&lt;2</expr> )</condition><then> <block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> = <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name><name>pOp</name><index>[<expr>-1</expr>]</index></name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>nullRow</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>wrFlag</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_KEYINFO</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>pKeyInfo</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCur</name>-&gt;<name>pKeyInfo</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pCur</name>-&gt;<name>pKeyInfo</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_BUSY</name></expr>: <block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = <name>pc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
      <goto>goto <name>vdbe_return</name>;</goto>
    }</block>
    </case><case>case <expr><name>SQLITE_OK</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><call><name>sqlite3BtreeFlags</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* Sanity checking.  Only the lower four bits of the flags byte should
      ** be used.  Bit 3 (mask 0x08) is unpredictable.  The lower 3 bits
      ** (mask 0x07) should be either 5 (intkey+leafdata for tables) or
      ** 2 (zerodata for indices).  If these conditions are not met it can
      ** only mean that we are dealing with a corrupt database file
      */</comment>
      <if>if<condition>( <expr>(<name>flags</name> &amp; 0xf0)!=0 || ((<name>flags</name> &amp; 0x07)!=5 &amp;&amp; (<name>flags</name> &amp; 0x07)!=2)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>isTable</name> = (<name>flags</name> &amp; <name>BTREE_INTKEY</name>)!=0 ?1:0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>isIndex</name> = (<name>flags</name> &amp; <name>BTREE_ZERODATA</name>)!=0 ?1:0</expr>;</expr_stmt>
      <comment type="block">/* If P4==0 it means we are expected to open a table.  If P4!=0 then
      ** we expect to be opening an index.  If this is not what happened,
      ** then the database is corrupt
      */</comment>
      <if>if<condition>( <expr>(<name>pCur</name>-&gt;<name>isTable</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4type</name>==<name>P4_KEYINFO</name>)
       || (<name>pCur</name>-&gt;<name>isIndex</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4type</name>!=<name>P4_KEYINFO</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_EMPTY</name></expr>: <block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name>isTable</name> = <name>pOp</name>-&gt;<name>p4type</name>!=<name>P4_KEYINFO</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>isIndex</name> = !<name>pCur</name>-&gt;<name>isTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pCursor</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block>
  </default>}</block></switch>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: OpenEphemeral P1 P2 * P4 *
**
** Open a new cursor P1 to a transient table.
** The cursor is always opened read/write even if 
** the main database is read-only.  The transient or virtual
** table is deleted automatically when the cursor is closed.
**
** P2 is the number of columns in the virtual table.
** The cursor points to a BTree table if P4==0 and to a BTree index
** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure
** that defines the format of keys in the index.
**
** This opcode was once called OpenTemp.  But that created
** confusion because the term "temp table", might refer either
** to a TEMP table at the SQL level, or to a table opened by
** this opcode.  Then this opcode was call OpenVirtual.  But
** that created confusion with the whole virtual-table idea.
*/</comment>
</case><case>case <expr><name>OP_OpenEphemeral</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>int</name></type> <name>openFlags</name> =<init> 
      <expr><name>SQLITE_OPEN_READWRITE</name> |
      <name>SQLITE_OPEN_CREATE</name> |
      <name>SQLITE_OPEN_EXCLUSIVE</name> |
      <name>SQLITE_OPEN_DELETEONCLOSE</name> |
      <name>SQLITE_OPEN_TRANSIENT_DB</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> = <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pOp</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCx</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>nullRow</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeFactory</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_DEFAULT_TEMP_CACHE_SIZE</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>,
                           <argument><expr>&amp;<name>pCx</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeBeginTrans</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* If a transient index is required, create it by calling
    ** sqlite3BtreeCreateTable() with the BTREE_ZERODATA flag before
    ** opening it. If a transient table is required, just use the
    ** automatically created table with root-page 1 (an INTKEY table).
    */</comment>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>pgno</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_KEYINFO</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>BTREE_ZERODATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name>==<name>MASTER_ROOT</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                <argument><expr>(<name>KeyInfo</name>*)<name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>, <argument><expr><name>pCx</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCx</name>-&gt;<name>pKeyInfo</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCx</name>-&gt;<name>pKeyInfo</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pCx</name>-&gt;<name>isTable</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCursor</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr><name>MASTER_ROOT</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pCx</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCx</name>-&gt;<name>isTable</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>isIndex</name> = !<name>pCx</name>-&gt;<name>isTable</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: OpenPseudo P1 P2 * * *
**
** Open a new cursor that points to a fake table that contains a single
** row of data.  Any attempt to write a second row of data causes the
** first row to be deleted.  All data is deleted when the cursor is
** closed.
**
** A pseudo-table created by this opcode is useful for holding the
** NEW or OLD tables in a trigger.  Also used to hold the a single
** row output from the sorter so that the row can be decomposed into
** individual columns using the OP_Column opcode.
**
** When OP_Insert is executed to insert a row in to the pseudo table,
** the pseudo-table cursor may or may not make it's own copy of the
** original row data. If P2 is 0, then the pseudo-table will copy the
** original row data. Otherwise, a pointer to the original memory cell
** is stored. In this case, the vdbe program must ensure that the 
** memory cell containing the row data is not overwritten until the
** pseudo table is closed (or a new row is inserted into it).
*/</comment>
</case><case>case <expr><name>OP_OpenPseudo</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCx</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> = <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name><name>pOp</name><index>[<expr>-1</expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCx</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>nullRow</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>pseudoTable</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>ephemPseudoTable</name> = (<name>u8</name>)<name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>isTable</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name>-&gt;<name>isIndex</name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Close P1 * * * *
**
** Close a cursor previously opened as P1.  If P1 is not
** currently open, this instruction is a no-op.
*/</comment>
</case><case>case <expr><name>OP_Close</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: SeekGe P1 P2 P3 P4 *
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as the key.  If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the smallest entry that 
** is greater than or equal to the key value. If there are no records 
** greater than or equal to the key and P2 is not zero, then jump to P2.
**
** See also: Found, NotFound, Distinct, SeekLt, SeekGt, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekGt P1 P2 P3 P4 *
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the smallest entry that 
** is greater than the key value. If there are no records greater than 
** the key and P2 is not zero, then jump to P2.
**
** See also: Found, NotFound, Distinct, SeekLt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLt P1 P2 P3 P4 * 
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that  it points to the largest entry that 
** is less than the key value. If there are no records less than 
** the key and P2 is not zero, then jump to P2.
**
** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLe
*/</comment>
<comment type="block">/* Opcode: SeekLe P1 P2 P3 P4 *
**
** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), 
** use the value in register P3 as a key. If cursor P1 refers 
** to an SQL index, then P3 is the first in an array of P4 registers 
** that are used as an unpacked index key. 
**
** Reposition cursor P1 so that it points to the largest entry that 
** is less than or equal to the key value. If there are no records 
** less than or equal to the key and P2 is not zero, then jump to P2.
**
** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLt
*/</comment>
</case><case>case <expr><name>OP_SeekLt</name></expr>:         <comment type="block">/* jump, in3 */</comment>
</case><case>case <expr><name>OP_SeekLe</name></expr>:         <comment type="block">/* jump, in3 */</comment>
</case><case>case <expr><name>OP_SeekGe</name></expr>:         <comment type="block">/* jump, in3 */</comment>
</case><case>case <expr><name>OP_SeekGt</name></expr>: <block>{       <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name>, <name>oc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>oc</name> = <name>pOp</name>-&gt;<name>opcode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pC</name>-&gt;<name>isTable</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>      <comment type="block">/* The rowid we are to seek to */</comment>

      <comment type="block">/* The input value in P3 might be of any type: integer, real, string,
      ** blob, or NULL.  But it needs to be an integer before we can do
      ** the seek, so covert it. */</comment>
      <expr_stmt><expr><call><name>applyNumericAffinity</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iKey</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>

      <comment type="block">/* If the P3 value could not be converted into an integer without
      ** loss of information, then special processing is required... */</comment>
      <if>if<condition>( <expr>(<name>pIn3</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr>(<name>pIn3</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name>)==0</expr> )</condition><then><block>{
          <comment type="block">/* If the P3 value cannot be converted into any kind of a number,
          ** then the seek is not possible, so jump to P2 */</comment>
          <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <comment type="block">/* If we reach this point, then the P3 value must be a floating
        ** point number. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pIn3</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

        <if>if<condition>( <expr><name>iKey</name>==<name>SMALLEST_INT64</name> &amp;&amp; (<name>pIn3</name>-&gt;<name>r</name>&lt;(<name>double</name>)<name>iKey</name> || <name>pIn3</name>-&gt;<name>r</name>&gt;0)</expr> )</condition><then><block>{
          <comment type="block">/* The P3 value is to large in magnitude to be expressed as an
          ** integer. */</comment>
          <expr_stmt><expr><name>res</name> = 1</expr>;</expr_stmt>
          <if>if<condition>( <expr><name>pIn3</name>-&gt;<name>r</name>&lt;0</expr> )</condition><then><block>{
            <if>if<condition>( <expr><name>oc</name>==<name>OP_SeekGt</name> || <name>oc</name>==<name>OP_SeekGe</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
            }</block></then></if>
          }</block></then><else>else<block>{
            <if>if<condition>( <expr><name>oc</name>==<name>OP_SeekLt</name> || <name>oc</name>==<name>OP_SeekLe</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
            }</block></then></if>
          }</block></else></if>
          <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
          }</block></then></if>
          <break>break;</break>
        }</block></then><else>else <if>if<condition>( <expr><name>oc</name>==<name>OP_SeekLt</name> || <name>oc</name>==<name>OP_SeekGe</name></expr> )</condition><then><block>{
          <comment type="block">/* Use the ceiling() function to convert real-&gt;int */</comment>
          <if>if<condition>( <expr><name>pIn3</name>-&gt;<name>r</name> &gt; (<name>double</name>)<name>iKey</name></expr> )</condition><then> <expr_stmt><expr><name>iKey</name>++</expr>;</expr_stmt></then></if>
        }</block></then><else>else<block>{
          <comment type="block">/* Use the floor() function to convert real-&gt;int */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name>==<name>OP_SeekLe</name> || <name>oc</name>==<name>OP_SeekGt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>pIn3</name>-&gt;<name>r</name> &lt; (<name>double</name>)<name>iKey</name></expr> )</condition><then> <expr_stmt><expr><name>iKey</name>--</expr>;</expr_stmt></then></if>
        }</block></else></if></else></if>
      }</block></then></if> 
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>u64</name>)<name>iKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
      <if>if<condition>( <expr><name>res</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pC</name>-&gt;<name>lastRowid</name> = <name>iKey</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nField</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>i</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nField</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name>.<name>pKeyInfo</name> = <name>pC</name>-&gt;<name>pKeyInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name>.<name>nField</name> = (<name>u16</name>)<name>nField</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>oc</name>==<name>OP_SeekGt</name> || <name>oc</name>==<name>OP_SeekLe</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>r</name>.<name>flags</name> = <name>UNPACKED_INCRKEY</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>r</name>.<name>flags</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>r</name>.<name>aMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_search_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr><name>oc</name>==<name>OP_SeekGe</name> || <name>oc</name>==<name>OP_SeekGt</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>res</name>&lt;0 || (<name>res</name>==0 &amp;&amp; <name>oc</name>==<name>OP_SeekGt</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
        <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>oc</name>==<name>OP_SeekLt</name> || <name>oc</name>==<name>OP_SeekLe</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>res</name>&gt;0 || (<name>res</name>==0 &amp;&amp; <name>oc</name>==<name>OP_SeekLt</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
        <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* res might be negative because the table is empty.  Check to
        ** see if this is the case.
        */</comment>
        <expr_stmt><expr><name>res</name> = <call><name>sqlite3BtreeEof</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>pseudoTable</name></expr> )</condition><then><block>{
    <comment type="block">/* This happens when attempting to open the sqlite3_master table
    ** for read access returns SQLITE_EMPTY. In this case always
    ** take the jump (since there are no records in the table).
    */</comment>
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Seek P1 P2 * * *
**
** P1 is an open table cursor and P2 is a rowid integer.  Arrange
** for P1 to move so that it points to the rowid given by P2.
**
** This is actually a deferred seek.  Nothing actually happens until
** the cursor is used to read a record.  That way, if no reads
** occur, no unnecessary I/O happens.
*/</comment>
</case><case>case <expr><name>OP_Seek</name></expr>: <block>{    <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>movetoTarget</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
  

<comment type="block">/* Opcode: Found P1 P2 P3 * *
**
** Register P3 holds a blob constructed by MakeRecord.  P1 is an index.
** If an entry that matches the value in register p3 exists in P1 then
** jump to P2.  If the P3 value does not match any entry in P1
** then fall thru.  The P1 cursor is left pointing at the matching entry
** if it exists.
**
** This instruction is used to implement the IN operator where the
** left-hand side is a SELECT statement.  P1 may be a true index, or it
** may be a temporary index that holds the results of the SELECT
** statement.   This instruction is also used to implement the
** DISTINCT keyword in SELECT statements.
**
** This instruction checks if index P1 contains a record for which 
** the first N serialized values exactly match the N serialized values
** in the record in register P3, where N is the total number of values in
** the P3 record (the P3 record is a prefix of the P1 record). 
**
** See also: NotFound, IsUnique, NotExists
*/</comment>
<comment type="block">/* Opcode: NotFound P1 P2 P3 * *
**
** Register P3 holds a blob constructed by MakeRecord.  P1 is
** an index.  If no entry exists in P1 that matches the blob then jump
** to P2.  If an entry does existing, fall through.  The cursor is left
** pointing to the entry that matches.
**
** See also: Found, NotExists, IsUnique
*/</comment>
</case><case>case <expr><name>OP_NotFound</name></expr>:       <comment type="block">/* jump, in3 */</comment>
</case><case>case <expr><name>OP_Found</name></expr>: <block>{        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>alreadyExists</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UnpackedRecord</name> *</type><name>pIdxKey</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn3</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxKey</name> = <call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pKeyInfo</name></expr></argument>, <argument><expr><name>pIn3</name>-&gt;<name>n</name></expr></argument>, <argument><expr><name>pIn3</name>-&gt;<name>z</name></expr></argument>,
                                      <argument><expr><name>aTempRec</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aTempRec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIdxKey</name>==0</expr> )</condition><then><block>{
      <goto>goto <name>no_mem</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Found</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pIdxKey</name>-&gt;<name>flags</name> |= <name>UNPACKED_PREFIX_MATCH</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteUnpackedRecord</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>alreadyExists</name> = (<name>res</name>==0)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Found</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>alreadyExists</name></expr> )</condition><then> <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt></then></if>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr>!<name>alreadyExists</name></expr> )</condition><then> <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt></then></if>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IsUnique P1 P2 P3 P4 *
**
** The P3 register contains an integer record number.  Call this
** record number R.  The P4 register contains an index key created
** using MakeRecord.  Call it K.
**
** P1 is an index.  So it has no data and its key consists of a
** record generated by OP_MakeRecord where the last field is the 
** rowid of the entry that the index refers to.
** 
** This instruction asks if there is an entry in P1 where the
** fields matches K but the rowid is different from R.
** If there is no such entry, then there is an immediate
** jump to P2.  If any entry does exist where the index string
** matches K but the record number is not R, then the record
** number for that entry is written into P3 and control
** falls through to the next instruction.
**
** See also: NotFound, NotExists, Found
*/</comment>
</case><case>case <expr><name>OP_IsUnique</name></expr>: <block>{        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pK</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>R</name></decl>;</decl_stmt>

  <comment type="block">/* Pop the value R off the top of the stack
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>i</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>i</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pK</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p4</name>.<name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>R</name> = <name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCx</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCx</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> = <name>pCx</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCrsr</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>                     <comment type="block">/* The record number that matches K */</comment>
    <decl_stmt><decl><type><name>UnpackedRecord</name> *</type><name>pIdxKey</name></decl>;</decl_stmt>   <comment type="block">/* Unpacked version of P4 */</comment>

    <comment type="block">/* Make sure K is a string and make zKey point to K
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pK</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxKey</name> = <call><name>sqlite3VdbeRecordUnpack</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pKeyInfo</name></expr></argument>, <argument><expr><name>pK</name>-&gt;<name>n</name></expr></argument>, <argument><expr><name>pK</name>-&gt;<name>z</name></expr></argument>,
                                      <argument><expr><name>aTempRec</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aTempRec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIdxKey</name>==0</expr> )</condition><then><block>{
      <goto>goto <name>no_mem</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pIdxKey</name>-&gt;<name>flags</name> |= <name>UNPACKED_IGNORE_ROWID</name></expr>;</expr_stmt>

    <comment type="block">/* Search for an entry in P1 where all but the last rowid match K
    ** If there is no such entry, jump immediately to P2.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCx</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCx</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeDeleteUnpackedRecord</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>res</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeDeleteUnpackedRecord</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeIdxKeyCompare</name><argument_list>(<argument><expr><name>pCx</name></expr></argument>, <argument><expr><name>pIdxKey</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>sqlite3VdbeDeleteUnpackedRecord</name><argument_list>(<argument><expr><name>pIdxKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
    <if>if<condition>( <expr><name>res</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <comment type="block">/* At this point, pCrsr is pointing to an entry in P1 where all but
    ** the final entry (the rowid) matches K.  Check to see if the
    ** final rowid column is different from R.  If it equals R then jump
    ** immediately to P2.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeIdxRowid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>v</name>==<name>R</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>

    <comment type="block">/* The final varint of the key is different from R.  Store it back
    ** into register R3.  (The record number of an entry that violates
    ** a UNIQUE constraint.)
    */</comment>
    <expr_stmt><expr><name>pIn3</name>-&gt;<name>u</name>.<name>i</name> = <name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn3</name>-&gt;<name>flags</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: NotExists P1 P2 P3 * *
**
** Use the content of register P3 as a integer key.  If a record 
** with that key does not exist in table of P1, then jump to P2. 
** If the record does exist, then fall thru.  The cursor is left 
** pointing to the record if it exists.
**
** The difference between this operation and NotFound is that this
** operation assumes the key is an integer and that P1 is a table whereas
** NotFound assumes key is a blob constructed from MakeRecord and
** P1 is an index.
**
** See also: Found, NotFound, IsUnique
*/</comment>
</case><case>case <expr><name>OP_NotExists</name></expr>: <block>{        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCrsr</name> = (<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>iKey</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn3</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iKey</name> = <call><name>intToKey</name><argument_list>(<argument><expr><name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iKey</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>lastRowid</name> = <name>pIn3</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = <name>res</name>==0 ?1:0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>rowidIsValid</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>pseudoTable</name></expr> )</condition><then><block>{
    <comment type="block">/* This happens when an attempt to open a read cursor on the 
    ** sqlite_master table returns SQLITE_EMPTY.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>rowidIsValid</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Sequence P1 P2 * * *
**
** Find the next available sequence number for cursor P1.
** Write the sequence number into register P2.
** The sequence number on the cursor is incremented after this
** instruction.  
*/</comment>
</case><case>case <expr><name>OP_Sequence</name></expr>: <block>{           <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>seqCount</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>


<comment type="block">/* Opcode: NewRowid P1 P2 P3 * *
**
** Get a new integer record number (a.k.a "rowid") used as the key to a table.
** The record number is not previously used as a key in the database
** table that cursor P1 points to.  The new record number is written
** written to register P2.
**
** If P3&gt;0 then P3 is a register that holds the largest previously
** generated record number.  No new record numbers are allowed to be less
** than this value.  When this value reaches its maximum, a SQLITE_FULL
** error is generated.  The P3 register is updated with the generated
** record number.  This P3 mechanism is used to help implement the
** AUTOINCREMENT feature.
*/</comment>
</case><case>case <expr><name>OP_NewRowid</name></expr>: <block>{           <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* The zero initialization above is all that is needed */</comment>
  }</block></then><else>else<block>{
    <comment type="block">/* The next rowid or record number (different terms for the same
    ** thing) is obtained in a two-step algorithm.
    **
    ** First we attempt to find the largest existing rowid and add one
    ** to that.  But if the largest existing rowid is already the maximum
    ** positive integer, we have to fall through to the second
    ** probabilistic algorithm
    **
    ** The second algorithm is to select a rowid at random and see if
    ** it already exists in the table.  If it does not exist, we have
    ** succeeded.  If the random rowid does exist, we select a new one
    ** and try again, up to 1000 times.
    **
    ** For a table with less than 2 billion entries, the probability
    ** of not finding a unused rowid is about 1.0e-300.  This is a 
    ** non-zero probability, but it is still vanishingly small and should
    ** never cause a problem.  You are much, much more likely to have a
    ** hardware failure than for this algorithm to fail.
    **
    ** The analysis in the previous paragraph assumes that you have a good
    ** source of random numbers.  Is a library function like lrand48()
    ** good enough?  Maybe. Maybe not. It's hard to know whether there
    ** might be subtle bugs is some implementations of lrand48() that
    ** could cause problems. To avoid uncertainty, SQLite uses its own 
    ** random number generator based on the RC4 algorithm.
    **
    ** To promote locality of reference for repetitive inserts, the
    ** first few attempts at choosing a random rowid pick values just a little
    ** larger than the previous rowid.  This has been shown experimentally
    ** to double the speed of the COPY operation.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name>, <name>rx</name>=<init><expr><name>SQLITE_OK</name></expr>, <expr><name>cnt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>cnt</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr>(<call><name>sqlite3BtreeFlags</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call>&amp;(<name>BTREE_INTKEY</name>|<name>BTREE_ZERODATA</name>)) !=
          <name>BTREE_INTKEY</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
      <goto>goto <name>abort_due_to_error</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<call><name>sqlite3BtreeFlags</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call> &amp; <name>BTREE_INTKEY</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<call><name>sqlite3BtreeFlags</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call> &amp; <name>BTREE_ZERODATA</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_32BIT_ROWID</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <name>MAX_ROWID</name> 0x7fffffff</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Some compilers complain about constants of the form 0x7fffffffffffffff.
    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems
    ** to provide the constant while making all compilers happy.
    */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <name>MAX_ROWID</name>  (i64)( (((u64)0x7fffffff)&lt;&lt;32) | (u64)0xffffffff )</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>useRandomRowid</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pC</name>-&gt;<name>nextRowidValid</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>v</name> = <name>pC</name>-&gt;<name>nextRowid</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <goto>goto <name>abort_due_to_error</name>;</goto>
        }</block></then></if>
        <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>v</name> = 1</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>v</name> = <call><name>keyToInt</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>v</name>==<name>MAX_ROWID</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pC</name>-&gt;<name>useRandomRowid</name> = 1</expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt>
          }</block></else></if>
        }</block></else></if>
      }</block></else></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p3</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* P3 is a valid memory cell */</comment>
        <expr_stmt><expr><name>pMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mem(P3) holds an integer */</comment>
        <if>if<condition>( <expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name>==<name>MAX_ROWID</name> || <name>pC</name>-&gt;<name>useRandomRowid</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_FULL</name></expr>;</expr_stmt>
          <goto>goto <name>abort_due_to_error</name>;</goto>
        }</block></then></if>
        <if>if<condition>( <expr><name>v</name>&lt;<name>pMem</name>-&gt;<name>u</name>.<name>i</name>+1</expr> )</condition><then><block>{
          <expr_stmt><expr><name>v</name> = <name>pMem</name>-&gt;<name>u</name>.<name>i</name> + 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>v</name></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>( <expr><name>v</name>&lt;<name>MAX_ROWID</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pC</name>-&gt;<name>nextRowidValid</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pC</name>-&gt;<name>nextRowid</name> = <name>v</name>+1</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pC</name>-&gt;<name>nextRowidValid</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>pC</name>-&gt;<name>useRandomRowid</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* SQLITE_FULL must have occurred prior to this */</comment>
      <expr_stmt><expr><name>v</name> = <name>db</name>-&gt;<name>priorNewRowid</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cnt</name> = 0</expr>;</expr_stmt>
      <do>do<block>{
        <if>if<condition>( <expr><name>cnt</name>==0 &amp;&amp; (<name>v</name>&amp;0xffffff)==<name>v</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>cnt</name>&lt;5</expr> )</condition><then> <expr_stmt><expr><name>v</name> &amp;= 0xffffff</expr>;</expr_stmt></then></if>
        }</block></else></if>
        <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
        <expr_stmt><expr><name>x</name> = <call><name>intToKey</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rx</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>u64</name>)<name>x</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt>
      }</block>while<condition>( <expr><name>cnt</name>&lt;100 &amp;&amp; <name>rx</name>==<name>SQLITE_OK</name> &amp;&amp; <name>res</name>==0</expr> )</condition>;</do>
      <expr_stmt><expr><name>db</name>-&gt;<name>priorNewRowid</name> = <name>v</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rx</name>==<name>SQLITE_OK</name> &amp;&amp; <name>res</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_FULL</name></expr>;</expr_stmt>
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>v</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Insert P1 P2 P3 P4 P5
**
** Write an entry into the table of cursor P1.  A new entry is
** created if it doesn't already exist or the data for an existing
** entry is overwritten.  The data is the value stored register
** number P2. The key is stored in register P3. The key must
** be an integer.
**
** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is
** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,
** then rowid is stored for subsequent return by the
** sqlite3_last_insert_rowid() function (otherwise it is unmodified).
**
** Parameter P4 may point to a string containing the table-name, or
** may be NULL. If it is not NULL, then the update-hook 
** (sqlite3.xUpdateCallback) is invoked following a successful insert.
**
** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
** allocated, then ownership of P2 is transferred to the pseudo-cursor
** and register P2 becomes ephemeral.  If the cursor is changed, the
** value of register P2 will then change.  Make sure this does not
** cause any problems.)
**
** This instruction only works on tables.  The equivalent instruction
** for indices is OP_IdxInsert.
*/</comment>
</case><case>case <expr><name>OP_Insert</name></expr>: <block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pData</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pKey</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>   <comment type="block">/* The integer ROWID or key for the record to be inserted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pCursor</name>!=0 || <name>pC</name>-&gt;<name>pseudoTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKey</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iKey</name> = <call><name>intToKey</name><argument_list>(<argument><expr><name>pKey</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>OPFLAG_NCHANGE</name></expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name>++</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>OPFLAG_LASTROWID</name></expr> )</condition><then> <expr_stmt><expr><name>db</name>-&gt;<name>lastRowid</name> = <name>pKey</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>nextRowidValid</name> &amp;&amp; <name>pKey</name>-&gt;<name>u</name>.<name>i</name>&gt;=<name>pC</name>-&gt;<name>nextRowid</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pC</name>-&gt;<name>nextRowidValid</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pData</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pData</name>-&gt;<name>z</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name>-&gt;<name>n</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name>-&gt;<name>flags</name> &amp; (<name>MEM_Blob</name>|<name>MEM_Str</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>pseudoTable</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>ephemPseudoTable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pC</name>-&gt;<name>iKey</name> = <name>iKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>nData</name> = <name>pData</name>-&gt;<name>n</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pData</name>-&gt;<name>z</name>==<name>pData</name>-&gt;<name>zMalloc</name> || <name>pC</name>-&gt;<name>ephemPseudoTable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pC</name>-&gt;<name>pData</name> = <name>pData</name>-&gt;<name>z</name></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>ephemPseudoTable</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pData</name>-&gt;<name>flags</name> &amp;= ~<name>MEM_Dyn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pData</name>-&gt;<name>flags</name> |= <name>MEM_Ephem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pData</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pC</name>-&gt;<name>pData</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>nData</name>+2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>pData</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pData</name></expr></argument>, <argument><expr><name>pData</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pC</name>-&gt;<name><name>pData</name><index>[<expr><name>pC</name>-&gt;<name>nData</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pC</name>-&gt;<name><name>pData</name><index>[<expr><name>pC</name>-&gt;<name>nData</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nZero</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pData</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nZero</name> = <name>pData</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nZero</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iKey</name></expr></argument>,
                            <argument><expr><name>pData</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pData</name>-&gt;<name>n</name></expr></argument>, <argument><expr><name>nZero</name></expr></argument>,
                            <argument><expr><name>pOp</name>-&gt;<name>p5</name> &amp; <name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  
  <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>db</name>-&gt;<name>xUpdateCallback</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pC</name>-&gt;<name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTbl</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr>((<name>pOp</name>-&gt;<name>p5</name> &amp; <name>OPFLAG_ISUPDATE</name>) ? <name>SQLITE_UPDATE</name> : <name>SQLITE_INSERT</name>)</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<call><name>xUpdateCallback</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pUpdateArg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>iDb</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Delete P1 P2 * P4 *
**
** Delete the record at which the P1 cursor is currently pointing.
**
** The cursor will be left pointing at either the next or the previous
** record in the table. If it is left pointing at the next record, then
** the next Next instruction will be a no-op.  Hence it is OK to delete
** a record from within an Next loop.
**
** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is
** incremented (otherwise not).
**
** P1 must not be pseudo-table.  It has to be a real table with
** multiple rows.
**
** If P4 is not NULL, then it is the name of the table that P1 is
** pointing to.  The update hook will be invoked, if it exists.
** If P4 is not NULL then the P1 cursor must have been positioned
** using OP_NotFound prior to invoking this opcode.
*/</comment>
</case><case>case <expr><name>OP_Delete</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Only valid for real tables, no pseudotables */</comment>

  <comment type="block">/* If the update-hook will be invoked, set iKey to the rowid of the
  ** row being deleted.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>xUpdateCallback</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>rowidIsValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* lastRowid set by previous OP_NotFound */</comment>
    <expr_stmt><expr><name>iKey</name> = <name>pC</name>-&gt;<name>lastRowid</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeCursorMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>nextRowidValid</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the update-hook if required. */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>db</name>-&gt;<name>xUpdateCallback</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pC</name>-&gt;<name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTbl</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<call><name>xUpdateCallback</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pUpdateArg</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTbl</name></expr></argument>, <argument><expr><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>iDb</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name> &amp; <name>OPFLAG_NCHANGE</name></expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name>++</expr>;</expr_stmt></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ResetCount P1 * *
**
** This opcode resets the VMs internal change counter to 0. If P1 is true,
** then the value of the change counter is copied to the database handle
** change counter (returned by subsequent calls to sqlite3_changes())
** before it is reset. This is used by trigger programs.
*/</comment>
</case><case>case <expr><name>OP_ResetCount</name></expr>: <block>{
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: RowData P1 P2 * * *
**
** Write into register P2 the complete row data for cursor P1.
** There is no interpretation of the data.  
** It is just copied onto the P2 register exactly as 
** it is found in the database file.
**
** If the P1 cursor must be pointing to a valid row (not a NULL row)
** of a real table, not a pseudo-table.
*/</comment>
<comment type="block">/* Opcode: RowKey P1 P2 * * *
**
** Write into register P2 the complete row key for cursor P1.
** There is no interpretation of the data.  
** The key is copied onto the P3 register exactly as 
** it is found in the database file.
**
** If the P1 cursor must be pointing to a valid row (not a NULL row)
** of a real table, not a pseudo-table.
*/</comment>
</case><case>case <expr><name>OP_RowKey</name></expr>:
</case><case>case <expr><name>OP_RowData</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Note that RowKey and RowData are really exactly the same instruction */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name> || <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_RowKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isIndex</name> || <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_RowData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>nullRow</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pseudoTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> = <name>pC</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeCursorMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>isIndex</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>n64</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pC</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>n64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>n64</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
      <goto>goto <name>too_big</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>n</name> = (<name>int</name>)<name>n64</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3BtreeDataSize</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>int</name>)<name>n</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
      <goto>goto <name>too_big</name>;</goto>
    }</block></then></if>
  }</block></else></if>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>n</name> = <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Blob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>isIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeKey</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pOut</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeData</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pOut</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>  <comment type="block">/* In case the blob is ever cast to text */</comment>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Rowid P1 P2 * * *
**
** Store in register P2 an integer which is the key of the table entry that
** P1 is currently point to.
*/</comment>
</case><case>case <expr><name>OP_Rowid</name></expr>: <block>{                 <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeCursorMoveto</name><argument_list>(<argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <goto>goto <name>abort_due_to_error</name>;</goto></then></if>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>rowidIsValid</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>v</name> = <name>pC</name>-&gt;<name>lastRowid</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pC</name>-&gt;<name>pseudoTable</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>v</name> = <call><name>keyToInt</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pC</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
    <comment type="block">/* Leave the rowid set to a NULL */</comment>
    <break>break;</break>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>pCursor</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> = <call><name>keyToInt</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>v</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: NullRow P1 * * * *
**
** Move the cursor P1 to a null row.  Any OP_Column operations
** that occur while the cursor is on the null row will always
** write a NULL.
*/</comment>
</case><case>case <expr><name>OP_NullRow</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>-&gt;<name>pCursor</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeClearCursor</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Last P1 P2 * * *
**
** The next use of the Rowid or Column or Next instruction for P1 
** will refer to the last entry in the database table or index.
** If the table or index is empty and P2&gt;0, then jump immediately to P2.
** If P2 is 0 or if the table or index is not empty, fall through
** to the following instruction.
*/</comment>
</case><case>case <expr><name>OP_Last</name></expr>: <block>{        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCrsr</name> = <name>pC</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeLast</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = (<name>u8</name>)<name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>res</name> &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>


<comment type="block">/* Opcode: Sort P1 P2 * * *
**
** This opcode does exactly the same thing as OP_Rewind except that
** it increments an undocumented global variable used for testing.
**
** Sorting is accomplished by writing records into a sorting index,
** then rewinding that index and playing it back from beginning to
** end.  We use the OP_Sort opcode instead of OP_Rewind to do the
** rewinding so that the global variable will be incremented and
** regression tests can determine whether or not the optimizer is
** correctly optimizing out sorts.
*/</comment>
</case><case>case <expr><name>OP_Sort</name></expr>: <block>{        <comment type="block">/* jump */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_sort_count</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3_search_count</name>--</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>p</name>-&gt;<name><name>aCounter</name><index>[<expr><name>SQLITE_STMTSTATUS_SORT</name>-1</expr>]</index></name>++</expr>;</expr_stmt>
  <comment type="block">/* Fall through into OP_Rewind */</comment>
}</block>
<comment type="block">/* Opcode: Rewind P1 P2 * * *
**
** The next use of the Rowid or Column or Next instruction for P1 
** will refer to the first entry in the database table or index.
** If the table or index is empty and P2&gt;0, then jump immediately to P2.
** If P2 is 0 or if the table or index is not empty, fall through
** to the following instruction.
*/</comment>
</case><case>case <expr><name>OP_Rewind</name></expr>: <block>{        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCrsr</name> = <name>pC</name>-&gt;<name>pCursor</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeFirst</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>atFirst</name> = <name>res</name>==0 ?1:0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>res</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = (<name>u8</name>)<name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Next P1 P2 * * *
**
** Advance cursor P1 so that it points to the next key/data pair in its
** table or index.  If there are no more key/value pairs then fall through
** to the following instruction.  But if the cursor advance was successful,
** jump immediately to P2.
**
** The P1 cursor must be for a real table, not a pseudo-table.
**
** See also: Prev
*/</comment>
<comment type="block">/* Opcode: Prev P1 P2 * * *
**
** Back up cursor P1 so that it points to the previous key/data pair in its
** table or index.  If there is no previous key/value pairs then fall through
** to the following instruction.  But if the cursor backup was successful,
** jump immediately to P2.
**
** The P1 cursor must be for a real table, not a pseudo-table.
*/</comment>
</case><case>case <expr><name>OP_Prev</name></expr>:          <comment type="block">/* jump */</comment>
</case><case>case <expr><name>OP_Next</name></expr>: <block>{        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>CHECK_FOR_INTERRUPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;=0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pC</name>==0</expr> )</condition><then><block>{
    <break>break;</break>  <comment type="block">/* See ticket #2273 */</comment>
  }</block></then></if>
  <expr_stmt><expr><name>pCrsr</name> = <name>pC</name>-&gt;<name>pCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCrsr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Next</name> ? <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call> :
                              <call><name>sqlite3BtreePrevious</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>nullRow</name> = (<name>u8</name>)<name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>res</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name></expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name><name>aCounter</name><index>[<expr><name>pOp</name>-&gt;<name>p5</name>-1</expr>]</index></name>++</expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_search_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <expr_stmt><expr><name>pC</name>-&gt;<name>rowidIsValid</name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IdxInsert P1 P2 P3 * *
**
** Register P2 holds a SQL index key made using the
** MakeIdxRec instructions.  This opcode writes that key
** into the index P1.  Data for the entry is nil.
**
** P3 is a flag that provides a hint to the b-tree layer that this
** insert is likely to be an append.
**
** This instruction only works for indices.  The equivalent instruction
** for tables is OP_Insert.
*/</comment>
</case><case>case <expr><name>OP_IdxInsert</name></expr>: <block>{        <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn2</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCrsr</name> = (<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>ExpandBlob</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> =<init> <expr><name>pIn2</name>-&gt;<name>n</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zKey</name> =<init> <expr><name>pIn2</name>-&gt;<name>z</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeInsert</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IdxDelete P1 P2 P3 * *
**
** The content of P3 registers starting at register P2 form
** an unpacked index key. This opcode removes that entry from the 
** index opened by cursor P1.
*/</comment>
</case><case>case <expr><name>OP_IdxDelete</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>+<name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCrsr</name> = (<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>r</name>.<name>pKeyInfo</name> = <name>pC</name>-&gt;<name>pKeyInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name>.<name>nField</name> = (<name>u16</name>)<name>pOp</name>-&gt;<name>p3</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name>.<name>flags</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name>.<name>aMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>res</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeDelete</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pC</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IdxRowid P1 P2 * * *
**
** Write into register P2 an integer which is the last entry in the record at
** the end of the index key pointed to by cursor P1.  This integer should be
** the rowid of the table entry to which this index entry points.
**
** See also: Rowid, MakeIdxRec.
*/</comment>
</case><case>case <expr><name>OP_IdxRowid</name></expr>: <block>{              <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCrsr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCrsr</name> = (<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>rowid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>isTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pC</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeIdxRowid</name><argument_list>(<argument><expr><name>pCrsr</name></expr></argument>, <argument><expr>&amp;<name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>abort_due_to_error</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>rowid</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IdxGE P1 P2 P3 P4 P5
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the ROWID.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the ROWID on the P1 index.
**
** If the P1 index entry is greater than or equal to the key value
** then jump to P2.  Otherwise fall through to the next instruction.
**
** If P5 is non-zero then the key value is increased by an epsilon 
** prior to the comparison.  This make the opcode work like IdxGT except
** that if the key from register P3 is a prefix of the key in the cursor,
** the result is false whereas it would be true with IdxGT.
*/</comment>
<comment type="block">/* Opcode: IdxLT P1 P2 P3 * P5
**
** The P4 register values beginning with P3 form an unpacked index 
** key that omits the ROWID.  Compare this key value against the index 
** that P1 is currently pointing to, ignoring the ROWID on the P1 index.
**
** If the P1 index entry is less than the key value then jump to P2.
** Otherwise fall through to the next instruction.
**
** If P5 is non-zero then the key value is increased by an epsilon prior 
** to the comparison.  This makes the opcode work like IdxLE.
*/</comment>
</case><case>case <expr><name>OP_IdxLT</name></expr>:          <comment type="block">/* jump, in3 */</comment>
</case><case>case <expr><name>OP_IdxGE</name></expr>: <block>{        <comment type="block">/* jump, in3 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>=<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pC</name> = <name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<name>pCursor</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UnpackedRecord</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pC</name>-&gt;<name>deferredMoveto</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p5</name>==0 || <name>pOp</name>-&gt;<name>p5</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_INT32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name>.<name>pKeyInfo</name> = <name>pC</name>-&gt;<name>pKeyInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name>.<name>nField</name> = (<name>u16</name>)<name>pOp</name>-&gt;<name>p4</name>.<name>i</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>r</name>.<name>flags</name> = <name>UNPACKED_INCRKEY</name> | <name>UNPACKED_IGNORE_ROWID</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>r</name>.<name>flags</name> = <name>UNPACKED_IGNORE_ROWID</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>r</name>.<name>aMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeIdxKeyCompare</name><argument_list>(<argument><expr><name>pC</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_IdxLT</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>res</name> = -<name>res</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>res</name>++</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>res</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr> ;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Destroy P1 P2 P3 * *
**
** Delete an entire database table or index whose root page in the database
** file is given by P1.
**
** The table being destroyed is in the main database file if P3==0.  If
** P3==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If AUTOVACUUM is enabled then it is possible that another root page
** might be moved into the newly deleted root page in order to keep all
** root pages contiguous at the beginning of the database.  The former
** value of the root page that moved - its value before the move occurred -
** is stored in register P2.  If no page 
** movement was required (because the table being dropped was already 
** the last one in the database) then a zero is stored in register P2.
** If AUTOVACUUM is disabled then a zero is stored in register P2.
**
** See also: Clear
*/</comment>
</case><case>case <expr><name>OP_Destroy</name></expr>: <block>{     <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iMoved</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCnt</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>pVdbe</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iCnt</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>pVdbe</name>=<name>db</name>-&gt;<name>pVdbe</name></expr>;</init> <condition><expr><name>pVdbe</name></expr>;</condition> <incr><expr><name>pVdbe</name>=<name>pVdbe</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>pVdbe</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_RUN</name> &amp;&amp; <name>pVdbe</name>-&gt;<name>inVtabMethod</name>&lt;2 &amp;&amp; <name>pVdbe</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>iCnt</name>++</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>iCnt</name> = <name>db</name>-&gt;<name>activeVdbeCnt</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>iCnt</name>&gt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_LOCKED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>errorAction</name> = <name>OE_Abort</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCnt</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>iDb</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeDropTable</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr>&amp;<name>iMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>iMoved</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>iMoved</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3RootPageMoved</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></argument>, <argument><expr><name>iMoved</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: Clear P1 P2 P3
**
** Delete all contents of the database table or index whose root page
** in the database file is given by P1.  But, unlike Destroy, do not
** remove the table or index from the database file.
**
** The table being clear is in the main database file if P2==0.  If
** P2==1 then the table to be clear is in the auxiliary database file
** that is used to store tables create using CREATE TEMPORARY TABLE.
**
** If the P3 value is non-zero, then the table refered to must be an
** intkey table (an SQL table, not an index). In this case the row change 
** count is incremented by the number of rows in the table being cleared. 
** If P3 is greater than zero, then the value stored in register P3 is
** also incremented by the number of rows in the table being cleared.
**
** See also: Destroy
*/</comment>
</case><case>case <expr><name>OP_Clear</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p2</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeClearTable</name><argument_list>(
      <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr>(<name>pOp</name>-&gt;<name>p3</name> ? &amp;<name>nChange</name> : 0)</expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p3</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name> += <name>nChange</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p3</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name>.<name>u</name>.<name>i</name> += <name>nChange</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: CreateTable P1 P2 * * *
**
** Allocate a new table in the main database file if P1==0 or in the
** auxiliary database file if P1==1 or in an attached database if
** P1&gt;1.  Write the root page number of the new table into
** register P2
**
** The difference between a table and an index is this:  A table must
** have a 4-byte integer key and can have arbitrary data.  An index
** has an arbitrary key but no data.
**
** See also: CreateIndex
*/</comment>
<comment type="block">/* Opcode: CreateIndex P1 P2 * * *
**
** Allocate a new index in the main database file if P1==0 or in the
** auxiliary database file if P1==1 or in an attached database if
** P1&gt;1.  Write the root page number of the new table into
** register P2.
**
** See documentation on OP_CreateTable for additional information.
*/</comment>
</case><case>case <expr><name>OP_CreateIndex</name></expr>:            <comment type="block">/* out2-prerelease */</comment>
</case><case>case <expr><name>OP_CreateTable</name></expr>: <block>{          <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pgno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;=0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p1</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> = &amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>pBt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_CreateTable</name></expr> )</condition><then><block>{
    <comment type="block">/* flags = BTREE_INTKEY; */</comment>
    <expr_stmt><expr><name>flags</name> = <name>BTREE_LEAFDATA</name>|<name>BTREE_INTKEY</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>flags</name> = <name>BTREE_ZERODATA</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCreateTable</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pBt</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>pgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ParseSchema P1 P2 * P4 *
**
** Read and parse all entries from the SQLITE_MASTER table of database P1
** that match the WHERE clause P4.  P2 is the "force" flag.   Always do
** the parsing if P2 is true.  If P2 is false, then this routine is a
** no-op if the schema is not currently loaded.  In other words, if P2
** is false, the SQLITE_MASTER table is only parsed if the rest of the
** schema is already loaded into the symbol table.
**
** This opcode invokes the parser to create a new virtual machine,
** then runs the new virtual machine.  It is thus a re-entrant opcode.
*/</comment>
</case><case>case <expr><name>OP_ParseSchema</name></expr>: <block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zMaster</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>InitData</name></type> <name>initData</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pOp</name>-&gt;<name>p2</name> &amp;&amp; !<call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><name>zMaster</name> = <call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>initData</name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>initData</name>.<name>iDb</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>initData</name>.<name>pzErrMsg</name> = &amp;<name>p</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
     <argument><expr>"SELECT name, rootpage, sql FROM '%q'.%s WHERE %s"</expr></argument>,
     <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>init</name>.<name>busy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>init</name>.<name>busy</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>initData</name>.<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>sqlite3InitCallback</name></expr></argument>, <argument><expr>&amp;<name>initData</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then> <expr_stmt><expr><name>rc</name> = <name>initData</name>.<name>rc</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>init</name>.<name>busy</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then></if>
  <break>break;</break>  
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ANALYZE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_PARSER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: LoadAnalysis P1 * * * *
**
** Read the sqlite_stat1 table for database P1 and load the content
** of that table into the internal index hash table.  This will cause
** the analysis to be used when preparing all subsequent queries.
*/</comment>
</case><case>case <expr><name>OP_LoadAnalysis</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3AnalysisLoad</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>  
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_ANALYZE) &amp;&amp; !defined(SQLITE_OMIT_PARSER)  */</comment>

<comment type="block">/* Opcode: DropTable P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the table named P4 in database P1.  This is called after a table
** is dropped in order to keep the internal representation of the
** schema consistent with what is on disk.
*/</comment>
</case><case>case <expr><name>OP_DropTable</name></expr>: <block>{
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: DropIndex P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the index named P4 in database P1.  This is called after an index
** is dropped in order to keep the internal representation of the
** schema consistent with what is on disk.
*/</comment>
</case><case>case <expr><name>OP_DropIndex</name></expr>: <block>{
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: DropTrigger P1 * * P4 *
**
** Remove the internal (in-memory) data structures that describe
** the trigger named P4 in database P1.  This is called after a trigger
** is dropped in order to keep the internal representation of the
** schema consistent with what is on disk.
*/</comment>
</case><case>case <expr><name>OP_DropTrigger</name></expr>: <block>{
  <expr_stmt><expr><call><name>sqlite3UnlinkAndDeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INTEGRITY_CHECK</name></cpp:ifndef>
<comment type="block">/* Opcode: IntegrityCk P1 P2 P3 * P5
**
** Do an analysis of the currently open database.  Store in
** register P1 the text of an error message describing any problems.
** If no problems are found, store a NULL in register P1.
**
** The register P3 contains the maximum number of allowed errors.
** At most reg(P3) errors will be reported.
** In other words, the analysis stops as soon as reg(P1) errors are 
** seen.  Reg(P1) is updated with the number of errors remaining.
**
** The root page numbers of all tables in the database are integer
** stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables
** total.
**
** If P5 is not zero, the check is done on the auxiliary database
** file, not the main database file.
**
** This opcode is used to implement the integrity_check pragma.
*/</comment>
</case><case>case <expr><name>OP_IntegrityCk</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nRoot</name></decl>;</decl_stmt>      <comment type="block">/* Number of tables to check.  (Number of root pages.) */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aRoot</name></decl>;</decl_stmt>     <comment type="block">/* Array of rootpage numbers for tables to be checked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>       <comment type="block">/* Number of errors reported */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>        <comment type="block">/* Text of the error report */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pnErr</name></decl>;</decl_stmt>     <comment type="block">/* Register keeping track of errors remaining */</comment>
  
  <expr_stmt><expr><name>nRoot</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nRoot</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aRoot</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>*(<name>nRoot</name>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>aRoot</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pnErr</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pnErr</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pnErr</name>-&gt;<name>flags</name> &amp; (<name>MEM_Str</name>|<name>MEM_Blob</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIn1</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>nRoot</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>aRoot</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>int</name>)<call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr>&amp;<name><name>pIn1</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>aRoot</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p5</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p5</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3BtreeIntegrityCheck</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p5</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr><name>aRoot</name></expr></argument>, <argument><expr><name>nRoot</name></expr></argument>,
                                 <argument><expr>(<name>int</name>)<name>pnErr</name>-&gt;<name>u</name>.<name>i</name></expr></argument>, <argument><expr>&amp;<name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pnErr</name>-&gt;<name>u</name>.<name>i</name> -= <name>nErr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nErr</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <goto>goto <name>no_mem</name>;</goto>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INTEGRITY_CHECK */</comment>

<comment type="block">/* Opcode: RowSetAdd P1 P2 * * *
**
** Insert the integer value held by register P2 into a boolean index
** held in register P1.
**
** An assertion fails if P2 is not an integer.
*/</comment>
</case><case>case <expr><name>OP_RowSetAdd</name></expr>: <block>{       <comment type="block">/* in2 */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pVal</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p2</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVal</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pVal</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pIdx</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetRowSet</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pIdx</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3RowSetInsert</name><argument_list>(<argument><expr><name>pIdx</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>, <argument><expr><name>pVal</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: RowSetRead P1 P2 P3 * *
**
** Extract the smallest value from boolean index P1 and put that value into
** register P3.  Or, if boolean index P1 is initially empty, leave P3
** unchanged and jump to instruction P2.
*/</comment>
</case><case>case <expr><name>OP_RowSetRead</name></expr>: <block>{       <comment type="block">/* jump, out3 */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>val</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>CHECK_FOR_INTERRUPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pIdx</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0 
   || <call><name>sqlite3RowSetNext</name><argument_list>(<argument><expr><name>pIdx</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call>==0</expr>
  )</condition><then><block>{
    <comment type="block">/* The boolean index is empty */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* A value was pulled from the index */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
<comment type="block">/* Opcode: ContextPush * * * 
**
** Save the current Vdbe context such that it can be restored by a ContextPop
** opcode. The context stores the last insert row id, the last statement change
** count, and the current statement change count.
*/</comment>
</case><case>case <expr><name>OP_ContextPush</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>p</name>-&gt;<name>contextStackTop</name>++</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Context</name> *</type><name>pContext</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* FIX ME: This should be allocated as part of the vdbe at compile-time */</comment>
  <if>if<condition>( <expr><name>i</name>&gt;=<name>p</name>-&gt;<name>contextStackDepth</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>contextStackDepth</name> = <name>i</name>+1</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>contextStack</name> = <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>contextStack</name></expr></argument>,
                                          <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call>*(<name>i</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>contextStack</name>==0</expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>pContext</name> = &amp;<name>p</name>-&gt;<name><name>contextStack</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pContext</name>-&gt;<name>lastRowid</name> = <name>db</name>-&gt;<name>lastRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pContext</name>-&gt;<name>nChange</name> = <name>p</name>-&gt;<name>nChange</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: ContextPop * * * 
**
** Restore the Vdbe context to the state it was in when contextPush was last
** executed. The context stores the last insert row id, the last statement
** change count, and the current statement change count.
*/</comment>
</case><case>case <expr><name>OP_ContextPop</name></expr>: <block>{
  <decl_stmt><decl><type><name>Context</name> *</type><name>pContext</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>contextStack</name><index>[<expr>--<name>p</name>-&gt;<name>contextStackTop</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>contextStackTop</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>lastRowid</name> = <name>pContext</name>-&gt;<name>lastRowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name> = <name>pContext</name>-&gt;<name>nChange</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_TRIGGER */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
<comment type="block">/* Opcode: MemMax P1 P2 * * *
**
** Set the value of register P1 to the maximum of its current value
** and the value in register P2.
**
** This instruction throws an error if the memory cell is not initially
** an integer.
*/</comment>
</case><case>case <expr><name>OP_MemMax</name></expr>: <block>{        <comment type="block">/* in1, in2 */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pIn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name>&lt;<name>pIn2</name>-&gt;<name>u</name>.<name>i</name></expr>)</condition><then><block>{
    <expr_stmt><expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name> = <name>pIn2</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTOINCREMENT */</comment>

<comment type="block">/* Opcode: IfPos P1 P2 * * *
**
** If the value of register P1 is 1 or greater, jump to P2.
**
** It is illegal to use this instruction on a register that does
** not contain an integer.  An assertion fault will result if you try.
*/</comment>
</case><case>case <expr><name>OP_IfPos</name></expr>: <block>{        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name>&gt;0</expr> )</condition><then><block>{
     <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IfNeg P1 P2 * * *
**
** If the value of register P1 is less than zero, jump to P2. 
**
** It is illegal to use this instruction on a register that does
** not contain an integer.  An assertion fault will result if you try.
*/</comment>
</case><case>case <expr><name>OP_IfNeg</name></expr>: <block>{        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name>&lt;0</expr> )</condition><then><block>{
     <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: IfZero P1 P2 * * *
**
** If the value of register P1 is exactly 0, jump to P2. 
**
** It is illegal to use this instruction on a register that does
** not contain an integer.  An assertion fault will result if you try.
*/</comment>
</case><case>case <expr><name>OP_IfZero</name></expr>: <block>{        <comment type="block">/* jump, in1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn1</name>-&gt;<name>flags</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIn1</name>-&gt;<name>u</name>.<name>i</name>==0</expr> )</condition><then><block>{
     <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: AggStep * P2 P3 P4 P5
**
** Execute the step function for an aggregate.  The
** function has P5 arguments.   P4 is a pointer to the FuncDef
** structure that specifies the function.  Use register
** P3 as the accumulator.
**
** The P5 arguments are taken from register P2 and its
** successors.
*/</comment>
</case><case>case <expr><name>OP_AggStep</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pOp</name>-&gt;<name>p5</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name>, *<name>pRec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> **</type><name>apVal</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRec</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>apVal</name> = <name>p</name>-&gt;<name>apArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>apVal</name> || <name>n</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pRec</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>apVal</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pRec</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr><name>pRec</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>ctx</name>.<name>pFunc</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>pMem</name> = <name>pMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>z</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>zMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>xDel</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>isError</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>ctx</name>.<name>pColl</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>ctx</name>.<name>pFunc</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>&gt;<name>p</name>-&gt;<name>aOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>p4type</name>==<name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>opcode</name>==<name>OP_CollSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pColl</name> = <name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>p4</name>.<name>pColl</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr>(<name>ctx</name>.<name>pFunc</name>-&gt;<name>xStep</name>)(&amp;<name>ctx</name>, <name>n</name>, <name>apVal</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>ctx</name>.<name>isError</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>ctx</name>.<name>isError</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>

<comment type="block">/* Opcode: AggFinal P1 P2 * P4 *
**
** Execute the finalizer function for an aggregate.  P1 is
** the memory location that is the accumulator for the aggregate.
**
** P2 is the number of arguments that the step function takes and
** P4 is a pointer to the FuncDef for this function.  The P2
** argument is not used by this opcode.  It is only there to disambiguate
** functions that can take varying numbers of arguments.  The
** P4 argument is only needed for the degenerate case where
** the step function was not previously called.
*/</comment>
</case><case>case <expr><name>OP_AggFinal</name></expr>: <block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; ~(<name>MEM_Null</name>|<name>MEM_Agg</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemFinalize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <break>break;</break>
}</block>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VACUUM</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_ATTACH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: Vacuum * * * * *
**
** Vacuum the entire database.  This opcode will cause other virtual
** machines to be created and run.  It may not be called from within
** a transaction.
*/</comment>
</case><case>case <expr><name>OP_Vacuum</name></expr>: <block>{
  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if> 
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3RunVacuum</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_AUTOVACUUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Opcode: IncrVacuum P1 P2 * * *
**
** Perform a single step of the incremental vacuum procedure on
** the P1 database. If the vacuum has finished, jump to instruction
** P2. Otherwise, fall through to the next instruction.
*/</comment>
</case><case>case <expr><name>OP_IncrVacuum</name></expr>: <block>{        <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p1</name>&gt;=0 &amp;&amp; <name>pOp</name>-&gt;<name>p1</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>pOp</name>-&gt;<name>p1</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeIncrVacuum</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DONE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Opcode: Expire P1 * * * *
**
** Cause precompiled statements to become expired. An expired statement
** fails with an error code of SQLITE_SCHEMA if it is ever executed 
** (via sqlite3_step()).
** 
** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,
** then only the currently executing statement is affected. 
*/</comment>
</case><case>case <expr><name>OP_Expire</name></expr>: <block>{
  <if>if<condition>( <expr>!<name>pOp</name>-&gt;<name>p1</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>expired</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/* Opcode: TableLock P1 P2 P3 P4 *
**
** Obtain a lock on a particular table. This instruction is only used when
** the shared-cache feature is enabled. 
**
** If P1 is  the index of the database in sqlite3.aDb[] of the database
** on which the lock is acquired.  A readlock is obtained if P3==0 or
** a write lock if P3==1.
**
** P2 contains the root-page of the table to lock.
**
** P4 contains a pointer to the name of the table being locked. This is only
** used to generate an error message if the lock cannot be obtained.
*/</comment>
</case><case>case <expr><name>OP_TableLock</name></expr>: <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>u8</name></type> <name>isWriteLock</name> =<init> <expr>(<name>u8</name>)<name>pOp</name>-&gt;<name>p3</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name>&gt;=0 &amp;&amp; <name>p1</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; (1&lt;&lt;<name>p1</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isWriteLock</name>==0 || <name>isWriteLock</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeLockTable</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>p1</name></expr>]</index></name>.<name>pBt</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>isWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_LOCKED</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"database table is locked: %s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_SHARED_CACHE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VBegin * * * P4 *
**
** P4 may be a pointer to an sqlite3_vtab structure. If so, call the 
** xBegin method for that table.
**
** Also, whether or not P4 is set, check that this is not being called from
** within a callback to a virtual table xSync() method. If it is, set the
** error code to SQLITE_LOCKED.
*/</comment>
</case><case>case <expr><name>OP_VBegin</name></expr>: <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VtabBegin</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pVtab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VCreate P1 * * P4 *
**
** P4 is the name of a virtual table in database P1. Call the xCreate method
** for that table.
*/</comment>
</case><case>case <expr><name>OP_VCreate</name></expr>: <block>{
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VtabCallCreate</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VDestroy P1 * * P4 *
**
** P4 is the name of a virtual table in database P1.  Call the xDestroy method
** of that table.
*/</comment>
</case><case>case <expr><name>OP_VDestroy</name></expr>: <block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 2</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VtabCallDestroy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 0</expr>;</expr_stmt>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VOpen P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** P1 is a cursor number.  This opcode opens a cursor to the virtual
** table and stores that cursor in P1.
*/</comment>
</case><case>case <expr><name>OP_VOpen</name></expr>: <block>{
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>pVtabCursor</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_module</name> *</type><name>pModule</name> =<init> <expr>(<name>sqlite3_module</name> *)<name>pVtab</name>-&gt;<name>pModule</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pVtab</name> &amp;&amp; <name>pModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xOpen</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr>&amp;<name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <if>if<condition>( <expr><name>SQLITE_OK</name>==<name>rc</name></expr> )</condition><then><block>{
    <comment type="block">/* Initialize sqlite3_vtab_cursor base class */</comment>
    <expr_stmt><expr><name>pVtabCursor</name>-&gt;<name>pVtab</name> = <name>pVtab</name></expr>;</expr_stmt>

    <comment type="block">/* Initialise vdbe cursor object */</comment>
    <expr_stmt><expr><name>pCur</name> = <call><name>allocateCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr>&amp;<name><name>pOp</name><index>[<expr>-1</expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCur</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pVtabCursor</name> = <name>pVtabCursor</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCur</name>-&gt;<name>pModule</name> = <name>pVtabCursor</name>-&gt;<name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pModule</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VFilter P1 P2 P3 P4 *
**
** P1 is a cursor opened using VOpen.  P2 is an address to jump to if
** the filtered result set is empty.
**
** P4 is either NULL or a string that was generated by the xBestIndex
** method of the module.  The interpretation of the P4 string is left
** to the module implementation.
**
** This opcode invokes the xFilter method on the virtual table specified
** by P1.  The integer query plan parameter to xFilter is stored in register
** P3. Register P3+1 stores the argc parameter to be passed to the
** xFilter method. Registers P3+2..P3+1+argc are the argc
** additional parameters which are passed to
** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.
**
** A jump is made to P2 if the result set after filtering would be empty.
*/</comment>
</case><case>case <expr><name>OP_VFilter</name></expr>: <block>{   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iQuery</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pQuery</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pArgc</name> =<init> <expr>&amp;<name><name>pQuery</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>pVtabCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name> =<init> <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtabCursor</name> = <name>pCur</name>-&gt;<name>pVtabCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name> = <name>pVtabCursor</name>-&gt;<name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> = <name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>

  <comment type="block">/* Grab the index number and argc parameters */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pQuery</name>-&gt;<name>flags</name>&amp;<name>MEM_Int</name>)!=0 &amp;&amp; <name>pArgc</name>-&gt;<name>flags</name>==<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nArg</name> = (<name>int</name>)<name>pArgc</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iQuery</name> = (<name>int</name>)<name>pQuery</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xFilter method */</comment>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name> **</type><name>apArg</name> =<init> <expr><name>p</name>-&gt;<name>apArg</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>pArgc</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
    <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xFilter</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>, <argument><expr><name>iQuery</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>res</name> = <name>pModule</name>-&gt;<call><name>xEof</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>

    <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block>
  <expr_stmt><expr><name>pCur</name>-&gt;<name>nullRow</name> = 0</expr>;</expr_stmt>

  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VRowid P1 P2 * * *
**
** Store into register P2  the rowid of
** the virtual-table that the P1 cursor is pointing to.
*/</comment>
</case><case>case <expr><name>OP_VRowid</name></expr>: <block>{             <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name> =<init> <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><name>pVtab</name> = <name>pCur</name>-&gt;<name>pVtabCursor</name>-&gt;<name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> = <name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pModule</name>-&gt;<name>xRowid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xRowid</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument>, <argument><expr>&amp;<name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>iRow</name></expr>;</expr_stmt>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VColumn P1 P2 P3 * *
**
** Store the value of the P2-th column of
** the row of the virtual-table that the 
** P1 cursor is pointing to into register P3.
*/</comment>
</case><case>case <expr><name>OP_VColumn</name></expr>: <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pDest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>sContext</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name> =<init> <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p3</name>&gt;0 &amp;&amp; <name>pOp</name>-&gt;<name>p3</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><name>pVtab</name> = <name>pCur</name>-&gt;<name>pVtabCursor</name>-&gt;<name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> = <name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pModule</name>-&gt;<name>xColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sContext</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The output cell may already have a buffer allocated. Move
  ** the current contents to sContext.s so in case the user-function 
  ** can use the already allocated buffer instead of allocating a 
  ** new one.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr>&amp;<name>sContext</name>.<name>s</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr>&amp;<name>sContext</name>.<name>s</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xColumn</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument>, <argument><expr>&amp;<name>sContext</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Copy the result of the function to the P3 register. We
  ** do this regardless of whether or not an error occured to ensure any
  ** dynamic allocation in sContext.s (a Mem struct) is  released.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr>&amp;<name>sContext</name>.<name>s</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemMove</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr>&amp;<name>sContext</name>.<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UPDATE_MAX_BLOBSIZE</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>abort_due_to_misuse</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemTooBig</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>too_big</name>;</goto>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VNext P1 P2 * * *
**
** Advance virtual table P1 to the next row in its result set and
** jump to instruction P2.  Or, if the virtual table has reached
** the end of its result set, then fall through to the next instruction.
*/</comment>
</case><case>case <expr><name>OP_VNext</name></expr>: <block>{   <comment type="block">/* jump */</comment>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pCur</name> =<init> <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCur</name>-&gt;<name>nullRow</name></expr> )</condition><then><block>{
    <break>break;</break>
  }</block></then></if>
  <expr_stmt><expr><name>pVtab</name> = <name>pCur</name>-&gt;<name>pVtabCursor</name>-&gt;<name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pModule</name> = <name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pModule</name>-&gt;<name>xNext</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Invoke the xNext() method of the module. There is no way for the
  ** underlying implementation to return an error if one occurs during
  ** xNext(). Instead, if an error occurs, true is returned (indicating that 
  ** data is available) and the error code returned when xColumn or
  ** some other method is next invoked on the save virtual table cursor.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xNext</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>res</name> = <name>pModule</name>-&gt;<call><name>xEof</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>

  <if>if<condition>( <expr>!<name>res</name></expr> )</condition><then><block>{
    <comment type="block">/* If there is data, jump to P2 */</comment>
    <expr_stmt><expr><name>pc</name> = <name>pOp</name>-&gt;<name>p2</name> - 1</expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VRename P1 * * P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xRename method. The value
** in register P1 is passed as the zName argument to the xRename method.
*/</comment>
</case><case>case <expr><name>OP_VRename</name></expr>: <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pName</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>pModule</name>-&gt;<name>xRename</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>REGISTER_TRACE</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Stringify</name><argument_list>(<argument><expr><name>pName</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
  <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>pVtab</name>-&gt;<name>pModule</name>-&gt;<call><name>xRename</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>pName</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>

  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Opcode: VUpdate P1 P2 P3 P4 *
**
** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
** This opcode invokes the corresponding xUpdate method. P2 values
** are contiguous memory cells starting at P3 to pass to the xUpdate 
** invocation. The value in register (P3+P2-1) corresponds to the 
** p2th element of the argv array passed to xUpdate.
**
** The xUpdate method will do a DELETE or an INSERT or both.
** The argv[0] element (which corresponds to memory cell P3)
** is the rowid of a row to delete.  If argv[0] is NULL then no 
** deletion occurs.  The argv[1] element is the rowid of the new 
** row.  This can be NULL to have the virtual table select the new 
** rowid for itself.  The subsequent elements in the array are 
** the values of columns in the new row.
**
** If P2==1 then no insert is performed.  argv[0] is the rowid of
** a row to delete.
**
** P1 is a boolean flag. If it is set to true and the xUpdate call
** is successful, then the value returned by sqlite3_last_insert_rowid() 
** is set to the value of the rowid for the row just inserted.
*/</comment>
</case><case>case <expr><name>OP_VUpdate</name></expr>: <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_module</name> *</type><name>pModule</name> =<init> <expr>(<name>sqlite3_module</name> *)<name>pVtab</name>-&gt;<name>pModule</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> =<init> <expr><name>pOp</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOp</name>-&gt;<name>p4type</name>==<name>P4_VTAB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pModule</name>-&gt;<name>xUpdate</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"read-only table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name> **</type><name>apArg</name> =<init> <expr><name>p</name>-&gt;<name>apArg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Mem</name> *</type><name>pX</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>pOp</name>-&gt;<name>p3</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>storeTypeInfo</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>apArg</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pX</name>++</expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr><call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
    <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xUpdate</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>apArg</name></expr></argument>, <argument><expr>&amp;<name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>abort_due_to_misuse</name>;</goto></then></if>
    <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name>&gt;1 &amp;&amp; <name><name>apArg</name><index>[<expr>0</expr>]</index></name> &amp;&amp; (<name><name>apArg</name><index>[<expr>0</expr>]</index></name>-&gt;<name>flags</name>&amp;<name>MEM_Null</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>lastRowid</name> = <name>rowid</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name>++</expr>;</expr_stmt>
  }</block></else></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>  <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<comment type="block">/* Opcode: Pagecount P1 P2 * * *
**
** Write the current number of pages in database P1 to memory cell P2.
*/</comment>
</case><case>case <expr><name>OP_Pagecount</name></expr>: <block>{            <comment type="block">/* out2-prerelease */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>pOp</name>-&gt;<name>p1</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>p1</name></expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOut</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name>-&gt;<name>u</name>.<name>i</name> = <name>nPage</name></expr>;</expr_stmt>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/* Opcode: Trace * * * P4 *
**
** If tracing is enabled (by the sqlite3_trace()) interface, then
** the UTF-8 string contained in P4 is emitted on the trace callback.
*/</comment>
</case><case>case <expr><name>OP_Trace</name></expr>: <block>{
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>xTrace</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<call><name>xTrace</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pTraceArg</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if>if<condition>( <expr>(<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_SqlTrace</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"SQL-trace: %s\n"</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>
  }</block></then></if>
  <break>break;</break>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Opcode: Noop * * * * *
**
** Do nothing.  This instruction is often useful as a jump
** destination.
*/</comment>
<comment type="block">/*
** The magic Explain opcode are only inserted when explain==2 (which
** is to say when the EXPLAIN QUERY PLAN syntax is used.)
** This opcode records information from the optimizer.  It is the
** the same as a no-op.  This opcodesnever appears in a real VM program.
*/</comment>
</case><default>default: <block>{          <comment type="block">/* This is really OP_Noop and OP_Explain */</comment>
  <break>break;</break>
}</block>

<comment type="block">/*****************************************************************************
** The cases of the switch statement above this line should all be indented
** by 6 spaces.  But the left-most 6 spaces have been removed to improve the
** readability.  From this point on down, the normal indentation rules are
** restored.
*****************************************************************************/</comment>
    </default>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
    <block>{
      <decl_stmt><decl><type><name>u64</name></type> <name>elapsed</name> =<init> <expr><call><name>sqlite3Hwtime</name><argument_list>()</argument_list></call> - <name>start</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>cycles</name> += <name>elapsed</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>cnt</name>++</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
        fprintf(stdout, "%10llu ", elapsed);
        sqlite3VdbePrintOp(stdout, origPc, &amp;p-&gt;aOp[origPc]);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* The following code adds nothing to the actual functionality
    ** of the program.  It is only here for testing and debugging.
    ** On the other hand, it does burn CPU cycles every time through
    ** the evaluator loop.  So we can leave it out when NDEBUG is defined.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pc</name>&gt;=-1 &amp;&amp; <name>pc</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>trace</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>trace</name></expr></argument>,<argument><expr>"rc=%d\n"</expr></argument>,<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if<condition>( <expr><name>opProperty</name> &amp; <name>OPFLG_OUT2_PRERELEASE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>trace</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>opProperty</name> &amp; <name>OPFLG_OUT3</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>registerTrace</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>trace</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_DEBUG */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>
  }</block></for>  <comment type="block">/* The end of the for(;;) loop the loops through opcodes */</comment>

  <comment type="block">/* If we reach this point, it means that execution is finished with
  ** an error of some kind.
  */</comment>
<label><name>vdbe_error_halt</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IOERR_NOMEM</name></expr> )</condition><then> <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>

  <comment type="block">/* This is the only way out of this procedure.  We have to
  ** release the mutexes on btrees that were acquired at the
  ** top. */</comment>
<label><name>vdbe_return</name>:</label>
  <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayLeave</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>

  <comment type="block">/* Jump to here if a string or blob larger than SQLITE_MAX_LENGTH
  ** is encountered.
  */</comment>
<label><name>too_big</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"string or blob too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here if a malloc() fails.
  */</comment>
<label><name>no_mem</name>:</label>
  <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here for an SQLITE_MISUSE error.
  */</comment>
<label><name>abort_due_to_misuse</name>:</label>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_MISUSE</name></expr>;</expr_stmt>
  <comment type="block">/* Fall thru into abort_due_to_error */</comment>

  <comment type="block">/* Jump to here for any other kind of fatal error.  The "rc" variable
  ** should hold the error number.
  */</comment>
<label><name>abort_due_to_error</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>zErrMsg</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_IOERR_NOMEM</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <goto>goto <name>vdbe_error_halt</name>;</goto>

  <comment type="block">/* Jump to here if the sqlite3_interrupt() API sets the interrupt
  ** flag.
  */</comment>
<label><name>abort_due_to_interrupt</name>:</label>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>u1</name>.<name>isInterrupted</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>vdbe_error_halt</name>;</goto>
}</block></function>
</unit>
