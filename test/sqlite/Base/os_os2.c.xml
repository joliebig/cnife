<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="os_os2.c" filename=""><comment type="block">/*
** 2006 Feb 14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains code that is specific to OS/2.
**
** $Id: os_os2.c,v 1.63 2008/12/10 19:26:24 drh Exp $
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_OS2</name></expr></cpp:if>

<comment type="block">/*
** A Note About Memory Allocation:
**
** This driver uses malloc()/free() directly rather than going through
** the SQLite-wrappers sqlite3_malloc()/sqlite3_free().  Those wrappers
** are designed for use on embedded systems where memory is scarce and
** malloc failures happen frequently.  OS/2 does not typically run on
** embedded systems, and when it does the developers normally have bigger
** problems to worry about than running out of memory.  So there is not
** a compelling need to use the wrappers.
**
** But there is a good reason to not use the wrappers.  If we use the
** wrappers then we will get simulated malloc() failures within this
** driver.  And that causes all kinds of problems for our tests.  We
** could enhance SQLite to deal with simulated malloc failures within
** the OS driver, but the code to deal with those failure would not
** be exercised on Linux (which does not need to malloc() in the driver)
** and so we would have difficulty writing coverage tests for that
** code.  Better to leave the code out, we think.
**
** The point of this discussion is as follows:  When creating a new
** OS layer for an embedded system, if you use this file as an example,
** avoid the use of malloc()/free().  Those routines work ok on OS/2
** desktops but not so well in embedded systems.
*/</comment>

<comment type="block">/*
** Macros used to determine whether or not to use threads.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_THREADSAFE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_THREADSAFE</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SQLITE_OS2_THREADS</name> 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Include code that is common to all os_*.c files
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_common.h"</cpp:file></cpp:include>

<comment type="block">/*
** The os2File structure is subclass of sqlite3_file specific for the OS/2
** protability layer.
*/</comment>
<typedef>typedef <type><struct>struct <name>os2File</name> os2File;</struct></type></typedef>
<struct>struct <name>os2File</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_io_methods</name> *</type><name>pMethod</name></decl>;</decl_stmt>  <comment type="block">/* Always the first entry */</comment>
  <decl_stmt><decl><type><name>HFILE</name></type> <name>h</name></decl>;</decl_stmt>                  <comment type="block">/* Handle for accessing the file */</comment>
  <decl_stmt><decl><type><name>char</name>*</type> <name>pathToDel</name></decl>;</decl_stmt>          <comment type="block">/* Name of file to delete on close, NULL if not */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>locktype</name></decl>;</decl_stmt>   <comment type="block">/* Type of lock currently held on this file */</comment>
</public>}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>LOCK_TIMEOUT</name> 10L</cpp:define> <comment type="block">/* the default locking timeout */</comment>

<comment type="block">/*****************************************************************************
** The next group of routines implement the I/O methods specified
** by the sqlite3_io_methods object.
******************************************************************************/</comment>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Close</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>id</name> &amp;&amp; (<name>pFile</name> = (<name>os2File</name>*)<name>id</name>) != 0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"CLOSE %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>DosClose</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>NO_LOCK</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pathToDel</name> != <name>NULL</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>DosForceDelete</name><argument_list>( <argument><expr>(<name>PSZ</name>)<name>pFile</name>-&gt;<name>pathToDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>pathToDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>pathToDel</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>id</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OpenCounter</name><argument_list>( <argument><expr>-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name> == <name>NO_ERROR</name> ? <name>SQLITE_OK</name> : <name>SQLITE_IOERR</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read data from a file into a buffer.  Return SQLITE_OK if all
** bytes were read successfully and SQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Read</name><parameter_list>(
  <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>,               <comment type="block">/* File to read from */</comment>
  <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>,                     <comment type="block">/* Write content into this buffer */</comment>
  <param><decl><type><name>int</name></type> <name>amt</name></decl></param>,                        <comment type="block">/* Number of bytes to read */</comment>
  <param><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></param>            <comment type="block">/* Begin reading at this offset */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>ULONG</name></type> <name>fileLocation</name> =<init> <expr>0L</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>got</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_READ</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"READ %d lock=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>DosSetFilePtr</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>, <argument><expr>&amp;<name>fileLocation</name></expr></argument>)</argument_list></call> != <name>NO_ERROR</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>DosRead</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr>&amp;<name>got</name></expr></argument> )</argument_list></call> != <name>NO_ERROR</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>got</name> == (<name>ULONG</name>)<name>amt</name></expr> )</condition><then>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return></then>
  <else>else <block>{
    <comment type="block">/* Unread portions of the input buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;((<name>char</name>*)<name>pBuf</name>)[<name>got</name>]</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>amt</name>-<name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Write data from a buffer into a file.  Return SQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Write</name><parameter_list>(
  <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>,               <comment type="block">/* File to write into */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pBuf</name></decl></param>,               <comment type="block">/* The bytes to be written */</comment>
  <param><decl><type><name>int</name></type> <name>amt</name></decl></param>,                        <comment type="block">/* Number of bytes to write */</comment>
  <param><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></param>            <comment type="block">/* Offset into the file to begin writing at */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>ULONG</name></type> <name>fileLocation</name> =<init> <expr>0L</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>wrote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_WRITE</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <macro><name>SimulateDiskfullError</name><argument_list>( <argument>return SQLITE_FULL</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"WRITE %d lock=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>DosSetFilePtr</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>, <argument><expr>&amp;<name>fileLocation</name></expr></argument>)</argument_list></call> != <name>NO_ERROR</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>amt</name> &gt; 0 &amp;&amp;
         ( <name>rc</name> = <call><name>DosWrite</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>(<name>PVOID</name>)<name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr>&amp;<name>wrote</name></expr></argument> )</argument_list></call> ) == <name>NO_ERROR</name> &amp;&amp;
         <name>wrote</name> &gt; 0</expr>
  )</condition><block>{
    <expr_stmt><expr><name>amt</name> -= <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> = &amp;((<name>char</name>*)<name>pBuf</name>)[<name>wrote</name>]</expr>;</expr_stmt>
  }</block></while>

  <return>return <expr>( <name>rc</name> != <name>NO_ERROR</name> || <name>amt</name> &gt; (<name>int</name>)<name>wrote</name> ) ? <name>SQLITE_FULL</name> : <name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Truncate</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>i64</name></type> <name>nByte</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"TRUNCATE %d %lld\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_TRUNCATE</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosSetFileSize</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name> == <name>NO_ERROR</name> ? <name>SQLITE_OK</name> : <name>SQLITE_IOERR_TRUNCATE</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Count the number of fullsyncs and normal syncs.  This is used to test
** that syncs and fullsyncs are occuring at the right times.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sync_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fullsync_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Sync</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"SYNC %d lock=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_SYNC_FULL</name></expr>)</condition><then><block>{
    <expr_stmt><expr><name>sqlite3_fullsync_count</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>sqlite3_sync_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a
  ** no-op
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>DosResetBuffer</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument> )</argument_list></call> == <name>NO_ERROR</name> ? <name>SQLITE_OK</name> : <name>SQLITE_IOERR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2FileSize</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>sqlite3_int64</name> *</type><name>pSize</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILESTATUS3</name></type> <name>fsts3FileInfo</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>fsts3FileInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>fsts3FileInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_FSTAT</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosQueryFileInfo</name><argument_list>( <argument><expr>((<name>os2File</name>*)<name>id</name>)-&gt;<name>h</name></expr></argument>, <argument><expr><name>FIL_STANDARD</name></expr></argument>, <argument><expr>&amp;<name>fsts3FileInfo</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>FILESTATUS3</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pSize</name> = <name>fsts3FileInfo</name>.<name>cbFile</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Acquire a reader lock.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getReadLock</name><parameter_list>( <param><decl><type><name>os2File</name> *</type><name>pFile</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>FILELOCK</name></type>  <name>LockArea</name>,
            <name>UnlockArea</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>LockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>UnlockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
  <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>1L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"GETREADLOCK %d res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Undo a readlock
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unlockReadLock</name><parameter_list>( <param><decl><type><name>os2File</name> *</type><name>id</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>FILELOCK</name></type>  <name>LockArea</name>,
            <name>UnlockArea</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>LockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>UnlockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
  <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
  <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>1L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK-READLOCK file handle=%d res=%d?\n"</expr></argument>, <argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  The os2Unlock() routine
** erases all locks at once and returns us immediately to locking level 0.
** It is not possible to lower the locking level one step at a time.  You
** must go straight to locking level 0.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Lock</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Return code from subroutines */</comment>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>res</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Result of an OS/2 lock call */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>newLocktype</name></decl>;</decl_stmt>       <comment type="block">/* Set pFile-&gt;locktype to this value before exiting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>gotPendingLock</name> =<init> <expr>0</expr></init></decl>;</decl_stmt><comment type="block">/* True if we acquired a PENDING lock this time */</comment>
  <decl_stmt><decl><type><name>FILELOCK</name></type>  <name>LockArea</name>,
            <name>UnlockArea</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>LockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>UnlockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>( <argument><expr>"LOCK %d %d was %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** os2File, do nothing. Don't use the end_lock: exit path, as
  ** sqlite3_mutex_enter() hasn't been called yet.
  */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>locktype</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d %d ok (already held)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Make sure the locking sequence is correct
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name> || <name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>RESERVED_LOCK</name> || <name>pFile</name>-&gt;<name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or
  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of
  ** the PENDING_LOCK byte is temporary.
  */</comment>
  <expr_stmt><expr><name>newLocktype</name> = <name>pFile</name>-&gt;<name>locktype</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>==<name>NO_LOCK</name>
      || (<name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>==<name>RESERVED_LOCK</name>)</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>

    <comment type="block">/* wait longer than LOCK_TIMEOUT here not to have to try multiple times */</comment>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>100L</expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>gotPendingLock</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d pending lock boolean set.  res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Acquire a shared lock
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name> &amp;&amp; <name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>==<name>NO_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>newLocktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d acquire shared lock. res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Acquire a RESERVED lock
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>RESERVED_LOCK</name> &amp;&amp; <name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>newLocktype</name> = <name>RESERVED_LOCK</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d acquire reserved lock. res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Acquire a PENDING lock
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>newLocktype</name> = <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>gotPendingLock</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"LOCK %d acquire pending lock. pending lock boolean unset.\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Acquire an EXCLUSIVE lock
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>unlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"unreadlock = %d\n"</expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>newLocktype</name> = <name>EXCLUSIVE_LOCK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"OS/2 error-code = %d\n"</expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d acquire exclusive lock.  res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If we are holding a PENDING lock that ought to be released, then
  ** release it now.
  */</comment>
  <if>if<condition>( <expr><name>gotPendingLock</name> &amp;&amp; <name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d unlocking pending/is shared. r=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Update the state of the lock has held in the file descriptor then
  ** return the appropriate result code.
  */</comment>
  <if>if<condition>( <expr><name>res</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>( <argument><expr>"LOCK FAILED %d trying for %d but got %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
              <argument><expr><name>locktype</name></expr></argument>, <argument><expr><name>newLocktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>newLocktype</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"LOCK %d now %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, return
** non-zero, otherwise zero.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2CheckReservedLock</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pOut</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>RESERVED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>r</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"TEST WR-LOCK %d %d (local)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>FILELOCK</name></type>  <name>LockArea</name>,
              <name>UnlockArea</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>LockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>UnlockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"TEST WR-LOCK %d lock reserved byte rc=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name> == <name>NO_ERROR</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>APIRET</name></type> <name>rcu</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt> <comment type="block">/* return code for unlocking */</comment>
      <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
      <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
      <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
      <expr_stmt><expr><name>rcu</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"TEST WR-LOCK %d unlock reserved byte r=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rcu</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>r</name> = !(<name>rc</name> == <name>NO_ERROR</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"TEST WR-LOCK %d %d (remote)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>r</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr>*<name>pOut</name> = <name>r</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor id to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** It is not possible for this routine to fail if the second argument
** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine
** might return SQLITE_IOERR;
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Unlock</name><parameter_list>( <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>res</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILELOCK</name></type>  <name>LockArea</name>,
            <name>UnlockArea</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>LockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>UnlockArea</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>( <argument><expr>"UNLOCK %d to %d was %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>type</name> = <name>pFile</name>-&gt;<name>locktype</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>type</name>&gt;=<name>EXCLUSIVE_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK %d exclusive lock res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name> &amp;&amp; <call><name>getReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call> != <name>NO_ERROR</name></expr> )</condition><then><block>{
      <comment type="block">/* This should never happen.  We should always be able to
      ** reacquire the read lock */</comment>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK %d to %d getReadLock() failed\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_UNLOCK</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>type</name>&gt;=<name>RESERVED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK %d reserved res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>locktype</name>==<name>NO_LOCK</name> &amp;&amp; <name>type</name>&gt;=<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>res</name> = <call><name>unlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>( <argument><expr>"UNLOCK %d is %d want %d res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>type</name>&gt;=<name>PENDING_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>LockArea</name>.<name>lOffset</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>LockArea</name>.<name>lRange</name> = 0L</expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lOffset</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>UnlockArea</name>.<name>lRange</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>DosSetFileLocks</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>UnlockArea</name></expr></argument>, <argument><expr>&amp;<name>LockArea</name></expr></argument>, <argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr>0L</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK %d pending res=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>res</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"UNLOCK %d now %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Control and query of the open file handle.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2FileControl</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr>: <block>{
      <expr_stmt><expr>*(<name>int</name>*)<name>pArg</name> = ((<name>os2File</name>*)<name>id</name>)-&gt;<name>locktype</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"FCNTL_LOCKSTATE %d lock=%d\n"</expr></argument>, <argument><expr>((<name>os2File</name>*)<name>id</name>)-&gt;<name>h</name></expr></argument>, <argument><expr>((<name>os2File</name>*)<name>id</name>)-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block>
  </case>}</block></switch>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2SectorSize</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a vector of device characteristics.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2DeviceCharacteristics</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list><block>{
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Character set conversion objects used by conversion routines.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>UconvObject</name></type> <name>ucUtf8</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* convert between UTF-8 and UCS-2 */</comment>
<decl_stmt><decl><type><name>static</name> <name>UconvObject</name></type> <name>uclCp</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* convert between local codepage and UCS-2 */</comment>

<comment type="block">/*
** Helper function to initialize the conversion objects from and to UTF-8.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>initUconvObjects</name><parameter_list>( <param><decl><type><name>void</name></type></decl></param> )</parameter_list><block>{
  <if>if<condition>( <expr><call><name>UniCreateUconvObject</name><argument_list>( <argument><expr><name>UTF_8</name></expr></argument>, <argument><expr>&amp;<name>ucUtf8</name></expr></argument> )</argument_list></call> != <name>ULS_SUCCESS</name></expr> )</condition><then>
    <expr_stmt><expr><name>ucUtf8</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
  <if>if <condition>( <expr><call><name>UniCreateUconvObject</name><argument_list>( <argument><expr>(<name>UniChar</name> *)L"@path=yes"</expr></argument>, <argument><expr>&amp;<name>uclCp</name></expr></argument> )</argument_list></call> != <name>ULS_SUCCESS</name></expr> )</condition><then>
    <expr_stmt><expr><name>uclCp</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
** Helper function to free the conversion objects from and to UTF-8.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>freeUconvObjects</name><parameter_list>( <param><decl><type><name>void</name></type></decl></param> )</parameter_list><block>{
  <if>if <condition>( <expr><name>ucUtf8</name></expr> )</condition><then>
    <expr_stmt><expr><call><name>UniFreeUconvObject</name><argument_list>( <argument><expr><name>ucUtf8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>( <expr><name>uclCp</name></expr> )</condition><then>
    <expr_stmt><expr><call><name>UniFreeUconvObject</name><argument_list>( <argument><expr><name>uclCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>ucUtf8</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>uclCp</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Helper function to convert UTF-8 filenames to local OS/2 codepage.
** The two-step process: first convert the incoming UTF-8 string
** into UCS-2 and then from UCS-2 to the current codepage.
** The returned char pointer has to be freed.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>convertUtf8PathToCp</name><parameter_list>( <param><decl><type><name>const</name> <name>char</name> *</type><name>in</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>UniChar</name></type> <name><name>tempPath</name><index>[<expr><name>CCHMAXPATH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>out</name> =<init> <expr>(<name>char</name> *)<call><name>calloc</name><argument_list>( <argument><expr><name>CCHMAXPATH</name></expr></argument>, <argument><expr>1</expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>out</name></expr> )</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <if>if<condition>( <expr>!<name>ucUtf8</name> || !<name>uclCp</name></expr> )</condition><then>
    <expr_stmt><expr><call><name>initUconvObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* determine string for the conversion of UTF-8 which is CP1208 */</comment>
  <if>if<condition>( <expr><call><name>UniStrToUcs</name><argument_list>( <argument><expr><name>ucUtf8</name></expr></argument>, <argument><expr><name>tempPath</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>in</name></expr></argument>, <argument><expr><name>CCHMAXPATH</name></expr></argument> )</argument_list></call> != <name>ULS_SUCCESS</name></expr> )</condition><then>
    <return>return <expr><name>out</name></expr>;</return></then></if> <comment type="block">/* if conversion fails, return the empty string */</comment>

  <comment type="block">/* conversion for current codepage which can be used for paths */</comment>
  <expr_stmt><expr><call><name>UniStrFromUcs</name><argument_list>( <argument><expr><name>uclCp</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>tempPath</name></expr></argument>, <argument><expr><name>CCHMAXPATH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>out</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Helper function to convert filenames from local codepage to UTF-8.
** The two-step process: first convert the incoming codepage-specific
** string into UCS-2 and then from UCS-2 to the codepage of UTF-8.
** The returned char pointer has to be freed.
**
** This function is non-static to be able to use this in shell.c and
** similar applications that take command line arguments.
*/</comment>
<function><type><name>char</name> *</type><name>convertCpPathToUtf8</name><parameter_list>( <param><decl><type><name>const</name> <name>char</name> *</type><name>in</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>UniChar</name></type> <name><name>tempPath</name><index>[<expr><name>CCHMAXPATH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>out</name> =<init> <expr>(<name>char</name> *)<call><name>calloc</name><argument_list>( <argument><expr><name>CCHMAXPATH</name></expr></argument>, <argument><expr>1</expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>out</name></expr> )</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <if>if<condition>( <expr>!<name>ucUtf8</name> || !<name>uclCp</name></expr> )</condition><then>
    <expr_stmt><expr><call><name>initUconvObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* conversion for current codepage which can be used for paths */</comment>
  <if>if<condition>( <expr><call><name>UniStrToUcs</name><argument_list>( <argument><expr><name>uclCp</name></expr></argument>, <argument><expr><name>tempPath</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>in</name></expr></argument>, <argument><expr><name>CCHMAXPATH</name></expr></argument> )</argument_list></call> != <name>ULS_SUCCESS</name></expr> )</condition><then>
    <return>return <expr><name>out</name></expr>;</return></then></if> <comment type="block">/* if conversion fails, return the empty string */</comment>

  <comment type="block">/* determine string for the conversion of UTF-8 which is CP1208 */</comment>
  <expr_stmt><expr><call><name>UniStrFromUcs</name><argument_list>( <argument><expr><name>ucUtf8</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>tempPath</name></expr></argument>, <argument><expr><name>CCHMAXPATH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>out</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This vector defines all the methods that can operate on an
** sqlite3_file for os2.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>sqlite3_io_methods</name></type> <name>os2IoMethod</name> =<init> <expr><block>{
  <expr>1</expr>,                        <comment type="block">/* iVersion */</comment>
  <expr><name>os2Close</name></expr>,
  <expr><name>os2Read</name></expr>,
  <expr><name>os2Write</name></expr>,
  <expr><name>os2Truncate</name></expr>,
  <expr><name>os2Sync</name></expr>,
  <expr><name>os2FileSize</name></expr>,
  <expr><name>os2Lock</name></expr>,
  <expr><name>os2Unlock</name></expr>,
  <expr><name>os2CheckReservedLock</name></expr>,
  <expr><name>os2FileControl</name></expr>,
  <expr><name>os2SectorSize</name></expr>,
  <expr><name>os2DeviceCharacteristics</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/***************************************************************************
** Here ends the I/O methods that form the sqlite3_io_methods object.
**
** The next block of code implements the VFS methods.
****************************************************************************/</comment>

<comment type="block">/*
** Create a temporary file name in zBuf.  zBuf must be big enough to
** hold at pVfs-&gt;mxPathname characters.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getTempname</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>zChars</name><index>[]</index></name> =<init>
    <expr>"abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "0123456789"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTempPathBuf</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PSZ</name></type> <name>zTempPath</name> =<init> <expr>(<name>PSZ</name>)&amp;<name>zTempPathBuf</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>sqlite3_temp_directory</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zTempPath</name> = <name>sqlite3_temp_directory</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><call><name>DosScanEnv</name><argument_list>( <argument><expr>(<name>PSZ</name>)"TEMP"</expr></argument>, <argument><expr>&amp;<name>zTempPath</name></expr></argument> )</argument_list></call></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>DosScanEnv</name><argument_list>( <argument><expr>(<name>PSZ</name>)"TMP"</expr></argument>, <argument><expr>&amp;<name>zTempPath</name></expr></argument> )</argument_list></call></expr> )</condition><then><block>{
        <if>if<condition>( <expr><call><name>DosScanEnv</name><argument_list>( <argument><expr>(<name>PSZ</name>)"TMPDIR"</expr></argument>, <argument><expr>&amp;<name>zTempPath</name></expr></argument> )</argument_list></call></expr> )</condition><then><block>{
           <decl_stmt><decl><type><name>ULONG</name></type> <name>ulDriveNum</name> =<init> <expr>0</expr>, <expr><name>ulDriveMap</name> = 0</expr></init></decl>;</decl_stmt>
           <expr_stmt><expr><call><name>DosQueryCurrentDisk</name><argument_list>( <argument><expr>&amp;<name>ulDriveNum</name></expr></argument>, <argument><expr>&amp;<name>ulDriveMap</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name>sprintf</name><argument_list>( <argument><expr>(<name>char</name>*)<name>zTempPath</name></expr></argument>, <argument><expr>"%c:"</expr></argument>, <argument><expr>(<name>char</name>)( 'A' + <name>ulDriveNum</name> - 1 )</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>
  <comment type="block">/* Strip off a trailing slashes or backslashes, otherwise we would get *
   * multiple (back)slashes which causes DosOpen() to fail.              *
   * Trailing spaces are not allowed, either.                            */</comment>
  <expr_stmt><expr><name>j</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTempPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>j</name> &gt; 0 &amp;&amp; ( <name><name>zTempPath</name><index>[<expr><name>j</name>-1</expr>]</index></name> == '\\' || <name><name>zTempPath</name><index>[<expr><name>j</name>-1</expr>]</index></name> == '/'
                    || <name><name>zTempPath</name><index>[<expr><name>j</name>-1</expr>]</index></name> == ' ' )</expr> )</condition><block>{
    <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name><name>zTempPath</name><index>[<expr><name>j</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>sqlite3_temp_directory</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zTempPathUTF</name> =<init> <expr><call><name>convertCpPathToUtf8</name><argument_list>( <argument><expr><name>zTempPath</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>( <argument><expr><name>nBuf</name>-30</expr></argument>, <argument><expr><name>zBuf</name></expr></argument>,
                      <argument><expr>"%s\\"<name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>, <argument><expr><name>zTempPathUTF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zTempPathUTF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>( <argument><expr><name>nBuf</name>-30</expr></argument>, <argument><expr><name>zBuf</name></expr></argument>,
                      <argument><expr>"%s\\"<name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>, <argument><expr><name>zTempPath</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>j</name> = <call><name>sqlite3Strlen30</name><argument_list>( <argument><expr><name>zBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>( <argument><expr>20</expr></argument>, <argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 20</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr> )<block>{
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>char</name>)<name><name>zChars</name><index>[ <expr>((<name>unsigned</name> <name>char</name>)<name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name>)%(<call><name>sizeof</name><argument_list>(<argument><expr><name>zChars</name></expr></argument>)</argument_list></call>-1)</expr> ]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"TEMP FILENAME: %s\n"</expr></argument>, <argument><expr><name>zBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Turn a relative pathname into a full pathname.  Write the full
** pathname into zFull[].  zFull[] will be at least pVfs-&gt;mxPathname
** bytes in size.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2FullPathname</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,          <comment type="block">/* Pointer to vfs object */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zRelative</name></decl></param>,      <comment type="block">/* Possibly relative input path */</comment>
  <param><decl><type><name>int</name></type> <name>nFull</name></decl></param>,                  <comment type="block">/* Size of output buffer in bytes */</comment>
  <param><decl><type><name>char</name> *</type><name>zFull</name></decl></param>                 <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zRelativeCp</name> =<init> <expr><call><name>convertUtf8PathToCp</name><argument_list>( <argument><expr><name>zRelative</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zFullCp</name><index>[<expr><name>CCHMAXPATH</name></expr>]</index></name> =<init> <expr>"\0"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFullUTF</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><call><name>DosQueryPathInfo</name><argument_list>( <argument><expr><name>zRelativeCp</name></expr></argument>, <argument><expr><name>FIL_QUERYFULLNAME</name></expr></argument>, <argument><expr><name>zFullCp</name></expr></argument>,
                                <argument><expr><name>CCHMAXPATH</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zRelativeCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFullUTF</name> = <call><name>convertCpPathToUtf8</name><argument_list>( <argument><expr><name>zFullCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>( <argument><expr><name>nFull</name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><name>zFullUTF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zFullUTF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name> == <name>NO_ERROR</name> ? <name>SQLITE_OK</name> : <name>SQLITE_IOERR</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Open a file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Open</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,            <comment type="block">/* Not used */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,            <comment type="block">/* Name of the file */</comment>
  <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>,             <comment type="block">/* Write the SQLite file handle here */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,                    <comment type="block">/* Open mode flags */</comment>
  <param><decl><type><name>int</name> *</type><name>pOutFlags</name></decl></param>                <comment type="block">/* Status return flags */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>HFILE</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>ulFileAttribute</name> =<init> <expr><name>FILE_NORMAL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>ulOpenFlags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>ulOpenMode</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>os2File</name> *</type><name>pFile</name> =<init> <expr>(<name>os2File</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ULONG</name></type> <name>ulAction</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zNameCp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTmpname</name><index>[<expr><name>CCHMAXPATH</name>+1</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Buffer to hold name of temp file */</comment>

  <comment type="block">/* If the second argument to this function is NULL, generate a 
  ** temporary file name to use 
  */</comment>
  <if>if<condition>( <expr>!<name>zName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>getTempname</name><argument_list>(<argument><expr><name>CCHMAXPATH</name>+1</expr></argument>, <argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zName</name> = <name>zTmpname</name></expr>;</expr_stmt>
  }</block></then></if>


  <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr><name>pFile</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pFile</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"OPEN want %d\n"</expr></argument>, <argument><expr><name>flags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_READWRITE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_ACCESS_READWRITE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN read/write\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_ACCESS_READONLY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN read only\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_CREATE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>ulOpenFlags</name> |= <name>OPEN_ACTION_OPEN_IF_EXISTS</name> | <name>OPEN_ACTION_CREATE_IF_NEW</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN open new/create\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>ulOpenFlags</name> |= <name>OPEN_ACTION_OPEN_IF_EXISTS</name> | <name>OPEN_ACTION_FAIL_IF_NEW</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN open existing\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_MAIN_DB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_SHARE_DENYNONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN share read/write\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_SHARE_DENYWRITE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN share read only\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_DELETEONCLOSE</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>pathUtf8</name><index>[<expr><name>CCHMAXPATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NDEBUG</name></cpp:ifdef> <comment type="block">/* when debugging we want to make sure it is deleted */</comment>
    <expr_stmt><expr><name>ulFileAttribute</name> = <name>FILE_HIDDEN</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>os2FullPathname</name><argument_list>( <argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>CCHMAXPATH</name></expr></argument>, <argument><expr><name>pathUtf8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pathToDel</name> = <call><name>convertUtf8PathToCp</name><argument_list>( <argument><expr><name>pathUtf8</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN hidden/delete on close file attributes\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pathToDel</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>( <argument><expr>"OPEN normal file attribute\n"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* always open in random access mode for possibly better speed */</comment>
  <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_FLAGS_RANDOM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_FLAGS_FAIL_ON_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ulOpenMode</name> |= <name>OPEN_FLAGS_NOINHERIT</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>zNameCp</name> = <call><name>convertUtf8PathToCp</name><argument_list>( <argument><expr><name>zName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosOpen</name><argument_list>( <argument><expr>(<name>PSZ</name>)<name>zNameCp</name></expr></argument>,
                <argument><expr>&amp;<name>h</name></expr></argument>,
                <argument><expr>&amp;<name>ulAction</name></expr></argument>,
                <argument><expr>0L</expr></argument>,
                <argument><expr><name>ulFileAttribute</name></expr></argument>,
                <argument><expr><name>ulOpenFlags</name></expr></argument>,
                <argument><expr><name>ulOpenMode</name></expr></argument>,
                <argument><expr>(<name>PEAOP2</name>)<name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zNameCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name> != <name>NO_ERROR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>OSTRACE7</name><argument_list>( <argument><expr>"OPEN Invalid handle rc=%d: zName=%s, ulAction=%#lx, ulAttr=%#lx, ulFlags=%#lx, ulMode=%#lx\n"</expr></argument>,
              <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>ulAction</name></expr></argument>, <argument><expr><name>ulFileAttribute</name></expr></argument>, <argument><expr><name>ulOpenFlags</name></expr></argument>, <argument><expr><name>ulOpenMode</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pathToDel</name></expr> )</condition><then>
      <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>pathToDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pathToDel</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_READWRITE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"OPEN %d Invalid handle\n"</expr></argument>, <argument><expr>((<name>flags</name> | <name>SQLITE_OPEN_READONLY</name>) &amp; ~<name>SQLITE_OPEN_READWRITE</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>os2Open</name><argument_list>( <argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
                      <argument><expr>((<name>flags</name> | <name>SQLITE_OPEN_READONLY</name>) &amp; ~<name>SQLITE_OPEN_READWRITE</name>)</expr></argument>,
                      <argument><expr><name>pOutFlags</name></expr></argument> )</argument_list></call></expr>;</return>
    }</block></then><else>else<block>{
      <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pOutFlags</name> = <name>flags</name> &amp; <name>SQLITE_OPEN_READWRITE</name> ? <name>SQLITE_OPEN_READWRITE</name> : <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>pFile</name>-&gt;<name>pMethod</name> = &amp;<name>os2IoMethod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>h</name> = <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"OPEN %d pOutFlags=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete the named file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Delete</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,                     <comment type="block">/* Not used on os2 */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,                 <comment type="block">/* Name of file to delete */</comment>
  <param><decl><type><name>int</name></type> <name>syncDir</name></decl></param>                            <comment type="block">/* Not used on os2 */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFilenameCp</name> =<init> <expr><call><name>convertUtf8PathToCp</name><argument_list>( <argument><expr><name>zFilename</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_DELETE</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosDelete</name><argument_list>( <argument><expr>(<name>PSZ</name>)<name>zFilenameCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zFilenameCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>( <argument><expr>"DELETE \"%s\"\n"</expr></argument>, <argument><expr><name>zFilename</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name> == <name>NO_ERROR</name> ? <name>SQLITE_OK</name> : <name>SQLITE_IOERR_DELETE</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Check the existance and status of a file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Access</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,        <comment type="block">/* Not used on os2 */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,    <comment type="block">/* Name of file to check */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,                <comment type="block">/* Type of test to make on this file */</comment>
  <param><decl><type><name>int</name> *</type><name>pOut</name></decl></param>                 <comment type="block">/* Write results here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>FILESTATUS3</name></type> <name>fsts3ConfigInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name> =<init> <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFilenameCp</name> =<init> <expr><call><name>convertUtf8PathToCp</name><argument_list>( <argument><expr><name>zFilename</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>( <argument><expr>&amp;<name>fsts3ConfigInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>fsts3ConfigInfo</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosQueryPathInfo</name><argument_list>( <argument><expr>(<name>PSZ</name>)<name>zFilenameCp</name></expr></argument>, <argument><expr><name>FIL_STANDARD</name></expr></argument>,
                         <argument><expr>&amp;<name>fsts3ConfigInfo</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>FILESTATUS3</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr><name>zFilenameCp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>( <argument><expr>"ACCESS fsts3ConfigInfo.attrFile=%d flags=%d rc=%d\n"</expr></argument>,
            <argument><expr><name>fsts3ConfigInfo</name>.<name>attrFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>flags</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_ACCESS_READ</name></expr>:
    </case><case>case <expr><name>SQLITE_ACCESS_EXISTS</name></expr>:
      <expr_stmt><expr><name>rc</name> = (<name>rc</name> == <name>NO_ERROR</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"ACCESS %s access of read and exists  rc=%d\n"</expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SQLITE_ACCESS_READWRITE</name></expr>:
      <expr_stmt><expr><name>rc</name> = (<name>rc</name> == <name>NO_ERROR</name>) &amp;&amp; ( (<name>fsts3ConfigInfo</name>.<name>attrFile</name> &amp; <name>FILE_READONLY</name>) == 0 )</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>( <argument><expr>"ACCESS %s access of read/write  rc=%d\n"</expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!"Invalid flags argument"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>
  <expr_stmt><expr>*<name>pOut</name> = <name>rc</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/</comment>
<comment type="block">/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>os2DlOpen</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>UCHAR</name></type> <name><name>loadErr</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HMODULE</name></type> <name>hmod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFilenameCp</name> =<init> <expr><call><name>convertUtf8PathToCp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosLoadModule</name><argument_list>(<argument><expr>(<name>PSZ</name>)<name>loadErr</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>loadErr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFilenameCp</name></expr></argument>, <argument><expr>&amp;<name>hmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zFilenameCp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name> != <name>NO_ERROR</name> ? 0 : (<name>void</name>*)<name>hmod</name></expr>;</return>
}</block></function>
<comment type="block">/*
** A no-op since the error code is returned on the DosLoadModule call.
** os2Dlopen returns zero if DosLoadModule is not successful.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>os2DlError</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBufOut</name></decl></param>)</parameter_list><block>{
<comment type="block">/* no-op */</comment>
}</block></function>
<function><type><name>static</name> <name>void</name> *</type><name>os2DlSym</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pHandle</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zSymbol</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PFN</name></type> <name>pfn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>DosQueryProcAddr</name><argument_list>(<argument><expr>(<name>HMODULE</name>)<name>pHandle</name></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>zSymbol</name></expr></argument>, <argument><expr>&amp;<name>pfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name> != <name>NO_ERROR</name></expr> )</condition><then><block>{
    <comment type="block">/* if the symbol itself was not found, search again for the same
     * symbol with an extra underscore, that might be needed depending
     * on the calling convention */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>_zSymbol</name><index>[<expr>256</expr>]</index></name> =<init> <expr>"_"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>_zSymbol</name></expr></argument>, <argument><expr><name>zSymbol</name></expr></argument>, <argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>DosQueryProcAddr</name><argument_list>(<argument><expr>(<name>HMODULE</name>)<name>pHandle</name></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>_zSymbol</name></expr></argument>, <argument><expr>&amp;<name>pfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name> != <name>NO_ERROR</name> ? 0 : (<name>void</name>*)<name>pfn</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>os2DlClose</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pHandle</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>DosFreeModule</name><argument_list>(<argument><expr>(<name>HMODULE</name>)<name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if SQLITE_OMIT_LOAD_EXTENSION is defined: */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>os2DlOpen</name> 0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>os2DlError</name> 0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>os2DlSym</name> 0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>os2DlClose</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Write up to nBuf bytes of randomness into zBuf.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Randomness</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>n</name> = <name>nBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>sizeofULong</name> =<init> <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>ULONG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>DATETIME</name></expr></argument>)</argument_list></call> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>DATETIME</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DosGetDateTime</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PPIB</name></type> <name>ppib</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DosGetInfoBlocks</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>ppib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>ppib</name>-&gt;<name>pib_ulpid</name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PTIB</name></type> <name>ptib</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DosGetInfoBlocks</name><argument_list>(<argument><expr>&amp;<name>ptib</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>ptib</name>-&gt;<name>tib_ptib2</name>-&gt;<name>tib2_ultid</name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* if we still haven't filled the buffer yet the following will */</comment>
  <comment type="block">/* grab everything once instead of making several calls for a single item */</comment>
  <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>ULONG</name></type> <name><name>ulSysInfo</name><index>[<expr><name>QSV_MAX</name></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>DosQuerySysInfo</name><argument_list>(<argument><expr>1L</expr></argument>, <argument><expr><name>QSV_MAX</name></expr></argument>, <argument><expr><name>ulSysInfo</name></expr></argument>, <argument><expr><name>sizeofULong</name> * <name>QSV_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>ulSysInfo</name><index>[<expr><name>QSV_MS_COUNT</name> - 1</expr>]</index></name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>ulSysInfo</name><index>[<expr><name>QSV_TIMER_INTERVAL</name> - 1</expr>]</index></name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>ulSysInfo</name><index>[<expr><name>QSV_TIME_LOW</name> - 1</expr>]</index></name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>ulSysInfo</name><index>[<expr><name>QSV_TIME_HIGH</name> - 1</expr>]</index></name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>sizeofULong</name> &lt;= <name>nBuf</name> - <name>n</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>ulSysInfo</name><index>[<expr><name>QSV_TOTAVAILMEM</name> - 1</expr>]</index></name></expr></argument>, <argument><expr><name>sizeofULong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> += <name>sizeofULong</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
** The argument is the number of microseconds we want to sleep.
** The return value is the number of microseconds of sleep actually
** requested from the underlying operating system, a number which
** might be greater than or equal to the argument, but not less
** than the argument.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>os2Sleep</name><parameter_list>( <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>int</name></type> <name>microsec</name></decl></param> )</parameter_list><block>{
  <expr_stmt><expr><call><name>DosSleep</name><argument_list>( <argument><expr>(<name>microsec</name>/1000)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microsec</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The following variable, if set to a non-zero value, becomes the result
** returned from sqlite3OsCurrentTime().  This is used for testing.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_current_time</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write the
** current time and date as a Julian Day number into *prNow and
** return 0.  Return 1 if the time and date cannot be found.
*/</comment>
<function><type><name>int</name></type> <name>os2CurrentTime</name><parameter_list>( <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>double</name> *</type><name>prNow</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>double</name></type> <name>now</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SHORT</name></type> <name>minute</name></decl>;</decl_stmt> <comment type="block">/* needs to be able to cope with negative timezone offset */</comment>
  <decl_stmt><decl><type><name>USHORT</name></type> <name>second</name>, <name>hour</name>,
         <name>day</name>, <name>month</name>, <name>year</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DATETIME</name></type> <name>dt</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>DosGetDateTime</name><argument_list>( <argument><expr>&amp;<name>dt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>second</name> = (<name>USHORT</name>)<name>dt</name>.<name>seconds</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>minute</name> = (<name>SHORT</name>)<name>dt</name>.<name>minutes</name> + <name>dt</name>.<name>timezone</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>hour</name> = (<name>USHORT</name>)<name>dt</name>.<name>hours</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>day</name> = (<name>USHORT</name>)<name>dt</name>.<name>day</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>month</name> = (<name>USHORT</name>)<name>dt</name>.<name>month</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>year</name> = (<name>USHORT</name>)<name>dt</name>.<name>year</name></expr>;</expr_stmt>

  <comment type="block">/* Calculations from http://www.astro.keele.ac.uk/~rno/Astronomy/hjd.html
     http://www.astro.keele.ac.uk/~rno/Astronomy/hjd-0.1.c */</comment>
  <comment type="block">/* Calculate the Julian days */</comment>
  <expr_stmt><expr><name>now</name> = <name>day</name> - 32076 +
    1461*(<name>year</name> + 4800 + (<name>month</name> - 14)/12)/4 +
    367*(<name>month</name> - 2 - (<name>month</name> - 14)/12*12)/12 -
    3*((<name>year</name> + 4900 + (<name>month</name> - 14)/12)/100)/4</expr>;</expr_stmt>

  <comment type="block">/* Add the fractional hours, mins and seconds */</comment>
  <expr_stmt><expr><name>now</name> += (<name>hour</name> + 12.0)/24.0</expr>;</expr_stmt>
  <expr_stmt><expr><name>now</name> += <name>minute</name>/1440.0</expr>;</expr_stmt>
  <expr_stmt><expr><name>now</name> += <name>second</name>/86400.0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prNow</name> = <name>now</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if>if<condition>( <expr><name>sqlite3_current_time</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>prNow</name> = <name>sqlite3_current_time</name>/86400.0 + 2440587.5</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type> <name>os2GetLastError</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>)</parameter_list><block>{
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Initialize and deinitialize the operating system interface.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>sqlite3_vfs</name></type> <name>os2Vfs</name> =<init> <expr><block>{
    <expr>1</expr>,                 <comment type="block">/* iVersion */</comment>
    <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>os2File</name></expr></argument>)</argument_list></call></expr>,   <comment type="block">/* szOsFile */</comment>
    <expr><name>CCHMAXPATH</name></expr>,        <comment type="block">/* mxPathname */</comment>
    <expr>0</expr>,                 <comment type="block">/* pNext */</comment>
    <expr>"os2"</expr>,             <comment type="block">/* zName */</comment>
    <expr>0</expr>,                 <comment type="block">/* pAppData */</comment>

    <expr><name>os2Open</name></expr>,           <comment type="block">/* xOpen */</comment>
    <expr><name>os2Delete</name></expr>,         <comment type="block">/* xDelete */</comment>
    <expr><name>os2Access</name></expr>,         <comment type="block">/* xAccess */</comment>
    <expr><name>os2FullPathname</name></expr>,   <comment type="block">/* xFullPathname */</comment>
    <expr><name>os2DlOpen</name></expr>,         <comment type="block">/* xDlOpen */</comment>
    <expr><name>os2DlError</name></expr>,        <comment type="block">/* xDlError */</comment>
    <expr><name>os2DlSym</name></expr>,          <comment type="block">/* xDlSym */</comment>
    <expr><name>os2DlClose</name></expr>,        <comment type="block">/* xDlClose */</comment>
    <expr><name>os2Randomness</name></expr>,     <comment type="block">/* xRandomness */</comment>
    <expr><name>os2Sleep</name></expr>,          <comment type="block">/* xSleep */</comment>
    <expr><name>os2CurrentTime</name></expr>,    <comment type="block">/* xCurrentTime */</comment>
    <expr><name>os2GetLastError</name></expr>    <comment type="block">/* xGetLastError */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr>&amp;<name>os2Vfs</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initUconvObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3_os_end</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>freeUconvObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_OS2 */</comment>
</unit>
