<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="select.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle SELECT statements in SQLite.
**
** $Id: select.c,v 1.498 2009/01/09 02:49:32 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>


<comment type="block">/*
** Delete all the content of a Select structure but do not deallocate
** the select structure itself.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>clearSelect</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Initialize a SelectDest structure.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectDestInit</name><parameter_list>(<param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>, <param><decl><type><name>int</name></type> <name>eDest</name></decl></param>, <param><decl><type><name>int</name></type> <name>iParm</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pDest</name>-&gt;<name>eDest</name> = (<name>u8</name>)<name>eDest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>iParm</name> = <name>iParm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>affinity</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>iMem</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>nMem</name> = 0</expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Allocate a new Select structure and return a pointer to that
** structure.
*/</comment>
<function><type><name>Select</name> *</type><name>sqlite3SelectNew</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,     <comment type="block">/* which columns to include in the result */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,        <comment type="block">/* the FROM clause -- which tables to scan */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,         <comment type="block">/* the WHERE clause */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pGroupBy</name></decl></param>,   <comment type="block">/* the GROUP BY clause */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pHaving</name></decl></param>,        <comment type="block">/* the HAVING clause */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,   <comment type="block">/* the ORDER BY clause */</comment>
  <param><decl><type><name>int</name></type> <name>isDistinct</name></decl></param>,       <comment type="block">/* true if the DISTINCT keyword is present */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLimit</name></decl></param>,         <comment type="block">/* LIMIT value.  NULL means not used */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pOffset</name></decl></param>         <comment type="block">/* OFFSET value.  NULL means no offset */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Select</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name></type> <name>standin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name> || !<name>pOffset</name> || <name>pLimit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* OFFSET implies LIMIT */</comment>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pNew</name> = &amp;<name>standin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pEList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pEList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>TK_ALL</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pEList</name> = <name>pEList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pSrc</name> = <name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pWhere</name> = <name>pWhere</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pGroupBy</name> = <name>pGroupBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pHaving</name> = <name>pHaving</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pOrderBy</name> = <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>selFlags</name> = <name>isDistinct</name> ? <name>SF_Distinct</name> : 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>op</name> = <name>TK_SELECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pLimit</name> = <name>pLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pOffset</name> = <name>pOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>1</expr>]</index></name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>2</expr>]</index></name> = -1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <block>{
    <expr_stmt><expr><call><name>clearSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pNew</name>!=&amp;<name>standin</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pNew</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete the given Select structure and all of its substructures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>clearSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Given 1 to 3 identifiers preceeding the JOIN keyword, determine the
** type of join.  Return an integer constant that expresses that type
** in terms of the following bit values:
**
**     JT_INNER
**     JT_CROSS
**     JT_OUTER
**     JT_NATURAL
**     JT_LEFT
**     JT_RIGHT
**
** A full outer join is the combination of JT_LEFT and JT_RIGHT.
**
** If an illegal or unsupported join type is seen, then still return
** a join type, but put an error in the pParse structure.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3JoinType</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pA</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pB</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pC</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>jointype</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> *</type><name><name>apAll</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <struct>struct <block>{<public type="default"/>
    <decl_stmt><decl><type><name>const</name> <name>char</name></type> <name><name>zKeyword</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>nChar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>code</name></decl>;</decl_stmt>
  }</block> <decl><name><name>keywords</name><index>[]</index></name> =<init> <expr><block>{
    <expr><block>{ <expr>"natural"</expr>, <expr>7</expr>, <expr><name>JT_NATURAL</name></expr> }</block></expr>,
    <expr><block>{ <expr>"left"</expr>,    <expr>4</expr>, <expr><name>JT_LEFT</name>|<name>JT_OUTER</name></expr> }</block></expr>,
    <expr><block>{ <expr>"right"</expr>,   <expr>5</expr>, <expr><name>JT_RIGHT</name>|<name>JT_OUTER</name></expr> }</block></expr>,
    <expr><block>{ <expr>"full"</expr>,    <expr>4</expr>, <expr><name>JT_LEFT</name>|<name>JT_RIGHT</name>|<name>JT_OUTER</name></expr> }</block></expr>,
    <expr><block>{ <expr>"outer"</expr>,   <expr>5</expr>, <expr><name>JT_OUTER</name></expr> }</block></expr>,
    <expr><block>{ <expr>"inner"</expr>,   <expr>5</expr>, <expr><name>JT_INNER</name></expr> }</block></expr>,
    <expr><block>{ <expr>"cross"</expr>,   <expr>5</expr>, <expr><name>JT_INNER</name>|<name>JT_CROSS</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr>0</expr>]</index></name> = <name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr>1</expr>]</index></name> = <name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>apAll</name><index>[<expr>2</expr>]</index></name> = <name>pC</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;3 &amp;&amp; <name><name>apAll</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = <name><name>apAll</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>n</name>==<name><name>keywords</name><index>[<expr><name>j</name></expr>]</index></name>.<name>nChar</name> 
          &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name><name>keywords</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zKeyword</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>jointype</name> |= <name><name>keywords</name><index>[<expr><name>j</name></expr>]</index></name>.<name>code</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>j</name>&gt;=<call><name>ArraySize</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>jointype</name> |= <name>JT_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <if>if<condition>(
     <expr>(<name>jointype</name> &amp; (<name>JT_INNER</name>|<name>JT_OUTER</name>))==(<name>JT_INNER</name>|<name>JT_OUTER</name>) ||
     (<name>jointype</name> &amp; <name>JT_ERROR</name>)!=0</expr>
  )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSp</name> =<init> <expr>" "</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pB</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pC</name>==0</expr> )</condition><then><block>{ <expr_stmt><expr><name>zSp</name>++</expr>;</expr_stmt> }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"unknown or unsupported join type: "
       "%T %T%s%T"</expr></argument>, <argument><expr><name>pA</name></expr></argument>, <argument><expr><name>pB</name></expr></argument>, <argument><expr><name>zSp</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jointype</name> = <name>JT_INNER</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>jointype</name> &amp; <name>JT_RIGHT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr>"RIGHT and FULL OUTER JOINs are not currently supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jointype</name> = <name>JT_INNER</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <return>return <expr><name>jointype</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the index of a column in a table.  Return -1 if the column
** is not contained in the table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>columnIndex</name><parameter_list>(<param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zCol</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <return>return <expr><name>i</name></expr>;</return></then></if>
  }</block></for>
  <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
** Set the value of a token to a '\000'-terminated string.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>setToken</name><parameter_list>(<param><decl><type><name>Token</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>z</name> = (<name>u8</name>*)<name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>n</name> = <name>z</name> ? <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>dyn</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the token to the double-quoted and escaped version of the string pointed
** to by z. For example;
**
**    {a"bc}  -&gt;  {"a""bc"}
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>setQuotedToken</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{

  <comment type="block">/* Check if the string appears to be quoted using "..." or `...`
  ** or [...] or '...' or if the string contains any " characters.  
  ** If it does, then record a version of the string with the special
  ** characters escaped.
  */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name> =<init> <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>*<name>z2</name>!='[' &amp;&amp; *<name>z2</name>!='`' &amp;&amp; *<name>z2</name>!='\''</expr> )</condition><then><block>{
    <while>while<condition>( <expr>*<name>z2</name></expr> )</condition><block>{
      <if>if<condition>( <expr>*<name>z2</name>=='"'</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><name>z2</name>++</expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>

  <if>if<condition>( <expr>*<name>z2</name></expr> )</condition><then><block>{
    <comment type="block">/* String contains " characters - copy and quote the string. */</comment>
    <expr_stmt><expr><name>p</name>-&gt;<name>z</name> = (<name>u8</name> *)<call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"\"%w\""</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>z</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>(<name>char</name> *)<name>p</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>dyn</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <comment type="block">/* String contains no " characters - copy the pointer. */</comment>
    <expr_stmt><expr><name>p</name>-&gt;<name>z</name> = (<name>u8</name>*)<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>n</name> = (<name>int</name>)(<name>z2</name> - <name>z</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>dyn</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Create an expression node for an identifier with the name of zName
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3CreateIdExpr</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Token</name></type> <name>dummy</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setToken</name><argument_list>(<argument><expr>&amp;<name>dummy</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Add a term to the WHERE expression in *ppExpr that requires the
** zCol column to be equal in the two tables pTab1 and pTab2.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>addWhereTerm</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,           <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zCol</name></decl></param>,        <comment type="block">/* Name of the column */</comment>
  <param><decl><type><name>const</name> <name>Table</name> *</type><name>pTab1</name></decl></param>,      <comment type="block">/* First table */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zAlias1</name></decl></param>,     <comment type="block">/* Alias for first table.  May be NULL */</comment>
  <param><decl><type><name>const</name> <name>Table</name> *</type><name>pTab2</name></decl></param>,      <comment type="block">/* Second table */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zAlias2</name></decl></param>,     <comment type="block">/* Alias for second table.  May be NULL */</comment>
  <param><decl><type><name>int</name></type> <name>iRightJoinTable</name></decl></param>,     <comment type="block">/* VDBE cursor for the right table */</comment>
  <param><decl><type><name>Expr</name> **</type><name>ppExpr</name></decl></param>,           <comment type="block">/* Add the equality term to this expression */</comment>
  <param><decl><type><name>int</name></type> <name>isOuterJoin</name></decl></param>          <comment type="block">/* True if dealing with an OUTER join */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pE1a</name>, *<name>pE1b</name>, *<name>pE1c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pE2a</name>, *<name>pE2b</name>, *<name>pE2c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pE1a</name> = <call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pE2a</name> = <call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zAlias1</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>zAlias1</name> = <name>pTab1</name>-&gt;<name>zName</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pE1b</name> = <call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zAlias1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zAlias2</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>zAlias2</name> = <name>pTab2</name>-&gt;<name>zName</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pE2b</name> = <call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zAlias2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pE1c</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, <argument><expr><name>pE1b</name></expr></argument>, <argument><expr><name>pE1a</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pE2c</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, <argument><expr><name>pE2b</name></expr></argument>, <argument><expr><name>pE2a</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pE</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_EQ</name></expr></argument>, <argument><expr><name>pE1c</name></expr></argument>, <argument><expr><name>pE2c</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pE</name> &amp;&amp; <name>isOuterJoin</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pE</name>-&gt;<name>iRightJoinTable</name> = <name>iRightJoinTable</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr>*<name>ppExpr</name> = <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>,<argument><expr>*<name>ppExpr</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the EP_FromJoin property on all terms of the given expression.
** And set the Expr.iRightJoinTable to iTable for every term in the
** expression.
**
** The EP_FromJoin property is used on terms of an expression to tell
** the LEFT OUTER JOIN processing logic that this term is part of the
** join restriction specified in the ON or USING clause and not a part
** of the more general WHERE clause.  These terms are moved over to the
** WHERE clause during join processing but we need to remember that they
** originated in the ON or USING clause.
**
** The Expr.iRightJoinTable tells the WHERE clause processing that the
** expression depends on table iRightJoinTable even if that table is not
** explicitly mentioned in the expression.  That information is needed
** for cases like this:
**
**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5
**
** The where clause needs to defer the handling of the t1.x=5
** term until after the t2 loop of the join.  In that way, a
** NULL t2 row will be inserted whenever t1.x!=5.  If we do not
** defer the handling of t1.x=5, it will be processed immediately
** after the t1 loop and rows with t1.x!=5 will never appear in
** the output, which is incorrect.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>setJoinExpr</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>)</parameter_list><block>{
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>ExprSetProperty</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iRightJoinTable</name> = <name>iTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setJoinExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pRight</name></expr>;</expr_stmt>
  }</block></while> 
}</block></function>

<comment type="block">/*
** This routine processes the join information for a SELECT statement.
** ON and USING clauses are converted into extra terms of the WHERE clause.
** NATURAL joins also create extra WHERE clause terms.
**
** The terms of a FROM clause are contained in the Select.pSrc structure.
** The left most table is the first entry in Select.pSrc.  The right-most
** table is the last entry.  The join operator is held in the entry to
** the left.  Thus entry 0 contains the join operator for the join between
** entries 0 and 1.  Any ON or USING clauses associated with the join are
** also attached to the left entry.
**
** This routine returns the number of errors encountered.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqliteProcessJoin</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>                  <comment type="block">/* All tables in the FROM clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                       <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pLeft</name></decl>;</decl_stmt>     <comment type="block">/* Left table being joined */</comment>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pRight</name></decl>;</decl_stmt>    <comment type="block">/* Right table being joined */</comment>

  <expr_stmt><expr><name>pSrc</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLeft</name> = &amp;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRight</name> = &amp;<name><name>pLeft</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pSrc</name>-&gt;<name>nSrc</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pRight</name>++</expr>, <expr><name>pLeft</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pLeftTab</name> =<init> <expr><name>pLeft</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> *</type><name>pRightTab</name> =<init> <expr><name>pRight</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isOuter</name></decl>;</decl_stmt>

    <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pLeftTab</name>==0 || <name>pRightTab</name>==0</expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>isOuter</name> = (<name>pRight</name>-&gt;<name>jointype</name> &amp; <name>JT_OUTER</name>)!=0</expr>;</expr_stmt>

    <comment type="block">/* When the NATURAL keyword is present, add WHERE clause terms for
    ** every column that the two tables have in common.
    */</comment>
    <if>if<condition>( <expr><name>pRight</name>-&gt;<name>jointype</name> &amp; <name>JT_NATURAL</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pRight</name>-&gt;<name>pOn</name> || <name>pRight</name>-&gt;<name>pUsing</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"a NATURAL join may not have "
           "an ON or USING clause"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pLeftTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><name>pLeftTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><call><name>columnIndex</name><argument_list>(<argument><expr><name>pRightTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>&gt;=0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>addWhereTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pLeftTab</name></expr></argument>, <argument><expr><name>pLeft</name>-&gt;<name>zAlias</name></expr></argument>, 
                              <argument><expr><name>pRightTab</name></expr></argument>, <argument><expr><name>pRight</name>-&gt;<name>zAlias</name></expr></argument>,
                              <argument><expr><name>pRight</name>-&gt;<name>iCursor</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>isOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
        }</block></then></if>
      }</block></for>
    }</block></then></if>

    <comment type="block">/* Disallow both ON and USING clauses in the same join
    */</comment>
    <if>if<condition>( <expr><name>pRight</name>-&gt;<name>pOn</name> &amp;&amp; <name>pRight</name>-&gt;<name>pUsing</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot have both ON and USING "
        "clauses in the same join"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Add the ON clause to the end of the WHERE clause, connected by
    ** an AND operator.
    */</comment>
    <if>if<condition>( <expr><name>pRight</name>-&gt;<name>pOn</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>isOuter</name></expr> )</condition><then> <expr_stmt><expr><call><name>setJoinExpr</name><argument_list>(<argument><expr><name>pRight</name>-&gt;<name>pOn</name></expr></argument>, <argument><expr><name>pRight</name>-&gt;<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>p</name>-&gt;<name>pWhere</name> = <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>pRight</name>-&gt;<name>pOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name>-&gt;<name>pOn</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Create extra terms on the WHERE clause for each column named
    ** in the USING clause.  Example: If the two tables to be joined are 
    ** A and B and the USING clause names X, Y, and Z, then add this
    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z
    ** Report an error if any column mentioned in the USING clause is
    ** not contained in both tables to be joined.
    */</comment>
    <if>if<condition>( <expr><name>pRight</name>-&gt;<name>pUsing</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>IdList</name> *</type><name>pList</name> =<init> <expr><name>pRight</name>-&gt;<name>pUsing</name></expr></init></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pList</name>-&gt;<name>nId</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><call><name>columnIndex</name><argument_list>(<argument><expr><name>pLeftTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>&lt;0 || <call><name>columnIndex</name><argument_list>(<argument><expr><name>pRightTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>&lt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot join using column %s - column "
            "not present in both tables"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr>1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>addWhereTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pLeftTab</name></expr></argument>, <argument><expr><name>pLeft</name>-&gt;<name>zAlias</name></expr></argument>, 
                            <argument><expr><name>pRightTab</name></expr></argument>, <argument><expr><name>pRight</name>-&gt;<name>zAlias</name></expr></argument>,
                            <argument><expr><name>pRight</name>-&gt;<name>iCursor</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>isOuter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Insert code into "v" that will push the record on the top of the
** stack into the sorter.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pushOntoSorter</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* Parser context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,    <comment type="block">/* The ORDER BY clause */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>,       <comment type="block">/* The whole SELECT statement */</comment>
  <param><decl><type><name>int</name></type> <name>regData</name></decl></param>            <comment type="block">/* Register holding data to be sorted */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> =<init> <expr><name>pOrderBy</name>-&gt;<name>nExpr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name> =<init> <expr><call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nExpr</name>+2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sequence</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>iECursor</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regData</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nExpr</name>+1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nExpr</name> + 2</expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>iECursor</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nExpr</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSelect</name>-&gt;<name>iLimit</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>addr1</name>, <name>addr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pSelect</name>-&gt;<name>iOffset</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>iLimit</name> = <name>pSelect</name>-&gt;<name>iOffset</name>+1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>iLimit</name> = <name>pSelect</name>-&gt;<name>iLimit</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>addr1</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfZero</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr2</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Last</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>iECursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>iECursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelect</name>-&gt;<name>iLimit</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Add code to implement the OFFSET
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeOffset</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>,          <comment type="block">/* Generate code into this VM */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,        <comment type="block">/* The SELECT statement being coded */</comment>
  <param><decl><type><name>int</name></type> <name>iContinue</name></decl></param>     <comment type="block">/* Jump here to skip the current record */</comment>
)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>iOffset</name> &amp;&amp; <name>iContinue</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iOffset</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNeg</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "skip OFFSET records")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Add code that will check to make sure the N registers starting at iMem
** form a distinct entry.  iTab is a sorting index that holds previously
** seen combinations of the N values.  A new entry is made in iTab
** if the current N values are new.
**
** A jump to addrRepeat is made and the N+1 values are popped from the
** stack if the top N elements are not distinct.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeDistinct</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>int</name></type> <name>iTab</name></decl></param>,          <comment type="block">/* A sorting index used to test for distinctness */</comment>
  <param><decl><type><name>int</name></type> <name>addrRepeat</name></decl></param>,    <comment type="block">/* Jump to here if not distinct */</comment>
  <param><decl><type><name>int</name></type> <name>N</name></decl></param>,             <comment type="block">/* Number of elements */</comment>
  <param><decl><type><name>int</name></type> <name>iMem</name></decl></param>           <comment type="block">/* First element */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Found</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrRepeat</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Generate an error message when a SELECT is used within a subexpression
** (example:  "a IN (SELECT * FROM table)") but it has more than 1 result
** column.  We do this in a subroutine because the error occurs in multiple
** places.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkForMultiColumnSelectError</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* Parse context. */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>,   <comment type="block">/* Destination of SELECT results */</comment>
  <param><decl><type><name>int</name></type> <name>nExpr</name></decl></param>            <comment type="block">/* Number of result columns returned by SELECT */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> =<init> <expr><name>pDest</name>-&gt;<name>eDest</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>nExpr</name>&gt;1 &amp;&amp; (<name>eDest</name>==<name>SRT_Mem</name> || <name>eDest</name>==<name>SRT_Set</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"only a single result allowed for "
       "a SELECT that is part of an expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>0</expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** This routine generates the code for the inside of the inner loop
** of a SELECT.
**
** If srcTab and nColumn are both zero, then the pEList expressions
** are evaluated in order to get the data for this row.  If nColumn&gt;0
** then data is pulled from srcTab and pEList is used only to get the
** datatypes for each column.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>selectInnerLoop</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,              <comment type="block">/* The complete select statement being coded */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,       <comment type="block">/* List of values being extracted */</comment>
  <param><decl><type><name>int</name></type> <name>srcTab</name></decl></param>,             <comment type="block">/* Pull data from this table */</comment>
  <param><decl><type><name>int</name></type> <name>nColumn</name></decl></param>,            <comment type="block">/* Number of columns in the source table */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,     <comment type="block">/* If not NULL, sort results using this key */</comment>
  <param><decl><type><name>int</name></type> <name>distinct</name></decl></param>,           <comment type="block">/* If &gt;=0, make sure results are distinct */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>,      <comment type="block">/* How to dispose of the results */</comment>
  <param><decl><type><name>int</name></type> <name>iContinue</name></decl></param>,          <comment type="block">/* Jump here to continue with next row */</comment>
  <param><decl><type><name>int</name></type> <name>iBreak</name></decl></param>              <comment type="block">/* Jump here to break out of the inner loop */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasDistinct</name></decl>;</decl_stmt>        <comment type="block">/* True if the DISTINCT keyword is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regResult</name></decl>;</decl_stmt>              <comment type="block">/* Start of memory holding result set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> =<init> <expr><name>pDest</name>-&gt;<name>eDest</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* How to dispose of results */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParm</name> =<init> <expr><name>pDest</name>-&gt;<name>iParm</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* First argument to disposal method */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nResultCol</name></decl>;</decl_stmt>             <comment type="block">/* Number of result columns */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>v</name>==0</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hasDistinct</name> = <name>distinct</name>&gt;=0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOrderBy</name>==0 &amp;&amp; !<name>hasDistinct</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Pull the requested columns.
  */</comment>
  <if>if<condition>( <expr><name>nColumn</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>nResultCol</name> = <name>nColumn</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>nResultCol</name> = <name>pEList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pDest</name>-&gt;<name>iMem</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pDest</name>-&gt;<name>iMem</name> = <name>pParse</name>-&gt;<name>nMem</name>+1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pDest</name>-&gt;<name>nMem</name> = <name>nResultCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>nResultCol</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{ 
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDest</name>-&gt;<name>nMem</name>==<name>nResultCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>regResult</name> = <name>pDest</name>-&gt;<name>iMem</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nColumn</name>&gt;0</expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>srcTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regResult</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then><else>else <if>if<condition>( <expr><name>eDest</name>!=<name>SRT_Exists</name></expr> )</condition><then><block>{
    <comment type="block">/* If the destination is an EXISTS(...) expression, the actual
    ** values returned by the SELECT are not required.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>eDest</name>==<name>SRT_Output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>nColumn</name> = <name>nResultCol</name></expr>;</expr_stmt>

  <comment type="block">/* If the DISTINCT keyword was present on the SELECT statement
  ** and this row has been seen before, then do not make this row
  ** part of the result.
  */</comment>
  <if>if<condition>( <expr><name>hasDistinct</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name>-&gt;<name>nExpr</name>==<name>nColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codeDistinct</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>distinct</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOrderBy</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if<condition>( <expr><call><name>checkForMultiColumnSelectError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

  <switch>switch<condition>( <expr><name>eDest</name></expr> )</condition><block>{
    <comment type="block">/* In this mode, write each query result to the key of the temporary
    ** table iParm.
    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
    <case>case <expr><name>SRT_Union</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/* Construct a record from the query result, but instead of
    ** saving that record, use it as a key to delete elements from
    ** the temporary table iParm.
    */</comment>
    </case><case>case <expr><name>SRT_Except</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxDelete</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Store the result as data using a unique key.
    */</comment>
    </case><case>case <expr><name>SRT_Table</name></expr>:
    </case><case>case <expr><name>SRT_EphemTab</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>r2</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <comment type="block">/* If we are creating a set for an "expr IN (SELECT ...)" construct,
    ** then there should be a single item on the stack.  Write this
    ** item into the set table with bogus data.
    */</comment>
    </case><case>case <expr><name>SRT_Set</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>affinity</name> = <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>affinity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
        <comment type="block">/* At first glance you would think we could optimize out the
        ** ORDER BY in this case since the order of entries in the set
        ** does not matter.  But there might be a LIMIT clause, in which
        ** case the order does matter */</comment>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>affinity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>

    <comment type="block">/* If any row exist in the result set, record that fact and abort.
    */</comment>
    </case><case>case <expr><name>SRT_Exists</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The LIMIT clause will terminate the loop for us */</comment>
      <break>break;</break>
    }</block>

    <comment type="block">/* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell and break out
    ** of the scan loop.
    */</comment>
    </case><case>case <expr><name>SRT_Mem</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The LIMIT clause will jump out of the loop for us */</comment>
      }</block></else></if>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_SUBQUERY */</comment>

    <comment type="block">/* Send the data to the callback function or to a subroutine.  In the
    ** case of a subroutine, the subroutine itself is responsible for
    ** popping the data from the stack.
    */</comment>
    </case><case>case <expr><name>SRT_Coroutine</name></expr>:
    </case><case>case <expr><name>SRT_Output</name></expr>: <block>{
      <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pushOntoSorter</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>eDest</name>==<name>SRT_Coroutine</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regResult</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if>
      <break>break;</break>
    }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Discard the results.  This is used for SELECT statements inside
    ** the body of a TRIGGER.  The purpose of such selects is to call
    ** user-defined functions that have side effects.  We do not care
    ** about the actual results of the select.
    */</comment>
    </case><default>default: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eDest</name>==<name>SRT_Discard</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </default>}</block></switch>

  <comment type="block">/* Jump to the end of the loop if the LIMIT is reached.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>iLimit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* If there is an ORDER BY, the call to
                            ** pushOntoSorter() would have cleared p-&gt;iLimit */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iLimit</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfZero</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iLimit</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Given an expression list, generate a KeyInfo structure that records
** the collating sequence for each expression in that expression list.
**
** If the ExprList is an ORDER BY or GROUP BY clause then the resulting
** KeyInfo structure is appropriate for initializing a virtual index to
** implement that clause.  If the ExprList is the result set of a SELECT
** then the KeyInfo structure is appropriate for initializing a virtual
** index to implement a DISTINCT test.
**
** Space to hold the KeyInfo structure is obtain from malloc.  The calling
** function is responsible for seeing that this structure is eventually
** freed.  Add the KeyInfo structure to the P4 field of an opcode using
** P4_KEYINFO_HANDOFF is the usual way of dealing with this.
*/</comment>
<function><type><name>static</name> <name>KeyInfo</name> *</type><name>keyInfoFromExprList</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nExpr</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pInfo</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pInfo</name></expr></argument>)</argument_list></call> + <name>nExpr</name>*(<call><name>sizeof</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>)</argument_list></call>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pInfo</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>aSortOrder</name> = (<name>u8</name>*)&amp;<name>pInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>nExpr</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>nField</name> = (<name>u16</name>)<name>nExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pInfo</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pColl</name> = <name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pColl</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pInfo</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pItem</name>-&gt;<name>sortOrder</name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>pInfo</name></expr>;</return>
}</block></function>


<comment type="block">/*
** If the inner loop was generated using a non-null pOrderBy argument,
** then the results were placed in a sorter.  After the loop is terminated
** we need to run the sorter and output the results.  The following
** routine generates the code needed to do that.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>generateSortTail</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,        <comment type="block">/* The SELECT statement */</comment>
  <param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>,          <comment type="block">/* Generate code into this VDBE */</comment>
  <param><decl><type><name>int</name></type> <name>nColumn</name></decl></param>,      <comment type="block">/* Number of columns of data */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param> <comment type="block">/* Write the sorted results here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addrBreak</name> =<init> <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>     <comment type="block">/* Jump here to exit loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrContinue</name> =<init> <expr><call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* Jump here for next cycle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pseudoTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pOrderBy</name> =<init> <expr><name>p</name>-&gt;<name>pOrderBy</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>eDest</name> =<init> <expr><name>pDest</name>-&gt;<name>eDest</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iParm</name> =<init> <expr><name>pDest</name>-&gt;<name>iParm</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>regRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iTab</name> = <name>pOrderBy</name>-&gt;<name>iECursor</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eDest</name>==<name>SRT_Output</name> || <name>eDest</name>==<name>SRT_Coroutine</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pseudoTab</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>pseudoTab</name></expr></argument>, <argument><expr><name>eDest</name>==<name>SRT_Output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>addr</name> = 1 + <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sort</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>addrContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRow</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRowid</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>nExpr</name> + 1</expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>eDest</name></expr> )</condition><block>{
    <case>case <expr><name>SRT_Table</name></expr>:
    </case><case>case <expr><name>SRT_EphemTab</name></expr>: <block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name>==<name>SRT_Table</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name>==<name>SRT_EphemTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    </case><case>case <expr><name>SRT_Set</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>affinity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SRT_Mem</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nColumn</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>iParm</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The LIMIT clause will terminate the loop for us */</comment>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>SRT_Output</name></expr>:
    </case><case>case <expr><name>SRT_Coroutine</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name>==<name>SRT_Output</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>eDest</name>==<name>SRT_Coroutine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>pseudoTab</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>regRow</name>!=<name>pDest</name>-&gt;<name>iMem</name>+<name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>pseudoTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iMem</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <if>if<condition>( <expr><name>eDest</name>==<name>SRT_Output</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <comment type="block">/* Do nothing */</comment>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* LIMIT has been implemented by the pushOntoSorter() routine.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>iLimit</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The bottom of the loop
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eDest</name>==<name>SRT_Output</name> || <name>eDest</name>==<name>SRT_Coroutine</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>pseudoTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Return a pointer to a string containing the 'declaration type' of the
** expression pExpr. The string may be treated as static by the caller.
**
** The declaration type is the exact datatype definition extracted from the
** original CREATE TABLE statement if the expression is a column. The
** declaration type for a ROWID field is INTEGER. Exactly when an expression
** is considered a column can be complex in the presence of subqueries. The
** result-set expression in all of the following SELECT statements is 
** considered a column by this function.
**
**   SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl);
**   SELECT abc FROM (SELECT col AS abc FROM tbl);
** 
** The declaration type for any expression other than a column is NULL.
*/</comment>
<function><type><name>static</name> <name>const</name> <name>char</name> *</type><name>columnType</name><parameter_list>(
  <param><decl><type><name>NameContext</name> *</type><name>pNC</name></decl></param>, 
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> **</type><name>pzOriginDb</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> **</type><name>pzOriginTab</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> **</type><name>pzOriginCol</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zType</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zOriginDb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zOriginTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zOriginCol</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pExpr</name>==0 || <name>pNC</name>-&gt;<name>pSrcList</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <switch>switch<condition>( <expr><name>pExpr</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_AGG_COLUMN</name></expr>:
    </case><case>case <expr><name>TK_COLUMN</name></expr>: <block>{
      <comment type="block">/* The expression is a column. Locate the table the column is being
      ** extracted from in NameContext.pSrcList. This table may be real
      ** database table or a subquery.
      */</comment>
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>            <comment type="block">/* Table structure column is extracted from */</comment>
      <decl_stmt><decl><type><name>Select</name> *</type><name>pS</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* Select the column is extracted from */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>pExpr</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Index of column in pTab */</comment>
      <while>while<condition>( <expr><name>pNC</name> &amp;&amp; !<name>pTab</name></expr> )</condition><block>{
        <decl_stmt><decl><type><name>SrcList</name> *</type><name>pTabList</name> =<init> <expr><name>pNC</name>-&gt;<name>pSrcList</name></expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>j</name>=0</expr>;</init><condition><expr><name>j</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name> &amp;&amp; <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>iCursor</name>!=<name>pExpr</name>-&gt;<name>iTable</name></expr>;</condition><incr><expr><name>j</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
        <if>if<condition>( <expr><name>j</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pTab</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pTab</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pS</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pSelect</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>pNC</name> = <name>pNC</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        }</block></else></if>
      }</block></while>

      <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* FIX ME:
        ** This can occurs if you have something like "SELECT new.x;" inside
        ** a trigger.  In other words, if you reference the special "new"
        ** table in the result set of a select.  We do not have a good way
        ** to find the actual table type, so call it "TEXT".  This is really
        ** something of a bug, but I do not know how to fix it.
        **
        ** This code does not produce the correct answer - it just prevents
        ** a segfault.  See ticket #1229.
        */</comment>
        <expr_stmt><expr><name>zType</name> = "TEXT"</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pS</name></expr> )</condition><then><block>{
        <comment type="block">/* The "table" is actually a sub-select or a view in the FROM clause
        ** of the SELECT statement. Return the declaration type and origin
        ** data for the result-set column of the sub-select.
        */</comment>
        <if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iCol</name>&gt;=0 &amp;&amp; <name>iCol</name>&lt;<name>pS</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <comment type="block">/* If iCol is less than zero, then the expression requests the
          ** rowid of the sub-select or view. This expression is legal (see 
          ** test case misc2.2.2) - it always evaluates to NULL.
          */</comment>
          <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name> =<init> <expr><name>pS</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pS</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>sNC</name>.<name>pNext</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pNC</name>-&gt;<name>pParse</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zType</name> = <call><name>columnType</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>zOriginDb</name></expr></argument>, <argument><expr>&amp;<name>zOriginTab</name></expr></argument>, <argument><expr>&amp;<name>zOriginCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <comment type="block">/* A real table */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>iCol</name> = <name>pTab</name>-&gt;<name>iPKey</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name>==-1 || (<name>iCol</name>&gt;=0 &amp;&amp; <name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>zType</name> = "INTEGER"</expr>;</expr_stmt>
          <expr_stmt><expr><name>zOriginCol</name> = "rowid"</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>zType</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zType</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zOriginCol</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>zOriginTab</name> = <name>pTab</name>-&gt;<name>zName</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pNC</name>-&gt;<name>pParse</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pNC</name>-&gt;<name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>zOriginDb</name> = <name>pNC</name>-&gt;<name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if></else></if>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    </case><case>case <expr><name>TK_SELECT</name></expr>: <block>{
      <comment type="block">/* The expression is a sub-select. Return the declaration type and
      ** origin info for the single column in the result set of the SELECT
      ** statement.
      */</comment>
      <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Select</name> *</type><name>pS</name> =<init> <expr><name>pExpr</name>-&gt;<name>pSelect</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name> =<init> <expr><name>pS</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pS</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sNC</name>.<name>pNext</name> = <name>pNC</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pNC</name>-&gt;<name>pParse</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType</name> = <call><name>columnType</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>zOriginDb</name></expr></argument>, <argument><expr>&amp;<name>zOriginTab</name></expr></argument>, <argument><expr>&amp;<name>zOriginCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case>}</block></switch>
  
  <if>if<condition>( <expr><name>pzOriginDb</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pzOriginTab</name> &amp;&amp; <name>pzOriginCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pzOriginDb</name> = <name>zOriginDb</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pzOriginTab</name> = <name>zOriginTab</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pzOriginCol</name> = <name>zOriginCol</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>zType</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code that will tell the VDBE the declaration types of columns
** in the result set.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>generateColumnTypes</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,      <comment type="block">/* Parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,  <comment type="block">/* List of tables */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>    <comment type="block">/* Expressions defining the result set */</comment>
)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DECLTYPE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name> =<init> <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zType</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zOrigDb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zOrigTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zOrigCol</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>zType</name> = <call><name>columnType</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>zOrigDb</name></expr></argument>, <argument><expr>&amp;<name>zOrigTab</name></expr></argument>, <argument><expr>&amp;<name>zOrigCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The vdbe must make its own copy of the column-type and other 
    ** column specific strings, in case the schema is reset before this
    ** virtual machine is deleted.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_DATABASE</name></expr></argument>, <argument><expr><name>zOrigDb</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_TABLE</name></expr></argument>, <argument><expr><name>zOrigTab</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_COLUMN</name></expr></argument>, <argument><expr><name>zOrigCol</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>zType</name> = <call><name>columnType</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_DECLTYPE</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DECLTYPE */</comment>
}</block></function>

<comment type="block">/*
** Generate code that will tell the VDBE the names of columns
** in the result set.  This information is used to provide the
** azCol[] values in the callback.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>generateColumnNames</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,      <comment type="block">/* Parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,  <comment type="block">/* List of tables */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>    <comment type="block">/* Expressions defining the result set */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fullNames</name>, <name>shortNames</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
  <comment type="block">/* If this is an EXPLAIN, skip this step */</comment>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>explain</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>colNamesSet</name> || <call><name>NEVER</name><argument_list>(<argument><expr><name>v</name>==0</expr></argument>)</argument_list></call> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>colNamesSet</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>fullNames</name> = (<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FullColNames</name>)!=0</expr>;</expr_stmt>
  <expr_stmt><expr><name>shortNames</name> = (<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_ShortColNames</name>)!=0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> = <name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>(<name>p</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> || <name>p</name>-&gt;<name>op</name>==<name>TK_AGG_COLUMN</name>) &amp;&amp; <name>pTabList</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>p</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>j</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>iCursor</name>==<name>p</name>-&gt;<name>iTable</name></expr> )</condition><then> <break>break;</break></then></if>
      }</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pTab</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>iCol</name> = <name>pTab</name>-&gt;<name>iPKey</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCol</name>==-1 || (<name>iCol</name>&gt;=0 &amp;&amp; <name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zCol</name> = "rowid"</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zCol</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr>!<name>shortNames</name> &amp;&amp; !<name>fullNames</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, 
            <argument><expr><call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>span</name>.<name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>span</name>.<name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>fullNames</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s.%s"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, 
          <argument><expr><call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>span</name>.<name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>span</name>.<name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></for>
  <expr_stmt><expr><call><name>generateColumnTypes</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<comment type="block">/*
** Name of the connection operator, used for error messages.
*/</comment>
<function><type><name>static</name> <name>const</name> <name>char</name> *</type><name>selectOpName</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>id</name></expr> )</condition><block>{
    <case>case <expr><name>TK_ALL</name></expr>:       <expr_stmt><expr><name>z</name> = "UNION ALL"</expr>;</expr_stmt>   <break>break;</break>
    </case><case>case <expr><name>TK_INTERSECT</name></expr>: <expr_stmt><expr><name>z</name> = "INTERSECT"</expr>;</expr_stmt>   <break>break;</break>
    </case><case>case <expr><name>TK_EXCEPT</name></expr>:    <expr_stmt><expr><name>z</name> = "EXCEPT"</expr>;</expr_stmt>      <break>break;</break>
    </case><default>default:           <expr_stmt><expr><name>z</name> = "UNION"</expr>;</expr_stmt>       <break>break;</break>
  </default>}</block></switch>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPOUND_SELECT */</comment>

<comment type="block">/*
** Given a an expression list (which is really the list of expressions
** that form the result set of a SELECT statement) compute appropriate
** column names for a table that would hold the expression list.
**
** All column names will be unique.
**
** Only the column names are computed.  Column.zType, Column.zColl,
** and other fields of Column are zeroed.
**
** Return SQLITE_OK on success.  If a memory allocation error occurs,
** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>selectColumnsFromExprList</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,       <comment type="block">/* Expr list from which to derive column names */</comment>
  <param><decl><type><name>int</name> *</type><name>pnCol</name></decl></param>,             <comment type="block">/* Write the number of columns here */</comment>
  <param><decl><type><name>Column</name> **</type><name>paCol</name></decl></param>          <comment type="block">/* Write the new column list here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>                    <comment type="block">/* Index added to make the name unique */</comment>
  <decl_stmt><decl><type><name>Column</name> *</type><name>aCol</name>, *<name>pCol</name></decl>;</decl_stmt>        <comment type="block">/* For looping over result columns */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the result set */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name></decl>;</decl_stmt>                    <comment type="block">/* Expression for a single result column */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>                <comment type="block">/* Column name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                  <comment type="block">/* Size of name in zName[] */</comment>

  <expr_stmt><expr>*<name>pnCol</name> = <name>nCol</name> = <name>pEList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aCol</name> = *<name>paCol</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>aCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>aCol</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pCol</name>=<name>aCol</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
    <comment type="block">/* Get an appropriate name for the column
    */</comment>
    <expr_stmt><expr><name>p</name> = <name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pRight</name>==0 || <name>p</name>-&gt;<name>pRight</name>-&gt;<name>token</name>.<name>z</name>==0 || <name>p</name>-&gt;<name>pRight</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>zName</name> = <name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name>)!=0</expr> )</condition><then><block>{
      <comment type="block">/* If the column contains an "AS &lt;name&gt;" phrase, use &lt;name&gt; as the name */</comment>
      <expr_stmt><expr><name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pColExpr</name> =<init> <expr><name>p</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The expression that is the result column name */</comment>
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>         <comment type="block">/* Table associated with this expression */</comment>
      <while>while<condition>( <expr><name>pColExpr</name>-&gt;<name>op</name>==<name>TK_DOT</name></expr> )</condition> <expr_stmt><expr><name>pColExpr</name> = <name>pColExpr</name>-&gt;<name>pRight</name></expr>;</expr_stmt></while>
      <if>if<condition>( <expr><name>pColExpr</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> &amp;&amp; (<name>pTab</name> = <name>pColExpr</name>-&gt;<name>pTab</name>)!=0</expr> )</condition><then><block>{
        <comment type="block">/* For columns use the column name name */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>pColExpr</name>-&gt;<name>iColumn</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>iCol</name> = <name>pTab</name>-&gt;<name>iPKey</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>zName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>,
                 <argument><expr><name>iCol</name>&gt;=0 ? <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zName</name> : "rowid"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* Use the original text of the column expression as its name */</comment>
        <decl_stmt><decl><type><name>Token</name> *</type><name>pToken</name> =<init> <expr>(<name>pColExpr</name>-&gt;<name>span</name>.<name>z</name>?&amp;<name>pColExpr</name>-&gt;<name>span</name>:&amp;<name>pColExpr</name>-&gt;<name>token</name>)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%T"</expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make sure the column name is unique.  If the name is not unique,
    ** append a integer to the name so that it becomes unique.
    */</comment>
    <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=<name>cnt</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zNewName</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>zName</name><index>[<expr><name>nName</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>zNewName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s:%d"</expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>++<name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zName</name> = <name>zNewName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = -1</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>zName</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>zName</name> = <name>zName</name></expr>;</expr_stmt>
  }</block></for>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>paCol</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pnCol</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add type and collation information to a column list based on
** a SELECT statement.
** 
** The column list presumably came from selectColumnNamesFromExprList().
** The column list has only names, not types or collations.  This
** routine goes through and adds the types and collations.
**
** This routine requires that all indentifiers in the SELECT
** statement be resolved.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>selectAddColumnTypeAndCollation</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing contexts */</comment>
  <param><decl><type><name>int</name></type> <name>nCol</name></decl></param>,             <comment type="block">/* Number of columns */</comment>
  <param><decl><type><name>Column</name> *</type><name>aCol</name></decl></param>,         <comment type="block">/* List of columns */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>       <comment type="block">/* SELECT used to determine types and collations */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>a</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSelect</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pSelect</name>-&gt;<name>selFlags</name> &amp; <name>SF_Resolved</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCol</name>==<name>pSelect</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pSelect</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>a</name> = <name>pSelect</name>-&gt;<name>pEList</name>-&gt;<name>a</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pCol</name>=<name>aCol</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>zType</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>columnType</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>affinity</name> = <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCol</name>-&gt;<name>zColl</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Given a SELECT statement, generate a Table structure that describes
** the result set of that SELECT.
*/</comment>
<function><type><name>Table</name> *</type><name>sqlite3ResultSetOfSelect</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>savedFlags</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>savedFlags</name> = <name>db</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> &amp;= ~<name>SQLITE_FullColNames</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_ShortColNames</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <while>while<condition>( <expr><name>pSelect</name>-&gt;<name>pPrior</name></expr> )</condition> <expr_stmt><expr><name>pSelect</name> = <name>pSelect</name>-&gt;<name>pPrior</name></expr>;</expr_stmt></while>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> = <name>savedFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>zName</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr>&amp;<name>pTab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr>&amp;<name>pTab</name>-&gt;<name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>selectAddColumnTypeAndCollation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>aCol</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>iPKey</name> = -1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <return>return <expr><name>pTab</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Get a VDBE for the given parser context.  Create a new one if necessary.
** If an error occurs, return NULL and leave a message in pParse.
*/</comment>
<function><type><name>Vdbe</name> *</type><name>sqlite3GetVdbe</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name> = <call><name>sqlite3VdbeCreate</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
    <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <return>return <expr><name>v</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Compute the iLimit and iOffset fields of the SELECT based on the
** pLimit and pOffset expressions.  pLimit and pOffset hold the expressions
** that appear in the original SQL statement after the LIMIT and OFFSET
** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset 
** are the integer memory register numbers for counters used to compute 
** the limit and offset.  If there is no limit and/or offset, then 
** iLimit and iOffset are negative.
**
** This routine changes the values of iLimit and iOffset only if
** a limit or offset is defined by pLimit and pOffset.  iLimit and
** iOffset should have been preset to appropriate default values
** (usually but not always -1) prior to calling this routine.
** Only if pLimit!=0 or pOffset!=0 do the limit registers get
** redefined.  The UNION ALL operator uses this property to force
** the reuse of the same limit and offset registers across multiple
** SELECT statements.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>computeLimitRegisters</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iBreak</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>iLimit</name></expr> )</condition><then> <return>return;</return></then></if>

  <comment type="block">/* 
  ** "LIMIT -1" always shows all rows.  There is some
  ** contraversy about what the correct behavior should be.
  ** The current implementation interprets "LIMIT 0" to mean
  ** no rows.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pLimit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>iLimit</name> = <name>iLimit</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "LIMIT counter")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfZero</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pOffset</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>iOffset</name> = <name>iOffset</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pLimit</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name>++</expr>;</expr_stmt>   <comment type="block">/* Allocate an extra register for limit+offset */</comment>
    }</block></then></if>
    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOffset</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "OFFSET counter")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr1</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pLimit</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Add</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>iOffset</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "LIMIT+OFFSET")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addr1</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>iOffset</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<comment type="block">/*
** Return the appropriate collating sequence for the iCol-th column of
** the result set for the compound-select statement "p".  Return NULL if
** the column has no default collating sequence.
**
** The collating sequence for the compound select is taken from the
** left-most term of the select that has a collating sequence.
*/</comment>
<function><type><name>static</name> <name>CollSeq</name> *</type><name>multiSelectCollSeq</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCol</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pRet</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrior</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pRet</name> = <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pRet</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pRet</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pRet</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pRet</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPOUND_SELECT */</comment>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>multiSelectOrderBy</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list>;</function_decl>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<comment type="block">/*
** This routine is called to process a compound query form from
** two or more separate queries using UNION, UNION ALL, EXCEPT, or
** INTERSECT
**
** "p" points to the right-most of the two queries.  the query on the
** left is p-&gt;pPrior.  The left query could also be a compound query
** in which case this routine will be called recursively. 
**
** The results of the total query are to be written into a destination
** of type eDest with parameter iParm.
**
** Example 1:  Consider a three-way compound SQL statement.
**
**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3
**
** This statement is parsed up as follows:
**
**     SELECT c FROM t3
**      |
**      `-----&gt;  SELECT b FROM t2
**                |
**                `------&gt;  SELECT a FROM t1
**
** The arrows in the diagram above represent the Select.pPrior pointer.
** So if this routine is called with p equal to the t3 query, then
** pPrior will be the t2 query.  p-&gt;op will be TK_UNION in this case.
**
** Notice that because of the way SQLite parses compound SELECTs, the
** individual selects always group from left to right.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>multiSelect</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Success code from a subroutine */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pPrior</name></decl>;</decl_stmt>       <comment type="block">/* Another SELECT immediately to our left */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code to this VDBE */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>      <comment type="block">/* Alternative data destination */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pDelete</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Chain of simple selects to delete */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>

  <comment type="block">/* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>pPrior</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Calling function guarantees this much */</comment>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name> = <name>p</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name>-&gt;<name>pRightmost</name>!=<name>pPrior</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name>-&gt;<name>pRightmost</name>==<name>p</name>-&gt;<name>pRightmost</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dest</name> = *<name>pDest</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPrior</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr>"ORDER BY clause should come after %s not before"</expr></argument>,
      <argument><expr><call><name>selectOpName</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>multi_select_end</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPrior</name>-&gt;<name>pLimit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr>"LIMIT clause should come after %s not before"</expr></argument>,
      <argument><expr><call><name>selectOpName</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>multi_select_end</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The VDBE already created by calling function */</comment>

  <comment type="block">/* Create the destination temporary table if necessary
  */</comment>
  <if>if<condition>( <expr><name>dest</name>.<name>eDest</name>==<name>SRT_EphemTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>dest</name>.<name>iParm</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dest</name>.<name>eDest</name> = <name>SRT_Table</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Make sure all SELECTs in the statement have the same number of elements
  ** in their result sets.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name> &amp;&amp; <name>pPrior</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name>!=<name>pPrior</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"SELECTs to the left and right of %s"
      " do not have the same number of result columns"</expr></argument>, <argument><expr><call><name>selectOpName</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>multi_select_end</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Compound SELECTs that have an ORDER BY clause are handled separately.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>multiSelectOrderBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Generate code for the left and right SELECT statements.
  */</comment>
  <switch>switch<condition>( <expr><name>p</name>-&gt;<name>op</name></expr> )</condition><block>{
    <case>case <expr><name>TK_ALL</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPrior</name>-&gt;<name>pLimit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrior</name>-&gt;<name>pLimit</name> = <name>p</name>-&gt;<name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPrior</name>-&gt;<name>pOffset</name> = <name>p</name>-&gt;<name>pOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>iLimit</name> = <name>pPrior</name>-&gt;<name>iLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>iOffset</name> = <name>pPrior</name>-&gt;<name>iOffset</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>iLimit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfZero</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "Jump ahead if LIMIT reached")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDelete</name> = <name>p</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = <name>pPrior</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>
      <if>if<condition>( <expr><name>addr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_EXCEPT</name></expr>:
    </case><case>case <expr><name>TK_UNION</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>unionTab</name></decl>;</decl_stmt>    <comment type="block">/* Cursor number of the temporary table holding result */</comment>
      <decl_stmt><decl><type><name>u8</name></type> <name>op</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* One of the SRT_ operations to apply to self */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>priorOp</name></decl>;</decl_stmt>     <comment type="block">/* The SRT_ operation to apply to prior selects */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLimit</name>, *<name>pOffset</name></decl>;</decl_stmt> <comment type="block">/* Saved values of p-&gt;nLimit and p-&gt;nOffset */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>uniondest</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>priorOp</name> = <name>SRT_Union</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>dest</name>.<name>eDest</name>==<name>priorOp</name> &amp;&amp; <call><name>ALWAYS</name><argument_list>(<argument><expr>!<name>p</name>-&gt;<name>pLimit</name> &amp;&amp;!<name>p</name>-&gt;<name>pOffset</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <comment type="block">/* We can reuse a temporary table generated by a SELECT to our
        ** right.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pRightmost</name>!=<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Can only happen for leftward elements
                                     ** of a 3-way or more compound */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pLimit</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Not allowed on leftward elements */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pOffset</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* Not allowed on leftward elements */</comment>
        <expr_stmt><expr><name>unionTab</name> = <name>dest</name>.<name>iParm</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* We will need to create our own temporary table to hold the
        ** intermediate results.
        */</comment>
        <expr_stmt><expr><name>unionTab</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pOrderBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> == -1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> = <name>addr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>pRightmost</name>-&gt;<name>selFlags</name> |= <name>SF_UsesEphemeral</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <comment type="block">/* Code the SELECT statements to our left
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPrior</name>-&gt;<name>pOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>uniondest</name></expr></argument>, <argument><expr><name>priorOp</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr>&amp;<name>uniondest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>

      <comment type="block">/* Code the current SELECT statement
      */</comment>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>op</name>==<name>TK_EXCEPT</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>op</name> = <name>SRT_Except</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>op</name>==<name>TK_UNION</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>op</name> = <name>SRT_Union</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLimit</name> = <name>p</name>-&gt;<name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOffset</name> = <name>p</name>-&gt;<name>pOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>uniondest</name>.<name>eDest</name> = <name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>uniondest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Query flattening in sqlite3Select() might refill p-&gt;pOrderBy.
      ** Be sure to delete p-&gt;pOrderBy, therefore, to avoid a memory leak. */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDelete</name> = <name>p</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = <name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = <name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = <name>pOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>iLimit</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>iOffset</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>


      <comment type="block">/* Convert the data in the temporary table into whatever form
      ** it is that we currently need.
      */</comment>      
      <if>if<condition>( <expr><name>dest</name>.<name>eDest</name>!=<name>priorOp</name> || <name>unionTab</name>!=<name>dest</name>.<name>iParm</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>iCont</name>, <name>iBreak</name>, <name>iStart</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>dest</name>.<name>eDest</name>==<name>SRT_Output</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>Select</name> *</type><name>pFirst</name> =<init> <expr><name>p</name></expr></init></decl>;</decl_stmt>
          <while>while<condition>( <expr><name>pFirst</name>-&gt;<name>pPrior</name></expr> )</condition> <expr_stmt><expr><name>pFirst</name> = <name>pFirst</name>-&gt;<name>pPrior</name></expr>;</expr_stmt></while>
          <expr_stmt><expr><call><name>generateColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFirst</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>iBreak</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iCont</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument>,
                        <argument><expr>0</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>unionTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>TK_INTERSECT</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tab1</name>, <name>tab2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iCont</name>, <name>iBreak</name>, <name>iStart</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLimit</name>, *<name>pOffset</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>intersectdest</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>

      <comment type="block">/* INTERSECT is different from the others since it requires
      ** two temporary tables.  Hence it has its own case.  Begin
      ** by allocating the tables we will need.
      */</comment>
      <expr_stmt><expr><name>tab1</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>tab2</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pOrderBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> == -1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>0</expr>]</index></name> = <name>addr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pRightmost</name>-&gt;<name>selFlags</name> |= <name>SF_UsesEphemeral</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Code the SELECTs to our left into temporary table "tab1".
      */</comment>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>intersectdest</name></expr></argument>, <argument><expr><name>SRT_Union</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr>&amp;<name>intersectdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>

      <comment type="block">/* Code the current SELECT into temporary table "tab2"
      */</comment>
      <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>1</expr>]</index></name> == -1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>1</expr>]</index></name> = <name>addr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLimit</name> = <name>p</name>-&gt;<name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOffset</name> = <name>p</name>-&gt;<name>pOffset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>intersectdest</name>.<name>iParm</name> = <name>tab2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>intersectdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDelete</name> = <name>p</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = <name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = <name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = <name>pOffset</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <goto>goto <name>multi_select_end</name>;</goto>
      }</block></then></if>

      <comment type="block">/* Generate code to take the intersection of the two temporary
      ** tables.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>dest</name>.<name>eDest</name>==<name>SRT_Output</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Select</name> *</type><name>pFirst</name> =<init> <expr><name>p</name></expr></init></decl>;</decl_stmt>
        <while>while<condition>( <expr><name>pFirst</name>-&gt;<name>pPrior</name></expr> )</condition> <expr_stmt><expr><name>pFirst</name> = <name>pFirst</name>-&gt;<name>pPrior</name></expr>;</expr_stmt></while>
        <expr_stmt><expr><call><name>generateColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFirst</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>iBreak</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iCont</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iStart</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowKey</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotFound</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument>,
                      <argument><expr>0</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>tab2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>tab1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </case>}</block></switch>

  <comment type="block">/* Compute collating sequences used by 
  ** temporary tables needed to implement the compound select.
  ** Attach the KeyInfo structure to all temporary tables.
  **
  ** This section is run by the right-most SELECT statement only.
  ** SELECT statements to the left always skip this part.  The right-most
  ** SELECT might also skip this part if it has no ORDER BY clause and
  ** no temp tables are required.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_UsesEphemeral</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
    <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>            <comment type="block">/* Collating sequence for the result set */</comment>
    <decl_stmt><decl><type><name>Select</name> *</type><name>pLoop</name></decl>;</decl_stmt>                <comment type="block">/* For looping through SELECT statements */</comment>
    <decl_stmt><decl><type><name>CollSeq</name> **</type><name>apColl</name></decl>;</decl_stmt>             <comment type="block">/* For looping through pKeyInfo-&gt;aColl[] */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                     <comment type="block">/* Number of columns in result set */</comment>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pRightmost</name>==<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nCol</name> = <name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                       <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pKeyInfo</name></expr></argument>)</argument_list></call>+<name>nCol</name>*(<call><name>sizeof</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>)</argument_list></call> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pKeyInfo</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>multi_select_end</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>pKeyInfo</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyInfo</name>-&gt;<name>nField</name> = (<name>u16</name>)<name>nCol</name></expr>;</expr_stmt>

    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>apColl</name>=<name>pKeyInfo</name>-&gt;<name>aColl</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>apColl</name>++</expr></incr>)<block>{
      <expr_stmt><expr>*<name>apColl</name> = <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>0==*<name>apColl</name></expr> )</condition><then><block>{
        <expr_stmt><expr>*<name>apColl</name> = <name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>

    <for>for(<init><expr><name>pLoop</name>=<name>p</name></expr>;</init> <condition><expr><name>pLoop</name></expr>;</condition> <incr><expr><name>pLoop</name>=<name>pLoop</name>-&gt;<name>pPrior</name></expr></incr>)<block>{
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>addr</name> =<init> <expr><name>pLoop</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>addr</name>&lt;0</expr> )</condition><then><block>{
          <comment type="block">/* If [0] is unused then [1] is also unused.  So we can
          ** always safely abort as soon as the first unused slot is found */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLoop</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>1</expr>]</index></name>&lt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLoop</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
      }</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pKeyInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<label><name>multi_select_end</name>:</label>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>iMem</name> = <name>dest</name>.<name>iMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDest</name>-&gt;<name>nMem</name> = <name>dest</name>.<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPOUND_SELECT */</comment>

<comment type="block">/*
** Code an output subroutine for a coroutine implementation of a
** SELECT statment.
**
** The data to be output is contained in pIn-&gt;iMem.  There are
** pIn-&gt;nMem columns to be output.  pDest is where the output should
** be sent.
**
** regReturn is the number of the register holding the subroutine
** return address.
**
** If regPrev&gt;0 then it is a the first register in a vector that
** records the previous output.  mem[regPrev] is a flag that is false
** if there has been no previous output.  If regPrev&gt;0 then code is
** generated to suppress duplicates.  pKeyInfo is used for comparing
** keys.
**
** If the LIMIT found in p-&gt;iLimit is reached, jump immediately to
** iBreak.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>generateOutputSubroutine</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,              <comment type="block">/* The SELECT statement */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pIn</name></decl></param>,        <comment type="block">/* Coroutine supplying data */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>,      <comment type="block">/* Where to send the data */</comment>
  <param><decl><type><name>int</name></type> <name>regReturn</name></decl></param>,          <comment type="block">/* The return address register */</comment>
  <param><decl><type><name>int</name></type> <name>regPrev</name></decl></param>,            <comment type="block">/* Previous result register.  No uniqueness if 0 */</comment>
  <param><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl></param>,      <comment type="block">/* For comparing with previous entry */</comment>
  <param><decl><type><name>int</name></type> <name>p4type</name></decl></param>,             <comment type="block">/* The p4 type for pKeyInfo */</comment>
  <param><decl><type><name>int</name></type> <name>iBreak</name></decl></param>              <comment type="block">/* Jump here if we hit the LIMIT */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iContinue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iContinue</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Suppress duplicates for UNION, EXCEPT, and INTERSECT 
  */</comment>
  <if>if<condition>( <expr><name>regPrev</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j1</name>, <name>j2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfNot</name></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j2</name> = <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>regPrev</name>+1</expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>,
                              <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>j2</name>+2</expr></argument>, <argument><expr><name>iContinue</name></expr></argument>, <argument><expr><name>j2</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCodeCopy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>regPrev</name>+1</expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* Suppress the the first OFFSET entries if there is an OFFSET clause
  */</comment>
  <expr_stmt><expr><call><name>codeOffset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch<condition>( <expr><name>pDest</name>-&gt;<name>eDest</name></expr> )</condition><block>{
    <comment type="block">/* Store the result as data using a unique key.
    */</comment>
    <case>case <expr><name>SRT_Table</name></expr>:
    </case><case>case <expr><name>SRT_EphemTab</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>r2</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
    <comment type="block">/* If we are creating a set for an "expr IN (SELECT ...)" construct,
    ** then there should be a single item on the stack.  Write this
    ** item into the set table with bogus data.
    */</comment>
    </case><case>case <expr><name>SRT_Set</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn</name>-&gt;<name>nMem</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>affinity</name> = 
         <call><name>sqlite3CompareAffinity</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>affinity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>affinity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>  <comment type="block">/* Never occurs on an ORDER BY query */</comment>
    <comment type="block">/* If any row exist in the result set, record that fact and abort.
    */</comment>
    case SRT_Exists: {
      sqlite3VdbeAddOp2(v, OP_Integer, 1, pDest-&gt;iParm);
      <comment type="block">/* The LIMIT clause will terminate the loop for us */</comment>
      break;
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell and break out
    ** of the scan loop.
    */</comment>
    </case><case>case <expr><name>SRT_Mem</name></expr>: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn</name>-&gt;<name>nMem</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The LIMIT clause will jump out of the loop for us */</comment>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_SUBQUERY */</comment>

    <comment type="block">/* The results are stored in a sequence of registers
    ** starting at pDest-&gt;iMem.  Then the co-routine yields.
    */</comment>
    </case><case>case <expr><name>SRT_Coroutine</name></expr>: <block>{
      <if>if<condition>( <expr><name>pDest</name>-&gt;<name>iMem</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDest</name>-&gt;<name>iMem</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDest</name>-&gt;<name>nMem</name> = <name>pIn</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/* Results are stored in a sequence of registers.  Then the
    ** OP_ResultRow opcode is used to cause sqlite3_step() to return
    ** the next row of result.
    */</comment>
    </case><case>case <expr><name>SRT_Output</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Discard the results.  This is used for SELECT statements inside
    ** the body of a TRIGGER.  The purpose of such selects is to call
    ** user-defined functions that have side effects.  We do not care
    ** about the actual results of the select.
    */</comment>
    </case><default>default: <block>{
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </default>}</block></switch>

  <comment type="block">/* Jump to the end of the loop if the LIMIT is reached.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>iLimit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iLimit</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfZero</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iLimit</name></expr></argument>, <argument><expr><name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Generate the subroutine return
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iContinue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>addr</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Alternative compound select code generator for cases when there
** is an ORDER BY clause.
**
** We assume a query of the following form:
**
**      &lt;selectA&gt;  &lt;operator&gt;  &lt;selectB&gt;  ORDER BY &lt;orderbylist&gt;
**
** &lt;operator&gt; is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea
** is to code both &lt;selectA&gt; and &lt;selectB&gt; with the ORDER BY clause as
** co-routines.  Then run the co-routines in parallel and merge the results
** into the output.  In addition to the two coroutines (called selectA and
** selectB) there are 7 subroutines:
**
**    outA:    Move the output of the selectA coroutine into the output
**             of the compound query.
**
**    outB:    Move the output of the selectB coroutine into the output
**             of the compound query.  (Only generated for UNION and
**             UNION ALL.  EXCEPT and INSERTSECT never output a row that
**             appears only in B.)
**
**    AltB:    Called when there is data from both coroutines and A&lt;B.
**
**    AeqB:    Called when there is data from both coroutines and A==B.
**
**    AgtB:    Called when there is data from both coroutines and A&gt;B.
**
**    EofA:    Called when data is exhausted from selectA.
**
**    EofB:    Called when data is exhausted from selectB.
**
** The implementation of the latter five subroutines depend on which 
** &lt;operator&gt; is used:
**
**
**             UNION ALL         UNION            EXCEPT          INTERSECT
**          -------------  -----------------  --------------  -----------------
**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA
**
**   AeqB:   outA, nextA         nextA             nextA         outA, nextA
**
**   AgtB:   outB, nextB      outB, nextB          nextB            nextB
**
**   EofA:   outB, nextB      outB, nextB          halt             halt
**
**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt
**
** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA
** causes an immediate jump to EofA and an EOF on B following nextB causes
** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or
** following nextX causes a jump to the end of the select processing.
**
** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled
** within the output subroutine.  The regPrev register set holds the previously
** output value.  A comparison is made against this value and the output
** is skipped if the next results would be the same as the previous.
**
** The implementation plan is to implement the two coroutines and seven
** subroutines first, then put the control logic at the bottom.  Like this:
**
**          goto Init
**     coA: coroutine for left query (A)
**     coB: coroutine for right query (B)
**    outA: output one row of A
**    outB: output one row of B (UNION and UNION ALL only)
**    EofA: ...
**    EofB: ...
**    AltB: ...
**    AeqB: ...
**    AgtB: ...
**    Init: initialize coroutine registers
**          yield coA
**          if eof(A) goto EofA
**          yield coB
**          if eof(B) goto EofB
**    Cmpr: Compare A, B
**          Jump AltB, AeqB, AgtB
**     End: ...
**
** We call AltB, AeqB, AgtB, EofA, and EofB "subroutines" but they are not
** actually called using Gosub and they do not Return.  EofA and EofB loop
** until all data is exhausted then jump to the "end" labe.  AltB, AeqB,
** and AgtB jump to either L2 or to one of EofA or EofB.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
<function><type><name>static</name> <name>int</name></type> <name>multiSelectOrderBy</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,            <comment type="block">/* The right-most of SELECTs to be coded */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>     <comment type="block">/* What to do with query results */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>             <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pPrior</name></decl>;</decl_stmt>       <comment type="block">/* Another SELECT immediately to our left */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>              <comment type="block">/* Generate code to this VDBE */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>destA</name></decl>;</decl_stmt>     <comment type="block">/* Destination for coroutine A */</comment>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>destB</name></decl>;</decl_stmt>     <comment type="block">/* Destination for coroutine B */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAddrA</name></decl>;</decl_stmt>         <comment type="block">/* Address register for select-A coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regEofA</name></decl>;</decl_stmt>          <comment type="block">/* Flag to indicate when select-A is complete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regAddrB</name></decl>;</decl_stmt>         <comment type="block">/* Address register for select-B coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regEofB</name></decl>;</decl_stmt>          <comment type="block">/* Flag to indicate when select-B is complete */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSelectA</name></decl>;</decl_stmt>      <comment type="block">/* Address of the select-A coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSelectB</name></decl>;</decl_stmt>      <comment type="block">/* Address of the select-B coroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOutA</name></decl>;</decl_stmt>          <comment type="block">/* Address register for the output-A subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOutB</name></decl>;</decl_stmt>          <comment type="block">/* Address register for the output-B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOutA</name></decl>;</decl_stmt>         <comment type="block">/* Address of the output-A subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrOutB</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Address of the output-B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEofA</name></decl>;</decl_stmt>         <comment type="block">/* Address of the select-A-exhausted subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrEofB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the select-B-exhausted subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAltB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A&lt;B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAeqB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A==B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrAgtB</name></decl>;</decl_stmt>         <comment type="block">/* Address of the A&gt;B subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regLimitA</name></decl>;</decl_stmt>        <comment type="block">/* Limit register for select-A */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regLimitB</name></decl>;</decl_stmt>        <comment type="block">/* Limit register for select-A */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regPrev</name></decl>;</decl_stmt>          <comment type="block">/* A range of registers to hold previous output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedLimit</name></decl>;</decl_stmt>       <comment type="block">/* Saved value of p-&gt;iLimit */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>savedOffset</name></decl>;</decl_stmt>      <comment type="block">/* Saved value of p-&gt;iOffset */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelCmpr</name></decl>;</decl_stmt>        <comment type="block">/* Label for the start of the merge algorithm */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>labelEnd</name></decl>;</decl_stmt>         <comment type="block">/* Label for the end of the overall SELECT stmt */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j1</name></decl>;</decl_stmt>               <comment type="block">/* Jump instructions that get retargetted */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>               <comment type="block">/* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyDup</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Comparison information for duplicate removal */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyMerge</name></decl>;</decl_stmt>   <comment type="block">/* Comparison information for merging rows */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl>;</decl_stmt>   <comment type="block">/* The ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>         <comment type="block">/* Number of terms in the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aPermute</name></decl>;</decl_stmt>        <comment type="block">/* Mapping from ORDER BY terms to result set columns */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pOrderBy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pKeyDup</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* "Managed" code needs this.  Ticket #3382. */</comment>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
  <expr_stmt><expr><name>labelEnd</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>labelCmpr</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Patch up the ORDER BY clause
  */</comment>
  <expr_stmt><expr><name>op</name> = <name>p</name>-&gt;<name>op</name></expr>;</expr_stmt>  
  <expr_stmt><expr><name>pPrior</name> = <name>p</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name>-&gt;<name>pOrderBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrderBy</name> = <name>p</name>-&gt;<name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOrderBy</name> = <name>pOrderBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>

  <comment type="block">/* For operators other than UNION ALL we have to make sure that
  ** the ORDER BY clause covers every term of the result set.  Add
  ** terms to the ORDER BY clause as necessary.
  */</comment>
  <if>if<condition>( <expr><name>op</name>!=<name>TK_ALL</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>db</name>-&gt;<name>mallocFailed</name>==0 &amp;&amp; <name>i</name>&lt;=<name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pItem</name>=<name>pOrderBy</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>nOrderBy</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name>-&gt;<name>iCol</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pItem</name>-&gt;<name>iCol</name>==<name>i</name></expr> )</condition><then> <break>break;</break></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>j</name>==<name>nOrderBy</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name> =<init> <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_INTEGER</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></then></if>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>flags</name> |= <name>EP_IntValue</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>iTable</name> = <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOrderBy</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>nOrderBy</name>++</expr>]</index></name>.<name>iCol</name> = (<name>u16</name>)<name>i</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>

  <comment type="block">/* Compute the comparison permutation and keyinfo that is used with
  ** the permutation in order to comparisons to determine if the next
  ** row of results comes from selectA or selectB.  Also add explicit
  ** collations to the ORDER BY clause terms so that when the subqueries
  ** to the right and the left are evaluated, they use the correct
  ** collation.
  */</comment>
  <expr_stmt><expr><name>aPermute</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>*<name>nOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>aPermute</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pItem</name>=<name>pOrderBy</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name>-&gt;<name>iCol</name>&gt;0  &amp;&amp; <name>pItem</name>-&gt;<name>iCol</name>&lt;=<name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pItem</name>-&gt;<name>iCol</name> - 1</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pKeyMerge</name> =
      <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pKeyMerge</name></expr></argument>)</argument_list></call>+<name>nOrderBy</name>*(<call><name>sizeof</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>)</argument_list></call>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pKeyMerge</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pKeyMerge</name>-&gt;<name>aSortOrder</name> = (<name>u8</name>*)&amp;<name>pKeyMerge</name>-&gt;<name><name>aColl</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyMerge</name>-&gt;<name>nField</name> = (<name>u16</name>)<name>nOrderBy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyMerge</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> *</type><name>pTerm</name> =<init> <expr><name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pColl</name> = <name>pTerm</name>-&gt;<name>pColl</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>pColl</name> = <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>aPermute</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTerm</name>-&gt;<name>flags</name> |= <name>EP_ExpCollate</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pTerm</name>-&gt;<name>pColl</name> = <name>pColl</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>pKeyMerge</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pColl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pKeyMerge</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sortOrder</name></expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pKeyMerge</name> = 0</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Reattach the ORDER BY clause to the query.
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name>-&gt;<name>pOrderBy</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a range of temporary registers and the KeyInfo needed
  ** for the logic that removes duplicate result rows when the
  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).
  */</comment>
  <if>if<condition>( <expr><name>op</name>==<name>TK_ALL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>regPrev</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nExpr</name> =<init> <expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOrderBy</name>&gt;=<name>nExpr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regPrev</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nExpr</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regPrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyDup</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pKeyDup</name></expr></argument>)</argument_list></call> + <name>nExpr</name>*(<call><name>sizeof</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>)</argument_list></call>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pKeyDup</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pKeyDup</name>-&gt;<name>aSortOrder</name> = (<name>u8</name>*)&amp;<name>pKeyDup</name>-&gt;<name><name>aColl</name><index>[<expr><name>nExpr</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyDup</name>-&gt;<name>nField</name> = (<name>u16</name>)<name>nExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyDup</name>-&gt;<name>enc</name> = <call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>pKeyDup</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>multiSelectCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pKeyDup</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>
  }</block></else></if>
 
  <comment type="block">/* Separate the left and the right query from one another
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name>-&gt;<name>pRightmost</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>, <argument><expr>"ORDER"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPrior</name>-&gt;<name>pPrior</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ResolveOrderGroupBy</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>pPrior</name>-&gt;<name>pOrderBy</name></expr></argument>, <argument><expr>"ORDER"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Compute the limit registers */</comment>
  <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>iLimit</name> &amp;&amp; <name>op</name>==<name>TK_ALL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>regLimitA</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regLimitB</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iOffset</name> ? <name>p</name>-&gt;<name>iOffset</name>+1 : <name>p</name>-&gt;<name>iLimit</name></expr></argument>,
                                  <argument><expr><name>regLimitA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Copy</name></expr></argument>, <argument><expr><name>regLimitA</name></expr></argument>, <argument><expr><name>regLimitB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>regLimitA</name> = <name>regLimitB</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pOffset</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>regAddrA</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regEofA</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regAddrB</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regEofB</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOutA</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regOutB</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>destA</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>destB</name></expr></argument>, <argument><expr><name>SRT_Coroutine</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Jump past the various subroutines and coroutines to the main
  ** merge loop
  */</comment>
  <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrSelectA</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Generate a coroutine to evaluate the SELECT statement to the
  ** left of the compound operator - the "A" select.
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "Begin coroutine for left SELECT")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPrior</name>-&gt;<name>iLimit</name> = <name>regLimitA</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr>&amp;<name>destA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "End coroutine for left SELECT")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a coroutine to evaluate the SELECT statement on 
  ** the right - the "B" select
  */</comment>
  <expr_stmt><expr><name>addrSelectB</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "Begin coroutine for right SELECT")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedLimit</name> = <name>p</name>-&gt;<name>iLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedOffset</name> = <name>p</name>-&gt;<name>iOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iLimit</name> = <name>regLimitB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iOffset</name> = 0</expr>;</expr_stmt>  
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>destB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iLimit</name> = <name>savedLimit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iOffset</name> = <name>savedOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "End coroutine for right SELECT")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate a subroutine that outputs the current row of the A
  ** select as the next output row of the compound select.
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "Output routine for A")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrOutA</name> = <call><name>generateOutputSubroutine</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                 <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>destA</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>,
                 <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>pKeyDup</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Generate a subroutine that outputs the current row of the B
  ** select as the next output row of the compound select.
  */</comment>
  <if>if<condition>( <expr><name>op</name>==<name>TK_ALL</name> || <name>op</name>==<name>TK_UNION</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "Output routine for B")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrOutB</name> = <call><name>generateOutputSubroutine</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
                 <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>destB</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>,
                 <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>pKeyDup</name></expr></argument>, <argument><expr><name>P4_KEYINFO_STATIC</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Generate a subroutine to run when the results from select A
  ** are exhausted and only data in select B remains.
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "eof-A subroutine")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>TK_EXCEPT</name> || <name>op</name>==<name>TK_INTERSECT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>addrEofA</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{  
    <expr_stmt><expr><name>addrEofA</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofB</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>, <argument><expr><name>addrOutB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Generate a subroutine to run when the results from select B
  ** are exhausted and only data in select A remains.
  */</comment>
  <if>if<condition>( <expr><name>op</name>==<name>TK_INTERSECT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>addrEofB</name> = <name>addrEofA</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{  
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "eof-B subroutine")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrEofB</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofA</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>, <argument><expr><name>addrOutA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Generate code to handle the case of A&lt;B
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "A-lt-B subroutine")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrAltB</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutA</name></expr></argument>, <argument><expr><name>addrOutA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofA</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code to handle the case of A==B
  */</comment>
  <if>if<condition>( <expr><name>op</name>==<name>TK_ALL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>addrAeqB</name> = <name>addrAltB</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>op</name>==<name>TK_INTERSECT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>addrAeqB</name> = <name>addrAltB</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrAltB</name>++</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "A-eq-B subroutine")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrAeqB</name> =
    <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofA</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>

  <comment type="block">/* Generate code to handle the case of A&gt;B
  */</comment>
  <expr_stmt><expr><call><name>VdbeNoopComment</name><argument_list>(<argument><expr>(<name>v</name>, "A-gt-B subroutine")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrAgtB</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>TK_ALL</name> || <name>op</name>==<name>TK_UNION</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutB</name></expr></argument>, <argument><expr><name>addrOutB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Yield</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofB</name></expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This code runs once to initialize everything.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regAddrA</name></expr></argument>, <argument><expr><name>addrSelectA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regAddrB</name></expr></argument>, <argument><expr><name>addrSelectB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofA</name></expr></argument>, <argument><expr><name>addrEofA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>regEofB</name></expr></argument>, <argument><expr><name>addrEofB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Implement the main merge loop
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelCmpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Permutation</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>char</name>*)<name>aPermute</name></expr></argument>, <argument><expr><name>P4_INTARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>destA</name>.<name>iMem</name></expr></argument>, <argument><expr><name>destB</name>.<name>iMem</name></expr></argument>, <argument><expr><name>nOrderBy</name></expr></argument>,
                         <argument><expr>(<name>char</name>*)<name>pKeyMerge</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>addrAltB</name></expr></argument>, <argument><expr><name>addrAeqB</name></expr></argument>, <argument><expr><name>addrAgtB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Release temporary registers
  */</comment>
  <if>if<condition>( <expr><name>regPrev</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regPrev</name></expr></argument>, <argument><expr><name>nOrderBy</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Jump to the this point in order to terminate the query.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>labelEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the number of output columns
  */</comment>
  <if>if<condition>( <expr><name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Output</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Select</name> *</type><name>pFirst</name> =<init> <expr><name>pPrior</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>pFirst</name>-&gt;<name>pPrior</name></expr> )</condition> <expr_stmt><expr><name>pFirst</name> = <name>pFirst</name>-&gt;<name>pPrior</name></expr>;</expr_stmt></while>
    <expr_stmt><expr><call><name>generateColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFirst</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Reassembly the compound query so that it will be freed correctly
  ** by the calling function */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrior</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = <name>pPrior</name></expr>;</expr_stmt>

  <comment type="block">/*** TBD:  Insert subroutine calls to close cursors on incomplete
  **** subqueries ****/</comment>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Forward Declarations */</comment>
<function_decl><type><name>static</name> <name>void</name></type> <name>substExprList</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>, <param><decl><type><name>ExprList</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>ExprList</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>void</name></type> <name>substSelect</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>, <param><decl><type><name>Select</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>ExprList</name> *</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Scan through the expression pExpr.  Replace every reference to
** a column in table number iTable with a copy of the iColumn-th
** entry in pEList.  (But leave references to the ROWID column 
** unchanged.)
**
** This routine is part of the flattening procedure.  A subquery
** whose result set is defined by pEList appears as entry in the
** FROM clause of a SELECT such that the VDBE cursor assigned to that
** FORM clause entry is iTable.  This routine make the necessary 
** changes to pExpr so that it refers directly to the source table
** of the subquery rather the result set of the subquery.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>substExpr</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,        <comment type="block">/* Report malloc errors to this connection */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,        <comment type="block">/* Expr in which substitution occurs */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,         <comment type="block">/* Table to be substituted */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>    <comment type="block">/* Substitute expressions */</comment>
)</parameter_list><block>{
  <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> &amp;&amp; <name>pExpr</name>-&gt;<name>iTable</name>==<name>iTable</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iColumn</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>TK_NULL</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEList</name>!=0 &amp;&amp; <name>pExpr</name>-&gt;<name>iColumn</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name>==0 &amp;&amp; <name>pExpr</name>-&gt;<name>pRight</name>==0 &amp;&amp; <name>pExpr</name>-&gt;<name>pList</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> = <name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>pExpr</name>-&gt;<name>iColumn</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>pNew</name>-&gt;<name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pLeft</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pRight</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pRight</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pList</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pList</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iTable</name> = <name>pNew</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pTab</name> = <name>pNew</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iColumn</name> = <name>pNew</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>iAgg</name> = <name>pNew</name>-&gt;<name>iAgg</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pExpr</name>-&gt;<name>token</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pExpr</name>-&gt;<name>span</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pSelect</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>flags</name> = <name>pNew</name>-&gt;<name>flags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pExpr</name>-&gt;<name>pAggInfo</name> = <name>pNew</name>-&gt;<name>pAggInfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>pAggInfo</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pSelect</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pList</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>substExprList</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,         <comment type="block">/* Report malloc errors here */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,     <comment type="block">/* List to scan and in which to make substitutes */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,          <comment type="block">/* Table to be substituted */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>     <comment type="block">/* Substitute values */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>substSelect</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,         <comment type="block">/* Report malloc errors here */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,           <comment type="block">/* SELECT statement in which to make substitutions */</comment>
  <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>,          <comment type="block">/* Table to be replaced */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>     <comment type="block">/* Substitute values */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>p</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pGroupBy</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pHaving</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pPrior</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSrc</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Even for (SELECT 1) we have: pSrc!=0 but pSrc-&gt;nSrc==0 */</comment>
  <if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=<name>pSrc</name>-&gt;<name>nSrc</name></expr>, <expr><name>pItem</name>=<name>pSrc</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&gt;0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>substSelect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pSelect</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This routine attempts to flatten subqueries in order to speed
** execution.  It returns 1 if it makes changes and 0 if no flattening
** occurs.
**
** To understand the concept of flattening, consider the following
** query:
**
**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z&lt;100) WHERE a&gt;5
**
** The default way of implementing this query is to execute the
** subquery first and store the results in a temporary table, then
** run the outer query on that temporary table.  This requires two
** passes over the data.  Furthermore, because the temporary table
** has no indices, the WHERE clause on the outer query cannot be
** optimized.
**
** This routine attempts to rewrite queries such as the above into
** a single flat select, like this:
**
**     SELECT x+y AS a FROM t1 WHERE z&lt;100 AND a&gt;5
**
** The code generated for this simpification gives the same result
** but only has to scan the data once.  And because indices might 
** exist on the table t1, a complete scan of the data might be
** avoided.
**
** Flattening is only attempted if all of the following are true:
**
**   (1)  The subquery and the outer query do not both use aggregates.
**
**   (2)  The subquery is not an aggregate or the outer query is not a join.
**
**   (3)  The subquery is not the right operand of a left outer join
**        (Originally ticket #306.  Strenghtened by ticket #3300)
**
**   (4)  The subquery is not DISTINCT or the outer query is not a join.
**
**   (5)  The subquery is not DISTINCT or the outer query does not use
**        aggregates.
**
**   (6)  The subquery does not use aggregates or the outer query is not
**        DISTINCT.
**
**   (7)  The subquery has a FROM clause.
**
**   (8)  The subquery does not use LIMIT or the outer query is not a join.
**
**   (9)  The subquery does not use LIMIT or the outer query does not use
**        aggregates.
**
**  (10)  The subquery does not use aggregates or the outer query does not
**        use LIMIT.
**
**  (11)  The subquery and the outer query do not both have ORDER BY clauses.
**
**  (12)  Not implemented.  Subsumed into restriction (3).  Was previously
**        a separate restriction deriving from ticket #350.
**
**  (13)  The subquery and outer query do not both use LIMIT
**
**  (14)  The subquery does not use OFFSET
**
**  (15)  The outer query is not part of a compound select or the
**        subquery does not have both an ORDER BY and a LIMIT clause.
**        (See ticket #2339)
**
**  (16)  The outer query is not an aggregate or the subquery does
**        not contain ORDER BY.  (Ticket #2942)  This used to not matter
**        until we introduced the group_concat() function.  
**
**  (17)  The sub-query is not a compound select, or it is a UNION ALL 
**        compound clause made up entirely of non-aggregate queries, and 
**        the parent query:
**
**          * is not itself part of a compound select,
**          * is not an aggregate or DISTINCT query, and
**          * has no other tables or sub-selects in the FROM clause.
**
**        The parent and sub-query may contain WHERE clauses. Subject to
**        rules (11), (13) and (14), they may also contain ORDER BY,
**        LIMIT and OFFSET clauses.
**
**  (18)  If the sub-query is a compound select, then all terms of the
**        ORDER by clause of the parent must be simple references to 
**        columns of the sub-query.
**
**  (19)  The subquery does not use LIMIT or the outer query does not
**        have a WHERE clause.
**
** In this routine, the "p" parameter is a pointer to the outer query.
** The subquery is p-&gt;pSrc-&gt;a[iFrom].  isAgg is true if the outer query
** uses aggregates and subqueryIsAgg is true if the subquery uses aggregates.
**
** If flattening is not attempted, this routine is a no-op and returns 0.
** If flattening is attempted this routine returns 1.
**
** All of the expression analysis must occur on both the outer query and
** the subquery before this routine runs.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>flattenSubquery</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,           <comment type="block">/* The parent or outer SELECT statement */</comment>
  <param><decl><type><name>int</name></type> <name>iFrom</name></decl></param>,           <comment type="block">/* Index in p-&gt;pSrc-&gt;a[] of the inner subquery */</comment>
  <param><decl><type><name>int</name></type> <name>isAgg</name></decl></param>,           <comment type="block">/* True if outer SELECT uses aggregate functions */</comment>
  <param><decl><type><name>int</name></type> <name>subqueryIsAgg</name></decl></param>    <comment type="block">/* True if the subquery uses aggregate functions */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSavedAuthContext</name> =<init> <expr><name>pParse</name>-&gt;<name>zAuthContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pParent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pSub</name></decl>;</decl_stmt>       <comment type="block">/* The inner query or "subquery" */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pSub1</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to the rightmost select in sub-query */</comment>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>      <comment type="block">/* The FROM clause of the outer query */</comment>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSubSrc</name></decl>;</decl_stmt>   <comment type="block">/* The FROM clause of the subquery */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name></decl>;</decl_stmt>    <comment type="block">/* The result set of the outer query */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParent</name></decl>;</decl_stmt>        <comment type="block">/* VDBE cursor number of the pSub result set temp table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>              <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pWhere</name></decl>;</decl_stmt>                    <comment type="block">/* The WHERE clause */</comment>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pSubitem</name></decl>;</decl_stmt>   <comment type="block">/* The subquery */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check to see if flattening is permitted.  Return 0 if not.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pPrior</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Unable to flatten compound queries */</comment>
  <expr_stmt><expr><name>pSrc</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name> &amp;&amp; <name>iFrom</name>&gt;=0 &amp;&amp; <name>iFrom</name>&lt;<name>pSrc</name>-&gt;<name>nSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name> = &amp;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iParent</name> = <name>pSubitem</name>-&gt;<name>iCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSub</name> = <name>pSubitem</name>-&gt;<name>pSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSub</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>isAgg</name> &amp;&amp; <name>subqueryIsAgg</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>                 <comment type="block">/* Restriction (1)  */</comment>
  <if>if<condition>( <expr><name>subqueryIsAgg</name> &amp;&amp; <name>pSrc</name>-&gt;<name>nSrc</name>&gt;1</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>          <comment type="block">/* Restriction (2)  */</comment>
  <expr_stmt><expr><name>pSubSrc</name> = <name>pSub</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSubSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,
  ** not arbitrary expresssions, we allowed some combining of LIMIT and OFFSET
  ** because they could be computed at compile-time.  But when LIMIT and OFFSET
  ** became arbitrary expressions, we were forced to add restrictions (13)
  ** and (14). */</comment>
  <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pLimit</name> &amp;&amp; <name>p</name>-&gt;<name>pLimit</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>              <comment type="block">/* Restriction (13) */</comment>
  <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pOffset</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>                          <comment type="block">/* Restriction (14) */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pRightmost</name> &amp;&amp; <name>pSub</name>-&gt;<name>pLimit</name> &amp;&amp; <name>pSub</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>                                            <comment type="block">/* Restriction (15) */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>pSubSrc</name>-&gt;<name>nSrc</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>                       <comment type="block">/* Restriction (7)  */</comment>
  <if>if<condition>( <expr>((<name>pSub</name>-&gt;<name>selFlags</name> &amp; <name>SF_Distinct</name>)!=0 || <name>pSub</name>-&gt;<name>pLimit</name>) 
         &amp;&amp; (<name>pSrc</name>-&gt;<name>nSrc</name>&gt;1 || <name>isAgg</name>)</expr> )</condition><then><block>{          <comment type="block">/* Restrictions (4)(5)(8)(9) */</comment>
     <return>return <expr>0</expr>;</return>       
  }</block></then></if>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Distinct</name>)!=0 &amp;&amp; <name>subqueryIsAgg</name></expr> )</condition><then><block>{
     <return>return <expr>0</expr>;</return>         <comment type="block">/* Restriction (6)  */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pOrderBy</name> &amp;&amp; <name>pSub</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
     <return>return <expr>0</expr>;</return>                                           <comment type="block">/* Restriction (11) */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>isAgg</name> &amp;&amp; <name>pSub</name>-&gt;<name>pOrderBy</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>                <comment type="block">/* Restriction (16) */</comment>
  <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pLimit</name> &amp;&amp; <name>p</name>-&gt;<name>pWhere</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>              <comment type="block">/* Restriction (19) */</comment>

  <comment type="block">/* OBSOLETE COMMENT 1:
  ** Restriction 3:  If the subquery is a join, make sure the subquery is 
  ** not used as the right operand of an outer join.  Examples of why this
  ** is not allowed:
  **
  **         t1 LEFT OUTER JOIN (t2 JOIN t3)
  **
  ** If we flatten the above, we would get
  **
  **         (t1 LEFT OUTER JOIN t2) JOIN t3
  **
  ** which is not at all the same thing.
  **
  ** OBSOLETE COMMENT 2:
  ** Restriction 12:  If the subquery is the right operand of a left outer
  ** join, make sure the subquery has no WHERE clause.
  ** An examples of why this is not allowed:
  **
  **         t1 LEFT OUTER JOIN (SELECT * FROM t2 WHERE t2.x&gt;0)
  **
  ** If we flatten the above, we would get
  **
  **         (t1 LEFT OUTER JOIN t2) WHERE t2.x&gt;0
  **
  ** But the t2.x&gt;0 test will always fail on a NULL row of t2, which
  ** effectively converts the OUTER JOIN into an INNER JOIN.
  **
  ** THIS OVERRIDES OBSOLETE COMMENTS 1 AND 2 ABOVE:
  ** Ticket #3300 shows that flattening the right term of a LEFT JOIN
  ** is fraught with danger.  Best to avoid the whole thing.  If the
  ** subquery is the right term of a LEFT JOIN, then do not flatten.
  */</comment>
  <if>if<condition>( <expr>(<name>pSubitem</name>-&gt;<name>jointype</name> &amp; <name>JT_OUTER</name>)!=0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* Restriction 17: If the sub-query is a compound SELECT, then it must
  ** use only the UNION ALL operator. And none of the simple select queries
  ** that make up the compound SELECT are allowed to be aggregate or distinct
  ** queries.
  */</comment>
  <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pPrior</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>isAgg</name> || (<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Distinct</name>)!=0 || <name>pSrc</name>-&gt;<name>nSrc</name>!=1</expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <for>for(<init><expr><name>pSub1</name>=<name>pSub</name></expr>;</init> <condition><expr><name>pSub1</name></expr>;</condition> <incr><expr><name>pSub1</name>=<name>pSub1</name>-&gt;<name>pPrior</name></expr></incr>)<block>{
      <if>if<condition>( <expr>(<name>pSub1</name>-&gt;<name>selFlags</name> &amp; (<name>SF_Distinct</name>|<name>SF_Aggregate</name>))!=0
       || (<name>pSub1</name>-&gt;<name>pPrior</name> &amp;&amp; <name>pSub1</name>-&gt;<name>op</name>!=<name>TK_ALL</name>) 
       || !<name>pSub1</name>-&gt;<name>pSrc</name> || <name>pSub1</name>-&gt;<name>pSrc</name>-&gt;<name>nSrc</name>!=1</expr>
      )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* Restriction 18. */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>p</name>-&gt;<name>pOrderBy</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>p</name>-&gt;<name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iCol</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
      }</block></for>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/***** If we reach this point, flattening is permitted. *****/</comment>

  <comment type="block">/* Authorize the subquery */</comment>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>zAuthContext</name> = <name>pSubitem</name>-&gt;<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SELECT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>zAuthContext</name> = <name>zSavedAuthContext</name></expr>;</expr_stmt>

  <comment type="block">/* If the sub-query is a compound SELECT statement, then (by restrictions
  ** 17 and 18 above) it must be a UNION ALL and the parent query must 
  ** be of the form:
  **
  **     SELECT &lt;expr-list&gt; FROM (&lt;sub-query&gt;) &lt;where-clause&gt; 
  **
  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block
  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or 
  ** OFFSET clauses and joins them to the left-hand-side of the original
  ** using UNION ALL operators. In this case N is the number of simple
  ** select statements in the compound sub-query.
  **
  ** Example:
  **
  **     SELECT a+1 FROM (
  **        SELECT x FROM tab
  **        UNION ALL
  **        SELECT y FROM tab
  **        UNION ALL
  **        SELECT abs(z*2) FROM tab2
  **     ) WHERE a!=5 ORDER BY 1
  **
  ** Transformed into:
  **
  **     SELECT x+1 FROM tab WHERE x+1!=5
  **     UNION ALL
  **     SELECT y+1 FROM tab WHERE y+1!=5
  **     UNION ALL
  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5
  **     ORDER BY 1
  **
  ** We call this the "compound-subquery flattening".
  */</comment>
  <for>for(<init><expr><name>pSub</name>=<name>pSub</name>-&gt;<name>pPrior</name></expr>;</init> <condition><expr><name>pSub</name></expr>;</condition> <incr><expr><name>pSub</name>=<name>pSub</name>-&gt;<name>pPrior</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>Select</name> *</type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pOrderBy</name> =<init> <expr><name>p</name>-&gt;<name>pOrderBy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pLimit</name> =<init> <expr><name>p</name>-&gt;<name>pLimit</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> *</type><name>pPrior</name> =<init> <expr><name>p</name>-&gt;<name>pPrior</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pSrc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pLimit</name> = <name>pLimit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = <name>pOrderBy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pSrc</name> = <name>pSrc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>op</name> = <name>TK_ALL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pRightmost</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pNew</name> = <name>pPrior</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pNew</name>-&gt;<name>pPrior</name> = <name>pPrior</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>pRightmost</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>pPrior</name> = <name>pNew</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  }</block></for>

  <comment type="block">/* Begin flattening the iFrom-th entry of the FROM clause 
  ** in the outer query.
  */</comment>
  <expr_stmt><expr><name>pSub</name> = <name>pSub1</name> = <name>pSubitem</name>-&gt;<name>pSelect</name></expr>;</expr_stmt>

  <comment type="block">/* Delete the transient table structure associated with the
  ** subquery
  */</comment>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSubitem</name>-&gt;<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSubitem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSubitem</name>-&gt;<name>zAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name>-&gt;<name>zDatabase</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name>-&gt;<name>zName</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name>-&gt;<name>zAlias</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pSubitem</name>-&gt;<name>pSelect</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Defer deleting the Table object associated with the
  ** subquery until code generation is
  ** complete, since there may still exist Expr.pTab entries that
  ** refer to the subquery even after flattening.  Ticket #3346.
  */</comment>
  <if>if<condition>( <expr><name>pSubitem</name>-&gt;<name>pTab</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTabToDel</name> =<init> <expr><name>pSubitem</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pTabToDel</name>-&gt;<name>nRef</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTabToDel</name>-&gt;<name>pNextZombie</name> = <name>pParse</name>-&gt;<name>pZombieTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>pZombieTab</name> = <name>pTabToDel</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pTabToDel</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pSubitem</name>-&gt;<name>pTab</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* The following loop runs once for each term in a compound-subquery
  ** flattening (as described above).  If we are doing a different kind
  ** of flattening - a flattening other than a compound-subquery flattening -
  ** then this loop only runs once.
  **
  ** This loop moves all of the FROM elements of the subquery into the
  ** the FROM clause of the outer query.  Before doing this, remember
  ** the cursor number for the original outer query FROM element in
  ** iParent.  The iParent cursor will never be used.  Subsequent code
  ** will scan expressions looking for iParent references and replace
  ** those references with expressions that resolve to the subquery FROM
  ** elements we are now copying in.
  */</comment>
  <for>for(<init><expr><name>pParent</name>=<name>p</name></expr>;</init> <condition><expr><name>pParent</name></expr>;</condition> <incr><expr><name>pParent</name>=<name>pParent</name>-&gt;<name>pPrior</name></expr>, <expr><name>pSub</name>=<name>pSub</name>-&gt;<name>pPrior</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nSubSrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>jointype</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pSubSrc</name> = <name>pSub</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>     <comment type="block">/* FROM clause of subquery */</comment>
    <expr_stmt><expr><name>nSubSrc</name> = <name>pSubSrc</name>-&gt;<name>nSrc</name></expr>;</expr_stmt>  <comment type="block">/* Number of terms in subquery FROM clause */</comment>
    <expr_stmt><expr><name>pSrc</name> = <name>pParent</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>     <comment type="block">/* FROM clause of the outer query */</comment>

    <if>if<condition>( <expr><name>pSrc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>==<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* First time through the loop */</comment>
      <expr_stmt><expr><name>jointype</name> = <name>pSubitem</name>-&gt;<name>jointype</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>!=<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 2nd and subsequent times through the loop */</comment>
      <expr_stmt><expr><name>pSrc</name> = <name>pParent</name>-&gt;<name>pSrc</name> = <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pSrc</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></else></if>

    <comment type="block">/* The subquery uses a single slot of the FROM clause of the outer
    ** query.  If the subquery has more than one element in its FROM clause,
    ** then expand the outer query to make space for it to hold all elements
    ** of the subquery.
    **
    ** Example:
    **
    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;
    **
    ** The outer query has 3 slots in its FROM clause.  One slot of the
    ** outer query (the middle slot) is used by the subquery.  The next
    ** block of code will expand the out query to 4 slots.  The middle
    ** slot is expanded to two slots in order to make space for the
    ** two elements in the FROM clause of the subquery.
    */</comment>
    <if>if<condition>( <expr><name>nSubSrc</name>&gt;1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pSrc</name> = <name>pSrc</name> = <call><name>sqlite3SrcListEnlarge</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>nSubSrc</name>-1</expr></argument>,<argument><expr><name>iFrom</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Transfer the FROM clause terms from the subquery into the
    ** outer query.
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nSubSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name>+<name>iFrom</name></expr>]</index></name> = <name>pSubSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pSubSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pSubSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>iFrom</name></expr>]</index></name>.<name>jointype</name> = <name>jointype</name></expr>;</expr_stmt>
  
    <comment type="block">/* Now begin substituting subquery result set expressions for 
    ** references to the iParent in the outer query.
    ** 
    ** Example:
    **
    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a&gt;b;
    **   \                     \_____________ subquery __________/          /
    **    \_____________________ outer query ______________________________/
    **
    ** We look at every expression in the outer query and every place we see
    ** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".
    */</comment>
    <expr_stmt><expr><name>pList</name> = <name>pParent</name>-&gt;<name>pEList</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name>==0 &amp;&amp; (<name>pExpr</name> = <name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name>)-&gt;<name>span</name>.<name>z</name>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name> = 
               <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>span</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>span</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>isAgg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pGroupBy</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pHaving</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>-&gt;<name>pOrderBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pOrderBy</name> = <name>pSub</name>-&gt;<name>pOrderBy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSub</name>-&gt;<name>pOrderBy</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pParent</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>substExprList</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pOrderBy</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pWhere</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pWhere</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pWhere</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>subqueryIsAgg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>-&gt;<name>pHaving</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pHaving</name> = <name>pParent</name>-&gt;<name>pWhere</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pWhere</name> = <name>pWhere</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pHaving</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pHaving</name> = <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pHaving</name></expr></argument>, 
                                  <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pHaving</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParent</name>-&gt;<name>pGroupBy</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pGroupBy</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>substExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>iParent</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pWhere</name> = <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParent</name>-&gt;<name>pWhere</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  
    <comment type="block">/* The flattened query is distinct if either the inner or the
    ** outer query is distinct. 
    */</comment>
    <expr_stmt><expr><name>pParent</name>-&gt;<name>selFlags</name> |= <name>pSub</name>-&gt;<name>selFlags</name> &amp; <name>SF_Distinct</name></expr>;</expr_stmt>
  
    <comment type="block">/*
    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;
    **
    ** One is tempted to try to add a and b to combine the limits.  But this
    ** does not work if either limit is negative.
    */</comment>
    <if>if<condition>( <expr><name>pSub</name>-&gt;<name>pLimit</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParent</name>-&gt;<name>pLimit</name> = <name>pSub</name>-&gt;<name>pLimit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSub</name>-&gt;<name>pLimit</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Finially, delete what is left of the subquery and return
  ** success.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSub1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</comment>

<comment type="block">/*
** Analyze the SELECT statement passed as an argument to see if it
** is a min() or max() query. Return WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX if 
** it is, or 0 otherwise. At present, a query is considered to be
** a min()/max() query if:
**
**   1. There is a single object in the FROM clause.
**
**   2. There is a single expression in the result set, and it is
**      either min(x) or max(x), where x is a column reference.
*/</comment>
<function><type><name>static</name> <name>u8</name></type> <name>minMaxQuery</name><parameter_list>(<param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name> =<init> <expr><name>p</name>-&gt;<name>pEList</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pEList</name>-&gt;<name>nExpr</name>!=1</expr> )</condition><then> <return>return <expr><name>WHERE_ORDERBY_NORMAL</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pExpr</name> = <name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> = <name>pExpr</name>-&gt;<name>pList</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_AGG_FUNCTION</name> || <name>pEList</name>==0 || <name>pEList</name>-&gt;<name>nExpr</name>!=1</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name>!=<name>TK_AGG_COLUMN</name></expr> )</condition><then> <return>return <expr><name>WHERE_ORDERBY_NORMAL</name></expr>;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>!=3</expr> )</condition><then> <return>return <expr><name>WHERE_ORDERBY_NORMAL</name></expr>;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>,<argument><expr>"min"</expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <return>return <expr><name>WHERE_ORDERBY_MIN</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>,<argument><expr>"max"</expr></argument>,<argument><expr>3</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <return>return <expr><name>WHERE_ORDERBY_MAX</name></expr>;</return>
  }</block></then></if></else></if>
  <return>return <expr><name>WHERE_ORDERBY_NORMAL</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the source-list item passed as an argument was augmented with an
** INDEXED BY clause, then try to locate the specified index. If there
** was such a clause and the named index cannot be found, return 
** SQLITE_ERROR and leave an error in pParse. Otherwise, populate 
** pFrom-&gt;pIndex and return SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IndexedByLookup</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type>struct <name>SrcList_item</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pFrom</name>-&gt;<name>pTab</name> &amp;&amp; <name>pFrom</name>-&gt;<name>zIndex</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pFrom</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zIndex</name> =<init> <expr><name>pFrom</name>-&gt;<name>zIndex</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> 
        <condition><expr><name>pIdx</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pIdx</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zIndex</name></expr></argument>)</argument_list></call></expr>;</condition> 
        <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>
    )<empty_stmt>;</empty_stmt></for>
    <if>if<condition>( <expr>!<name>pIdx</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such index: %s"</expr></argument>, <argument><expr><name>zIndex</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pFrom</name>-&gt;<name>pIndex</name> = <name>pIdx</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is a Walker callback for "expanding" a SELECT statement.
** "Expanding" means to do the following:
**
**    (1)  Make sure VDBE cursor numbers have been assigned to every
**         element of the FROM clause.
**
**    (2)  Fill in the pTabList-&gt;a[].pTab fields in the SrcList that 
**         defines FROM clause.  When views appear in the FROM clause,
**         fill pTabList-&gt;a[].pSelect with a copy of the SELECT statement
**         that implements the view.  A copy is made of the view's SELECT
**         statement so that we can freely modify or delete that statement
**         without worrying about messing up the presistent representation
**         of the view.
**
**    (3)  Add terms to the WHERE clause to accomodate the NATURAL keyword
**         on joins and the ON and USING clause of joins.
**
**    (4)  Scan the list of columns in the result set (pEList) looking
**         for instances of the "*" operator or the TABLE.* operator.
**         If found, expand each "*" to be every column in every table
**         and TABLE.* to be every column in TABLE.
**
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>selectExpander</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWalker</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pFrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr>  )</condition><then><block>{
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pSrc</name>==0 || (<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Expanded</name>)!=0</expr> )</condition><then><block>{
    <return>return <expr><name>WRC_Prune</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>selFlags</name> |= <name>SF_Expanded</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> = <name>p</name>-&gt;<name>pEList</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure cursor numbers have been assigned to all entries in
  ** the FROM clause of the SELECT statement.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Look up every table named in the FROM clause of the select.  If
  ** an entry of the FROM clause is a subquery instead of a table or view,
  ** then create a transient table structure to describe the subquery.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pFrom</name>=<name>pTabList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pFrom</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pFrom</name>-&gt;<name>pTab</name>!=0</expr> )</condition><then><block>{
      <comment type="block">/* This statement has already been prepared.  There is no need
      ** to go further. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>WRC_Prune</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>pFrom</name>-&gt;<name>zName</name>==0</expr> )</condition><then><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
      <decl_stmt><decl><type><name>Select</name> *</type><name>pSel</name> =<init> <expr><name>pFrom</name>-&gt;<name>pSelect</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* A sub-query in the FROM clause of a SELECT */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSel</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFrom</name>-&gt;<name>pTab</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFrom</name>-&gt;<name>pTab</name> = <name>pTab</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return <expr><name>WRC_Abort</name></expr>;</return></then></if>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>zName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_subquery_%p_"</expr></argument>, <argument><expr>(<name>void</name>*)<name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>pSel</name>-&gt;<name>pPrior</name></expr> )</condition><block>{ <expr_stmt><expr><name>pSel</name> = <name>pSel</name>-&gt;<name>pPrior</name></expr>;</expr_stmt> }</block></while>
      <expr_stmt><expr><call><name>selectColumnsFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr>&amp;<name>pTab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr>&amp;<name>pTab</name>-&gt;<name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>iPKey</name> = -1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>tabFlags</name> |= <name>TF_Ephemeral</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else<block>{
      <comment type="block">/* An ordinary table or view name in the FROM clause */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFrom</name>-&gt;<name>pTab</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFrom</name>-&gt;<name>pTab</name> = <name>pTab</name> = 
        <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>pFrom</name>-&gt;<name>zName</name></expr></argument>,<argument><expr><name>pFrom</name>-&gt;<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return <expr><name>WRC_Abort</name></expr>;</return></then></if>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> || !<call><name>defined</name> <argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name> || <call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <comment type="block">/* We reach here if the named table is a really a view */</comment>
        <if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>WRC_Abort</name></expr>;</return></then></if>

        <comment type="block">/* If pFrom-&gt;pSelect!=0 it means we are dealing with a
        ** view within a view.  The SELECT structure has already been
        ** copied by the outer view so we can skip the copy step here
        ** in the inner view.
        */</comment>
        <if>if<condition>( <expr><name>pFrom</name>-&gt;<name>pSelect</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFrom</name>-&gt;<name>pSelect</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr><name>pWalker</name></expr></argument>, <argument><expr><name>pFrom</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>

    <comment type="block">/* Locate the index named by the INDEXED BY clause, if any. */</comment>
    <if>if<condition>( <expr><call><name>sqlite3IndexedByLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>WRC_Abort</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Process NATURAL keywords, and ON and USING clauses of joins.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name> || <call><name>sqliteProcessJoin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>WRC_Abort</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* For every "*" that occurs in the column list, insert the names of
  ** all columns in all tables.  And for every TABLE.* insert the names
  ** of all columns in TABLE.  The parser inserted a special expression
  ** with the TK_ALL operator for each "*" that it found in the column list.
  ** The following code just has to locate the TK_ALL expressions and expand
  ** each one to the list of all columns in all tables.
  **
  ** The first loop just checks to see if there are any "*" operators
  ** that need expanding.
  */</comment>
  <for>for(<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name> =<init> <expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pE</name>-&gt;<name>op</name>==<name>TK_ALL</name></expr> )</condition><then> <break>break;</break></then></if>
    <if>if<condition>( <expr><name>pE</name>-&gt;<name>op</name>==<name>TK_DOT</name> &amp;&amp; <name>pE</name>-&gt;<name>pRight</name> &amp;&amp; <name>pE</name>-&gt;<name>pRight</name>-&gt;<name>op</name>==<name>TK_ALL</name>
         &amp;&amp; <name>pE</name>-&gt;<name>pLeft</name> &amp;&amp; <name>pE</name>-&gt;<name>pLeft</name>-&gt;<name>op</name>==<name>TK_ID</name></expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>k</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr> )</condition><then><block>{
    <comment type="block">/*
    ** If we get here it means the result set contains one or more "*"
    ** operators that need to be expanded.  Loop through each expression
    ** in the result set and expand them one by one.
    */</comment>
    <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>a</name> =<init> <expr><name>pEList</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pNew</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>longNames</name> =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_FullColNames</name>)!=0
                      &amp;&amp; (<name>flags</name> &amp; <name>SQLITE_ShortColNames</name>)==0</expr></init></decl>;</decl_stmt>

    <for>for(<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name> =<init> <expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pE</name>-&gt;<name>op</name>!=<name>TK_ALL</name> &amp;&amp;
           (<name>pE</name>-&gt;<name>op</name>!=<name>TK_DOT</name> || <name>pE</name>-&gt;<name>pRight</name>==0 || <name>pE</name>-&gt;<name>pRight</name>-&gt;<name>op</name>!=<name>TK_ALL</name>)</expr> )</condition><then><block>{
        <comment type="block">/* This particular expression does not need to be expanded.
        */</comment>
        <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pNew</name>-&gt;<name><name>a</name><index>[<expr><name>pNew</name>-&gt;<name>nExpr</name>-1</expr>]</index></name>.<name>zName</name> = <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>pExpr</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name>.<name>zName</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* This expression is a "*" or a "TABLE.*" and needs to be
        ** expanded. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>tableSeen</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* Set to 1 when TABLE matches */</comment>
        <decl_stmt><decl><type><name>char</name> *</type><name>zTName</name></decl>;</decl_stmt>            <comment type="block">/* text of name of TABLE */</comment>
        <if>if<condition>( <expr><name>pE</name>-&gt;<name>op</name>==<name>TK_DOT</name> &amp;&amp; <name>pE</name>-&gt;<name>pLeft</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>zTName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pE</name>-&gt;<name>pLeft</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>zTName</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
        <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pFrom</name>=<name>pTabList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pFrom</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pFrom</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> *</type><name>zTabName</name> =<init> <expr><name>pFrom</name>-&gt;<name>zAlias</name></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>zTabName</name>==0 || <name><name>zTabName</name><index>[<expr>0</expr>]</index></name>==0</expr> )</condition><then><block>{ 
            <expr_stmt><expr><name>zTabName</name> = <name>pTab</name>-&gt;<name>zName</name></expr>;</expr_stmt>
          }</block></then></if>
          <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <break>break;</break></then></if>
          <if>if<condition>( <expr><name>zTName</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zTName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
            <continue>continue;</continue>
          }</block></then></if>
          <expr_stmt><expr><name>tableSeen</name> = 1</expr>;</expr_stmt>
          <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
            <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name>, *<name>pRight</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* If a column is marked as 'hidden' (currently only possible
            ** for virtual tables), do not include it in the expanded
            ** result-set list.
            */</comment>
            <if>if<condition>( <expr><call><name>IsHiddenColumn</name><argument_list>(<argument><expr>&amp;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
              <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>

            <if>if<condition>( <expr><name>i</name>&gt;0 &amp;&amp; <name>zTName</name>==0</expr> )</condition><then><block>{
              <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pLeft</name> =<init> <expr>&amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
              <if>if<condition>( <expr>(<name><name>pLeft</name><index>[<expr>1</expr>]</index></name>.<name>jointype</name> &amp; <name>JT_NATURAL</name>)!=0 &amp;&amp;
                        <call><name>columnIndex</name><argument_list>(<argument><expr><name>pLeft</name>-&gt;<name>pTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>&gt;=0</expr> )</condition><then><block>{
                <comment type="block">/* In a NATURAL join, omit the join columns from the 
                ** table on the right */</comment>
                <continue>continue;</continue>
              }</block></then></if>
              <if>if<condition>( <expr><call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name><name>pLeft</name><index>[<expr>1</expr>]</index></name>.<name>pUsing</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>&gt;=0</expr> )</condition><then><block>{
                <comment type="block">/* In a join with a USING clause, omit columns in the
                ** using clause from the table on the right. */</comment>
                <continue>continue;</continue>
              }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><name>pRight</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>pRight</name>==0</expr> )</condition><then> <break>break;</break></then></if>
            <expr_stmt><expr><call><name>setQuotedToken</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>pRight</name>-&gt;<name>token</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>longNames</name> || <name>pTabList</name>-&gt;<name>nSrc</name>&gt;1</expr> )</condition><then><block>{
              <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr><call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_ID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pExpr</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DOT</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then> <break>break;</break></then></if>
              <expr_stmt><expr><call><name>setQuotedToken</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>pLeft</name>-&gt;<name>token</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>setToken</name><argument_list>(<argument><expr>&amp;<name>pExpr</name>-&gt;<name>span</name></expr></argument>, 
                  <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s.%s"</expr></argument>, <argument><expr><name>zTabName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>span</name>.<name>dyn</name> = 1</expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>token</name>.<name>z</name> = 0</expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name> = 0</expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>token</name>.<name>dyn</name> = 0</expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><name>pExpr</name> = <name>pRight</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>span</name> = <name>pExpr</name>-&gt;<name>token</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pExpr</name>-&gt;<name>span</name>.<name>dyn</name> = 0</expr>;</expr_stmt>
            }</block></else></if>
            <if>if<condition>( <expr><name>longNames</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>pExpr</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>pRight</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          }</block></for>
        }</block></for>
        <if>if<condition>( <expr>!<name>tableSeen</name></expr> )</condition><then><block>{
          <if>if<condition>( <expr><name>zTName</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such table: %s"</expr></argument>, <argument><expr><name>zTName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no tables specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pEList</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name></expr></cpp:if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pEList</name> &amp;&amp; <name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name>&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"too many columns in result set"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
}</block></function>

<comment type="block">/*
** No-op routine for the parse-tree walker.
**
** When this routine is the Walker.xExprCallback then expression trees
** are walked without any actions being taken at each node.  Presumably,
** when this routine is used for Walker.xExprCallback then 
** Walker.xSelectCallback is set to do something useful for every 
** subquery in the parser tree.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>exprWalkNoop</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>NotUsed2</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine "expands" a SELECT statement and all of its subqueries.
** For additional information on what it means to "expand" a SELECT
** statement, see the comment on the selectExpand worker callback above.
**
** Expanding a SELECT statement is the first step in processing a
** SELECT statement.  The SELECT statement must be expanded before
** name resolution is performed.
**
** If anything goes wrong, an error message is written into pParse.
** The calling function can detect the problem by looking at pParse-&gt;nErr
** and/or pParse-&gt;db-&gt;mallocFailed.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqlite3SelectExpand</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>w</name>.<name>xSelectCallback</name> = <name>selectExpander</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xExprCallback</name> = <name>exprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
<comment type="block">/*
** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()
** interface.
**
** For each FROM-clause subquery, add Column.zType and Column.zColl
** information to the Table structure that represents the result set
** of that subquery.
**
** The Table structure that represents the result set was constructed
** by selectExpander() but the type and collation information was omitted
** at that point because identifiers had not yet been resolved.  This
** routine is called after identifier resolution.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>selectAddSubqueryTypeInfo</name><parameter_list>(<param><decl><type><name>Walker</name> *</type><name>pWalker</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pFrom</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Resolved</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_HasTypeInfo</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>selFlags</name> |= <name>SF_HasTypeInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name> = <name>pWalker</name>-&gt;<name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTabList</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pFrom</name>=<name>pTabList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pFrom</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pFrom</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pTab</name> &amp;&amp; (<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Ephemeral</name>)!=0</expr> )</condition><then><block>{
        <comment type="block">/* A sub-query in the FROM clause of a SELECT */</comment>
        <decl_stmt><decl><type><name>Select</name> *</type><name>pSel</name> =<init> <expr><name>pFrom</name>-&gt;<name>pSelect</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>pSel</name>-&gt;<name>pPrior</name></expr> )</condition> <expr_stmt><expr><name>pSel</name> = <name>pSel</name>-&gt;<name>pPrior</name></expr>;</expr_stmt></while>
        <expr_stmt><expr><call><name>selectAddColumnTypeAndCollation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>aCol</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>WRC_Continue</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This routine adds datatype and collating sequence information to
** the Table structures of all FROM-clause subqueries in a
** SELECT statement.
**
** Use this routine after name resolution.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqlite3SelectAddTypeInfo</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Walker</name></type> <name>w</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>w</name>.<name>xSelectCallback</name> = <name>selectAddSubqueryTypeInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>xExprCallback</name> = <name>exprWalkNoop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>w</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3WalkSelect</name><argument_list>(<argument><expr>&amp;<name>w</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/*
** This routine sets of a SELECT statement for processing.  The
** following is accomplished:
**
**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.
**     *  Ephemeral Table objects are created for all FROM-clause subqueries.
**     *  ON and USING clauses are shifted into WHERE statements
**     *  Wildcards "*" and "TABLE.*" in result sets are expanded.
**     *  Identifiers in expression are matched to tables.
**
** This routine acts recursively on all subqueries within the SELECT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SelectPrep</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <param><decl><type><name>NameContext</name> *</type><name>pOuterNC</name></decl></param>  <comment type="block">/* Name context for container */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_HasTypeInfo</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3SelectExpand</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3ResolveSelectNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pOuterNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3SelectAddTypeInfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Reset the aggregate accumulator.
**
** The aggregate accumulator is a set of memory cells that hold
** intermediate results while calculating an aggregate.  This
** routine simply stores NULLs in all of those memory cells.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>resetAccumulator</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>AggInfo</name> *</type><name>pAggInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>AggInfo_func</name> *</type><name>pFunc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pAggInfo</name>-&gt;<name>nFunc</name>+<name>pAggInfo</name>-&gt;<name>nColumn</name>==0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pAggInfo</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <for>for(<init><expr><name>pFunc</name>=<name>pAggInfo</name>-&gt;<name>aFunc</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nFunc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pFunc</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFunc</name>-&gt;<name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFunc</name>-&gt;<name>iDistinct</name>&gt;=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name> =<init> <expr><name>pFunc</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pE</name>-&gt;<name>pList</name>==0 || <name>pE</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name>!=1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"DISTINCT in aggregate must be followed "
           "by an expression"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pFunc</name>-&gt;<name>iDistinct</name> = -1</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name> =<init> <expr><call><name>keyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>pFunc</name>-&gt;<name>iDistinct</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                          <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Invoke the OP_AggFinalize opcode for every aggregate function
** in the AggInfo structure.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>finalizeAggFunctions</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>AggInfo</name> *</type><name>pAggInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>AggInfo_func</name> *</type><name>pF</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pF</name>=<name>pAggInfo</name>-&gt;<name>aFunc</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nFunc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pF</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pF</name>-&gt;<name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggFinal</name></expr></argument>, <argument><expr><name>pF</name>-&gt;<name>iMem</name></expr></argument>, <argument><expr><name>pList</name> ? <name>pList</name>-&gt;<name>nExpr</name> : 0</expr></argument>, <argument><expr>0</expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>pF</name>-&gt;<name>pFunc</name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<comment type="block">/*
** Update the accumulator memory cells for an aggregate based on
** the current cursor position.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>updateAccumulator</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>AggInfo</name> *</type><name>pAggInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>AggInfo_func</name> *</type><name>pF</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>AggInfo_col</name> *</type><name>pC</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pAggInfo</name>-&gt;<name>directMode</name> = 1</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pF</name>=<name>pAggInfo</name>-&gt;<name>aFunc</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nFunc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pF</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addrNext</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regAgg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pF</name>-&gt;<name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nArg</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regAgg</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nArg</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>regAgg</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pF</name>-&gt;<name>iDistinct</name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>addrNext</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeDistinct</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pF</name>-&gt;<name>iDistinct</name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>regAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pF</name>-&gt;<name>pFunc</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_NEEDCOLL</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pList!=0 if pF-&gt;pFunc has NEEDCOLL */</comment>
      <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>;</init> <condition><expr>!<name>pColl</name> &amp;&amp; <name>j</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pColl</name> = <name>pParse</name>-&gt;<name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CollSeq</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>char</name> *)<name>pColl</name></expr></argument>, <argument><expr><name>P4_COLLSEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AggStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><name>pF</name>-&gt;<name>iMem</name></expr></argument>,
                      <argument><expr>(<name>void</name>*)<name>pF</name>-&gt;<name>pFunc</name></expr></argument>, <argument><expr><name>P4_FUNCDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regAgg</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>addrNext</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pC</name>=<name>pAggInfo</name>-&gt;<name>aCol</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pAggInfo</name>-&gt;<name>nAccumulator</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pC</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>pC</name>-&gt;<name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pAggInfo</name>-&gt;<name>directMode</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Generate code for the SELECT statement given in the p argument.  
**
** The results are distributed in various ways depending on the
** contents of the SelectDest structure pointed to by argument pDest
** as follows:
**
**     pDest-&gt;eDest    Result
**     ------------    -------------------------------------------
**     SRT_Output      Generate a row of output (using the OP_ResultRow
**                     opcode) for each row in the result set.
**
**     SRT_Mem         Only valid if the result is a single column.
**                     Store the first column of the first result row
**                     in register pDest-&gt;iParm then abandon the rest
**                     of the query.  This destination implies "LIMIT 1".
**
**     SRT_Set         The result must be a single column.  Store each
**                     row of result as the key in table pDest-&gt;iParm. 
**                     Apply the affinity pDest-&gt;affinity before storing
**                     results.  Used to implement "IN (SELECT ...)".
**
**     SRT_Union       Store results as a key in a temporary table pDest-&gt;iParm.
**
**     SRT_Except      Remove results from the temporary table pDest-&gt;iParm.
**
**     SRT_Table       Store results in temporary table pDest-&gt;iParm.
**                     This is like SRT_EphemTab except that the table
**                     is assumed to already be open.
**
**     SRT_EphemTab    Create an temporary table pDest-&gt;iParm and store
**                     the result there. The cursor is left open after
**                     returning.  This is like SRT_Table except that
**                     this destination uses OP_OpenEphemeral to create
**                     the table first.
**
**     SRT_Coroutine   Generate a co-routine that returns a new row of
**                     results each time it is invoked.  The entry point
**                     of the co-routine is stored in register pDest-&gt;iParm.
**
**     SRT_Exists      Store a 1 in memory cell pDest-&gt;iParm if the result
**                     set is not empty.
**
**     SRT_Discard     Throw the results away.  This is used by SELECT
**                     statements within triggers whose only purpose is
**                     the side-effects of functions.
**
** This routine returns the number of errors.  If any errors are
** encountered, then an appropriate error message is left in
** pParse-&gt;zErrMsg.
**
** This routine does NOT free the Select structure passed in.  The
** calling function needs to do that.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Select</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>Select</name> *</type><name>p</name></decl></param>,             <comment type="block">/* The SELECT statement being coded. */</comment>
  <param><decl><type><name>SelectDest</name> *</type><name>pDest</name></decl></param>      <comment type="block">/* What to do with the query results */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>              <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl>;</decl_stmt>     <comment type="block">/* Return from sqlite3WhereBegin() */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual machine under construction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isAgg</name></decl>;</decl_stmt>             <comment type="block">/* True for select lists like "count(*)" */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name></decl>;</decl_stmt>      <comment type="block">/* List of columns to extract. */</comment>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl>;</decl_stmt>     <comment type="block">/* List of tables to select from */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pWhere</name></decl>;</decl_stmt>          <comment type="block">/* The WHERE clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl>;</decl_stmt>    <comment type="block">/* The ORDER BY clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pGroupBy</name></decl>;</decl_stmt>    <comment type="block">/* The GROUP BY clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pHaving</name></decl>;</decl_stmt>         <comment type="block">/* The HAVING clause.  May be NULL */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isDistinct</name></decl>;</decl_stmt>        <comment type="block">/* True if the DISTINCT keyword is present */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>distinct</name></decl>;</decl_stmt>          <comment type="block">/* Table to use for the distinct set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>            <comment type="block">/* Value to return from this function */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrSortIndex</name></decl>;</decl_stmt>     <comment type="block">/* Address of an OP_OpenEphemeral instruction */</comment>
  <decl_stmt><decl><type><name>AggInfo</name></type> <name>sAggInfo</name></decl>;</decl_stmt>      <comment type="block">/* Information used by aggregate queries */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEnd</name></decl>;</decl_stmt>              <comment type="block">/* Address of the end of the query */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database connection */</comment>

  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0 || <name>db</name>-&gt;<name>mallocFailed</name> || <name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SELECT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sAggInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pOrderBy</name> = <name>p</name>-&gt;<name>pOrderBy</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>IgnorableOrderby</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = 0</expr>;</expr_stmt>

    <comment type="block">/* In these cases the DISTINCT operator makes no difference to the
    ** results, so remove it if it were specified.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Exists</name> || <name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Union</name> || 
           <name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Except</name> || <name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Discard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>selFlags</name> &amp;= ~<name>SF_Distinct</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3SelectPrep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabList</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEList</name> = <name>p</name>-&gt;<name>pEList</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>select_end</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pOrderBy</name> = <name>pOrderBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>isAgg</name> = (<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Aggregate</name>)!=0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pEList</name>==0</expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>

  <comment type="block">/* 
  ** Do not even attempt to generate any code if we have already seen
  ** errors before this routine starts.
  */</comment>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name>&gt;0</expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>

  <comment type="block">/* ORDER BY is ignored for some destinations.
  */</comment>
  <if>if<condition>( <expr><call><name>IgnorableOrderby</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOrderBy</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Begin generating code.
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>

  <comment type="block">/* Generate code for all sub-queries in the FROM clause
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr>!<name>p</name>-&gt;<name>pPrior</name> &amp;&amp; <name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Select</name> *</type><name>pSub</name> =<init> <expr><name>pItem</name>-&gt;<name>pSelect</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isAggSub</name></decl>;</decl_stmt>

    <if>if<condition>( <expr><name>pSub</name>==0 || <name>pItem</name>-&gt;<name>isPopulated</name></expr> )</condition><then> <continue>continue;</continue></then></if>

    <comment type="block">/* Increment Parse.nHeight by the height of the largest expression
    ** tree refered to by this, the parent select. The child select
    ** may contain expression trees of at most
    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit
    ** more conservative than necessary, but much easier than enforcing
    ** an exact limit.
    */</comment>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nHeight</name> += <call><name>sqlite3SelectExprHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check to see if the subquery can be absorbed into the parent. */</comment>
    <expr_stmt><expr><name>isAggSub</name> = (<name>pSub</name>-&gt;<name>selFlags</name> &amp; <name>SF_Aggregate</name>)!=0</expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>flattenSubquery</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>isAgg</name></expr></argument>, <argument><expr><name>isAggSub</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>isAggSub</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>isAgg</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>selFlags</name> |= <name>SF_Aggregate</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>i</name> = -1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_EphemTab</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name>-&gt;<name>isPopulated</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSub</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pItem</name>-&gt;<name>isPopulated</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <goto>goto <name>select_end</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nHeight</name> -= <call><name>sqlite3SelectExprHeight</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTabList</name> = <name>p</name>-&gt;<name>pSrc</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<call><name>IgnorableOrderby</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pOrderBy</name> = <name>p</name>-&gt;<name>pOrderBy</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>pEList</name> = <name>p</name>-&gt;<name>pEList</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pWhere</name> = <name>p</name>-&gt;<name>pWhere</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pGroupBy</name> = <name>p</name>-&gt;<name>pGroupBy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pHaving</name> = <name>p</name>-&gt;<name>pHaving</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>isDistinct</name> = (<name>p</name>-&gt;<name>selFlags</name> &amp; <name>SF_Distinct</name>)!=0</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPOUND_SELECT</name></cpp:ifndef>
  <comment type="block">/* If there is are a sequence of queries, do the earlier ones first.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrior</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pRightmost</name>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Select</name> *</type><name>pLoop</name>, *<name>pRight</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>mxSelect</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>pLoop</name>=<name>p</name></expr>;</init> <condition><expr><name>pLoop</name></expr>;</condition> <incr><expr><name>pLoop</name>=<name>pLoop</name>-&gt;<name>pPrior</name></expr>, <expr><name>cnt</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>pLoop</name>-&gt;<name>pRightmost</name> = <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLoop</name>-&gt;<name>pNext</name> = <name>pRight</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pRight</name> = <name>pLoop</name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><name>mxSelect</name> = <name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COMPOUND_SELECT</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>mxSelect</name> &amp;&amp; <name>cnt</name>&gt;<name>mxSelect</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"too many terms in compound SELECT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <return>return <expr><call><name>multiSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If writing to memory or generating a set
  ** only a single column may be output.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>checkForMultiColumnSelectError</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>select_end</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If possible, rewrite the query to use GROUP BY instead of DISTINCT.
  ** GROUP BY might use an index, DISTINCT never does.
  */</comment>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>selFlags</name> &amp; (<name>SF_Distinct</name>|<name>SF_Aggregate</name>))==<name>SF_Distinct</name> &amp;&amp; !<name>p</name>-&gt;<name>pGroupBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pGroupBy</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pGroupBy</name> = <name>p</name>-&gt;<name>pGroupBy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>selFlags</name> &amp;= ~<name>SF_Distinct</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>isDistinct</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If there is an ORDER BY clause, then this sorting
  ** index might end up being unused if the data can be 
  ** extracted in pre-sorted order.  If that is the case, then the
  ** OP_OpenEphemeral instruction will be changed to an OP_Noop once
  ** we figure out that the sorting index is not needed.  The addrSortIndex
  ** variable is used to facilitate that change.
  */</comment>
  <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> = <call><name>keyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrderBy</name>-&gt;<name>iECursor</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>2</expr>]</index></name> = <name>addrSortIndex</name> =
      <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>,
                           <argument><expr><name>pOrderBy</name>-&gt;<name>iECursor</name></expr></argument>, <argument><expr><name>pOrderBy</name>-&gt;<name>nExpr</name>+2</expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>addrSortIndex</name> = -1</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* If the output is destined for a temporary table, open that table.
  */</comment>
  <if>if<condition>( <expr><name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_EphemTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>pDest</name>-&gt;<name>iParm</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Set the limiter.
  */</comment>
  <expr_stmt><expr><name>iEnd</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>computeLimitRegisters</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open a virtual index to use for the distinct set.
  */</comment>
  <if>if<condition>( <expr><name>isDistinct</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isAgg</name> || <name>pGroupBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>distinct</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> = <call><name>keyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>distinct</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>distinct</name> = -1</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Aggregate and non-aggregate queries are handled differently */</comment>
  <if>if<condition>( <expr>!<name>isAgg</name> &amp;&amp; <name>pGroupBy</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* This case is for non-aggregate queries
    ** Begin the database scan
    */</comment>
    <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>&amp;<name>pOrderBy</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pWInfo</name>==0</expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>

    <comment type="block">/* If sorting index that was created by a prior OP_OpenEphemeral 
    ** instruction ended up not being needed, then change the OP_OpenEphemeral
    ** into an OP_Noop.
    */</comment>
    <if>if<condition>( <expr><name>addrSortIndex</name>&gt;=0 &amp;&amp; <name>pOrderBy</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSortIndex</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>addrOpenEphm</name><index>[<expr>2</expr>]</index></name> = -1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Use the standard inner loop
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>isDistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>pDest</name></expr></argument>,
                    <argument><expr><name>pWInfo</name>-&gt;<name>iContinue</name></expr></argument>, <argument><expr><name>pWInfo</name>-&gt;<name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* End the database scan loop.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* This is the processing for aggregate queries */</comment>
    <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>    <comment type="block">/* Name context for processing aggregate information */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iAMem</name></decl>;</decl_stmt>          <comment type="block">/* First Mem address for storing current GROUP BY */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iBMem</name></decl>;</decl_stmt>          <comment type="block">/* First Mem address for previous GROUP BY */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iUseFlag</name></decl>;</decl_stmt>       <comment type="block">/* Mem address holding flag indicating that at least
                        ** one row of the input to the aggregator has been
                        ** processed */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iAbortFlag</name></decl>;</decl_stmt>     <comment type="block">/* Mem address which causes query abort if positive */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>groupBySort</name></decl>;</decl_stmt>    <comment type="block">/* Rows come from source in GROUP BY order */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>addrEnd</name></decl>;</decl_stmt>        <comment type="block">/* End of processing for this SELECT */</comment>

    <comment type="block">/* Remove any and all aliases between the result set and the
    ** GROUP BY clause.
    */</comment>
    <if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>  <comment type="block">/* For looping over expression in a list */</comment>

      <for>for(<init><expr><name>k</name>=<name>p</name>-&gt;<name>pEList</name>-&gt;<name>nExpr</name></expr>, <expr><name>pItem</name>=<name>p</name>-&gt;<name>pEList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>k</name>&gt;0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>pItem</name>-&gt;<name>iAlias</name> = 0</expr>;</expr_stmt>
      }</block></for>
      <for>for(<init><expr><name>k</name>=<name>pGroupBy</name>-&gt;<name>nExpr</name></expr>, <expr><name>pItem</name>=<name>pGroupBy</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>k</name>&gt;0</expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>pItem</name>-&gt;<name>iAlias</name> = 0</expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>

 
    <comment type="block">/* Create a label to jump to when we want to abort the query */</comment>
    <expr_stmt><expr><name>addrEnd</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
    ** SELECT statement.
    */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pTabList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>pAggInfo</name> = &amp;<name>sAggInfo</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sAggInfo</name>.<name>nSortingColumn</name> = <name>pGroupBy</name> ? <name>pGroupBy</name>-&gt;<name>nExpr</name>+1 : 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sAggInfo</name>.<name>pGroupBy</name> = <name>pGroupBy</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pHaving</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggregates</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sAggInfo</name>.<name>nAccumulator</name> = <name>sAggInfo</name>.<name>nColumn</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>sAggInfo</name>.<name>nFunc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3ExprAnalyzeAggList</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>

    <comment type="block">/* Processing for aggregates with GROUP BY is very different and
    ** much more complex than aggregates without a GROUP BY.
    */</comment>
    <if>if<condition>( <expr><name>pGroupBy</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>  <comment type="block">/* Keying information for the group by clause */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j1</name></decl>;</decl_stmt>             <comment type="block">/* A-vs-B comparision jump */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrOutputRow</name></decl>;</decl_stmt>  <comment type="block">/* Start of subroutine that outputs a result row */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regOutputRow</name></decl>;</decl_stmt>   <comment type="block">/* Return address register for output subroutine */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrSetAbort</name></decl>;</decl_stmt>   <comment type="block">/* Set the abort flag and return */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrTopOfLoop</name></decl>;</decl_stmt>  <comment type="block">/* Top of the input loop */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrSortingIdx</name></decl>;</decl_stmt> <comment type="block">/* The OP_OpenEphemeral for the sorting index */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>addrReset</name></decl>;</decl_stmt>      <comment type="block">/* Subroutine for resetting the accumulator */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>regReset</name></decl>;</decl_stmt>       <comment type="block">/* Return address register for reset subroutine */</comment>

      <comment type="block">/* If there is a GROUP BY clause we might need a sorting index to
      ** implement it.  Allocate that sorting index now.  If it turns out
      ** that we do not need it after all, the OpenEphemeral instruction
      ** will be converted into a Noop.  
      */</comment>
      <expr_stmt><expr><name>sAggInfo</name>.<name>sortingIdx</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>pKeyInfo</name> = <call><name>keyInfoFromExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrSortingIdx</name> = <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, 
          <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>nSortingColumn</name></expr></argument>, 
          <argument><expr>0</expr></argument>, <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Initialize memory locations used by GROUP BY aggregate processing
      */</comment>
      <expr_stmt><expr><name>iUseFlag</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iAbortFlag</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>regOutputRow</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrOutputRow</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>regReset</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrReset</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iAMem</name> = <name>pParse</name>-&gt;<name>nMem</name> + 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>pGroupBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBMem</name> = <name>pParse</name>-&gt;<name>nMem</name> + 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>pGroupBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "clear abort flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "indicate accumulator empty")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Begin a loop that will extract all source rows in GROUP BY order.
      ** This might involve two separate loops with an OP_Sort in between, or
      ** it might be a single loop that uses an index to extract information
      ** in the right order to begin with.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>&amp;<name>pGroupBy</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pWInfo</name>==0</expr> )</condition><then> <goto>goto <name>select_end</name>;</goto></then></if>
      <if>if<condition>( <expr><name>pGroupBy</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* The optimizer is able to deliver rows in group by order so
        ** we do not have to sort.  The OP_OpenEphemeral table will be
        ** cancelled later because we still need to use the pKeyInfo
        */</comment>
        <expr_stmt><expr><name>pGroupBy</name> = <name>p</name>-&gt;<name>pGroupBy</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>groupBySort</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* Rows are coming out in undetermined order.  We have to push
        ** each row into a sorting index, terminate the first loop,
        ** then loop over the sorting index in order to get the output
        ** in sorted order
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nGroupBy</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>groupBySort</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>nGroupBy</name> = <name>pGroupBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nCol</name> = <name>nGroupBy</name> + 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = <name>nGroupBy</name>+1</expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>sAggInfo</name>.<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><name>sAggInfo</name>.<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iSorterColumn</name>&gt;=<name>j</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>nCol</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>regBase</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprCodeExprList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGroupBy</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sequence</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>,<argument><expr><name>regBase</name>+<name>nGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> = <name>nGroupBy</name>+1</expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>sAggInfo</name>.<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type>struct <name>AggInfo_col</name> *</type><name>pCol</name> =<init> <expr>&amp;<name>sAggInfo</name>.<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>pCol</name>-&gt;<name>iSorterColumn</name>&gt;=<name>j</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><name>j</name> + <name>regBase</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>r2</name> = <call><name>sqlite3ExprCodeGetColumn</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
                               <argument><expr><name>pCol</name>-&gt;<name>pTab</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>iColumn</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>iTable</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>r1</name>!=<name>r2</name></expr> )</condition><then><block>{
              <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>regRecord</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Sort</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "GROUP BY sort")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sAggInfo</name>.<name>useSortingIdx</name> = 1</expr>;</expr_stmt>
      }</block></else></if>

      <comment type="block">/* Evaluate the current GROUP BY terms and store in b0, b1, b2...
      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)
      ** Then compare the current GROUP BY terms against the GROUP BY terms
      ** from the previous row currently stored in a0, a1, a2...
      */</comment>
      <expr_stmt><expr><name>addrTopOfLoop</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pGroupBy</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>groupBySort</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>iBMem</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>sAggInfo</name>.<name>directMode</name> = 1</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pGroupBy</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>iBMem</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Compare</name></expr></argument>, <argument><expr><name>iAMem</name></expr></argument>, <argument><expr><name>iBMem</name></expr></argument>, <argument><expr><name>pGroupBy</name>-&gt;<name>nExpr</name></expr></argument>,
                          <argument><expr>(<name>char</name>*)<name>pKeyInfo</name></expr></argument>, <argument><expr><name>P4_KEYINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Jump</name></expr></argument>, <argument><expr><name>j1</name>+1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j1</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate code that runs whenever the GROUP BY changes.
      ** Changes in the GROUP BY are detected by the previous code
      ** block.  If there were no changes, this block is skipped.
      **
      ** This code copies current group by terms in b0,b1,b2,...
      ** over to a0,a1,a2.  It then calls the output subroutine
      ** and resets the aggregate accumulator registers in preparation
      ** for the next GROUP BY batch.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3ExprCodeMove</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iBMem</name></expr></argument>, <argument><expr><name>iAMem</name></expr></argument>, <argument><expr><name>pGroupBy</name>-&gt;<name>nExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "output one row")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "check abort flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "reset accumulator")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Update the aggregate accumulators based on the content of
      ** the current row
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>updateAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "indicate data in accumulator")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* End of the loop
      */</comment>
      <if>if<condition>( <expr><name>groupBySort</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>sortingIdx</name></expr></argument>, <argument><expr><name>addrTopOfLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeToNoop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrSortingIdx</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <comment type="block">/* Output the final row of result
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Gosub</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "output final row")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Jump over the subroutines
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate a subroutine that outputs a single row of the result
      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag
      ** is less than or equal to zero, the subroutine is a no-op.  If
      ** the processing calls for the query to abort, this subroutine
      ** increments the iAbortFlag memory location before returning in
      ** order to signal the caller to abort.
      */</comment>
      <expr_stmt><expr><name>addrSetAbort</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iAbortFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "set abort flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrOutputRow</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>iUseFlag</name></expr></argument>, <argument><expr><name>addrOutputRow</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "Groupby result generator entry point")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>finalizeAggFunctions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pHaving</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>, <argument><expr><name>addrOutputRow</name>+1</expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>,
                      <argument><expr><name>distinct</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>,
                      <argument><expr><name>addrOutputRow</name>+1</expr></argument>, <argument><expr><name>addrSetAbort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regOutputRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "end groupby result generator")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Generate a subroutine that will reset the group-by accumulator
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>resetAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Return</name></expr></argument>, <argument><expr><name>regReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
    }</block></then> <comment type="block">/* endif pGroupBy */</comment>
    <else>else <block>{
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pMinMax</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pDel</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>flag</name></decl>;</decl_stmt>

      <comment type="block">/* Check if the query is of one of the following forms:
      **
      **   SELECT min(x) FROM ...
      **   SELECT max(x) FROM ...
      **
      ** If it is, then ask the code in where.c to attempt to sort results
      ** as if there was an "ORDER ON x" or "ORDER ON x DESC" clause. 
      ** If where.c is able to produce results sorted in this order, then
      ** add vdbe code to break out of the processing loop after the 
      ** first iteration (since the first iteration of the loop is 
      ** guaranteed to operate on the row with the minimum or maximum 
      ** value of x, the only row required).
      **
      ** A special flag must be passed to sqlite3WhereBegin() to slightly
      ** modify behaviour as follows:
      **
      **   + If the query is a "SELECT min(x)", then the loop coded by
      **     where.c should not iterate over any values with a NULL value
      **     for x.
      **
      **   + The optimizer code in where.c (the thing that decides which
      **     index or indices to use) should place a different priority on 
      **     satisfying the 'ORDER BY' clause than it does in other cases.
      **     Refer to code and comments in where.c for details.
      */</comment>
      <expr_stmt><expr><name>flag</name> = <call><name>minMaxQuery</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>flag</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDel</name> = <name>pMinMax</name> = <call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pMinMax</name> &amp;&amp; !<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pMinMax</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>sortOrder</name> = <name>flag</name>!=<name>WHERE_ORDERBY_MIN</name> ?1:0</expr>;</expr_stmt>
          <expr_stmt><expr><name>pMinMax</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name> = <name>TK_COLUMN</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>

      <comment type="block">/* This case runs if the aggregate has no GROUP BY clause.  The
      ** processing is much simpler since there is only a single row
      ** of output.
      */</comment>
      <expr_stmt><expr><call><name>resetAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>&amp;<name>pMinMax</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pWInfo</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>select_end</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><call><name>updateAccumulator</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pMinMax</name> &amp;&amp; <name>flag</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pWInfo</name>-&gt;<name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%s() by index",(<name>flag</name>==<name>WHERE_ORDERBY_MIN</name>?"min":"max"))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>finalizeAggFunctions</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sAggInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOrderBy</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pHaving</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pHaving</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>selectInnerLoop</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>-1</expr></argument>, 
                      <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  }</block></else></if> <comment type="block">/* endif aggregate query */</comment>

  <comment type="block">/* If there is an ORDER BY clause, then we need to sort the results
  ** and send them to the callback one by one.
  */</comment>
  <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>generateSortTail</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name>nExpr</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Jump here to skip this query
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The SELECT was successfully coded.   Set the return code to 0
  ** to indicate no errors.
  */</comment>
  <expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Control jumps to here if an error is encountered above, or upon
  ** successful coding of the SELECT.
  */</comment>
<label><name>select_end</name>:</label>

  <comment type="block">/* Identify column names if results of the SELECT are to be output.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pDest</name>-&gt;<name>eDest</name>==<name>SRT_Output</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>generateColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sAggInfo</name>.<name>aFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
*******************************************************************************
** The following code is used for testing and debugging only.  The code
** that follows does not appear in normal builds.
**
** These routines are used to print out the content of all or part of a 
** parse structures such as Select or Expr.  Such printouts are useful
** for helping to understand what is happening inside the code generator
** during the execution of complex SELECT statements.
**
** These routine are not called anywhere from within the normal
** code base.  Then are intended to be called from within the debugger
** or from temporary "printf" statements inserted for debugging.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PrintExpr</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>token</name>.<name>z</name> &amp;&amp; <name>p</name>-&gt;<name>token</name>.<name>n</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"(%.*s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>token</name>.<name>n</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>token</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"(%d"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pLeft</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pRight</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3PrintExprList</name><parameter_list>(<param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3PrintExpr</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name>-1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3PrintSelect</name><parameter_list>(<param><decl><type><name>Select</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>indent</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*sSELECT(%p) "</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PrintExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pSrc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zPrefix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zPrefix</name> = "FROM"</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>pSrc</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s "</expr></argument>, <argument><expr><name>indent</name>+6</expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zPrefix</name> = ""</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"(\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PrintSelect</name><argument_list>(<argument><expr><name>pItem</name>-&gt;<name>pSelect</name></expr></argument>, <argument><expr><name>indent</name>+10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s)"</expr></argument>, <argument><expr><name>indent</name>+8</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pItem</name>-&gt;<name>zName</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>pTab</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"(table: %s)"</expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>zAlias</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>" AS %s"</expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>i</name>&lt;<name>p</name>-&gt;<name>pSrc</name>-&gt;<name>nSrc</name>-1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pWhere</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s WHERE "</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pGroupBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s GROUP BY "</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pHaving</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s HAVING "</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExpr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pOrderBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"%*s ORDER BY "</expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PrintExprList</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<comment type="block">/* End of the structure debug printing code
*****************************************************************************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */</comment>
</unit>
