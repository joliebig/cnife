<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="rowset.c" filename=""><comment type="block">/*
** 2008 December 3
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This module implements an object we call a "Row Set".
**
** The RowSet object is a bag of rowids.  Rowids
** are inserted into the bag in an arbitrary order.  Then they are
** pulled from the bag in sorted order.  Rowids only appear in the
** bag once.  If the same rowid is inserted multiple times, the
** second and subsequent inserts make no difference on the output.
**
** This implementation accumulates rowids in a linked list.  For
** output, it first sorts the linked list (removing duplicates during
** the sort) then returns elements one by one by walking the list.
**
** Big chunks of rowid/next-ptr pairs are allocated at a time, to
** reduce the malloc overhead.
**
** $Id: rowset.c,v 1.3 2009/01/13 20:14:16 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** The number of rowset entries per allocation chunk.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ROWSET_ENTRY_PER_CHUNK</name>  63</cpp:define>

<comment type="block">/*
** Each entry in a RowSet is an instance of the following
** structure:
*/</comment>
<struct>struct <name>RowSetEntry</name> <block>{<public type="default">            
  <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>                        <comment type="block">/* ROWID value for this entry */</comment>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pNext</name></decl>;</decl_stmt>    <comment type="block">/* Next entry on a list of all entries */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Index entries are allocated in large chunks (instances of the
** following structure) to reduce memory allocation overhead.  The
** chunks are kept on a linked list so that they can be deallocated
** when the RowSet is destroyed.
*/</comment>
<struct>struct <name>RowSetChunk</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>RowSetChunk</name> *</type><name>pNext</name></decl>;</decl_stmt>             <comment type="block">/* Next chunk on list of them all */</comment>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name></type> <name><name>aEntry</name><index>[<expr><name>ROWSET_ENTRY_PER_CHUNK</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Allocated entries */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A RowSet in an instance of the following structure.
**
** A typedef of this structure if found in sqliteInt.h.
*/</comment>
<struct>struct <name>RowSet</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>RowSetChunk</name> *</type><name>pChunk</name></decl>;</decl_stmt>    <comment type="block">/* List of all chunk allocations */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>                   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pEntry</name></decl>;</decl_stmt>    <comment type="block">/* List of entries in the rowset */</comment>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pLast</name></decl>;</decl_stmt>     <comment type="block">/* Last entry on the pEntry list */</comment>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pFresh</name></decl>;</decl_stmt>    <comment type="block">/* Source of new entry objects */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFresh</name></decl>;</decl_stmt>                    <comment type="block">/* Number of objects on pFresh */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isSorted</name></decl>;</decl_stmt>                   <comment type="block">/* True if content is sorted */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Turn bulk memory into a RowSet object.  N bytes of memory
** are available at pSpace.  The db pointer is used as a memory context
** for any subsequent allocations that need to occur.
** Return a pointer to the new RowSet object.
**
** It must be the case that N is sufficient to make a Rowset.  If not
** an assertion fault occurs.
** 
** If N is larger than the minimum, use the surplus as an initial
** allocation of entries available to be filled.
*/</comment>
<function><type><name>RowSet</name> *</type><name>sqlite3RowSetInit</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pSpace</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>RowSet</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>N</name> &gt;= <call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <name>pSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pChunk</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pLast</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pFresh</name> = (struct <name>RowSetEntry</name>*)&amp;<name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nFresh</name> = (<name>u16</name>)((<name>N</name> - <call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call>)/<call><name>sizeof</name><argument_list>(<argument><expr>struct <name>RowSetEntry</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>isSorted</name> = 1</expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Deallocate all chunks from a RowSet.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RowSetClear</name><parameter_list>(<param><decl><type><name>RowSet</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>RowSetChunk</name> *</type><name>pChunk</name>, *<name>pNextChunk</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>pChunk</name>=<name>p</name>-&gt;<name>pChunk</name></expr>;</init> <condition><expr><name>pChunk</name></expr>;</condition> <incr><expr><name>pChunk</name> = <name>pNextChunk</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pNextChunk</name> = <name>pChunk</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pChunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>p</name>-&gt;<name>pChunk</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nFresh</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pLast</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>isSorted</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Insert a new value into a RowSet.
**
** The mallocFailed flag of the database connection is set if a
** memory allocation fails.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RowSetInsert</name><parameter_list>(<param><decl><type><name>RowSet</name> *</type><name>p</name></decl></param>, <param><decl><type><name>i64</name></type> <name>rowid</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pLast</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>  <comment type="block">/* Must have been a malloc failure */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nFresh</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>RowSetChunk</name> *</type><name>pNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>pNext</name> = <name>p</name>-&gt;<name>pChunk</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pChunk</name> = <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pFresh</name> = <name>pNew</name>-&gt;<name>aEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>nFresh</name> = <name>ROWSET_ENTRY_PER_CHUNK</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pEntry</name> = <name>p</name>-&gt;<name>pFresh</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nFresh</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><name>pEntry</name>-&gt;<name>v</name> = <name>rowid</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEntry</name>-&gt;<name>pNext</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pLast</name> = <name>p</name>-&gt;<name>pLast</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pLast</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>isSorted</name> &amp;&amp; <name>rowid</name>&lt;=<name>pLast</name>-&gt;<name>v</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>isSorted</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pLast</name>-&gt;<name>pNext</name> = <name>pEntry</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pEntry</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = <name>pEntry</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pLast</name> = <name>pEntry</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Merge two lists of RowSet entries.  Remove duplicates.
**
** The input lists are assumed to be in sorted order.
*/</comment>
<function><type><name>static</name> struct <name>RowSetEntry</name> *</type><name>boolidxMerge</name><parameter_list>(
  <param><decl><type>struct <name>RowSetEntry</name> *</type><name>pA</name></decl></param>,    <comment type="block">/* First sorted list to be merged */</comment>
  <param><decl><type>struct <name>RowSetEntry</name> *</type><name>pB</name></decl></param>     <comment type="block">/* Second sorted list to be merged */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>RowSetEntry</name></type> <name>head</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pTail</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTail</name> = &amp;<name>head</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> &amp;&amp; <name>pB</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pA</name>-&gt;<name>pNext</name>==0 || <name>pA</name>-&gt;<name>v</name>&lt;=<name>pA</name>-&gt;<name>pNext</name>-&gt;<name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pB</name>-&gt;<name>pNext</name>==0 || <name>pB</name>-&gt;<name>v</name>&lt;=<name>pB</name>-&gt;<name>pNext</name>-&gt;<name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pA</name>-&gt;<name>v</name>&lt;<name>pB</name>-&gt;<name>v</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTail</name>-&gt;<name>pNext</name> = <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> = <name>pA</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> = <name>pTail</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pB</name>-&gt;<name>v</name>&lt;<name>pA</name>-&gt;<name>v</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTail</name>-&gt;<name>pNext</name> = <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> = <name>pB</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> = <name>pTail</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pA</name> = <name>pA</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></while>
  <if>if<condition>( <expr><name>pA</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pA</name>-&gt;<name>pNext</name>==0 || <name>pA</name>-&gt;<name>v</name>&lt;=<name>pA</name>-&gt;<name>pNext</name>-&gt;<name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTail</name>-&gt;<name>pNext</name> = <name>pA</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pB</name>==0 || <name>pB</name>-&gt;<name>pNext</name>==0 || <name>pB</name>-&gt;<name>v</name>&lt;=<name>pB</name>-&gt;<name>pNext</name>-&gt;<name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTail</name>-&gt;<name>pNext</name> = <name>pB</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>head</name>.<name>pNext</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sort all elements of the RowSet into ascending order.
*/</comment> 
<function><type><name>static</name> <name>void</name></type> <name>sqlite3RowSetSort</name><parameter_list>(<param><decl><type><name>RowSet</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name>pEntry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>RowSetEntry</name> *</type><name><name>aBucket</name><index>[<expr>40</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>isSorted</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aBucket</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aBucket</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name>-&gt;<name>pEntry</name></expr> )</condition><block>{
    <expr_stmt><expr><name>pEntry</name> = <name>p</name>-&gt;<name>pEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = <name>pEntry</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEntry</name>-&gt;<name>pNext</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>pEntry</name> = <call><name>boolidxMerge</name><argument_list>(<argument><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pEntry</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>pEntry</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>aBucket</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>aBucket</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>pEntry</name> = <call><name>boolidxMerge</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>,<argument><expr><name><name>aBucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = <name>pEntry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pLast</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>isSorted</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Extract the next (smallest) element from the RowSet.
** Write the element into *pRowid.  Return 1 on success.  Return
** 0 if the RowSet is already empty.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3RowSetNext</name><parameter_list>(<param><decl><type><name>RowSet</name> *</type><name>p</name></decl></param>, <param><decl><type><name>i64</name> *</type><name>pRowid</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>isSorted</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3RowSetSort</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pEntry</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRowid</name> = <name>p</name>-&gt;<name>pEntry</name>-&gt;<name>v</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pEntry</name> = <name>p</name>-&gt;<name>pEntry</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pEntry</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>0</expr>;</return>
  }</block></else></if>
}</block></function>
</unit>
