<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="auth.c" filename=""><comment type="block">/*
** 2003 January 11
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to implement the sqlite3_set_authorizer()
** API.  This facility is an optional feature of the library.  Embedded
** systems that do not need this facility may omit it by recompiling
** the library with -DSQLITE_OMIT_AUTHORIZATION=1
**
** $Id: auth.c,v 1.29 2007/09/18 15:55:07 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** All of the code in this file may be omitted by defining a single
** macro.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>

<comment type="block">/*
** Set or clear the access authorization function.
**
** The access authorization function is be called during the compilation
** phase to verify that the user has read and/or write access permission on
** various fields of the database.  The first argument to the auth function
** is a copy of the 3rd argument to this routine.  The second argument
** to the auth function is one of these constants:
**
**       SQLITE_CREATE_INDEX
**       SQLITE_CREATE_TABLE
**       SQLITE_CREATE_TEMP_INDEX
**       SQLITE_CREATE_TEMP_TABLE
**       SQLITE_CREATE_TEMP_TRIGGER
**       SQLITE_CREATE_TEMP_VIEW
**       SQLITE_CREATE_TRIGGER
**       SQLITE_CREATE_VIEW
**       SQLITE_DELETE
**       SQLITE_DROP_INDEX
**       SQLITE_DROP_TABLE
**       SQLITE_DROP_TEMP_INDEX
**       SQLITE_DROP_TEMP_TABLE
**       SQLITE_DROP_TEMP_TRIGGER
**       SQLITE_DROP_TEMP_VIEW
**       SQLITE_DROP_TRIGGER
**       SQLITE_DROP_VIEW
**       SQLITE_INSERT
**       SQLITE_PRAGMA
**       SQLITE_READ
**       SQLITE_SELECT
**       SQLITE_TRANSACTION
**       SQLITE_UPDATE
**
** The third and fourth arguments to the auth function are the name of
** the table and the column that are being accessed.  The auth function
** should return either SQLITE_OK, SQLITE_DENY, or SQLITE_IGNORE.  If
** SQLITE_OK is returned, it means that access is allowed.  SQLITE_DENY
** means that the SQL statement will never-run - the sqlite3_exec() call
** will return with an error.  SQLITE_IGNORE means that the SQL statement
** should run but attempts to read the specified column will return NULL
** and attempts to write the column will be ignored.
**
** Setting the auth function to NULL disables this hook.  The default
** setting of the auth function is NULL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_set_authorizer</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><function_decl><type><name>int</name></type> (*<name>xAuth</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xAuth</name> = <name>xAuth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pAuthArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Write an error message into pParse-&gt;zErrMsg that explains that the
** user-supplied authorization function returned an illegal value.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqliteAuthBadReturnCode</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"illegal return value (%d) from the "
    "authorization function - should be SQLITE_OK, SQLITE_IGNORE, "
    "or SQLITE_DENY"</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The pExpr should be a TK_COLUMN expression.  The table referred to
** is in pTabList or else it is the NEW or OLD table of a trigger.  
** Check to see if it is OK to read this particular column.
**
** If the auth function returns SQLITE_IGNORE, change the TK_COLUMN 
** instruction into a TK_NULL.  If the auth function returns SQLITE_DENY,
** then generate an error.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AuthRead</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,          <comment type="block">/* The expression to check authorization on */</comment>
  <param><decl><type><name>Schema</name> *</type><name>pSchema</name></decl></param>,      <comment type="block">/* The schema of the expression */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>     <comment type="block">/* All table that pExpr might refer to */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* The table being read */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zCol</name></decl>;</decl_stmt>     <comment type="block">/* Name of the column of the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSrc</name></decl>;</decl_stmt>             <comment type="block">/* Index in pTabList-&gt;a[] of table being read */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDBase</name></decl>;</decl_stmt>   <comment type="block">/* Name of database being accessed */</comment>
  <decl_stmt><decl><type><name>TriggerStack</name> *</type><name>pStack</name></decl>;</decl_stmt> <comment type="block">/* The stack of current triggers */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* The index of the database the expression refers to */</comment>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>xAuth</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then><block>{
    <comment type="block">/* An attempt to read a column out of a subquery or other
    ** temporary table. */</comment>
    <return>return;</return>
  }</block></then></if>
  <for>for(<init><expr><name>iSrc</name>=0</expr>;</init> <condition><expr><name>pTabList</name> &amp;&amp; <name>iSrc</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>iSrc</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iTable</name>==<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>iSrc</name></expr>]</index></name>.<name>iCursor</name></expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>iSrc</name>&gt;=0 &amp;&amp; <name>pTabList</name> &amp;&amp; <name>iSrc</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>iSrc</name></expr>]</index></name>.<name>pTab</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr>(<name>pStack</name> = <name>pParse</name>-&gt;<name>trigStack</name>)!=0</expr> )</condition><then><block>{
    <comment type="block">/* This must be an attempt to read the NEW or OLD pseudo-tables
    ** of a trigger.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>iTable</name>==<name>pStack</name>-&gt;<name>newIdx</name> || <name>pExpr</name>-&gt;<name>iTable</name>==<name>pStack</name>-&gt;<name>oldIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> = <name>pStack</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iColumn</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>iColumn</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCol</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>pExpr</name>-&gt;<name>iColumn</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pTab</name>-&gt;<name>iPKey</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>-&gt;<name>iPKey</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCol</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>pTab</name>-&gt;<name>iPKey</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zCol</name> = "ROWID"</expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDBase</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>db</name>-&gt;<call><name>xAuth</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pAuthArg</name></expr></argument>, <argument><expr><name>SQLITE_READ</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>zDBase</name></expr></argument>, 
                 <argument><expr><name>pParse</name>-&gt;<name>zAuthContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IGNORE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = <name>TK_NULL</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DENY</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>nDb</name>&gt;2 || <name>iDb</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"access to %s.%s.%s is prohibited"</expr></argument>, 
         <argument><expr><name>zDBase</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"access to %s.%s is prohibited"</expr></argument>,<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>,<argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_AUTH</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqliteAuthBadReturnCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if>
}</block></function>

<comment type="block">/*
** Do an authorization check using the code and arguments given.  Return
** either SQLITE_OK (zero) or SQLITE_IGNORE or SQLITE_DENY.  If SQLITE_DENY
** is returned, then the error count and error message in pParse are
** modified appropriately.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3AuthCheck</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>code</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg1</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg2</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg3</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* Don't do any authorization checks if the database is initialising
  ** or if the parser is being invoked from within sqlite3_declare_vtab.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name> || <name>IN_DECLARE_VTAB</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>xAuth</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <name>db</name>-&gt;<call><name>xAuth</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pAuthArg</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>zArg1</name></expr></argument>, <argument><expr><name>zArg2</name></expr></argument>, <argument><expr><name>zArg3</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>zAuthContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DENY</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"not authorized"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_AUTH</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_IGNORE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_DENY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqliteAuthBadReturnCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Push an authorization context.  After this routine is called, the
** zArg3 argument to authorization callbacks will be zContext until
** popped.  Or if pParse==0, this routine is a no-op.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AuthContextPush</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,
  <param><decl><type><name>AuthContext</name> *</type><name>pContext</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zContext</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><name>pContext</name>-&gt;<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pContext</name>-&gt;<name>zAuthContext</name> = <name>pParse</name>-&gt;<name>zAuthContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>zAuthContext</name> = <name>zContext</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Pop an authorization context that was previously pushed
** by sqlite3AuthContextPush
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AuthContextPop</name><parameter_list>(<param><decl><type><name>AuthContext</name> *</type><name>pContext</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pContext</name>-&gt;<name>pParse</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pContext</name>-&gt;<name>pParse</name>-&gt;<name>zAuthContext</name> = <name>pContext</name>-&gt;<name>zAuthContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pContext</name>-&gt;<name>pParse</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTHORIZATION */</comment>
</unit>
