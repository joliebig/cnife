<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="vdbemem.c" filename=""><comment type="block">/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to manipulate "Mem" structure.  A "Mem"
** stores a single value in the VDBE.  Mem is an opaque structure visible
** only within the VDBE.  Interface routines refer to a Mem using the
** name sqlite_value
**
** $Id: vdbemem.c,v 1.134 2009/01/05 22:30:39 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)
** P if required.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>expandBlob</name>(P) (((P)-&gt;flags&amp;MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)</cpp:define>

<comment type="block">/*
** If pMem is an object with a valid string representation, this routine
** ensures the internal encoding for the string representation is
** 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.
**
** If pMem is not a string object, or the encoding of the string
** representation is already stored using the requested encoding, then this
** routine is a no-op.
**
** SQLITE_OK is returned if the conversion is successful (or not required).
** SQLITE_NOMEM may be returned if a malloc() fails during conversion
** between formats.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeChangeEncoding</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>desiredEnc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>desiredEnc</name>==<name>SQLITE_UTF8</name> || <name>desiredEnc</name>==<name>SQLITE_UTF16LE</name>
           || <name>desiredEnc</name>==<name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Str</name>) || <name>pMem</name>-&gt;<name>enc</name>==<name>desiredEnc</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifdef>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <comment type="block">/* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,
  ** then the encoding of the value may not have changed.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemTranslate</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name>==<name>SQLITE_OK</name>    || <name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name>==<name>SQLITE_OK</name>    || <name>pMem</name>-&gt;<name>enc</name>!=<name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name> || <name>pMem</name>-&gt;<name>enc</name>==<name>desiredEnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Make sure pMem-&gt;z points to a writable allocation of at least 
** n bytes.
**
** If the memory cell currently contains string or blob data
** and the third argument passed to this function is true, the 
** current content of the cell is preserved. Otherwise, it may
** be discarded.  
**
** This function sets the MEM_Dyn flag and clears any xDel callback.
** It also clears MEM_Ephem and MEM_Static. If the preserve flag is 
** not set, Mem.n is zeroed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemGrow</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>preserve</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>1 &gt;=
    ((<name>pMem</name>-&gt;<name>zMalloc</name> &amp;&amp; <name>pMem</name>-&gt;<name>zMalloc</name>==<name>pMem</name>-&gt;<name>z</name>) ? 1 : 0) +
    (((<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name>)&amp;&amp;<name>pMem</name>-&gt;<name>xDel</name>) ? 1 : 0) + 
    ((<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Ephem</name>) ? 1 : 0) + 
    ((<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Static</name>) ? 1 : 0)</expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>n</name>&lt;32</expr> )</condition><then> <expr_stmt><expr><name>n</name> = 32</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call>&lt;<name>n</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>preserve</name> &amp;&amp; <name>pMem</name>-&gt;<name>z</name>==<name>pMem</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = <name>pMem</name>-&gt;<name>zMalloc</name> = <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>preserve</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>zMalloc</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>preserve</name> &amp;&amp; <name>pMem</name>-&gt;<name>z</name> &amp;&amp; <name>pMem</name>-&gt;<name>zMalloc</name> &amp;&amp; <name>pMem</name>-&gt;<name>z</name>!=<name>pMem</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name> &amp;&amp; <name>pMem</name>-&gt;<name>xDel</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<call><name>xDel</name><argument_list>(<argument><expr>(<name>void</name> *)(<name>pMem</name>-&gt;<name>z</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = <name>pMem</name>-&gt;<name>zMalloc</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Ephem</name>|<name>MEM_Static</name>)</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  <return>return <expr>(<name>pMem</name>-&gt;<name>z</name> ? <name>SQLITE_OK</name> : <name>SQLITE_NOMEM</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Make the given Mem object MEM_Dyn.  In other words, make it so
** that any TEXT or BLOB content is stored in memory obtained from
** malloc().  In this way, we know that the memory is safe to be
** overwritten or altered.
**
** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemMakeWriteable</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expandBlob</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>f</name> = <name>pMem</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>f</name>&amp;(<name>MEM_Str</name>|<name>MEM_Blob</name>)) &amp;&amp; <name>pMem</name>-&gt;<name>z</name>!=<name>pMem</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>n</name> + 2</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>pMem</name>-&gt;<name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>pMem</name>-&gt;<name>n</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Term</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the given Mem* has a zero-filled tail, turn it into an ordinary
** blob stored in dynamically allocated space.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3VdbeMemExpandBlob</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Blob</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set nByte to the number of bytes required to store the expanded blob. */</comment>
    <expr_stmt><expr><name>nByte</name> = <name>pMem</name>-&gt;<name>n</name> + <name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nByte</name>&lt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>nByte</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>pMem</name>-&gt;<name>n</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> += <name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Zero</name>|<name>MEM_Term</name>)</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Make sure the given Mem is \u0000 terminated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemNulTerminate</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Term</name>)!=0 || (<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Str</name>)==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>   <comment type="block">/* Nothing to do */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>n</name>+2</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>pMem</name>-&gt;<name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>pMem</name>-&gt;<name>n</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Term</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add MEM_Str to the set of representations for the given Mem.  Numbers
** are converted using sqlite3_snprintf().  Converting a BLOB to a string
** is a no-op.
**
** Existing representations MEM_Int and MEM_Real are *not* invalidated.
**
** A MEM_Null value will never be passed to this function. This function is
** used for converting values to text for returning to the user (i.e. via
** sqlite3_value_text()), or for ensuring that values to be used as btree
** keys are strings. In the former case a NULL pointer is returned the
** user and the later is an internal programming error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemStringify</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>enc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fg</name> =<init> <expr><name>pMem</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>nByte</name> =<init> <expr>32</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(<name>fg</name>&amp;<name>MEM_Zero</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(<name>fg</name>&amp;(<name>MEM_Str</name>|<name>MEM_Blob</name>))</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fg</name>&amp;(<name>MEM_Int</name>|<name>MEM_Real</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>


  <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* For a Real or Integer, use sqlite3_mprintf() to produce the UTF-8
  ** string representation of the value. Then, if the required encoding
  ** is UTF-16le or UTF-16be do a translation.
  ** 
  ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.
  */</comment>
  <if>if<condition>( <expr><name>fg</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>"%lld"</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fg</name> &amp; <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>"%!.15g"</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Str</name>|<name>MEM_Term</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Memory cell pMem contains the context of an aggregate function.
** This routine calls the finalize method for that function.  The
** result of the aggregate is stored back into pMem.
**
** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK
** otherwise.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemFinalize</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>FuncDef</name> *</type><name>pFunc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pFunc</name> &amp;&amp; <name>pFunc</name>-&gt;<name>xFinalize</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_context</name></type> <name>ctx</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)!=0 || <name>pFunc</name>==<name>pMem</name>-&gt;<name>u</name>.<name>pDef</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>s</name>.<name>db</name> = <name>pMem</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pMem</name> = <name>pMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name>.<name>pFunc</name> = <name>pFunc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFunc</name>-&gt;<call><name>xFinalize</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==(<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name>) &amp;&amp; !<name>pMem</name>-&gt;<name>xDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr>&amp;<name>ctx</name>.<name>s</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>ctx</name>.<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = (<name>ctx</name>.<name>isError</name>?<name>SQLITE_ERROR</name>:<name>SQLITE_OK</name>)</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the memory cell contains a string value that must be freed by
** invoking an external callback, free it now. Calling this function
** does not free any Mem.zMalloc buffer.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemReleaseExternal</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name>&amp;<name>MEM_Agg</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemFinalize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>u</name>.<name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Agg</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name> &amp;&amp; <name>p</name>-&gt;<name>xDel</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>p</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<call><name>xDel</name><argument_list>(<argument><expr>(<name>void</name> *)<name>p</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name>&amp;<name>MEM_RowSet</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if>
}</block></function>

<comment type="block">/*
** Release any memory held by the Mem. This may leave the Mem in an
** inconsistent state, for example with (Mem.z==0) and
** (Mem.type==SQLITE_TEXT).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemRelease</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseExternal</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>z</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Convert a 64-bit IEEE double into a 64-bit signed integer.
** If the double is too large, return 0x8000000000000000.
**
** Most systems appear to do this simply by assigning
** variables and without the extra range tests.  But
** there are reports that windows throws an expection
** if the floating point value is out of range. (See ticket #2880.)
** Because we do not completely understand the problem, we will
** take the conservative approach and always do range tests
** before attempting the conversion.
*/</comment>
<function><type><name>static</name> <name>i64</name></type> <name>doubleToInt64</name><parameter_list>(<param><decl><type><name>double</name></type> <name>r</name></decl></param>)</parameter_list><block>{
  <comment type="block">/*
  ** Many compilers we encounter do not define constants for the
  ** minimum and maximum 64-bit integers, or they define them
  ** inconsistently.  And many do not understand the "LL" notation.
  ** So we define our own static constants here using nothing
  ** larger than a 32-bit integer constant.
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>i64</name></type> <name>maxInt</name> =<init> <expr><name>LARGEST_INT64</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>i64</name></type> <name>minInt</name> =<init> <expr><name>SMALLEST_INT64</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>r</name>&lt;(<name>double</name>)<name>minInt</name></expr> )</condition><then><block>{
    <return>return <expr><name>minInt</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>r</name>&gt;(<name>double</name>)<name>maxInt</name></expr> )</condition><then><block>{
    <return>return <expr><name>minInt</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>(<name>i64</name>)<name>r</name></expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="block">/*
** Return some kind of integer value which is the best we can do
** at representing the value that *pMem describes as an integer.
** If pMem is an integer, then the value is exact.  If pMem is
** a floating-point then the value returned is the integer part.
** If pMem is a string or blob, then we make an attempt to convert
** it into a integer and return that.  If pMem is NULL, return 0.
**
** If pMem is a string, its encoding might be changed.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3VdbeIntValue</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>flags</name> = <name>pMem</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <return>return <expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>doubleToInt64</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>flags</name> &amp; (<name>MEM_Str</name>|<name>MEM_Blob</name>)</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Str</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call>
       || <call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Atoi64</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>value</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>0</expr>;</return>
  }</block></else></if></else></if></else></if>
}</block></function>

<comment type="block">/*
** Return the best representation of pMem that we can get into a
** double.  If pMem is already a double or an integer, return its
** value.  If it is a string or blob, try to convert it to a double.
** If it is a NULL, return 0.0.
*/</comment>
<function><type><name>double</name></type> <name>sqlite3VdbeRealValue</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
    <return>return <expr><name>pMem</name>-&gt;<name>r</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
    <return>return <expr>(<name>double</name>)<name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; (<name>MEM_Str</name>|<name>MEM_Blob</name>)</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>double</name></type> <name>val</name> =<init> <expr>0.0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Str</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call>
       || <call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr>0.0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>val</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>0.0</expr>;</return>
  }</block></else></if></else></if></else></if>
}</block></function>

<comment type="block">/*
** The MEM structure is already a MEM_Real.  Try to also make it a
** MEM_Int if we can.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIntegerAffinity</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <call><name>doubleToInt64</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>r</name>==(<name>double</name>)<name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> |= <name>MEM_Int</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Convert pMem to type integer.  Invalidate any prior representations.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemIntegerify</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Convert pMem so that it is of type MEM_Real.
** Invalidate any prior representations.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemRealify</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>r</name> = <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Convert pMem so that it has types MEM_Real or MEM_Int or both.
** Invalidate any prior representations.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemNumerify</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>double</name></type> <name>r1</name>, <name>r2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; (<name>MEM_Int</name>|<name>MEM_Real</name>|<name>MEM_Null</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; (<name>MEM_Blob</name>|<name>MEM_Str</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>r1</name> = <call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> = <call><name>doubleToInt64</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>r2</name> = (<name>double</name>)<name>i</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>r1</name>==<name>r2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemIntegerify</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>r</name> = <name>r1</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Real</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to NULL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetNull</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_NULL</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Delete any previous value and set the value to be a BLOB of length
** n containing all zeros.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetZeroBlob</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Blob</name>|<name>MEM_Zero</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_BLOB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>nZero</name> = <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type INTEGER.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetInt64</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>i64</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type REAL.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetDouble</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>double</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>r</name> = <name>val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Real</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_FLOAT</name></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Delete any previous value and set the value of pMem to be an
** empty boolean index.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemSetRowSet</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pMem</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>zMalloc</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>64</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name> = <call><name>sqlite3RowSetInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>, 
                                       <argument><expr><call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_RowSet</name></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Return true if the Mem object contains a TEXT or BLOB that is
** too large - whose size exceeds SQLITE_MAX_LENGTH.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemTooBig</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; (<name>MEM_Str</name>|<name>MEM_Blob</name>)</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>p</name>-&gt;<name>n</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> += <name>p</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>n</name>&gt;<name>p</name>-&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return> 
}</block></function>

<comment type="block">/*
** Size of struct Mem not including the Mem.zMalloc member.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEMCELLSIZE</name> (size_t)(&amp;(((Mem *)0)-&gt;zMalloc))</cpp:define>

<comment type="block">/*
** Make an shallow copy of pFrom into pTo.  Prior contents of
** pTo are freed.  The pFrom-&gt;z field is not duplicated.  If
** pFrom-&gt;z is used, then pTo-&gt;z points to the same thing as pFrom-&gt;z
** and flags gets srcType (either MEM_Ephem or MEM_Static).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemShallowCopy</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>const</name> <name>Mem</name> *</type><name>pFrom</name></decl></param>, <param><decl><type><name>int</name></type> <name>srcType</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pFrom</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseExternal</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTo</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pFrom</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name>)!=0 || <name>pFrom</name>-&gt;<name>z</name>==<name>pFrom</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTo</name>-&gt;<name>flags</name> &amp;= ~(<name>MEM_Dyn</name>|<name>MEM_Static</name>|<name>MEM_Ephem</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>srcType</name>==<name>MEM_Ephem</name> || <name>srcType</name>==<name>MEM_Static</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTo</name>-&gt;<name>flags</name> |= <name>srcType</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Make a full copy of pFrom into pTo.  Prior contents of pTo are
** freed before the copy is made.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemCopy</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>const</name> <name>Mem</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pFrom</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemReleaseExternal</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTo</name>-&gt;<name>flags</name> &amp;= ~<name>MEM_Dyn</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pTo</name>-&gt;<name>flags</name>&amp;(<name>MEM_Str</name>|<name>MEM_Blob</name>)</expr> )</condition><then><block>{
    <if>if<condition>( <expr>0==(<name>pFrom</name>-&gt;<name>flags</name>&amp;<name>MEM_Static</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTo</name>-&gt;<name>flags</name> |= <name>MEM_Ephem</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Transfer the contents of pFrom to pTo. Any existing value in pTo is
** freed. If pFrom contains ephemeral data, a copy is made.
**
** pFrom contains an SQL NULL when this routine returns.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMemMove</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pTo</name></decl></param>, <param><decl><type><name>Mem</name> *</type><name>pFrom</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFrom</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pFrom</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTo</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pTo</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFrom</name>-&gt;<name>db</name>==0 || <name>pTo</name>-&gt;<name>db</name>==0 || <name>pFrom</name>-&gt;<name>db</name>==<name>pTo</name>-&gt;<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTo</name></expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrom</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrom</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFrom</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Change the value of a Mem to be a string or a BLOB.
**
** The memory management strategy depends on the value of the xDel
** parameter. If the value passed is SQLITE_TRANSIENT, then the 
** string is copied into a (possibly existing) buffer managed by the 
** Mem structure. Otherwise, any existing buffer is freed and the
** pointer copied.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemSetStr</name><parameter_list>(
  <param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>,          <comment type="block">/* Memory cell to set to string value */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>,      <comment type="block">/* String pointer */</comment>
  <param><decl><type><name>int</name></type> <name>n</name></decl></param>,              <comment type="block">/* Bytes in string, or negative */</comment>
  <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>,             <comment type="block">/* Encoding of z.  0 for BLOBs */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param> <comment type="block">/* Destructor function */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> =<init> <expr><name>n</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* New value for pMem-&gt;n */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLimit</name></decl>;</decl_stmt>         <comment type="block">/* Maximum allowed string or blob size */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* New value for pMem-&gt;flags */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If z is a NULL pointer, set pMem to contain an SQL NULL. */</comment>
  <if>if<condition>( <expr>!<name>z</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>db</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iLimit</name> = <name>pMem</name>-&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>iLimit</name> = <name>SQLITE_MAX_LENGTH</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>flags</name> = (<name>enc</name>==0?<name>MEM_Blob</name>:<name>MEM_Str</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nByte</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>enc</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>enc</name>==<name>SQLITE_UTF8</name></expr> )</condition><then><block>{
      <for>for(<init><expr><name>nByte</name>=0</expr>;</init> <condition><expr><name>nByte</name>&lt;=<name>iLimit</name> &amp;&amp; <name><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name></expr>;</condition> <incr><expr><name>nByte</name>++</expr></incr>)<block>{}</block></for>
    }</block></then><else>else<block>{
      <for>for(<init><expr><name>nByte</name>=0</expr>;</init> <condition><expr><name>nByte</name>&lt;=<name>iLimit</name> &amp;&amp; (<name><name>z</name><index>[<expr><name>nByte</name></expr>]</index></name> | <name><name>z</name><index>[<expr><name>nByte</name>+1</expr>]</index></name>)</expr>;</condition> <incr><expr><name>nByte</name>+=2</expr></incr>)<block>{}</block></for>
    }</block></else></if>
    <expr_stmt><expr><name>flags</name> |= <name>MEM_Term</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* The following block sets the new values of Mem.z and Mem.xDel. It
  ** also sets a flag in local variable "flags" to indicate the memory
  ** management (one of MEM_Dyn or MEM_Static).
  */</comment>
  <if>if<condition>( <expr><name>xDel</name>==<name>SQLITE_TRANSIENT</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> =<init> <expr><name>nByte</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>flags</name>&amp;<name>MEM_Term</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nAlloc</name> += (<name>enc</name>==<name>SQLITE_UTF8</name>?1:2)</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>nByte</name>&gt;<name>iLimit</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>xDel</name>==<name>SQLITE_DYNAMIC</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>zMalloc</name> = <name>pMem</name>-&gt;<name>z</name> = (<name>char</name> *)<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = (<name>char</name> *)<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>xDel</name> = <name>xDel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> |= ((<name>xDel</name>==<name>SQLITE_STATIC</name>)?<name>MEM_Static</name>:<name>MEM_Dyn</name>)</expr>;</expr_stmt>
  }</block></else></if></else></if>
  <if>if<condition>( <expr><name>nByte</name>&gt;<name>iLimit</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = (<name>enc</name>==0 ? <name>SQLITE_UTF8</name> : <name>enc</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = (<name>enc</name>==0 ? <name>SQLITE_BLOB</name> : <name>SQLITE_TEXT</name>)</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <if>if<condition>( <expr><name>pMem</name>-&gt;<name>enc</name>!=<name>SQLITE_UTF8</name> &amp;&amp; <call><name>sqlite3VdbeMemHandleBom</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Compare the values contained by the two memory cells, returning
** negative, zero or positive if pMem1 is less than, equal to, or greater
** than pMem2. Sorting order is NULL's first, followed by numbers (integers
** and reals) sorted numerically, followed by text ordered by the collating
** sequence pColl and finally blob's ordered by memcmp().
**
** Two NULL values are considered equal by this function.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MemCompare</name><parameter_list>(<param><decl><type><name>const</name> <name>Mem</name> *</type><name>pMem1</name></decl></param>, <param><decl><type><name>const</name> <name>Mem</name> *</type><name>pMem2</name></decl></param>, <param><decl><type><name>const</name> <name>CollSeq</name> *</type><name>pColl</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>f1</name>, <name>f2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>combined_flags</name></decl>;</decl_stmt>

  <comment type="block">/* Interchange pMem1 and pMem2 if the collating sequence specifies
  ** DESC order.
  */</comment>
  <expr_stmt><expr><name>f1</name> = <name>pMem1</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>f2</name> = <name>pMem2</name>-&gt;<name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>combined_flags</name> = <name>f1</name>|<name>f2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>combined_flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
 
  <comment type="block">/* If one value is NULL, it is less than the other. If both values
  ** are NULL, return 0.
  */</comment>
  <if>if<condition>( <expr><name>combined_flags</name>&amp;<name>MEM_Null</name></expr> )</condition><then><block>{
    <return>return <expr>(<name>f2</name>&amp;<name>MEM_Null</name>) - (<name>f1</name>&amp;<name>MEM_Null</name>)</expr>;</return>
  }</block></then></if>

  <comment type="block">/* If one value is a number and the other is not, the number is less.
  ** If both are numbers, compare as reals if one is a real, or as integers
  ** if both values are integers.
  */</comment>
  <if>if<condition>( <expr><name>combined_flags</name>&amp;(<name>MEM_Int</name>|<name>MEM_Real</name>)</expr> )</condition><then><block>{
    <if>if<condition>( <expr>!(<name>f1</name>&amp;(<name>MEM_Int</name>|<name>MEM_Real</name>))</expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr>!(<name>f2</name>&amp;(<name>MEM_Int</name>|<name>MEM_Real</name>))</expr> )</condition><then><block>{
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr>(<name>f1</name> &amp; <name>f2</name> &amp; <name>MEM_Int</name>)==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>double</name></type> <name>r1</name>, <name>r2</name></decl>;</decl_stmt>
      <if>if<condition>( <expr>(<name>f1</name>&amp;<name>MEM_Real</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>r1</name> = (<name>double</name>)<name>pMem1</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>r1</name> = <name>pMem1</name>-&gt;<name>r</name></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr>(<name>f2</name>&amp;<name>MEM_Real</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>r2</name> = (<name>double</name>)<name>pMem2</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>r2</name> = <name>pMem2</name>-&gt;<name>r</name></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>r1</name>&lt;<name>r2</name></expr> )</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <if>if<condition>( <expr><name>r1</name>&gt;<name>r2</name></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
      <return>return <expr>0</expr>;</return>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>f1</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>f2</name>&amp;<name>MEM_Int</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pMem1</name>-&gt;<name>u</name>.<name>i</name> &lt; <name>pMem2</name>-&gt;<name>u</name>.<name>i</name></expr> )</condition><then> <return>return <expr>-1</expr>;</return></then></if>
      <if>if<condition>( <expr><name>pMem1</name>-&gt;<name>u</name>.<name>i</name> &gt; <name>pMem2</name>-&gt;<name>u</name>.<name>i</name></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
      <return>return <expr>0</expr>;</return>
    }</block></else></if>
  }</block></then></if>

  <comment type="block">/* If one value is a string and the other is a blob, the string is less.
  ** If both are strings, compare using the collating functions.
  */</comment>
  <if>if<condition>( <expr><name>combined_flags</name>&amp;<name>MEM_Str</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>(<name>f1</name> &amp; <name>MEM_Str</name>)==0</expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr>(<name>f2</name> &amp; <name>MEM_Str</name>)==0</expr> )</condition><then><block>{
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem1</name>-&gt;<name>enc</name>==<name>pMem2</name>-&gt;<name>enc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem1</name>-&gt;<name>enc</name>==<name>SQLITE_UTF8</name> || 
            <name>pMem1</name>-&gt;<name>enc</name>==<name>SQLITE_UTF16LE</name> || <name>pMem1</name>-&gt;<name>enc</name>==<name>SQLITE_UTF16BE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The collation sequence must be defined at this point, even if
    ** the user deletes the collation sequence after the vdbe program is
    ** compiled (this was not always the case).
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pColl</name> || <name>pColl</name>-&gt;<name>xCmp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pMem1</name>-&gt;<name>enc</name>==<name>pColl</name>-&gt;<name>enc</name></expr> )</condition><then><block>{
        <comment type="block">/* The strings are already in the correct encoding.  Call the
        ** comparison function directly */</comment>
        <return>return <expr><name>pColl</name>-&gt;<call><name>xCmp</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>pUser</name></expr></argument>,<argument><expr><name>pMem1</name>-&gt;<name>n</name></expr></argument>,<argument><expr><name>pMem1</name>-&gt;<name>z</name></expr></argument>,<argument><expr><name>pMem2</name>-&gt;<name>n</name></expr></argument>,<argument><expr><name>pMem2</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>const</name> <name>void</name> *</type><name>v1</name>, *<name>v2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n1</name>, <name>n2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Mem</name></type> <name>c1</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Mem</name></type> <name>c2</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>c1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>c2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr>&amp;<name>c1</name></expr></argument>, <argument><expr><name>pMem1</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemShallowCopy</name><argument_list>(<argument><expr>&amp;<name>c2</name></expr></argument>, <argument><expr><name>pMem2</name></expr></argument>, <argument><expr><name>MEM_Ephem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>v1</name> = <call><name>sqlite3ValueText</name><argument_list>(<argument><expr>(<name>sqlite3_value</name>*)&amp;<name>c1</name></expr></argument>, <argument><expr><name>pColl</name>-&gt;<name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n1</name> = <name>v1</name>==0 ? 0 : <name>c1</name>.<name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>v2</name> = <call><name>sqlite3ValueText</name><argument_list>(<argument><expr>(<name>sqlite3_value</name>*)&amp;<name>c2</name></expr></argument>, <argument><expr><name>pColl</name>-&gt;<name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n2</name> = <name>v2</name>==0 ? 0 : <name>c2</name>.<name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>pColl</name>-&gt;<call><name>xCmp</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>pUser</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></else></if>
    }</block></then></if>
    <comment type="block">/* If a NULL pointer was passed as the collate function, fall through
    ** to the blob case and use memcmp().  */</comment>
  }</block></then></if>
 
  <comment type="block">/* Both values must be blobs.  Compare using memcmp().  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name>pMem1</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pMem2</name>-&gt;<name>z</name></expr></argument>, <argument><expr>(<name>pMem1</name>-&gt;<name>n</name>&gt;<name>pMem2</name>-&gt;<name>n</name>)?<name>pMem2</name>-&gt;<name>n</name>:<name>pMem1</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>pMem1</name>-&gt;<name>n</name> - <name>pMem2</name>-&gt;<name>n</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Move data out of a btree key or data field and into a Mem structure.
** The data or key is taken from the entry that pCur is currently pointing
** to.  offset and amt determine what portion of the data or key to retrieve.
** key is true to get the key or false to get data.  The result is written
** into the pMem element.
**
** The pMem structure is assumed to be uninitialized.  Any prior content
** is overwritten without being freed.
**
** If this routine fails for any reason (malloc returns NULL or unable
** to read from the disk) then the pMem is left in an inconsistent state.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMemFromBtree</name><parameter_list>(
  <param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>,   <comment type="block">/* Cursor pointing at record to retrieve. */</comment>
  <param><decl><type><name>int</name></type> <name>offset</name></decl></param>,       <comment type="block">/* Offset from the start of data to return bytes from. */</comment>
  <param><decl><type><name>int</name></type> <name>amt</name></decl></param>,          <comment type="block">/* Number of bytes to return. */</comment>
  <param><decl><type><name>int</name></type> <name>key</name></decl></param>,          <comment type="block">/* If true, retrieve from the btree key, not data. */</comment>
  <param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>         <comment type="block">/* OUT: Return data in this Mem structure. */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zData</name></decl>;</decl_stmt>       <comment type="block">/* Data from the btree layer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>available</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Number of bytes available on the local btree page */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>       <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>db</name> = <call><name>sqlite3BtreeCursorDb</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>key</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zData</name> = (<name>char</name> *)<call><name>sqlite3BtreeKeyFetch</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>available</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zData</name> = (<name>char</name> *)<call><name>sqlite3BtreeDataFetch</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>available</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zData</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>offset</name>+<name>amt</name>&lt;=<name>available</name> &amp;&amp; ((<name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name>)==0 || <name>pMem</name>-&gt;<name>xDel</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = &amp;<name><name>zData</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Blob</name>|<name>MEM_Ephem</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>SQLITE_OK</name>==(<name>rc</name> = <call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>amt</name>+2</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Blob</name>|<name>MEM_Dyn</name>|<name>MEM_Term</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_BLOB</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>key</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeKey</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeData</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>amt</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name><name>z</name><index>[<expr><name>amt</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <name>amt</name></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/*
** Perform various checks on the memory cell pMem. An assert() will
** fail if pMem is internally inconsistent.
*/</comment>
void sqlite3VdbeMemSanity(Mem *pMem){
  int flags = pMem-&gt;flags;
  assert( flags!=0 );  <comment type="block">/* Must define some type */</comment>
  if( flags &amp; (MEM_Str|MEM_Blob) ){
    int x = flags &amp; (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short);
    assert( x!=0 );            <comment type="block">/* Strings must define a string subtype */</comment>
    assert( (x &amp; (x-1))==0 );  <comment type="block">/* Only one string subtype can be defined */</comment>
    assert( pMem-&gt;z!=0 );      <comment type="block">/* Strings must have a value */</comment>
    <comment type="block">/* Mem.z points to Mem.zShort iff the subtype is MEM_Short */</comment>
    assert( (x &amp; MEM_Short)==0 || pMem-&gt;z==pMem-&gt;zShort );
    assert( (x &amp; MEM_Short)!=0 || pMem-&gt;z!=pMem-&gt;zShort );
    <comment type="block">/* No destructor unless there is MEM_Dyn */</comment>
    assert( pMem-&gt;xDel==0 || (pMem-&gt;flags &amp; MEM_Dyn)!=0 );

    if( (flags &amp; MEM_Str) ){
      assert( pMem-&gt;enc==SQLITE_UTF8 || 
              pMem-&gt;enc==SQLITE_UTF16BE ||
              pMem-&gt;enc==SQLITE_UTF16LE 
      );
      <comment type="block">/* If the string is UTF-8 encoded and nul terminated, then pMem-&gt;n
      ** must be the length of the string.  (Later:)  If the database file
      ** has been corrupted, '\000' characters might have been inserted
      ** into the middle of the string.  In that case, the sqlite3Strlen30()
      ** might be less.
      */</comment>
      if( pMem-&gt;enc==SQLITE_UTF8 &amp;&amp; (flags &amp; MEM_Term) ){ 
        assert( sqlite3Strlen30(pMem-&gt;z)&lt;=pMem-&gt;n );
        assert( pMem-&gt;z[pMem-&gt;n]==0 );
      }
    }
  }else{
    <comment type="block">/* Cannot define a string subtype for non-string objects */</comment>
    assert( (pMem-&gt;flags &amp; (MEM_Static|MEM_Dyn|MEM_Ephem|MEM_Short))==0 );
    assert( pMem-&gt;xDel==0 );
  }
  <comment type="block">/* MEM_Null excludes all other types */</comment>
  assert( (pMem-&gt;flags&amp;(MEM_Str|MEM_Int|MEM_Real|MEM_Blob))==0
          || (pMem-&gt;flags&amp;MEM_Null)==0 );
  <comment type="block">/* If the MEM is both real and integer, the values are equal */</comment>
  assert( (pMem-&gt;flags &amp; (MEM_Int|MEM_Real))!=(MEM_Int|MEM_Real) 
          || pMem-&gt;r==pMem-&gt;u.i );
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This function is only available internally, it is not part of the
** external API. It works in a similar way to sqlite3_value_text(),
** except the data returned is in the encoding specified by the second
** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or
** SQLITE_UTF8.
**
** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
** If that is the case, then the result must be aligned on an even byte
** boundary.
*/</comment>
<function><type><name>const</name> <name>void</name> *</type><name>sqlite3ValueText</name><parameter_list>(<param><decl><type><name>sqlite3_value</name>*</type> <name>pVal</name></decl></param>, <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>pVal</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVal</name>-&gt;<name>db</name>==0 || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pVal</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>enc</name>&amp;3)==(<name>enc</name>&amp;~<name>SQLITE_UTF16_ALIGNED</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pVal</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pVal</name>-&gt;<name>flags</name>&amp;<name>MEM_Null</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>MEM_Blob</name>&gt;&gt;3) == <name>MEM_Str</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVal</name>-&gt;<name>flags</name> |= (<name>pVal</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name>)&gt;&gt;3</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expandBlob</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pVal</name>-&gt;<name>flags</name>&amp;<name>MEM_Str</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeChangeEncoding</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name> &amp; ~<name>SQLITE_UTF16_ALIGNED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>enc</name> &amp; <name>SQLITE_UTF16_ALIGNED</name>)!=0 &amp;&amp; 1==(1&amp;<call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pVal</name>-&gt;<name>z</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pVal</name>-&gt;<name>flags</name> &amp; (<name>MEM_Ephem</name>|<name>MEM_Static</name>))!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeMemNulTerminate</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pVal</name>-&gt;<name>flags</name>&amp;<name>MEM_Blob</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemStringify</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==(1&amp;<call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>pVal</name>-&gt;<name>z</name></expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pVal</name>-&gt;<name>enc</name>==(<name>enc</name> &amp; ~<name>SQLITE_UTF16_ALIGNED</name>) || <name>pVal</name>-&gt;<name>db</name>==0
              || <name>pVal</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pVal</name>-&gt;<name>enc</name>==(<name>enc</name> &amp; ~<name>SQLITE_UTF16_ALIGNED</name>)</expr> )</condition><then><block>{
    <return>return <expr><name>pVal</name>-&gt;<name>z</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>0</expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Create a new sqlite3_value object.
*/</comment>
<function><type><name>sqlite3_value</name> *</type><name>sqlite3ValueNew</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>p</name> =<init> <expr><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>type</name> = <name>SQLITE_NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new sqlite3_value object, containing the value of pExpr.
**
** This only works for very simple expressions that consist of one constant
** token (i.e. "5", "5.1", "'a string'"). If the expression can
** be converted directly into a value, then the value is allocated and
** a pointer written to *ppVal. The caller is responsible for deallocating
** the value by passing it to sqlite3ValueFree() later on. If the expression
** cannot be converted to a value, then *ppVal is set to NULL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ValueFromExpr</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,              <comment type="block">/* The database connection */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,              <comment type="block">/* The expression to evaluate */</comment>
  <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>,                   <comment type="block">/* Encoding to use */</comment>
  <param><decl><type><name>u8</name></type> <name>affinity</name></decl></param>,              <comment type="block">/* Affinity to use */</comment>
  <param><decl><type><name>sqlite3_value</name> **</type><name>ppVal</name></decl></param>     <comment type="block">/* Write the new value here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zVal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pVal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>pExpr</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>ppVal</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>op</name> = <name>pExpr</name>-&gt;<name>op</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>op</name>==<name>TK_STRING</name> || <name>op</name>==<name>TK_FLOAT</name> || <name>op</name>==<name>TK_INTEGER</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zVal</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> = <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zVal</name> || !<name>pVal</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
    <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>op</name>==<name>TK_INTEGER</name> || <name>op</name>==<name>TK_FLOAT</name> ) &amp;&amp; <name>affinity</name>==<name>SQLITE_AFF_NONE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ValueApplyAffinity</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>affinity</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>op</name>==<name>TK_UMINUS</name></expr> )</condition><then> <block>{
    <if>if<condition>( <expr><name>SQLITE_OK</name>==<call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>,<argument><expr><name>enc</name></expr></argument>,<argument><expr><name>affinity</name></expr></argument>,<argument><expr>&amp;<name>pVal</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pVal</name>-&gt;<name>u</name>.<name>i</name> = -1 * <name>pVal</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVal</name>-&gt;<name>r</name> = -1.0 * <name>pVal</name>-&gt;<name>r</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BLOB_LITERAL</name></cpp:ifndef>
  <else>else <if>if<condition>( <expr><name>op</name>==<name>TK_BLOB</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>&gt;=3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>=='x' || <name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>=='X'</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr>1</expr>]</index></name>=='\''</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>-1</expr>]</index></name>=='\''</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVal</name> = <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pVal</name></expr> )</condition><then> <goto>goto <name>no_mem</name>;</goto></then></if>
    <expr_stmt><expr><name>nVal</name> = <name>pExpr</name>-&gt;<name>token</name>.<name>n</name> - 3</expr>;</expr_stmt>
    <expr_stmt><expr><name>zVal</name> = (<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name> + 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><call><name>sqlite3HexToBlob</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nVal</name>/2</expr></argument>,
                         <argument><expr>0</expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr>*<name>ppVal</name> = <name>pVal</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>no_mem</name>:</label>
  <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>ppVal</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the string value of an sqlite3_value object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueSetStr</name><parameter_list>(
  <param><decl><type><name>sqlite3_value</name> *</type><name>v</name></decl></param>,     <comment type="block">/* Value to be set */</comment>
  <param><decl><type><name>int</name></type> <name>n</name></decl></param>,                <comment type="block">/* Length of string z */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>z</name></decl></param>,        <comment type="block">/* Text of the new string */</comment>
  <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>,               <comment type="block">/* Encoding to use */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>   <comment type="block">/* Destructor for the string */</comment>
)</parameter_list><block>{
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr>(<name>Mem</name> *)<name>v</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
** Free an sqlite3_value object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ValueFree</name><parameter_list>(<param><decl><type><name>sqlite3_value</name> *</type><name>v</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>v</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>(<name>Mem</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr>((<name>Mem</name>*)<name>v</name>)-&gt;<name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the number of bytes in the sqlite3_value object assuming
** that it uses the encoding "enc"
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ValueBytes</name><parameter_list>(<param><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl></param>, <param><decl><type><name>u8</name></type> <name>enc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>p</name> =<init> <expr>(<name>Mem</name>*)<name>pVal</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Blob</name>)!=0 || <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <return>return <expr><name>p</name>-&gt;<name>n</name> + <name>p</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</return>
    }</block></then><else>else<block>{
      <return>return <expr><name>p</name>-&gt;<name>n</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
</unit>
