<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="test_thread.c" filename=""><comment type="block">/*
** 2007 September 9
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains the implementation of some Tcl commands used to
** test that sqlite3 database handles may be concurrently accessed by 
** multiple threads. Right now this only works on unix.
**
** $Id: test_thread.c,v 1.8 2008/08/28 13:55:10 danielk1977 Exp $
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcl.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>TCL_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** One of these is allocated for each thread created by [sqlthread spawn].
*/</comment>
<typedef>typedef <type><struct>struct <name>SqlThread</name> SqlThread;</struct></type></typedef>
<struct>struct <name>SqlThread</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Tcl_ThreadId</name></type> <name>parent</name></decl>;</decl_stmt>     <comment type="block">/* Thread id of parent thread */</comment>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>      <comment type="block">/* Parent interpreter */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zScript</name></decl>;</decl_stmt>           <comment type="block">/* The script to execute. */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zVarname</name></decl>;</decl_stmt>          <comment type="block">/* Varname in parent script */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A custom Tcl_Event type used by this module. When the event is
** handled, script zScript is evaluated in interpreter interp. If
** the evaluation throws an exception (returns TCL_ERROR), then the
** error is handled by Tcl_BackgroundError(). If no error occurs,
** the result is simply discarded.
*/</comment>
<typedef>typedef <type><struct>struct <name>EvalEvent</name> EvalEvent;</struct></type></typedef>
<struct>struct <name>EvalEvent</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Tcl_Event</name></type> <name>base</name></decl>;</decl_stmt>          <comment type="block">/* Base class of type Tcl_Event */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zScript</name></decl>;</decl_stmt>           <comment type="block">/* The script to execute. */</comment>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>      <comment type="block">/* The interpreter to execute it in. */</comment>
</public>}</block>;</struct>

<decl_stmt><decl><type><name>static</name> <name>Tcl_ObjCmdProc</name></type> <name>sqlthread_proc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>Tcl_ObjCmdProc</name></type> <name>clock_seconds_proc</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> <name>Sqlitetest1_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Handler for events of type EvalEvent.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>tclScriptEvent</name><parameter_list>(<param><decl><type><name>Tcl_Event</name> *</type><name>evPtr</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>EvalEvent</name> *</type><name>p</name> =<init> <expr>(<name>EvalEvent</name> *)<name>evPtr</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_BackgroundError</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** Register an EvalEvent to evaluate the script pScript in the
** parent interpreter/thread of SqlThread p.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>postToParent</name><parameter_list>(<param><decl><type><name>SqlThread</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>EvalEvent</name> *</type><name>pEvent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMsg</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zMsg</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>, <argument><expr>&amp;<name>nMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>pEvent</name> = (<name>EvalEvent</name> *)<call><name>ckalloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>EvalEvent</name></expr></argument>)</argument_list></call>+<name>nMsg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>base</name>.<name>nextPtr</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>base</name>.<name>proc</name> = <name>tclScriptEvent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>zScript</name> = (<name>char</name> *)&amp;<name><name>pEvent</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pEvent</name>-&gt;<name>zScript</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>nMsg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>interp</name> = <name>p</name>-&gt;<name>interp</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Tcl_ThreadQueueEvent</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>parent</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name> *)<name>pEvent</name></expr></argument>, <argument><expr><name>TCL_QUEUE_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ThreadAlert</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The main function for threads created with [sqlthread spawn].
*/</comment>
<function><type><name>static</name> <name>Tcl_ThreadCreateType</name></type> <name>tclScriptThread</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>pSqlThread</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pRes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>SqlThread</name> *</type><name>p</name> =<init> <expr>(<name>SqlThread</name> *)<name>pSqlThread</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>interp</name> = <call><name>Tcl_CreateInterp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"clock_seconds"</expr></argument>, <argument><expr><name>clock_seconds_proc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlthread"</expr></argument>, <argument><expr><name>sqlthread_proc</name></expr></argument>, <argument><expr><name>pSqlThread</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Sqlitetest1_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRes</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pList</name> = <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr>"error"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>postToParent</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> = <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr>"set"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zVarname</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>postToParent</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr>(<name>void</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DeleteInterp</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** sqlthread spawn VARNAME SCRIPT
**
**     Spawn a new thread with its own Tcl interpreter and run the
**     specified SCRIPT(s) in it. The thread terminates after running
**     the script. The result of the script is stored in the variable
**     VARNAME.
**
**     The caller can wait for the script to terminate using [vwait VARNAME].
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlthread_spawn</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_ThreadId</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlThread</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>nVarname</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name> *</type><name>zVarname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nScript</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name> *</type><name>zScript</name></decl>;</decl_stmt>

  <comment type="block">/* Parameters for thread creation */</comment>
  <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>nStack</name> =<init> <expr><name>TCL_THREAD_STACK_DEFAULT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>flags</name> =<init> <expr><name>TCL_THREAD_NOFLAGS</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>objc</name>==4</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zVarname</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nVarname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zScript</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pNew</name> = (<name>SqlThread</name> *)<call><name>ckalloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>SqlThread</name></expr></argument>)</argument_list></call>+<name>nVarname</name>+<name>nScript</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zVarname</name> = (<name>char</name> *)&amp;<name><name>pNew</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zScript</name> = (<name>char</name> *)&amp;<name>pNew</name>-&gt;<name><name>zVarname</name><index>[<expr><name>nVarname</name>+1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zVarname</name></expr></argument>, <argument><expr><name>zVarname</name></expr></argument>, <argument><expr><name>nVarname</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zScript</name></expr></argument>, <argument><expr><name>zScript</name></expr></argument>, <argument><expr><name>nScript</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>parent</name> = <call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_CreateThread</name><argument_list>(<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>tclScriptThread</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>pNew</name></expr></argument>, <argument><expr><name>nStack</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error in Tcl_CreateThread()"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr>(<name>char</name> *)<name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** sqlthread parent SCRIPT
**
**     This can be called by spawned threads only. It sends the specified
**     script back to the parent thread for execution. The result of
**     evaluating the SCRIPT is returned. The parent thread must enter
**     the event loop for this to work - otherwise the caller will
**     block indefinitely.
**
**     NOTE: At the moment, this doesn't work. FIXME.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlthread_parent</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>EvalEvent</name> *</type><name>pEvent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqlThread</name> *</type><name>p</name> =<init> <expr>(<name>SqlThread</name> *)<name>clientData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>objc</name>==3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"no parent thread"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>zMsg</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name> = (<name>EvalEvent</name> *)<call><name>ckalloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>EvalEvent</name></expr></argument>)</argument_list></call>+<name>nMsg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>base</name>.<name>nextPtr</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>base</name>.<name>proc</name> = <name>tclScriptEvent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>zScript</name> = (<name>char</name> *)&amp;<name><name>pEvent</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pEvent</name>-&gt;<name>zScript</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>nMsg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pEvent</name>-&gt;<name>interp</name> = <name>p</name>-&gt;<name>interp</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ThreadQueueEvent</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>parent</name></expr></argument>, <argument><expr>(<name>Tcl_Event</name> *)<name>pEvent</name></expr></argument>, <argument><expr><name>TCL_QUEUE_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ThreadAlert</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type> <name>xBusy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBusy</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_sleep</name><argument_list>(<argument><expr>50</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>             <comment type="block">/* Try again... */</comment>
}</block></function>

<comment type="block">/*
** sqlthread open
**
**     Open a database handle and return the string representation of
**     the pointer value.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlthread_open</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <function_decl><type><name>int</name></type> <name>sqlite3TestMakePointerStr</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zPtr</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>

  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
  <function_decl><type><name>extern</name> <name>void</name></type> <name>Md5_Register</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>

  <expr_stmt><expr><name>zFilename</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_open</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Md5_Register</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>xBusy</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if>if<condition>( <expr><call><name>sqlite3TestMakePointerStr</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** sqlthread open
**
**     Return the current thread-id (Tcl_GetCurrentThread()) cast to
**     an integer.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlthread_id</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_ThreadId</name></type> <name>id</name> =<init> <expr><call><name>Tcl_GetCurrentThread</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr>(<name>int</name>)<name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Dispatch routine for the sub-commands of [sqlthread].
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlthread_proc</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <struct>struct <name>SubCommand</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> *</type><name>xProc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zUsage</name></decl>;</decl_stmt>
  </public>}</block> <decl><name><name>aSub</name><index>[]</index></name> =<init> <expr><block>{
    <expr><block>{<expr>"parent"</expr>, <expr><name>sqlthread_parent</name></expr>, <expr>1</expr>, <expr>"SCRIPT"</expr>}</block></expr>,
    <expr><block>{<expr>"spawn"</expr>,  <expr><name>sqlthread_spawn</name></expr>,  <expr>2</expr>, <expr>"VARNAME SCRIPT"</expr>}</block></expr>,
    <expr><block>{<expr>"open"</expr>,   <expr><name>sqlthread_open</name></expr>,   <expr>1</expr>, <expr>"DBNAME"</expr>}</block></expr>,
    <expr><block>{<expr>"id"</expr>,     <expr><name>sqlthread_id</name></expr>,     <expr>0</expr>, <expr>""</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>
  }</block></expr></init></decl>;</struct>
  <decl_stmt><decl><type>struct <name>SubCommand</name> *</type><name>pSub</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iIndex</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>objc</name>&lt;2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SUB-COMMAND"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_GetIndexFromObjStruct</name><argument_list>(
      <argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>aSub</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>aSub</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"sub-command"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>iIndex</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pSub</name> = &amp;<name><name>aSub</name><index>[<expr><name>iIndex</name></expr>]</index></name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>objc</name>!=(<name>pSub</name>-&gt;<name>nArg</name>+2)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr><name>pSub</name>-&gt;<name>zUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>pSub</name>-&gt;<call><name>xProc</name><argument_list>(<argument><expr><name>clientData</name></expr></argument>, <argument><expr><name>interp</name></expr></argument>, <argument><expr><name>objc</name></expr></argument>, <argument><expr><name>objv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** The [clock_seconds] command. This is more or less the same as the
** regular tcl [clock seconds], except that it is available in testfixture
** when linked against both Tcl 8.4 and 8.5. Because [clock seconds] is
** implemented as a script in Tcl 8.5, it is not usually available to
** testfixture.
*/</comment> 
<function><type><name>static</name> <name>int</name></type> <name>clock_seconds_proc</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_Time</name></type> <name>now</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_GetTime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>now</name>.<name>sec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Register commands with the TCL interpreter.
*/</comment>
<function><type><name>int</name></type> <name>SqlitetestThread_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlthread"</expr></argument>, <argument><expr><name>sqlthread_proc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"clock_seconds"</expr></argument>, <argument><expr><name>clock_seconds_proc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>int</name></type> <name>SqlitetestThread_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
