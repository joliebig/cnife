<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="pcache1.c" filename=""><comment type="block">/*
** 2008 November 05
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements the default page cache implementation (the
** sqlite3_pcache interface). It also contains part of the implementation
** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.
** If the default page cache implementation is overriden, then neither of
** these two features are available.
**
** @(#) $Id: pcache1.c,v 1.7 2009/01/07 15:18:21 danielk1977 Exp $
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>PCache1</name> PCache1;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>PgHdr1</name> PgHdr1;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>PgFreeslot</name> PgFreeslot;</struct></type></typedef>

<comment type="block">/* Pointers to structures of this type are cast and returned as 
** opaque sqlite3_pcache* handles
*/</comment>
<struct>struct <name>PCache1</name> <block>{<public type="default">
  <comment type="block">/* Cache configuration parameters. Page size (szPage) and the purgeable
  ** flag (bPurgeable) are set when the cache is created. nMax may be 
  ** modified at any time by a call to the pcache1CacheSize() method.
  ** The global mutex must be held when accessing nMax.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                         <comment type="block">/* Size of allocated pages in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPurgeable</name></decl>;</decl_stmt>                     <comment type="block">/* True if cache is purgeable */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMin</name></decl>;</decl_stmt>                  <comment type="block">/* Minimum number of pages reserved */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nMax</name></decl>;</decl_stmt>                  <comment type="block">/* Configured "cache_size" value */</comment>

  <comment type="block">/* Hash table of all pages. The following variables may only be accessed
  ** when the accessor is holding the global mutex (see pcache1EnterMutex() 
  ** and pcache1LeaveMutex()).
  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nRecyclable</name></decl>;</decl_stmt>           <comment type="block">/* Number of pages in the LRU list */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                 <comment type="block">/* Total number of pages in apHash */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nHash</name></decl>;</decl_stmt>                 <comment type="block">/* Number of slots in apHash[] */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> **</type><name>apHash</name></decl>;</decl_stmt>                    <comment type="block">/* Hash table for fast lookup by key */</comment>

  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iMaxKey</name></decl>;</decl_stmt>               <comment type="block">/* Largest key seen since xTruncate() */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Each cache entry is represented by an instance of the following 
** structure. A buffer of PgHdr1.pCache-&gt;szPage bytes is allocated 
** directly after the structure in memory (see the PGHDR1_TO_PAGE() 
** macro below).
*/</comment>
<struct>struct <name>PgHdr1</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl>;</decl_stmt>             <comment type="block">/* Key value (page number) */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pNext</name></decl>;</decl_stmt>                 <comment type="block">/* Next in hash table chain */</comment>
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name></decl>;</decl_stmt>               <comment type="block">/* Cache that currently owns this page */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pLruNext</name></decl>;</decl_stmt>              <comment type="block">/* Next in LRU list of unpinned pages */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pLruPrev</name></decl>;</decl_stmt>              <comment type="block">/* Previous in LRU list of unpinned pages */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Free slots in the allocator used to divide up the buffer provided using
** the SQLITE_CONFIG_PAGECACHE mechanism.
*/</comment>
<struct>struct <name>PgFreeslot</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>PgFreeslot</name> *</type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next free slot */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Global data used by this cache.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>SQLITE_WSD</name> struct</type> <name>PCacheGlobal</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutex</name></decl>;</decl_stmt>               <comment type="block">/* static mutex MUTEX_STATIC_LRU */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nMaxPage</name></decl>;</decl_stmt>                       <comment type="block">/* Sum of nMaxPage for purgeable caches */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMinPage</name></decl>;</decl_stmt>                       <comment type="block">/* Sum of nMinPage for purgeable caches */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCurrentPage</name></decl>;</decl_stmt>                   <comment type="block">/* Number of purgeable pages allocated */</comment>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pLruHead</name>, *<name>pLruTail</name></decl>;</decl_stmt>        <comment type="block">/* LRU list of unpinned pages */</comment>

  <comment type="block">/* Variables related to SQLITE_CONFIG_PAGECACHE settings. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szSlot</name></decl>;</decl_stmt>                         <comment type="block">/* Size of each free slot */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pStart</name>, *<name>pEnd</name></decl>;</decl_stmt>                <comment type="block">/* Bounds of pagecache malloc range */</comment>
  <decl_stmt><decl><type><name>PgFreeslot</name> *</type><name>pFree</name></decl>;</decl_stmt>                  <comment type="block">/* Free page blocks */</comment>
}</block></decl></decl_stmt> <expr_stmt><expr><name>pcache1_g</name></expr>;</expr_stmt>

<comment type="block">/*
** All code in this file should access the global structure above via the
** alias "pcache1". This ensures that the WSD emulation is used when
** compiling for systems that do not support real WSD.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>pcache1</name> (GLOBAL(struct PCacheGlobal, pcache1_g))</cpp:define>

<comment type="block">/*
** When a PgHdr1 structure is allocated, the associated PCache1.szPage
** bytes of data are located directly after it in memory (i.e. the total
** size of the allocation is sizeof(PgHdr1)+PCache1.szPage byte). The
** PGHDR1_TO_PAGE() macro takes a pointer to a PgHdr1 structure as
** an argument and returns a pointer to the associated block of szPage
** bytes. The PAGE_TO_PGHDR1() macro does the opposite: its argument is
** a pointer to a block of szPage bytes of data and the return value is
** a pointer to the associated PgHdr1 structure.
**
**   assert( PGHDR1_TO_PAGE(PAGE_TO_PGHDR1(X))==X );
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PGHDR1_TO_PAGE</name>(p) (void *)(&amp;((unsigned char *)p)[sizeof(PgHdr1)])</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGE_TO_PGHDR1</name>(p) (PgHdr1 *)(&amp;((unsigned char *)p)[-1*(int)sizeof(PgHdr1)])</cpp:define>

<comment type="block">/*
** Macros to enter and leave the global LRU mutex.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>pcache1EnterMutex</name>() sqlite3_mutex_enter(pcache1.mutex)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>pcache1LeaveMutex</name>() sqlite3_mutex_leave(pcache1.mutex)</cpp:define>

<comment type="block">/******************************************************************************/</comment>
<comment type="block">/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/</comment>

<comment type="block">/*
** This function is called during initialization if a static buffer is 
** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE
** verb to sqlite3_config(). Parameter pBuf points to an allocation large
** enough to contain 'n' buffers of 'sz' bytes each.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PCacheBufferSetup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>sz</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgFreeslot</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>sz</name> &amp;= ~7</expr>;</expr_stmt>
  <expr_stmt><expr><name>pcache1</name>.<name>szSlot</name> = <name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcache1</name>.<name>pStart</name> = <name>pBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcache1</name>.<name>pFree</name> = 0</expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name>--</expr> )</condition><block>{
    <expr_stmt><expr><name>p</name> = (<name>PgFreeslot</name>*)<name>pBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>pcache1</name>.<name>pFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcache1</name>.<name>pFree</name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> = (<name>void</name>*)&amp;((<name>char</name>*)<name>pBuf</name>)[<name>sz</name>]</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>pcache1</name>.<name>pEnd</name> = <name>pBuf</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Malloc function used within this file to allocate space from the buffer
** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no 
** such buffer exists or there is no space left in it, this function falls 
** back to sqlite3Malloc().
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>pcache1Alloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nByte</name>&lt;=<name>pcache1</name>.<name>szSlot</name> &amp;&amp; <name>pcache1</name>.<name>pFree</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name> = (<name>PgHdr1</name> *)<name>pcache1</name>.<name>pFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcache1</name>.<name>pFree</name> = <name>pcache1</name>.<name>pFree</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusSet</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_SIZE</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_USED</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{

    <comment type="block">/* Allocate a new buffer using sqlite3Malloc. Before doing so, exit the
    ** global pcache mutex and unlock the pager-cache object pCache. This is 
    ** so that if the attempt to allocate a new buffer causes the the 
    ** configured soft-heap-limit to be breached, it will be possible to
    ** reclaim memory from this pager-cache.
    */</comment>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> =<init> <expr><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_OVERFLOW</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Free an allocated buffer obtained from pcache1Alloc().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>p</name>&gt;=<name>pcache1</name>.<name>pStart</name> &amp;&amp; <name>p</name>&lt;<name>pcache1</name>.<name>pEnd</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgFreeslot</name> *</type><name>pSlot</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_USED</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSlot</name> = (<name>PgFreeslot</name>*)<name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSlot</name>-&gt;<name>pNext</name> = <name>pcache1</name>.<name>pFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcache1</name>.<name>pFree</name> = <name>pSlot</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iSize</name> =<init> <expr><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_PAGECACHE_OVERFLOW</name></expr></argument>, <argument><expr>-<name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Allocate a new page object initially associated with cache pCache.
*/</comment>
<function><type><name>static</name> <name>PgHdr1</name> *</type><name>pcache1AllocPage</name><parameter_list>(<param><decl><type><name>PCache1</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> =<init> <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>)</argument_list></call> + <name>pCache</name>-&gt;<name>szPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>p</name> =<init> <expr>(<name>PgHdr1</name> *)<call><name>pcache1Alloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCache</name>-&gt;<name>bPurgeable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pcache1</name>.<name>nCurrentPage</name>++</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Free a page object allocated by pcache1AllocPage().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1FreePage</name><parameter_list>(<param><decl><type><name>PgHdr1</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pCache</name>-&gt;<name>bPurgeable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pcache1</name>.<name>nCurrentPage</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>pcache1Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Malloc function used by SQLite to obtain space from the buffer configured
** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer
** exists, this function falls back to sqlite3Malloc().
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3PageMalloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sz</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>pcache1Alloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Free an allocated buffer obtained from sqlite3PageMalloc().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PageFree</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/******************************************************************************/</comment>
<comment type="block">/******** General Implementation Functions ************************************/</comment>

<comment type="block">/*
** This function is used to resize the hash table used by the cache passed
** as the first argument.
**
** The global mutex must be held when this function is called.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pcache1ResizeHash</name><parameter_list>(<param><decl><type><name>PCache1</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr1</name> **</type><name>apNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nNew</name> = <name>p</name>-&gt;<name>nHash</name>*2</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nNew</name>&lt;256</expr> )</condition><then><block>{
    <expr_stmt><expr><name>nNew</name> = 256</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nHash</name></expr> )</condition><then><block>{ <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></then></if>
  <expr_stmt><expr><name>apNew</name> = (<name>PgHdr1</name> **)<call><name>sqlite3_malloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PgHdr1</name> *</expr></argument>)</argument_list></call>*<name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nHash</name></expr> )</condition><then><block>{ <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></then></if>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>apNew</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>apNew</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PgHdr1</name> *</expr></argument>)</argument_list></call>*<name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nHash</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pPage</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pNext</name> =<init> <expr><name>p</name>-&gt;<name><name>apHash</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr>(<name>pPage</name> = <name>pNext</name>)!=0</expr> )</condition><block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> =<init> <expr><name>pPage</name>-&gt;<name>iKey</name> % <name>nNew</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pNext</name> = <name>pPage</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPage</name>-&gt;<name>pNext</name> = <name><name>apNew</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>apNew</name><index>[<expr><name>h</name></expr>]</index></name> = <name>pPage</name></expr>;</expr_stmt>
      }</block></while>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>apHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>apHash</name> = <name>apNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>nHash</name> = <name>nNew</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr>(<name>p</name>-&gt;<name>apHash</name> ? <name>SQLITE_OK</name> : <name>SQLITE_NOMEM</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** This function is used internally to remove the page pPage from the 
** global LRU list, if is part of it. If pPage is not part of the global
** LRU list, then this function is a no-op.
**
** The global mutex must be held when this function is called.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1PinPage</name><parameter_list>(<param><decl><type><name>PgHdr1</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name> &amp;&amp; (<name>pPage</name>-&gt;<name>pLruNext</name> || <name>pPage</name>==<name>pcache1</name>.<name>pLruTail</name>)</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pLruPrev</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPage</name>-&gt;<name>pLruPrev</name>-&gt;<name>pLruNext</name> = <name>pPage</name>-&gt;<name>pLruNext</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pLruNext</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPage</name>-&gt;<name>pLruNext</name>-&gt;<name>pLruPrev</name> = <name>pPage</name>-&gt;<name>pLruPrev</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pcache1</name>.<name>pLruHead</name>==<name>pPage</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pcache1</name>.<name>pLruHead</name> = <name>pPage</name>-&gt;<name>pLruNext</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pcache1</name>.<name>pLruTail</name>==<name>pPage</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pcache1</name>.<name>pLruTail</name> = <name>pPage</name>-&gt;<name>pLruPrev</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pLruNext</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pLruPrev</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pCache</name>-&gt;<name>nRecyclable</name>--</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<comment type="block">/*
** Remove the page supplied as an argument from the hash table 
** (PCache1.apHash structure) that it is currently stored in.
**
** The global mutex must be held when this function is called.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1RemoveFromHash</name><parameter_list>(<param><decl><type><name>PgHdr1</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr><name>pPage</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> **</type><name>pp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>h</name> = <name>pPage</name>-&gt;<name>iKey</name> % <name>pCache</name>-&gt;<name>nHash</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>pp</name>=&amp;<name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr>(*<name>pp</name>)!=<name>pPage</name></expr>;</condition> <incr><expr><name>pp</name>=&amp;(*<name>pp</name>)-&gt;<name>pNext</name></expr></incr>)<empty_stmt>;</empty_stmt></for>
  <expr_stmt><expr>*<name>pp</name> = (*<name>pp</name>)-&gt;<name>pNext</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCache</name>-&gt;<name>nPage</name>--</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** If there are currently more than pcache.nMaxPage pages allocated, try
** to recycle pages to reduce the number allocated to pcache.nMaxPage.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1EnforceMaxPage</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pcache1</name>.<name>nCurrentPage</name>&gt;<name>pcache1</name>.<name>nMaxPage</name> &amp;&amp; <name>pcache1</name>.<name>pLruTail</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>p</name> =<init> <expr><name>pcache1</name>.<name>pLruTail</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="block">/*
** Discard all pages from cache pCache with a page number (key value) 
** greater than or equal to iLimit. Any pinned pages that meet this 
** criteria are unpinned before they are discarded.
**
** The global mutex must be held when this function is called.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1TruncateUnsafe</name><parameter_list>(
  <param><decl><type><name>PCache1</name> *</type><name>pCache</name></decl></param>, 
  <param><decl><type><name>unsigned</name> <name>int</name></type> <name>iLimit</name></decl></param> 
)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>pcache1</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>h</name>=0</expr>;</init> <condition><expr><name>h</name>&lt;<name>pCache</name>-&gt;<name>nHash</name></expr>;</condition> <incr><expr><name>h</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>PgHdr1</name> **</type><name>pp</name> =<init> <expr>&amp;<name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pPage</name></decl>;</decl_stmt>
    <while>while<condition>( <expr>(<name>pPage</name> = *<name>pp</name>)!=0</expr> )</condition><block>{
      <if>if<condition>( <expr><name>pPage</name>-&gt;<name>iKey</name>&gt;=<name>iLimit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>pp</name> = <name>pPage</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pp</name> = &amp;<name>pPage</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></while>
  }</block></for>
}</block></function>

<comment type="block">/******************************************************************************/</comment>
<comment type="block">/******** sqlite3_pcache Methods **********************************************/</comment>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xInit method.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pcache1Init</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pcache1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pcache1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pcache1</name>.<name>mutex</name> = <call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_LRU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xShutdown method.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Shutdown</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* no-op */</comment>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xCreate method.
**
** Allocate a new cache.
*/</comment>
<function><type><name>static</name> <name>sqlite3_pcache</name> *</type><name>pcache1Create</name><parameter_list>(<param><decl><type><name>int</name></type> <name>szPage</name></decl></param>, <param><decl><type><name>int</name></type> <name>bPurgeable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCache</name> = (<name>PCache1</name> *)<call><name>sqlite3_malloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PCache1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PCache1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>szPage</name> = <name>szPage</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>bPurgeable</name> = (<name>bPurgeable</name> ? 1 : 0)</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>bPurgeable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCache</name>-&gt;<name>nMin</name> = 10</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pcache1</name>.<name>nMinPage</name> += <name>pCache</name>-&gt;<name>nMin</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr>(<name>sqlite3_pcache</name> *)<name>pCache</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xCachesize method. 
**
** Configure the cache_size limit for a cache.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Cachesize</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>nMax</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>bPurgeable</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcache1</name>.<name>nMaxPage</name> += (<name>nMax</name> - <name>pCache</name>-&gt;<name>nMax</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>nMax</name> = <name>nMax</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1EnforceMaxPage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xPagecount method. 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pcache1Pagecount</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = ((<name>PCache1</name> *)<name>p</name>)-&gt;<name>nPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xFetch method. 
**
** Fetch a page by key value.
**
** Whether or not a new page may be allocated by this function depends on
** the value of the createFlag argument.
**
** There are three different approaches to obtaining space for a page,
** depending on the value of parameter createFlag (which may be 0, 1 or 2).
**
**   1. Regardless of the value of createFlag, the cache is searched for a 
**      copy of the requested page. If one is found, it is returned.
**
**   2. If createFlag==0 and the page is not already in the cache, NULL is
**      returned.
**
**   3. If createFlag is 1, the cache is marked as purgeable and the page is 
**      not already in the cache, and if either of the following are true, 
**      return NULL:
**
**       (a) the number of pages pinned by the cache is greater than
**           PCache1.nMax, or
**       (b) the number of pages pinned by the cache is greater than
**           the sum of nMax for all purgeable caches, less the sum of 
**           nMin for all other purgeable caches. 
**
**   4. If none of the first three conditions apply and the cache is marked
**      as purgeable, and if one of the following is true:
**
**       (a) The number of pages allocated for the cache is already 
**           PCache1.nMax, or
**
**       (b) The number of pages allocated for all purgeable caches is
**           already equal to or greater than the sum of nMax for all
**           purgeable caches,
**
**      then attempt to recycle a page from the LRU list. If it is the right
**      size, return the recycled buffer. Otherwise, free the buffer and
**      proceed to step 5. 
**
**   5. Otherwise, allocate and return a new page buffer.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>pcache1Fetch</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>iKey</name></decl></param>, <param><decl><type><name>int</name></type> <name>createFlag</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nPinned</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>createFlag</name>==1</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Search the hash table for an existing entry. */</comment>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>nHash</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> =<init> <expr><name>iKey</name> % <name>pCache</name>-&gt;<name>nHash</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>pPage</name>=<name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</init> <condition><expr><name>pPage</name>&amp;&amp;<name>pPage</name>-&gt;<name>iKey</name>!=<name>iKey</name></expr>;</condition> <incr><expr><name>pPage</name>=<name>pPage</name>-&gt;<name>pNext</name></expr></incr>)<empty_stmt>;</empty_stmt></for>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPage</name> || <name>createFlag</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>fetch_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Step 3 of header comment. */</comment>
  <expr_stmt><expr><name>nPinned</name> = <name>pCache</name>-&gt;<name>nPage</name> - <name>pCache</name>-&gt;<name>nRecyclable</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>createFlag</name>==1 &amp;&amp; <name>pCache</name>-&gt;<name>bPurgeable</name> &amp;&amp; (
        <name>nPinned</name>&gt;=(<name>pcache1</name>.<name>nMaxPage</name>+<name>pCache</name>-&gt;<name>nMin</name>-<name>pcache1</name>.<name>nMinPage</name>)
     || <name>nPinned</name>&gt;=(<name>pCache</name>-&gt;<name>nMax</name>)
  )</expr>)</condition><then><block>{
    <goto>goto <name>fetch_out</name>;</goto>
  }</block></then></if>

  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>nPage</name>&gt;=<name>pCache</name>-&gt;<name>nHash</name> &amp;&amp; <call><name>pcache1ResizeHash</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>fetch_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Step 4. Try to recycle a page buffer if appropriate. */</comment>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>bPurgeable</name> &amp;&amp; <name>pcache1</name>.<name>pLruTail</name> &amp;&amp; (
      <name>pCache</name>-&gt;<name>nPage</name>&gt;=<name>pCache</name>-&gt;<name>nMax</name>-1 || <name>pcache1</name>.<name>nCurrentPage</name>&gt;=<name>pcache1</name>.<name>nMaxPage</name>
  )</expr>)</condition><then><block>{
    <expr_stmt><expr><name>pPage</name> = <name>pcache1</name>.<name>pLruTail</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pCache</name>-&gt;<name>szPage</name>!=<name>pCache</name>-&gt;<name>szPage</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pcache1</name>.<name>nCurrentPage</name> -= (<name>pPage</name>-&gt;<name>pCache</name>-&gt;<name>bPurgeable</name> - <name>pCache</name>-&gt;<name>bPurgeable</name>)</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <comment type="block">/* Step 5. If a usable page buffer has still not been found, 
  ** attempt to allocate a new one. 
  */</comment>
  <if>if<condition>( <expr>!<name>pPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name> = <call><name>pcache1AllocPage</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPage</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name> =<init> <expr><name>iKey</name> % <name>pCache</name>-&gt;<name>nHash</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pCache</name>-&gt;<name>szPage</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>PgHdr1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>nPage</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>iKey</name> = <name>iKey</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pNext</name> = <name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pCache</name> = <name>pCache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name> = <name>pPage</name></expr>;</expr_stmt>
  }</block></then></if>

<label><name>fetch_out</name>:</label>
  <if>if<condition>( <expr><name>pPage</name> &amp;&amp; <name>iKey</name>&gt;<name>pCache</name>-&gt;<name>iMaxKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCache</name>-&gt;<name>iMaxKey</name> = <name>iKey</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>createFlag</name>==1</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name>pPage</name> ? <call><name>PGHDR1_TO_PAGE</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call> : 0)</expr>;</return>
}</block></function>


<comment type="block">/*
** Implementation of the sqlite3_pcache.xUnpin method.
**
** Mark a page as unpinned (eligible for asynchronous recycling).
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Unpin</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pPg</name></decl></param>, <param><decl><type><name>int</name></type> <name>reuseUnlikely</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pPage</name> =<init> <expr><call><name>PAGE_TO_PGHDR1</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is an error to call this function if the page is already 
  ** part of the global LRU list.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pLruPrev</name>==0 &amp;&amp; <name>pPage</name>-&gt;<name>pLruNext</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pcache1</name>.<name>pLruHead</name>!=<name>pPage</name> &amp;&amp; <name>pcache1</name>.<name>pLruTail</name>!=<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>reuseUnlikely</name> || <name>pcache1</name>.<name>nCurrentPage</name>&gt;<name>pcache1</name>.<name>nMaxPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Add the page to the global LRU list. Normally, the page is added to
    ** the head of the list (last page to be recycled). However, if the 
    ** reuseUnlikely flag passed to this function is true, the page is added
    ** to the tail of the list (first page to be recycled).
    */</comment>
    <if>if<condition>( <expr><name>pcache1</name>.<name>pLruHead</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pcache1</name>.<name>pLruHead</name>-&gt;<name>pLruPrev</name> = <name>pPage</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPage</name>-&gt;<name>pLruNext</name> = <name>pcache1</name>.<name>pLruHead</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pcache1</name>.<name>pLruHead</name> = <name>pPage</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pcache1</name>.<name>pLruTail</name> = <name>pPage</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pcache1</name>.<name>pLruHead</name> = <name>pPage</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>nRecyclable</name>++</expr>;</expr_stmt>
  }</block></else></if>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xRekey method. 
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Rekey</name><parameter_list>(
  <param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pPg</name></decl></param>,
  <param><decl><type><name>unsigned</name> <name>int</name></type> <name>iOld</name></decl></param>,
  <param><decl><type><name>unsigned</name> <name>int</name></type> <name>iNew</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>pPage</name> =<init> <expr><call><name>PAGE_TO_PGHDR1</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr1</name> **</type><name>pp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>iKey</name>==<name>iOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>h</name> = <name>iOld</name>%<name>pCache</name>-&gt;<name>nHash</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pp</name> = &amp;<name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <while>while<condition>( <expr>(*<name>pp</name>)!=<name>pPage</name></expr> )</condition><block>{
    <expr_stmt><expr><name>pp</name> = &amp;(*<name>pp</name>)-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr>*<name>pp</name> = <name>pPage</name>-&gt;<name>pNext</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>h</name> = <name>iNew</name>%<name>pCache</name>-&gt;<name>nHash</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>iKey</name> = <name>iNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pNext</name> = <name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCache</name>-&gt;<name><name>apHash</name><index>[<expr><name>h</name></expr>]</index></name> = <name>pPage</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>iNew</name>&gt;<name>pCache</name>-&gt;<name>iMaxKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCache</name>-&gt;<name>iMaxKey</name> = <name>iNew</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xTruncate method. 
**
** Discard all unpinned pages in the cache with a page number equal to
** or greater than parameter iLimit. Any pinned pages with a page number
** equal to or greater than iLimit are implicitly unpinned.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Truncate</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>iLimit</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iLimit</name>&lt;=<name>pCache</name>-&gt;<name>iMaxKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcache1TruncateUnsafe</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>iMaxKey</name> = <name>iLimit</name>-1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the sqlite3_pcache.xDestroy method. 
**
** Destroy a cache allocated using pcache1Create().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcache1Destroy</name><parameter_list>(<param><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache1</name> *</type><name>pCache</name> =<init> <expr>(<name>PCache1</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1TruncateUnsafe</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcache1</name>.<name>nMaxPage</name> -= <name>pCache</name>-&gt;<name>nMax</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pcache1</name>.<name>nMinPage</name> -= <name>pCache</name>-&gt;<name>nMin</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1EnforceMaxPage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>apHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This function is called during initialization (sqlite3_initialize()) to
** install the default pluggable cache module, assuming the user has not
** already provided an alternative.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PCacheSetDefault</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>sqlite3_pcache_methods</name></type> <name>defaultMethods</name> =<init> <expr><block>{
    <expr>0</expr>,                       <comment type="block">/* pArg */</comment>
    <expr><name>pcache1Init</name></expr>,             <comment type="block">/* xInit */</comment>
    <expr><name>pcache1Shutdown</name></expr>,         <comment type="block">/* xShutdown */</comment>
    <expr><name>pcache1Create</name></expr>,           <comment type="block">/* xCreate */</comment>
    <expr><name>pcache1Cachesize</name></expr>,        <comment type="block">/* xCachesize */</comment>
    <expr><name>pcache1Pagecount</name></expr>,        <comment type="block">/* xPagecount */</comment>
    <expr><name>pcache1Fetch</name></expr>,            <comment type="block">/* xFetch */</comment>
    <expr><name>pcache1Unpin</name></expr>,            <comment type="block">/* xUnpin */</comment>
    <expr><name>pcache1Rekey</name></expr>,            <comment type="block">/* xRekey */</comment>
    <expr><name>pcache1Truncate</name></expr>,         <comment type="block">/* xTruncate */</comment>
    <expr><name>pcache1Destroy</name></expr>           <comment type="block">/* xDestroy */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_config</name><argument_list>(<argument><expr><name>SQLITE_CONFIG_PCACHE</name></expr></argument>, <argument><expr>&amp;<name>defaultMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
<comment type="block">/*
** This function is called to free superfluous dynamically allocated memory
** held by the pager system. Memory in use by any SQLite pager allocated
** by the current thread may be sqlite3_free()ed.
**
** nReq is the number of bytes of memory required. Once this much has
** been released, the function returns. The return value is the total number 
** of bytes of memory released.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheReleaseMemory</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nReq</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pcache1</name>.<name>pStart</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pcache1EnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr>(<name>nReq</name>&lt;0 || <name>nFree</name>&lt;<name>nReq</name>) &amp;&amp; (<name>p</name>=<name>pcache1</name>.<name>pLruTail</name>)</expr> )</condition><block>{
      <expr_stmt><expr><name>nFree</name> += <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1PinPage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1RemoveFromHash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcache1FreePage</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>pcache1LeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>nFree</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_MEMORY_MANAGEMENT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** This function is used by test procedures to inspect the internal state
** of the global cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheStats</name><parameter_list>(
  <param><decl><type><name>int</name> *</type><name>pnCurrent</name></decl></param>,      <comment type="block">/* OUT: Total number of pages cached */</comment>
  <param><decl><type><name>int</name> *</type><name>pnMax</name></decl></param>,          <comment type="block">/* OUT: Global maximum cache size */</comment>
  <param><decl><type><name>int</name> *</type><name>pnMin</name></decl></param>,          <comment type="block">/* OUT: Sum of PCache1.nMin for purgeable caches */</comment>
  <param><decl><type><name>int</name> *</type><name>pnRecyclable</name></decl></param>    <comment type="block">/* OUT: Total number of pages available for recycling */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr1</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRecyclable</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name>=<name>pcache1</name>.<name>pLruHead</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pLruNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>nRecyclable</name>++</expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr>*<name>pnCurrent</name> = <name>pcache1</name>.<name>nCurrentPage</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnMax</name> = <name>pcache1</name>.<name>nMaxPage</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnMin</name> = <name>pcache1</name>.<name>nMinPage</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnRecyclable</name> = <name>nRecyclable</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
