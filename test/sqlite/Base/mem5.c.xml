<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="mem5.c" filename=""><comment type="block">/*
** 2007 October 14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C functions that implement a memory
** allocation subsystem for use by SQLite. 
**
** This version of the memory allocation subsystem omits all
** use of malloc(). The SQLite user supplies a block of memory
** before calling sqlite3_initialize() from which allocations
** are made and returned by the xMalloc() and xRealloc() 
** implementations. Once sqlite3_initialize() has been called,
** the amount of memory available to SQLite is fixed and cannot
** be changed.
**
** This version of the memory allocation subsystem is included
** in the build only if SQLITE_ENABLE_MEMSYS5 is defined.
**
** $Id: mem5.c,v 1.19 2008/11/19 16:52:44 danielk1977 Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** This version of the memory allocator is used only when 
** SQLITE_ENABLE_MEMSYS5 is defined.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS5</name></cpp:ifdef>

<comment type="block">/*
** A minimum allocation is an instance of the following structure.
** Larger allocations are an array of these structures where the
** size of the array is a power of 2.
*/</comment>
<typedef>typedef <type><struct>struct <name>Mem5Link</name> Mem5Link;</struct></type></typedef>
<struct>struct <name>Mem5Link</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>       <comment type="block">/* Index of next free chunk */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>       <comment type="block">/* Index of previous free chunk */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Maximum size of any allocation is ((1&lt;&lt;LOGMAX)*mem5.nAtom). Since
** mem5.nAtom is always at least 8, this is not really a practical
** limitation.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>LOGMAX</name> 30</cpp:define>

<comment type="block">/*
** Masks used for mem5.aCtrl[] elements.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CTRL_LOGSIZE</name>  0x1f</cpp:define>    <comment type="block">/* Log2 Size of this block relative to POW2_MIN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CTRL_FREE</name>     0x20</cpp:define>    <comment type="block">/* True if not checked out */</comment>

<comment type="block">/*
** All of the static variables used by this module are collected
** into a single structure named "mem5".  This is to keep the
** static variables organized and to reduce namespace pollution
** when this module is combined with other in the amalgamation.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>SQLITE_WSD</name> struct</type> <name>Mem5Global</name> <block>{
  <comment type="block">/*
  ** Memory available for allocation
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAtom</name></decl>;</decl_stmt>       <comment type="block">/* Smallest possible allocation in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlock</name></decl>;</decl_stmt>      <comment type="block">/* Number of nAtom sized blocks in zPool */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>zPool</name></decl>;</decl_stmt>
  
  <comment type="block">/*
  ** Mutex to control access to the memory allocation subsystem.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutex</name></decl>;</decl_stmt>

  <comment type="block">/*
  ** Performance statistics
  */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nAlloc</name></decl>;</decl_stmt>         <comment type="block">/* Total number of calls to malloc */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>totalAlloc</name></decl>;</decl_stmt>     <comment type="block">/* Total of all malloc calls - includes internal frag */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>totalExcess</name></decl>;</decl_stmt>    <comment type="block">/* Total internal fragmentation */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>currentOut</name></decl>;</decl_stmt>     <comment type="block">/* Current checkout, including internal fragmentation */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>currentCount</name></decl>;</decl_stmt>   <comment type="block">/* Current number of distinct checkouts */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>maxOut</name></decl>;</decl_stmt>         <comment type="block">/* Maximum instantaneous currentOut */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>maxCount</name></decl>;</decl_stmt>       <comment type="block">/* Maximum instantaneous currentCount */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>maxRequest</name></decl>;</decl_stmt>     <comment type="block">/* Largest allocation (exclusive of internal frag) */</comment>
  
  <comment type="block">/*
  ** Lists of free blocks of various sizes.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aiFreelist</name><index>[<expr><name>LOGMAX</name>+1</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/*
  ** Space for tracking which blocks are checked out and the size
  ** of each block.  One byte per block.
  */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aCtrl</name></decl>;</decl_stmt>

}</block></decl></decl_stmt> <expr_stmt><expr><name>mem5</name> = <block>{ <expr>19804167</expr> }</block></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>mem5</name> <name>GLOBAL</name>(struct Mem5Global, mem5)</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM5LINK</name>(idx) ((Mem5Link *)(&amp;mem5.zPool[(idx)*mem5.nAtom]))</cpp:define>

<comment type="block">/*
** Unlink the chunk at mem5.aPool[i] from list it is currently
** on.  It should be found on mem5.aiFreelist[iLogsize].
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Unlink</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>iLogsize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>next</name>, <name>prev</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLogsize</name>&gt;=0 &amp;&amp; <name>iLogsize</name>&lt;=<name>LOGMAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> &amp; <name>CTRL_LOGSIZE</name>)==<name>iLogsize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>next</name> = <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<name>next</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prev</name> = <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<name>prev</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>prev</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name> = <name>next</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call>-&gt;<name>next</name> = <name>next</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>next</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call>-&gt;<name>prev</name> = <name>prev</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Link the chunk at mem5.aPool[i] so that is on the iLogsize
** free list.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Link</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>iLogsize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>mem5</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLogsize</name>&gt;=0 &amp;&amp; <name>iLogsize</name>&lt;=<name>LOGMAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> &amp; <name>CTRL_LOGSIZE</name>)==<name>iLogsize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>x</name> = <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<name>next</name> = <name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<name>prev</name> = -1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>x</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name>&lt;<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>-&gt;<name>prev</name> = <name>i</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** If the STATIC_MEM mutex is not already held, obtain it now. The mutex
** will already be held (obtained by code in malloc.c) if
** sqlite3GlobalConfig.bMemStat is true.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Enter</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name>==0 &amp;&amp; <name>mem5</name>.<name>mutex</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>mem5</name>.<name>mutex</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem5</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Leave</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem5</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the size of an outstanding allocation, in bytes.  The
** size returned omits the 8-byte header overhead.  This only
** works for chunks that are currently checked out.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>memsys5Size</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iSize</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>((<name>u8</name> *)<name>p</name>-<name>mem5</name>.<name>zPool</name>)/<name>mem5</name>.<name>nAtom</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSize</name> = <name>mem5</name>.<name>nAtom</name> * (1 &lt;&lt; (<name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name>&amp;<name>CTRL_LOGSIZE</name>))</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>iSize</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Find the first entry on the freelist iLogsize.  Unlink that
** entry and return its index. 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>memsys5UnlinkFirst</name><parameter_list>(<param><decl><type><name>int</name></type> <name>iLogsize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLogsize</name>&gt;=0 &amp;&amp; <name>iLogsize</name>&lt;=<name>LOGMAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> = <name>iFirst</name> = <name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iFirst</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name>&gt;0</expr> )</condition><block>{
    <if>if<condition>( <expr><name>i</name>&lt;<name>iFirst</name></expr> )</condition><then> <expr_stmt><expr><name>iFirst</name> = <name>i</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>i</name> = <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>-&gt;<name>next</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>memsys5Unlink</name><argument_list>(<argument><expr><name>iFirst</name></expr></argument>, <argument><expr><name>iLogsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iFirst</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a block of memory of at least nBytes in size.
** Return NULL if unable.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>memsys5MallocUnsafe</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>           <comment type="block">/* Index of a mem5.aPool[] slot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBin</name></decl>;</decl_stmt>        <comment type="block">/* Index into mem5.aiFreelist[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFullSz</name></decl>;</decl_stmt>     <comment type="block">/* Size of allocation rounded up to power of 2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLogsize</name></decl>;</decl_stmt>    <comment type="block">/* Log2 of iFullSz/POW2_MIN */</comment>

  <comment type="block">/* Keep track of the maximum allocation request.  Even unfulfilled
  ** requests are counted */</comment>
  <if>if<condition>( <expr>(<name>u32</name>)<name>nByte</name>&gt;<name>mem5</name>.<name>maxRequest</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>mem5</name>.<name>maxRequest</name> = <name>nByte</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Round nByte up to the next valid power of two */</comment>
  <for>for(<init><expr><name>iFullSz</name>=<name>mem5</name>.<name>nAtom</name></expr>, <expr><name>iLogsize</name>=0</expr>;</init> <condition><expr><name>iFullSz</name>&lt;<name>nByte</name></expr>;</condition> <incr><expr><name>iFullSz</name> *= 2</expr>, <expr><name>iLogsize</name>++</expr></incr>)<block>{}</block></for>

  <comment type="block">/* Make sure mem5.aiFreelist[iLogsize] contains at least one free
  ** block.  If not, then split a block of the next larger power of
  ** two in order to create a new free block of size iLogsize.
  */</comment>
  <for>for(<init><expr><name>iBin</name>=<name>iLogsize</name></expr>;</init> <condition><expr><name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>iBin</name></expr>]</index></name>&lt;0 &amp;&amp; <name>iBin</name>&lt;=<name>LOGMAX</name></expr>;</condition> <incr><expr><name>iBin</name>++</expr></incr>)<block>{}</block></for>
  <if>if<condition>( <expr><name>iBin</name>&gt;<name>LOGMAX</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>i</name> = <call><name>memsys5UnlinkFirst</name><argument_list>(<argument><expr><name>iBin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>iBin</name>&gt;<name>iLogsize</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iBin</name>--</expr>;</expr_stmt>
    <expr_stmt><expr><name>newSize</name> = 1 &lt;&lt; <name>iBin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>i</name>+<name>newSize</name></expr>]</index></name> = <name>CTRL_FREE</name> | <name>iBin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>i</name>+<name>newSize</name></expr></argument>, <argument><expr><name>iBin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> = <name>iLogsize</name></expr>;</expr_stmt>

  <comment type="block">/* Update allocator performance statistics. */</comment>
  <expr_stmt><expr><name>mem5</name>.<name>nAlloc</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>totalAlloc</name> += <name>iFullSz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>totalExcess</name> += <name>iFullSz</name> - <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>currentCount</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>currentOut</name> += <name>iFullSz</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>mem5</name>.<name>maxCount</name>&lt;<name>mem5</name>.<name>currentCount</name></expr> )</condition><then> <expr_stmt><expr><name>mem5</name>.<name>maxCount</name> = <name>mem5</name>.<name>currentCount</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>mem5</name>.<name>maxOut</name>&lt;<name>mem5</name>.<name>currentOut</name></expr> )</condition><then> <expr_stmt><expr><name>mem5</name>.<name>maxOut</name> = <name>mem5</name>.<name>currentOut</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Return a pointer to the allocated memory. */</comment>
  <return>return <expr>(<name>void</name>*)&amp;<name>mem5</name>.<name><name>zPool</name><index>[<expr><name>i</name>*<name>mem5</name>.<name>nAtom</name></expr>]</index></name></expr>;</return>
}</block></function>

<comment type="block">/*
** Free an outstanding memory allocation.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5FreeUnsafe</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pOld</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>size</name>, <name>iLogsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlock</name></decl>;</decl_stmt>             

  <comment type="block">/* Set iBlock to the index of the block pointed to by pOld in 
  ** the array of mem5.nAtom byte blocks pointed to by mem5.zPool.
  */</comment>
  <expr_stmt><expr><name>iBlock</name> = ((<name>u8</name> *)<name>pOld</name>-<name>mem5</name>.<name>zPool</name>)/<name>mem5</name>.<name>nAtom</name></expr>;</expr_stmt>

  <comment type="block">/* Check that the pointer pOld points to a valid, non-free block. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlock</name>&gt;=0 &amp;&amp; <name>iBlock</name>&lt;<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>((<name>u8</name> *)<name>pOld</name>-<name>mem5</name>.<name>zPool</name>)%<name>mem5</name>.<name>nAtom</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> &amp; <name>CTRL_FREE</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iLogsize</name> = <name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> &amp; <name>CTRL_LOGSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> = 1&lt;&lt;<name>iLogsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlock</name>+<name>size</name>-1&lt;(<name>u32</name>)<name>mem5</name>.<name>nBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> |= <name>CTRL_FREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name>+<name>size</name>-1</expr>]</index></name> |= <name>CTRL_FREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mem5</name>.<name>currentCount</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mem5</name>.<name>currentOut</name>&gt;=(<name>size</name>*<name>mem5</name>.<name>nAtom</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>currentCount</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>currentOut</name> -= <name>size</name>*<name>mem5</name>.<name>nAtom</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mem5</name>.<name>currentOut</name>&gt;0 || <name>mem5</name>.<name>currentCount</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mem5</name>.<name>currentCount</name>&gt;0 || <name>mem5</name>.<name>currentOut</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> = <name>CTRL_FREE</name> | <name>iLogsize</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>iLogsize</name>&lt;<name>LOGMAX</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iBuddy</name></decl>;</decl_stmt>
    <if>if<condition>( <expr>(<name>iBlock</name>&gt;&gt;<name>iLogsize</name>) &amp; 1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>iBuddy</name> = <name>iBlock</name> - <name>size</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>iBuddy</name> = <name>iBlock</name> + <name>size</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBuddy</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>iBuddy</name>+(1&lt;&lt;<name>iLogsize</name>))&gt;<name>mem5</name>.<name>nBlock</name></expr> )</condition><then> <break>break;</break></then></if>
    <if>if<condition>( <expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name>!=(<name>CTRL_FREE</name> | <name>iLogsize</name>)</expr> )</condition><then> <break>break;</break></then></if>
    <expr_stmt><expr><call><name>memsys5Unlink</name><argument_list>(<argument><expr><name>iBuddy</name></expr></argument>, <argument><expr><name>iLogsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLogsize</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iBuddy</name>&lt;<name>iBlock</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name> = <name>CTRL_FREE</name> | <name>iLogsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlock</name> = <name>iBuddy</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> = <name>CTRL_FREE</name> | <name>iLogsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>size</name> *= 2</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>iBlock</name></expr></argument>, <argument><expr><name>iLogsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Allocate nBytes of memory
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>memsys5Malloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nBytes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_int64</name> *</type><name>p</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>nBytes</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <call><name>memsys5MallocUnsafe</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>(<name>void</name>*)<name>p</name></expr>;</return> 
}</block></function>

<comment type="block">/*
** Free memory.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pPrior</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pPrior</name>==0</expr> )</condition><then><block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5FreeUnsafe</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
}</block></function>

<comment type="block">/*
** Change the size of an existing memory allocation
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>memsys5Realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pPrior</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBytes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pPrior</name>==0</expr> )</condition><then><block>{
    <return>return <expr><call><name>memsys5Malloc</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>nBytes</name>&lt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memsys5Free</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>nOld</name> = <call><name>memsys5Size</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nBytes</name>&lt;=<name>nOld</name></expr> )</condition><then><block>{
    <return>return <expr><name>pPrior</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>memsys5MallocUnsafe</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5FreeUnsafe</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Round up a request size to the next valid allocation size.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>memsys5Roundup</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iFullSz</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>iFullSz</name>=<name>mem5</name>.<name>nAtom</name></expr>;</init> <condition><expr><name>iFullSz</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>iFullSz</name> *= 2</expr></incr>)<empty_stmt>;</empty_stmt></for>
  <return>return <expr><name>iFullSz</name></expr>;</return>
}</block></function>

<function><type><name>static</name> <name>int</name></type> <name>memsys5Log</name><parameter_list>(<param><decl><type><name>int</name></type> <name>iValue</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iLog</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>iLog</name>=0</expr>;</init> <condition><expr>(1&lt;&lt;<name>iLog</name>)&lt;<name>iValue</name></expr>;</condition> <incr><expr><name>iLog</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
  <return>return <expr><name>iLog</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Initialize this module.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>memsys5Init</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> =<init> <expr><name>sqlite3GlobalConfig</name>.<name>nHeap</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name> *</type><name>zByte</name> =<init> <expr>(<name>u8</name> *)<name>sqlite3GlobalConfig</name>.<name>pHeap</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMinLog</name></decl>;</decl_stmt>                 <comment type="block">/* Log of minimum allocation size in bytes*/</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>zByte</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>nMinLog</name> = <call><name>memsys5Log</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>mnReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>nAtom</name> = (1&lt;&lt;<name>nMinLog</name>)</expr>;</expr_stmt>
  <while>while<condition>( <expr>(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>Mem5Link</name></expr></argument>)</argument_list></call>&gt;<name>mem5</name>.<name>nAtom</name></expr> )</condition><block>{
    <expr_stmt><expr><name>mem5</name>.<name>nAtom</name> = <name>mem5</name>.<name>nAtom</name> &lt;&lt; 1</expr>;</expr_stmt>
  }</block></while>

  <expr_stmt><expr><name>mem5</name>.<name>nBlock</name> = (<name>nByte</name> / (<name>mem5</name>.<name>nAtom</name>+<call><name>sizeof</name><argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>zPool</name> = <name>zByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem5</name>.<name>aCtrl</name> = (<name>u8</name> *)&amp;<name>mem5</name>.<name><name>zPool</name><index>[<expr><name>mem5</name>.<name>nBlock</name>*<name>mem5</name>.<name>nAtom</name></expr>]</index></name></expr>;</expr_stmt>

  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;=<name>LOGMAX</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>ii</name></expr>]</index></name> = -1</expr>;</expr_stmt>
  }</block></for>

  <expr_stmt><expr><name>iOffset</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>ii</name>=<name>LOGMAX</name></expr>;</init> <condition><expr><name>ii</name>&gt;=0</expr>;</condition> <incr><expr><name>ii</name>--</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> =<init> <expr>(1&lt;&lt;<name>ii</name>)</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr>(<name>iOffset</name>+<name>nAlloc</name>)&lt;=<name>mem5</name>.<name>nBlock</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>mem5</name>.<name><name>aCtrl</name><index>[<expr><name>iOffset</name></expr>]</index></name> = <name>ii</name> | <name>CTRL_FREE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOffset</name> += <name>nAlloc</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>iOffset</name>+<name>nAlloc</name>)&gt;<name>mem5</name>.<name>nBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Deinitialize this module.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>memsys5Shutdown</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** Open the file indicated and write a log of all unfreed memory 
** allocations into that log.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Memsys5Dump</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>out</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMinLog</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>zFilename</name>==0 || <name><name>zFilename</name><index>[<expr>0</expr>]</index></name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>out</name> = <name>stdout</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>out</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>out</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"** Unable to output memory debug output log: %s **\n"</expr></argument>,
                      <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></else></if>
  <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMinLog</name> = <call><name>memsys5Log</name><argument_list>(<argument><expr><name>mem5</name>.<name>nAtom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>LOGMAX</name> &amp;&amp; <name>i</name>+<name>nMinLog</name>&lt;32</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <for>for(<init><expr><name>n</name>=0</expr>, <expr><name>j</name>=<name>mem5</name>.<name><name>aiFreelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name>&gt;=0</expr>;</condition> <incr><expr><name>j</name> = <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call>-&gt;<name>next</name></expr>, <expr><name>n</name>++</expr></incr>)<block>{}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"freelist items of size %d: %d\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>nAtom</name> &lt;&lt; <name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.nAlloc       = %llu\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.totalAlloc   = %llu\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>totalAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.totalExcess  = %llu\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>totalExcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.currentOut   = %u\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>currentOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.currentCount = %u\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>currentCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.maxOut       = %u\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>maxOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.maxCount     = %u\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>maxCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"mem5.maxRequest   = %u\n"</expr></argument>, <argument><expr><name>mem5</name>.<name>maxRequest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>out</name>==<name>stdout</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** This routine is the only routine in this file with external 
** linkage. It returns a pointer to a static sqlite3_mem_methods
** struct populated with the memsys5 methods.
*/</comment>
<function><type><name>const</name> <name>sqlite3_mem_methods</name> *</type><name>sqlite3MemGetMemsys5</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>sqlite3_mem_methods</name></type> <name>memsys5Methods</name> =<init> <expr><block>{
     <expr><name>memsys5Malloc</name></expr>,
     <expr><name>memsys5Free</name></expr>,
     <expr><name>memsys5Realloc</name></expr>,
     <expr><name>memsys5Size</name></expr>,
     <expr><name>memsys5Roundup</name></expr>,
     <expr><name>memsys5Init</name></expr>,
     <expr><name>memsys5Shutdown</name></expr>,
     <expr>0</expr>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr>&amp;<name>memsys5Methods</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_MEMSYS5 */</comment>
</unit>
