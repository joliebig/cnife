<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="update.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle UPDATE statements.
**
** $Id: update.c,v 1.191 2008/12/23 23:56:22 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/* Forward declaration */</comment>
<function_decl><type><name>static</name> <name>void</name></type> <name>updateVirtualTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,       <comment type="block">/* The virtual table to be modified */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,         <comment type="block">/* The virtual table */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pChanges</name></decl></param>,  <comment type="block">/* The columns to change in the UPDATE statement */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRowidExpr</name></decl></param>,    <comment type="block">/* Expression used to recompute the rowid */</comment>
  <param><decl><type><name>int</name> *</type><name>aXRef</name></decl></param>,          <comment type="block">/* Mapping from columns of pTab to entries in pChanges */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>         <comment type="block">/* WHERE clause of the UPDATE statement */</comment>
)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** The most recently coded instruction was an OP_Column to retrieve the
** i-th column of table pTab. This routine sets the P4 parameter of the 
** OP_Column to the default value, if any.
**
** The default value of a column is specified by a DEFAULT clause in the 
** column definition. This was either supplied by the user when the table
** was created, or added later to the table definition by an ALTER TABLE
** command. If the latter, then the row-records in the table btree on disk
** may not contain a value for the column and the default value, taken
** from the P4 parameter of the OP_Column instruction, is returned instead.
** If the former, then all row-records are guaranteed to include a value
** for the column and the P4 value is not required.
**
** Column definitions created by an ALTER TABLE command may only have 
** literal default values specified: a number, null or a string. (If a more
** complicated default expression value was provided, it is evaluated 
** when the ALTER TABLE is executed and one of the literal values written
** into the sqlite_master table.)
**
** Therefore, the P4 parameter is only required if the default value for
** the column is a literal number, string or null. The sqlite3ValueFromExpr()
** function is capable of transforming these types of expressions into
** sqlite3_value objects.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ColumnDefault</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pTab</name> &amp;&amp; !<name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> =<init> <expr><call><name>ENC</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name> =<init> <expr>&amp;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%s.%s", <name>pTab</name>-&gt;<name>zName</name>, <name>pCol</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><call><name>sqlite3VdbeDb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>pDflt</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, 
                         <argument><expr><name>pCol</name>-&gt;<name>affinity</name></expr></argument>, <argument><expr>&amp;<name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pValue</name></expr> )</condition><then><block>{
      <macro><name>sqlite3VdbeChangeP4</name><argument_list>(<argument>v</argument>, <argument>-1</argument>, <argument>(const char *)pValue</argument>, <argument>P4_MEM</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Process an UPDATE statement.
**
**   UPDATE OR IGNORE table_wxyz SET a=b, c=d WHERE e&lt;5 AND f NOT NULL;
**          \_______/ \________/     \______/       \________________/
*            onError   pTabList      pChanges             pWhere
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Update</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,     <comment type="block">/* The table in which we should change things */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pChanges</name></decl></param>,    <comment type="block">/* Things to be changed */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,          <comment type="block">/* The WHERE clause.  May be null */</comment>
  <param><decl><type><name>int</name></type> <name>onError</name></decl></param>            <comment type="block">/* How to handle constraint errors */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>              <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>           <comment type="block">/* The table to be updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* VDBE instruction address of the start of the loop */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl>;</decl_stmt>     <comment type="block">/* Information about the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>           <comment type="block">/* For looping over indices */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIdx</name></decl>;</decl_stmt>              <comment type="block">/* Number of indices that need updating */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>              <comment type="block">/* VDBE Cursor number of pTab */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* The database structure */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aRegIdx</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* One register assigned to each index to be updated */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aXRef</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* aXRef[i] is the index in pChanges-&gt;a[] of the
                         ** an expression for the i-th column of the table.
                         ** aXRef[i]==-1 if the i-th column is not changed. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>chngRowid</name></decl>;</decl_stmt>         <comment type="block">/* True if the record number is being changed */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pRowidExpr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Expression defining the new record number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openAll</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* True if all indices need to be opened */</comment>
  <decl_stmt><decl><type><name>AuthContext</name></type> <name>sContext</name></decl>;</decl_stmt>  <comment type="block">/* The authorization context */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>       <comment type="block">/* The name-context to resolve expressions in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>               <comment type="block">/* Database containing the table being updated */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j1</name></decl>;</decl_stmt>                <comment type="block">/* Addresses of jump instructions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>okOnePass</name></decl>;</decl_stmt>         <comment type="block">/* True for one-pass algorithm without the FIFO */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>                  <comment type="block">/* Trying to update a view */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>triggers_exist</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* True if any row triggers exist */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>iBeginAfterTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Address of after trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEndAfterTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Exit of after trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBeginBeforeTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Address of before trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEndBeforeTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Exit of before trigger program */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>old_col_mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* Mask of OLD.* columns in use */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>new_col_mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* Mask of NEW.* columns in use */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>newIdx</name>      =<init> <expr>-1</expr></init></decl>;</decl_stmt>  <comment type="block">/* index of trigger "new" temp table       */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oldIdx</name>      =<init> <expr>-1</expr></init></decl>;</decl_stmt>  <comment type="block">/* index of trigger "old" temp table       */</comment>

  <comment type="block">/* Register Allocations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowCount</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* A count of rows changed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regOldRowid</name></decl>;</decl_stmt>       <comment type="block">/* The old rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regNewRowid</name></decl>;</decl_stmt>       <comment type="block">/* The new rowid */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regData</name></decl>;</decl_stmt>           <comment type="block">/* New data for the row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowSet</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Rowset of rows to be updated */</comment>

  <expr_stmt><expr><name>sContext</name>.<name>pParse</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>update_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabList</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locate the table which we want to update. 
  */</comment>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <goto>goto <name>update_cleanup</name>;</goto></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** updated is a view
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>triggers_exist</name> = <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> = <name>pTab</name>-&gt;<name>pSelect</name>!=0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>triggers_exist</name> 0</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>isView</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>isView</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>triggers_exist</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>update_cleanup</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>update_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>aXRef</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call> * <name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>aXRef</name>==0</expr> )</condition><then> <goto>goto <name>update_cleanup</name>;</goto></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt></for>

  <comment type="block">/* If there are FOR EACH ROW triggers, allocate cursors for the
  ** special OLD and NEW tables
  */</comment>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>newIdx</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>oldIdx</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Allocate a cursors for the main database table and for all indices.
  ** The index cursors might not be used, but if they are used they
  ** need to occur right after the database cursor.  So go ahead and
  ** allocate enough space, just in case.
  */</comment>
  <expr_stmt><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>iCursor</name> = <name>iCur</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Initialize the name-context */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pTabList</name></expr>;</expr_stmt>

  <comment type="block">/* Resolve the column names in all the expressions of the
  ** of the UPDATE statement.  Also find the column index
  ** for each column to be updated in the pChanges array.  For each
  ** column to be updated, make sure we have authorization to change
  ** that column.
  */</comment>
  <expr_stmt><expr><name>chngRowid</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pChanges</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>update_cleanup</name>;</goto>
    }</block></then></if>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>j</name>==<name>pTab</name>-&gt;<name>iPKey</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>chngRowid</name> = 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>pRowidExpr</name> = <name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>j</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>j</name>&gt;=<name>pTab</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>chngRowid</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pRowidExpr</name> = <name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such column: %s"</expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>update_cleanup</name>;</goto>
      }</block></else></if>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_UPDATE</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>,
                           <argument><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DENY</name></expr> )</condition><then><block>{
        <goto>goto <name>update_cleanup</name>;</goto>
      }</block></then><else>else <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IGNORE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>aXRef</name><index>[<expr><name>j</name></expr>]</index></name> = -1</expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></for>

  <comment type="block">/* Allocate memory for the array aRegIdx[].  There is one entry in the
  ** array for each index associated with table being updated.  Fill in
  ** the value with a register number for indices that are to be used
  ** and with zero for unused indices.
  */</comment>
  <for>for(<init><expr><name>nIdx</name>=0</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr>, <expr><name>nIdx</name>++</expr></incr>)<block>{}</block></for>
  <if>if<condition>( <expr><name>nIdx</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>aRegIdx</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Index</name>*</expr></argument>)</argument_list></call> * <name>nIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>aRegIdx</name>==0</expr> )</condition><then> <goto>goto <name>update_cleanup</name>;</goto></then></if>
  }</block></then></if>
  <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr>, <expr><name>j</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>reg</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>reg</name> = 0</expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pIdx</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>&gt;=0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>reg</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
    }</block></else></if>
    <expr_stmt><expr><name><name>aRegIdx</name><index>[<expr><name>j</name></expr>]</index></name> = <name>reg</name></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Allocate a block of register used to store the change record
  ** sent to sqlite3GenerateConstraintChecks().  There are either
  ** one or two registers for holding the rowid.  One rowid register
  ** is used if chngRowid is false and two are used if chngRowid is
  ** true.  Following these are pTab-&gt;nCol register holding column
  ** data.
  */</comment>
  <expr_stmt><expr><name>regOldRowid</name> = <name>regNewRowid</name> = <name>pParse</name>-&gt;<name>nMem</name> + 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>pTab</name>-&gt;<name>nCol</name> + 1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>regNewRowid</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>regData</name> = <name>regNewRowid</name>+1</expr>;</expr_stmt>
 

  <comment type="block">/* Begin generating code.
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <goto>goto <name>update_cleanup</name>;</goto></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nested</name>==0</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <comment type="block">/* Virtual tables must be handled separately */</comment>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>updateVirtualTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>pRowidExpr</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>,
                       <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWhere</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTabList</name> = 0</expr>;</expr_stmt>
    <goto>goto <name>update_cleanup</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Start the view context
  */</comment>
  <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3AuthContextPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sContext</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Generate the code for triggers.
  */</comment>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iGoto</name></decl>;</decl_stmt>

    <comment type="block">/* Create pseudo-tables for NEW and OLD
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>newIdx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iGoto</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iBeginBeforeTrigger</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>,
          <argument><expr><name>newIdx</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>&amp;<name>old_col_mask</name></expr></argument>, <argument><expr>&amp;<name>new_col_mask</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>update_cleanup</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>iEndBeforeTrigger</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iBeginAfterTrigger</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_UPDATE</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>, <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, 
          <argument><expr><name>newIdx</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>&amp;<name>old_col_mask</name></expr></argument>, <argument><expr>&amp;<name>new_col_mask</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>update_cleanup</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>iEndAfterTrigger</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iGoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If we are trying to update a view, realize that view into
  ** a ephemeral table.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3MaterializeView</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Resolve the column names in all the expressions in the
  ** WHERE clause.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>update_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Begin the database scan
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><name>WHERE_ONEPASS_DESIRED</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pWInfo</name>==0</expr> )</condition><then> <goto>goto <name>update_cleanup</name>;</goto></then></if>
  <expr_stmt><expr><name>okOnePass</name> = <name>pWInfo</name>-&gt;<name>okOnePass</name></expr>;</expr_stmt>

  <comment type="block">/* Remember the rowid of every item to be updated.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call>?<name>OP_VRowid</name>:<name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>okOnePass</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>regRowSet</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* End the database scan loop.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the count of updated rows
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name> &amp;&amp; !<name>pParse</name>-&gt;<name>trigStack</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>regRowCount</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr>!<name>isView</name> &amp;&amp; !<call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* 
    ** Open every index that needs updating.  Note that if any
    ** index could potentially invoke a REPLACE conflict resolution 
    ** action, then we need to open all indices because we might need
    ** to be deleting some records.
    */</comment>
    <if>if<condition>( <expr>!<name>okOnePass</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> 
    <if>if<condition>( <expr><name>onError</name>==<name>OE_Replace</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>openAll</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>openAll</name> = 0</expr>;</expr_stmt>
      <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
        <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>onError</name>==<name>OE_Replace</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>openAll</name> = 1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
    }</block></else></if>
    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr>, <expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>openAll</name> || <name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name>&gt;0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKey</name> =<init> <expr><call><name>sqlite3IndexKeyinfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>iCur</name>+<name>i</name>+1</expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>,
                       <argument><expr>(<name>char</name>*)<name>pKey</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>nTab</name>&gt;<name>iCur</name>+<name>i</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  
  <comment type="block">/* Jump back to this point if a trigger encounters an IGNORE constraint. */</comment>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Top of the update loop */</comment>
  <if>if<condition>( <expr><name>okOnePass</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>a1</name> =<init> <expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotNull</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetRead</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regRow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regCols</name></decl>;</decl_stmt>

    <comment type="block">/* Make cursor iCur point to the record that is being updated.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate the OLD table
    */</comment>
    <expr_stmt><expr><name>regRowid</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>regRow</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>old_col_mask</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate the NEW table
    */</comment>
    <if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprCodeAndCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRowidExpr</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>regCols</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>i</name>==<name>pTab</name>-&gt;<name>iPKey</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regCols</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>
      <expr_stmt><expr><name>j</name> = <name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>new_col_mask</name>&amp;((<name>u32</name>)1&lt;&lt;<name>i</name>) || <name>new_col_mask</name>==0xffffffff</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>j</name>&lt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regCols</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3ExprCodeAndCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>regCols</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regCols</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>isView</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3TableAffinityStr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regCols</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* if( pParse-&gt;nErr ) goto update_cleanup; */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>newIdx</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iBeginBeforeTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEndBeforeTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr>!<name>isView</name> &amp;&amp; !<call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* Loop over every record that needs updating.  We have to load
    ** the old data for each record to be updated because some columns
    ** might not change and we will need to copy the old value.
    ** Also, the old data is needed to delete the old index entries.
    ** So make the cursor point at the old record.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the record number will change, push the record number as it
    ** will be after the update. (The old record number is currently
    ** on top of the stack.)
    */</comment>
    <if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRowidExpr</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Compute new data for this record.  
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>i</name>==<name>pTab</name>-&gt;<name>iPKey</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regData</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>
      <expr_stmt><expr><name>j</name> = <name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>j</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>regData</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pExpr</name></expr></argument>, <argument><expr><name>regData</name>+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>

    <comment type="block">/* Do constraint checks
    */</comment>
    <expr_stmt><expr><call><name>sqlite3GenerateConstraintChecks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>,
                                    <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr><name>chngRowid</name></expr></argument>, <argument><expr>1</expr></argument>,
                                    <argument><expr><name>onError</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Delete the old indices for the current record.
    */</comment>
    <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regOldRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If changing the record number, delete the old record.
    */</comment>
    <if>if<condition>( <expr><name>chngRowid</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the new index entries and the new record.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3CompleteInsertion</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regNewRowid</name></expr></argument>, 
                             <argument><expr><name>aRegIdx</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Increment the row counter 
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name> &amp;&amp; !<name>pParse</name>-&gt;<name>trigStack</name></expr>)</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If there are triggers, close all the cursors after each iteration
  ** through the loop.  The fire the after triggers.
  */</comment>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iBeginAfterTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEndAfterTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Repeat the above with the next record to be updated, until
  ** all record selected by the WHERE clause have been updated.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close all tables */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr>, <expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>openAll</name> || <name><name>aRegIdx</name><index>[<expr><name>i</name></expr>]</index></name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCur</name>+<name>i</name>+1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>newIdx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/*
  ** Return the number of rows that were changed. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name> &amp;&amp; !<name>pParse</name>-&gt;<name>trigStack</name> &amp;&amp; <name>pParse</name>-&gt;<name>nested</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>regRowCount</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr>"rows updated"</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<label><name>update_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3AuthContextPop</name><argument_list>(<argument><expr>&amp;<name>sContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aRegIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aXRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Generate code for an UPDATE of a virtual table.
**
** The strategy is that we create an ephemerial table that contains
** for each row to be changed:
**
**   (A)  The original rowid of that row.
**   (B)  The revised rowid for the row. (note1)
**   (C)  The content of every column in the row.
**
** Then we loop over this ephemeral table and for each row in
** the ephermeral table call VUpdate.
**
** When finished, drop the ephemeral table.
**
** (note1) Actually, if we know in advance that (A) is always the same
** as (B) we only store (A), then duplicate (A) when pulling
** it out of the ephemeral table before calling VUpdate.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>updateVirtualTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,       <comment type="block">/* The virtual table to be modified */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,         <comment type="block">/* The virtual table */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pChanges</name></decl></param>,  <comment type="block">/* The columns to change in the UPDATE statement */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pRowid</name></decl></param>,        <comment type="block">/* Expression used to recompute the rowid */</comment>
  <param><decl><type><name>int</name> *</type><name>aXRef</name></decl></param>,          <comment type="block">/* Mapping from columns of pTab to entries in pChanges */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>         <comment type="block">/* WHERE clause of the UPDATE statement */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Virtual machine under construction */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* The result set of the SELECT statement */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pSelect</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* The SELECT statement */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>              <comment type="block">/* Temporary expression */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ephemTab</name></decl>;</decl_stmt>             <comment type="block">/* Table holding the result of the SELECT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                    <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>                 <comment type="block">/* Address of top of loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>                 <comment type="block">/* First register in set passed to OP_VUpdate */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>pVtab</name> =<init> <expr>(<name>const</name> <name>char</name>*)<name>pTab</name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>

  <comment type="block">/* Construct the SELECT statement that will find the new values for
  ** all updated rows. 
  */</comment>
  <expr_stmt><expr><name>pEList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, 
                                 <argument><expr><call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"_rowid_"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pRowid</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pEList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>,
                                   <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>-&gt;<name>iPKey</name>&lt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pExpr</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pChanges</name>-&gt;<name><name>a</name><index>[<expr><name><name>aXRef</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pExpr</name> = <call><name>sqlite3CreateIdExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pEList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pSelect</name> = <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Create the ephemeral table into which the update results will
  ** be stored.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ephemTab</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenEphemeral</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name>+1+(<name>pRowid</name>!=0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* fill the ephemeral table 
  */</comment>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_Table</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate code to scan the ephemeral table and call VUpdate. */</comment>
  <expr_stmt><expr><name>iReg</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>pTab</name>-&gt;<name>nCol</name>+1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>,  <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr>(<name>pRowid</name>?1:0)</expr></argument>, <argument><expr><name>iReg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>i</name>+1+(<name>pRowid</name>!=0)</expr></argument>, <argument><expr><name>iReg</name>+2+<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name>+2</expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>ephemTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Cleanup */</comment>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/* Make sure "isView" gets undefined in case this file becomes part of
** the amalgamation - so that subsequent files do not see isView as a
** macro. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
</unit>
