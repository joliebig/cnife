<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="trigger.c" filename=""><comment type="block">/*
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
**
** $Id: trigger.c,v 1.133 2008/12/26 07:56:39 danielk1977 Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
<comment type="block">/*
** Delete a linked list of TriggerStep structures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteTriggerStep</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>TriggerStep</name> *</type><name>pTriggerStep</name></decl></param>)</parameter_list><block>{
  <while>while<condition>( <expr><name>pTriggerStep</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>TriggerStep</name> *</type> <name>pTmp</name> =<init> <expr><name>pTriggerStep</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTriggerStep</name> = <name>pTriggerStep</name>-&gt;<name>pNext</name></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>pTmp</name>-&gt;<name>target</name>.<name>dyn</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pTmp</name>-&gt;<name>target</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name>-&gt;<name>pExprList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name>-&gt;<name>pIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="block">/*
** This is called by the parser when it sees a CREATE TRIGGER statement
** up to the point of the BEGIN before the trigger actions.  A Trigger
** structure is generated based on the information available and stored
** in pParse-&gt;pNewTrigger.  After the trigger actions have been parsed, the
** sqlite3FinishTrigger() function is called to complete the trigger
** construction process.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginTrigger</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,      <comment type="block">/* The parse context of the CREATE TRIGGER statement */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,      <comment type="block">/* The name of the trigger */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,      <comment type="block">/* The name of the trigger */</comment>
  <param><decl><type><name>int</name></type> <name>tr_tm</name></decl></param>,          <comment type="block">/* One of TK_BEFORE, TK_AFTER, TK_INSTEAD */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,             <comment type="block">/* One of TK_INSERT, TK_UPDATE, TK_DELETE */</comment>
  <param><decl><type><name>IdList</name> *</type><name>pColumns</name></decl></param>,   <comment type="block">/* column list if this is an UPDATE OF trigger */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTableName</name></decl></param>,<comment type="block">/* The name of the table/view the trigger applies to */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhen</name></decl></param>,        <comment type="block">/* WHEN clause */</comment>
  <param><decl><type><name>int</name></type> <name>isTemp</name></decl></param>,         <comment type="block">/* True if the TEMPORARY keyword is present */</comment>
  <param><decl><type><name>int</name></type> <name>noErr</name></decl></param>           <comment type="block">/* Suppress errors if the trigger already exists */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* Name of the trigger */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                <comment type="block">/* The database to store the trigger in */</comment>
  <decl_stmt><decl><type><name>Token</name> *</type><name>pName</name></decl>;</decl_stmt>           <comment type="block">/* The unqualified db name */</comment>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTabDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName1</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* pName1-&gt;z might be NULL, but not pName1 itself */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName2</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>==<name>TK_INSERT</name> || <name>op</name>==<name>TK_UPDATE</name> || <name>op</name>==<name>TK_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>&gt;0 &amp;&amp; <name>op</name>&lt;0xff</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>isTemp</name></expr> )</condition><then><block>{
    <comment type="block">/* If TEMP was specified, then the trigger name may not be qualified. */</comment>
    <if>if<condition>( <expr><name>pName2</name>-&gt;<name>n</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"temporary trigger may not have qualified name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>trigger_cleanup</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>iDb</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pName</name> = <name>pName1</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* Figure out the db that the the trigger will be created in */</comment>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>&amp;<name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then><block>{
      <goto>goto <name>trigger_cleanup</name>;</goto>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* If the trigger name was unqualified, and the table is a temp table,
  ** then set iDb to 1 to create the trigger in the temporary database.
  ** If sqlite3SrcListLookup() returns 0, indicating the table does not
  ** exist, the error is caught by the block below.
  */</comment>
  <if>if<condition>( <expr>!<name>pTableName</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pName2</name>-&gt;<name>n</name>==0 &amp;&amp; <name>pTab</name> &amp;&amp; <name>pTab</name>-&gt;<name>pSchema</name>==<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iDb</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Ensure the table name matches database name and that the table exists */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>trigger_cleanup</name>;</goto></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTableName</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>"trigger"</expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <call><name>sqlite3FixSrcList</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pTableName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pTab</name></expr> )</condition><then><block>{
    <comment type="block">/* The table does not exist. */</comment>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot create triggers on virtual tables"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Check that the trigger name is not reserved and that no trigger of the
  ** specified name exists */</comment>
  <expr_stmt><expr><name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zName</name> || <name>SQLITE_OK</name>!=<call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;(<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>trigHash</name>)</expr></argument>,
                      <argument><expr><name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<name>noErr</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"trigger %T already exists"</expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Do not create a trigger on a system table */</comment>
  <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot create trigger on system table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nErr</name>++</expr>;</expr_stmt>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* INSTEAD of triggers are only for views and views only support INSTEAD
  ** of triggers.
  */</comment>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name> &amp;&amp; <name>tr_tm</name>!=<name>TK_INSTEAD</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot create %s trigger on view: %S"</expr></argument>, 
        <argument><expr>(<name>tr_tm</name> == <name>TK_BEFORE</name>)?"BEFORE":"AFTER"</expr></argument>, <argument><expr><name>pTableName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>pTab</name>-&gt;<name>pSelect</name> &amp;&amp; <name>tr_tm</name>==<name>TK_INSTEAD</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot create INSTEAD OF"
        " trigger on table: %S"</expr></argument>, <argument><expr><name>pTableName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>trigger_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>iTabDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name>SQLITE_CREATE_TRIGGER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iTabDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDbTrig</name> =<init> <expr><name>isTemp</name> ? <name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>zName</name> : <name>zDb</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>iTabDb</name>==1 || <name>isTemp</name></expr> )</condition><then> <expr_stmt><expr><name>code</name> = <name>SQLITE_CREATE_TEMP_TRIGGER</name></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zDbTrig</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>trigger_cleanup</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iTabDb</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
      <goto>goto <name>trigger_cleanup</name>;</goto>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* INSTEAD OF triggers can only appear on views and BEFORE triggers
  ** cannot appear on views.  So we might as well translate every
  ** INSTEAD OF trigger into a BEFORE trigger.  It simplifies code
  ** elsewhere.
  */</comment>
  <if>if <condition>(<expr><name>tr_tm</name> == <name>TK_INSTEAD</name></expr>)</condition><then><block>{
    <expr_stmt><expr><name>tr_tm</name> = <name>TK_BEFORE</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Build the Trigger object */</comment>
  <expr_stmt><expr><name>pTrigger</name> = (<name>Trigger</name>*)<call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Trigger</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTrigger</name>==0</expr> )</condition><then> <goto>goto <name>trigger_cleanup</name>;</goto></then></if>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>name</name> = <name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>table</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTableName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>pSchema</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>pTabSchema</name> = <name>pTab</name>-&gt;<name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>op</name> = (<name>u8</name>)<name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>tr_tm</name> = <name>tr_tm</name>==<name>TK_BEFORE</name> ? <name>TRIGGER_BEFORE</name> : <name>TRIGGER_AFTER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>pWhen</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrigger</name>-&gt;<name>pColumns</name> = <call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pTrigger</name>-&gt;<name>nameToken</name></expr></argument>,<argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>pNewTrigger</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTrigger</name> = <name>pTrigger</name></expr>;</expr_stmt>

<label><name>trigger_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>pNewTrigger</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>pNewTrigger</name>==<name>pTrigger</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** This routine is called after all of the trigger actions have been parsed
** in order to complete the process of building the trigger.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FinishTrigger</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parser context */</comment>
  <param><decl><type><name>TriggerStep</name> *</type><name>pStepList</name></decl></param>, <comment type="block">/* The triggered program */</comment>
  <param><decl><type><name>Token</name> *</type><name>pAll</name></decl></param>             <comment type="block">/* Token that describes the complete CREATE TRIGGER */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrig</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* The trigger whose construction is finishing up */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                   <comment type="block">/* Database containing the trigger */</comment>

  <expr_stmt><expr><name>pTrig</name> = <name>pParse</name>-&gt;<name>pNewTrigger</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTrigger</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || !<name>pTrig</name></expr> )</condition><then> <goto>goto <name>triggerfinish_cleanup</name>;</goto></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTrig</name>-&gt;<name>step_list</name> = <name>pStepList</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pStepList</name></expr> )</condition><block>{
    <expr_stmt><expr><name>pStepList</name>-&gt;<name>pTrig</name> = <name>pTrig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStepList</name> = <name>pStepList</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>"trigger"</expr></argument>, <argument><expr>&amp;<name>pTrig</name>-&gt;<name>nameToken</name></expr></argument>)</argument_list></call> 
          &amp;&amp; <call><name>sqlite3FixTriggerStep</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>step_list</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>triggerfinish_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* if we are not initializing, and this trigger is not on a TEMP table, 
  ** build the sqlite_master entry
  */</comment>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>

    <comment type="block">/* Make an entry in the sqlite_master table */</comment>
    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <goto>goto <name>triggerfinish_cleanup</name>;</goto></then></if>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pAll</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pAll</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
       <argument><expr>"INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')"</expr></argument>,
       <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>,
       <argument><expr><name>pTrig</name>-&gt;<name>table</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr>"type='trigger' AND name='%q'"</expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Trigger</name> *</type><name>pDel</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDel</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>trigHash</name></expr></argument>, 
                     <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pTrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pDel</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDel</name>==<name>pTrig</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <goto>goto <name>triggerfinish_cleanup</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pTrig</name>-&gt;<name>table</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pTrig</name>-&gt;<name>pTabSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>table</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTrig</name>-&gt;<name>pNext</name> = <name>pTab</name>-&gt;<name>pTrigger</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>pTrigger</name> = <name>pTrig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTrig</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

<label><name>triggerfinish_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pParse</name>-&gt;<name>pNewTrigger</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pStepList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Make a copy of all components of the given trigger step.  This has
** the effect of copying all Expr.token.z values into memory obtained
** from sqlite3_malloc().  As initially created, the Expr.token.z values
** all point to the input string that was fed to the parser.  But that
** string is ephemeral - it will go away as soon as the sqlite3_exec()
** call that started the parser exits.  This routine makes a persistent
** copy of all the Expr.token.z strings so that the TriggerStep structure
** will be valid even after the sqlite3_exec() call returns.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqlitePersistTriggerStep</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>TriggerStep</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>target</name>.<name>z</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>target</name>.<name>z</name> = (<name>u8</name>*)<call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name>-&gt;<name>target</name>.<name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>target</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>target</name>.<name>dyn</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Select</name> *</type><name>pNew</name> =<init> <expr><call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pSelect</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pWhere</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name> =<init> <expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pWhere</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pExprList</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pNew</name> =<init> <expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pExprList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pExprList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pExprList</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pIdList</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>IdList</name> *</type><name>pNew</name> =<init> <expr><call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pIdList</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Turn a SELECT statement (that the pSelect parameter points to) into
** a trigger step.  Return a pointer to a TriggerStep structure.
**
** The parser calls this routine when it finds a SELECT statement in
** body of a TRIGGER.  
*/</comment>
<function><type><name>TriggerStep</name> *</type><name>sqlite3TriggerSelectStep</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>TriggerStep</name> *</type><name>pTriggerStep</name> =<init> <expr><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>TriggerStep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pTriggerStep</name>==0</expr> )</condition><then> <block>{
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>op</name> = <name>TK_SELECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pSelect</name> = <name>pSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>orconf</name> = <name>OE_Default</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlitePersistTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>pTriggerStep</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Build a trigger step out of an INSERT statement.  Return a pointer
** to the new trigger step.
**
** The parser calls this routine when it sees an INSERT inside the
** body of a trigger.
*/</comment>
<function><type><name>TriggerStep</name> *</type><name>sqlite3TriggerInsertStep</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,        <comment type="block">/* The database connection */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTableName</name></decl></param>,  <comment type="block">/* Name of the table into which we insert */</comment>
  <param><decl><type><name>IdList</name> *</type><name>pColumn</name></decl></param>,    <comment type="block">/* List of columns in pTableName to insert into */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,   <comment type="block">/* The VALUE clause: a list of values to be inserted */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>,    <comment type="block">/* A SELECT statement that supplies values */</comment>
  <param><decl><type><name>int</name></type> <name>orconf</name></decl></param>          <comment type="block">/* The conflict algorithm (OE_Abort, OE_Replace, etc.) */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>TriggerStep</name> *</type><name>pTriggerStep</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pEList</name> == 0 || <name>pSelect</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pEList</name> != 0 || <name>pSelect</name> != 0 || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTriggerStep</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>TriggerStep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTriggerStep</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>op</name> = <name>TK_INSERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pSelect</name> = <name>pSelect</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>target</name>  = *<name>pTableName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pIdList</name> = <name>pColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pExprList</name> = <name>pEList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>orconf</name> = <name>orconf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlitePersistTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>pTriggerStep</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Construct a trigger step that implements an UPDATE statement and return
** a pointer to that trigger step.  The parser calls this routine when it
** sees an UPDATE statement inside the body of a CREATE TRIGGER.
*/</comment>
<function><type><name>TriggerStep</name> *</type><name>sqlite3TriggerUpdateStep</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,         <comment type="block">/* The database connection */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTableName</name></decl></param>,   <comment type="block">/* Name of the table to be updated */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>,    <comment type="block">/* The SET clause: list of column and new values */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,        <comment type="block">/* The WHERE clause */</comment>
  <param><decl><type><name>int</name></type> <name>orconf</name></decl></param>           <comment type="block">/* The conflict algorithm. (OE_Abort, OE_Ignore, etc) */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>TriggerStep</name> *</type><name>pTriggerStep</name> =<init> <expr><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>TriggerStep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pTriggerStep</name>==0</expr> )</condition><then><block>{
     <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>op</name> = <name>TK_UPDATE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>target</name>  = *<name>pTableName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pExprList</name> = <name>pEList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pWhere</name> = <name>pWhere</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>orconf</name> = <name>orconf</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlitePersistTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>pTriggerStep</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Construct a trigger step that implements a DELETE statement and return
** a pointer to that trigger step.  The parser calls this routine when it
** sees a DELETE statement inside the body of a CREATE TRIGGER.
*/</comment>
<function><type><name>TriggerStep</name> *</type><name>sqlite3TriggerDeleteStep</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,            <comment type="block">/* Database connection */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTableName</name></decl></param>,      <comment type="block">/* The table from which rows are deleted */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>            <comment type="block">/* The WHERE clause */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>TriggerStep</name> *</type><name>pTriggerStep</name> =<init> <expr><call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>TriggerStep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pTriggerStep</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>op</name> = <name>TK_DELETE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>target</name>  = *<name>pTableName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>pWhere</name> = <name>pWhere</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTriggerStep</name>-&gt;<name>orconf</name> = <name>OE_Default</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlitePersistTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>pTriggerStep</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Recursively delete a Trigger structure
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteTrigger</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pTrigger</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3DeleteTriggerStep</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>step_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>pWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>pColumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTrigger</name>-&gt;<name>nameToken</name>.<name>dyn</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pTrigger</name>-&gt;<name>nameToken</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This function is called to drop a trigger from the database schema. 
**
** This may be called directly from the parser and therefore identifies
** the trigger by name.  The sqlite3DropTriggerPtr() routine does the
** same job as this routine except it takes a pointer to the trigger
** instead of the trigger name.
**/</comment>
<function><type><name>void</name></type> <name>sqlite3DropTrigger</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pName</name></decl></param>, <param><decl><type><name>int</name></type> <name>noErr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>drop_trigger_cleanup</name>;</goto></then></if>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>drop_trigger_cleanup</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> = <name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> = <name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>OMIT_TEMPDB</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>(<name>i</name>&lt;2) ? <name>i</name>^1 : <name>i</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Search TEMP before MAIN */</comment>
    <if>if<condition>( <expr><name>zDb</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>pTrigger</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;(<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>trigHash</name>)</expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTrigger</name></expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <if>if<condition>( <expr>!<name>pTrigger</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<name>noErr</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such trigger: %S"</expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <goto>goto <name>drop_trigger_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3DropTriggerPtr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>drop_trigger_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return a pointer to the Table structure for the table that a trigger
** is set on.
*/</comment>
<function><type><name>static</name> <name>Table</name> *</type><name>tableOfTrigger</name><parameter_list>(<param><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pTrigger</name>-&gt;<name>table</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pTrigger</name>-&gt;<name>pTabSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>table</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*
** Drop a trigger given a pointer to that trigger. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DropTriggerPtr</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name>   *</type><name>pTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name> = <call><name>tableOfTrigger</name><argument_list>(<argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>-&gt;<name>pSchema</name>==<name>pTrigger</name>-&gt;<name>pSchema</name> || <name>iDb</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name>SQLITE_DROP_TRIGGER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name> =<init> <expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>iDb</name>==1</expr> )</condition><then> <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_TEMP_TRIGGER</name></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>name</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call> ||
      <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return;</return>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Generate code to destroy the database record of the trigger.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>VdbeOpList</name></type> <name><name>dropTrigger</name><index>[]</index></name> =<init> <expr><block>{
      <expr><block>{ <expr><name>OP_Rewind</name></expr>,     <expr>0</expr>, <expr><call><name>ADDR</name><argument_list>(<argument><expr>9</expr></argument>)</argument_list></call></expr>,  <expr>0</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_String8</name></expr>,    <expr>0</expr>, <expr>1</expr>,        <expr>0</expr>}</block></expr>, <comment type="block">/* 1 */</comment>
      <expr><block>{ <expr><name>OP_Column</name></expr>,     <expr>0</expr>, <expr>1</expr>,        <expr>2</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_Ne</name></expr>,         <expr>2</expr>, <expr><call><name>ADDR</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>,  <expr>1</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_String8</name></expr>,    <expr>0</expr>, <expr>1</expr>,        <expr>0</expr>}</block></expr>, <comment type="block">/* 4: "trigger" */</comment>
      <expr><block>{ <expr><name>OP_Column</name></expr>,     <expr>0</expr>, <expr>0</expr>,        <expr>2</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_Ne</name></expr>,         <expr>2</expr>, <expr><call><name>ADDR</name><argument_list>(<argument><expr>8</expr></argument>)</argument_list></call></expr>,  <expr>1</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_Delete</name></expr>,     <expr>0</expr>, <expr>0</expr>,        <expr>0</expr>}</block></expr>,
      <expr><block>{ <expr><name>OP_Next</name></expr>,       <expr>0</expr>, <expr><call><name>ADDR</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>,  <expr>0</expr>}</block></expr>, <comment type="block">/* 8 */</comment>
    }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3OpenMasterTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name> = <call><name>sqlite3VdbeAddOpList</name><argument_list>(<argument><expr><name>v</name></expr></argument>,  <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>dropTrigger</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dropTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>base</name>+1</expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>base</name>+4</expr></argument>, <argument><expr>"trigger"</expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTrigger</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTrigger</name>-&gt;<name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Remove a trigger from the hash tables of the sqlite* pointer.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UnlinkAndDeleteTrigger</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pTrigger</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;(<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>trigHash</name>)</expr></argument>,
                               <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTrigger</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTable</name> =<init> <expr><call><name>tableOfTrigger</name><argument_list>(<argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTable</name>-&gt;<name>pTrigger</name> == <name>pTrigger</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTable</name>-&gt;<name>pTrigger</name> = <name>pTrigger</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Trigger</name> *</type><name>cc</name> =<init> <expr><name>pTable</name>-&gt;<name>pTrigger</name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>cc</name></expr> )</condition><block>{ 
        <if>if<condition>( <expr><name>cc</name>-&gt;<name>pNext</name> == <name>pTrigger</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>cc</name>-&gt;<name>pNext</name> = <name>cc</name>-&gt;<name>pNext</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>cc</name> = <name>cc</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3DeleteTrigger</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** pEList is the SET clause of an UPDATE statement.  Each entry
** in pEList is of the format &lt;id&gt;=&lt;expr&gt;.  If any of the entries
** in pEList have an &lt;id&gt; which matches an identifier in pIdList,
** then return TRUE.  If pIdList==NULL, then it is considered a
** wildcard that matches anything.  Likewise if pEList==NULL then
** it matches anything so always return true.  Return false only
** if there is no match.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>checkColumnOverLap</name><parameter_list>(<param><decl><type><name>IdList</name> *</type><name>pIdList</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pEList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>pIdList</name> || !<name>pEList</name></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <for>for(<init><expr><name>e</name>=0</expr>;</init> <condition><expr><name>e</name>&lt;<name>pEList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>sqlite3IdListIndex</name><argument_list>(<argument><expr><name>pIdList</name></expr></argument>, <argument><expr><name>pEList</name>-&gt;<name><name>a</name><index>[<expr><name>e</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call>&gt;=0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return> 
}</block></function>

<comment type="block">/*
** Return a bit vector to indicate what kind of triggers exist for operation
** "op" on table pTab.  If pChanges is not NULL then it is a list of columns
** that are being updated.  Triggers only match if the ON clause of the
** trigger definition overlaps the set of columns being updated.
**
** The returned bit vector is some combination of TRIGGER_BEFORE and
** TRIGGER_AFTER.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3TriggersExist</name><parameter_list>(
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,            <comment type="block">/* The table the contains the triggers */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,                 <comment type="block">/* one of TK_DELETE, TK_INSERT, TK_UPDATE */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pChanges</name></decl></param>      <comment type="block">/* Columns that change in an UPDATE statement */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTrigger</name> = <call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> ? 0 : <name>pTab</name>-&gt;<name>pTrigger</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{
    <if>if<condition>( <expr><name>pTrigger</name>-&gt;<name>op</name>==<name>op</name> &amp;&amp; <call><name>checkColumnOverLap</name><argument_list>(<argument><expr><name>pTrigger</name>-&gt;<name>pColumns</name></expr></argument>, <argument><expr><name>pChanges</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>mask</name> |= <name>pTrigger</name>-&gt;<name>tr_tm</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pTrigger</name> = <name>pTrigger</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>mask</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Convert the pStep-&gt;target token into a SrcList and return a pointer
** to that SrcList.
**
** This routine adds a specific database name, if needed, to the target when
** forming the SrcList.  This prevents a trigger in one database from
** referring to a target in another database.  An exception is when the
** trigger is in TEMP in which case it can refer to any other database it
** wants.
*/</comment>
<function><type><name>static</name> <name>SrcList</name> *</type><name>targetSrcList</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>TriggerStep</name> *</type><name>pStep</name></decl></param>   <comment type="block">/* The trigger containing the target token */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Token</name></type> <name>sDb</name></decl>;</decl_stmt>           <comment type="block">/* Dummy database name token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>             <comment type="block">/* Index of the database to use */</comment>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>       <comment type="block">/* SrcList to be returned */</comment>

  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pStep</name>-&gt;<name>pTrig</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iDb</name>==0 || <name>iDb</name>&gt;=2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&lt;<name>pParse</name>-&gt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sDb</name>.<name>z</name> = (<name>u8</name>*)<name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sDb</name>.<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>(<name>char</name>*)<name>sDb</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name> = <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>sDb</name></expr></argument>, <argument><expr>&amp;<name>pStep</name>-&gt;<name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>pSrc</name> = <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pStep</name>-&gt;<name>target</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>pSrc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate VDBE code for zero or more statements inside the body of a
** trigger.  
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>codeTriggerProgram</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,            <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>TriggerStep</name> *</type><name>pStepList</name></decl></param>,   <comment type="block">/* List of statements inside the trigger body */</comment>
  <param><decl><type><name>int</name></type> <name>orconfin</name></decl></param>              <comment type="block">/* Conflict algorithm. (OE_Abort, etc) */</comment>  
)</parameter_list><block>{
  <decl_stmt><decl><type><name>TriggerStep</name> *</type> <name>pTriggerStep</name> =<init> <expr><name>pStepList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>orconf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTriggerStep</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ContextPush</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "begin trigger %s", <name>pStepList</name>-&gt;<name>pTrig</name>-&gt;<name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pTriggerStep</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>sqlite3ExprClearColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>orconf</name> = (<name>orconfin</name> == <name>OE_Default</name>)?<name>pTriggerStep</name>-&gt;<name>orconf</name>:<name>orconfin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>trigStack</name>-&gt;<name>orconf</name> = <name>orconf</name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>pTriggerStep</name>-&gt;<name>op</name></expr> )</condition><block>{
      <case>case <expr><name>TK_SELECT</name></expr>: <block>{
        <decl_stmt><decl><type><name>Select</name> *</type><name>ss</name> =<init> <expr><call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>ss</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_Discard</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>TK_UPDATE</name></expr>: <block>{
        <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSrc</name> = <call><name>targetSrcList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3Update</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>,
                <argument><expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pExprList</name></expr></argument>)</argument_list></call></expr></argument>, 
                <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>TK_INSERT</name></expr>: <block>{
        <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pSrc</name> = <call><name>targetSrcList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3Insert</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>,
          <argument><expr><call><name>sqlite3ExprListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pExprList</name></expr></argument>)</argument_list></call></expr></argument>, 
          <argument><expr><call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr></argument>, 
          <argument><expr><call><name>sqlite3IdListDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pIdList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>TK_DELETE</name></expr>: <block>{
        <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSrc</name> = <call><name>targetSrcList</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTriggerStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DeleteFrom</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, 
                          <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTriggerStep</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResetCount</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><default>default:
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch> 
    <expr_stmt><expr><name>pTriggerStep</name> = <name>pTriggerStep</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ContextPop</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "end trigger %s", <name>pStepList</name>-&gt;<name>pTrig</name>-&gt;<name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** This is called to code FOR EACH ROW triggers.
**
** When the code that this function generates is executed, the following 
** must be true:
**
** 1. No cursors may be open in the main database.  (But newIdx and oldIdx
**    can be indices of cursors in temporary tables.  See below.)
**
** 2. If the triggers being coded are ON INSERT or ON UPDATE triggers, then
**    a temporary vdbe cursor (index newIdx) must be open and pointing at
**    a row containing values to be substituted for new.* expressions in the
**    trigger program(s).
**
** 3. If the triggers being coded are ON DELETE or ON UPDATE triggers, then
**    a temporary vdbe cursor (index oldIdx) must be open and pointing at
**    a row containing values to be substituted for old.* expressions in the
**    trigger program(s).
**
** If they are not NULL, the piOldColMask and piNewColMask output variables
** are set to values that describe the columns used by the trigger program
** in the OLD.* and NEW.* tables respectively. If column N of the 
** pseudo-table is read at least once, the corresponding bit of the output
** mask is set. If a column with an index greater than 32 is read, the
** output mask is set to the special value 0xffffffff.
**
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CodeRowTrigger</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* Parse context */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,              <comment type="block">/* One of TK_UPDATE, TK_INSERT, TK_DELETE */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pChanges</name></decl></param>,  <comment type="block">/* Changes list for any UPDATE OF triggers */</comment>
  <param><decl><type><name>int</name></type> <name>tr_tm</name></decl></param>,           <comment type="block">/* One of TRIGGER_BEFORE, TRIGGER_AFTER */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,         <comment type="block">/* The table to code triggers from */</comment>
  <param><decl><type><name>int</name></type> <name>newIdx</name></decl></param>,          <comment type="block">/* The indice of the "new" row to access */</comment>
  <param><decl><type><name>int</name></type> <name>oldIdx</name></decl></param>,          <comment type="block">/* The indice of the "old" row to access */</comment>
  <param><decl><type><name>int</name></type> <name>orconf</name></decl></param>,          <comment type="block">/* ON CONFLICT policy */</comment>
  <param><decl><type><name>int</name></type> <name>ignoreJump</name></decl></param>,      <comment type="block">/* Instruction to jump to for RAISE(IGNORE) */</comment>
  <param><decl><type><name>u32</name> *</type><name>piOldColMask</name></decl></param>,   <comment type="block">/* OUT: Mask of columns used from the OLD.* table */</comment>
  <param><decl><type><name>u32</name> *</type><name>piNewColMask</name></decl></param>    <comment type="block">/* OUT: Mask of columns used from the NEW.* table */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TriggerStack</name></type> <name>trigStackEntry</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>trigStackEntry</name>.<name>oldColMask</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>trigStackEntry</name>.<name>newColMask</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> == <name>TK_UPDATE</name> || <name>op</name> == <name>TK_INSERT</name> || <name>op</name> == <name>TK_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tr_tm</name> == <name>TRIGGER_BEFORE</name> || <name>tr_tm</name> == <name>TRIGGER_AFTER</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newIdx</name> != -1 || <name>oldIdx</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for(<init><expr><name>p</name>=<name>pTab</name>-&gt;<name>pTrigger</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fire_this</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Determine whether we should code this trigger */</comment>
    <if>if<condition>( 
      <expr><name>p</name>-&gt;<name>op</name>==<name>op</name> &amp;&amp; 
      <name>p</name>-&gt;<name>tr_tm</name>==<name>tr_tm</name> &amp;&amp; 
      (<name>p</name>-&gt;<name>pSchema</name>==<name>p</name>-&gt;<name>pTabSchema</name> || <name>p</name>-&gt;<name>pSchema</name>==<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name>) &amp;&amp;
      (<name>op</name>!=<name>TK_UPDATE</name>||!<name>p</name>-&gt;<name>pColumns</name>||<call><name>checkColumnOverLap</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pColumns</name></expr></argument>,<argument><expr><name>pChanges</name></expr></argument>)</argument_list></call>)</expr>
    )</condition><then><block>{
      <decl_stmt><decl><type><name>TriggerStack</name> *</type><name>pS</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to trigger-stack entry */</comment>
      <for>for(<init><expr><name>pS</name>=<name>pParse</name>-&gt;<name>trigStack</name></expr>;</init> <condition><expr><name>pS</name> &amp;&amp; <name>p</name>!=<name>pS</name>-&gt;<name>pTrigger</name></expr>;</condition> <incr><expr><name>pS</name>=<name>pS</name>-&gt;<name>pNext</name></expr></incr>)<block>{}</block></for>
      <if>if<condition>( <expr>!<name>pS</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>fire_this</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>    <comment type="block">/* Give no warning for recursive triggers.  Just do not do them */</comment>
      else{
        sqlite3ErrorMsg(pParse, "recursive triggers not supported (%s)",
            p-&gt;name);
        return SQLITE_ERROR;
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
 
    <if>if<condition>( <expr><name>fire_this</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>endTrigger</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> *</type> <name>whenExpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>AuthContext</name></type> <name>sContext</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>OP_Trace</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"-- TRIGGER %s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>

      <comment type="block">/* Push an entry on to the trigger stack */</comment>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>pTrigger</name> = <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>newIdx</name> = <name>newIdx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>oldIdx</name> = <name>oldIdx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>pTab</name> = <name>pTab</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>pNext</name> = <name>pParse</name>-&gt;<name>trigStack</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>trigStackEntry</name>.<name>ignoreJump</name> = <name>ignoreJump</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>trigStack</name> = &amp;<name>trigStackEntry</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3AuthContextPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sContext</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* code the WHEN clause */</comment>
      <expr_stmt><expr><name>endTrigger</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>whenExpr</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name> || <call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>whenExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pParse</name>-&gt;<name>trigStack</name> = <name>trigStackEntry</name>.<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>whenExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>whenExpr</name></expr></argument>, <argument><expr><name>endTrigger</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>whenExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>codeTriggerProgram</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>step_list</name></expr></argument>, <argument><expr><name>orconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

      <comment type="block">/* Pop the entry off the trigger stack */</comment>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>trigStack</name> = <name>trigStackEntry</name>.<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3AuthContextPop</name><argument_list>(<argument><expr>&amp;<name>sContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>endTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>piOldColMask</name></expr> )</condition><then> <expr_stmt><expr>*<name>piOldColMask</name> |= <name>trigStackEntry</name>.<name>oldColMask</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>piNewColMask</name></expr> )</condition><then> <expr_stmt><expr>*<name>piNewColMask</name> |= <name>trigStackEntry</name>.<name>newColMask</name></expr>;</expr_stmt></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_TRIGGER) */</comment>
</unit>
