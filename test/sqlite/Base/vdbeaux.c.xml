<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="vdbeaux.c" filename=""><comment type="block">/*
** 2003 September 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used for creating, destroying, and populating
** a VDBE (or an "sqlite3_stmt" as it is known to the outside world.)  Prior
** to version 2.8.7, all this code was combined into the vdbe.c source file.
** But that file was getting too big so this subroutines were split out.
**
** $Id: vdbeaux.c,v 1.430 2009/01/07 08:12:16 danielk1977 Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>



<comment type="block">/*
** When debugging the code generator in a symbolic debugger, one can
** set the sqlite3VdbeAddopTrace to 1 and all opcodes will be printed
** as they are added to the instruction stream.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3VdbeAddopTrace</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Create a new virtual database engine.
*/</comment>
<function><type><name>Vdbe</name> *</type><name>sqlite3VdbeCreate</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Vdbe</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>pVdbe</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>pVdbe</name>-&gt;<name>pPrev</name> = <name>p</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>db</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pVdbe</name> = <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_INIT</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Remember the SQL string for a prepared statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetSql</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>zSql</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zSql</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the SQL associated with a prepared statement
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3_sql</name><parameter_list>(<param><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl></param>)</parameter_list><block>{
  <return>return <expr>((<name>Vdbe</name> *)<name>pStmt</name>)-&gt;<name>zSql</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Swap all content between two VDBE structures.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSwap</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>pA</name></decl></param>, <param><decl><type><name>Vdbe</name> *</type><name>pB</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name></type> <name>tmp</name>, *<name>pTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zTmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTmp</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>tmp</name> = *<name>pA</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pA</name> = *<name>pB</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pB</name> = <name>tmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> = <name>pA</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pA</name>-&gt;<name>pNext</name> = <name>pB</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pB</name>-&gt;<name>pNext</name> = <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTmp</name> = <name>pA</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pA</name>-&gt;<name>pPrev</name> = <name>pB</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pB</name>-&gt;<name>pPrev</name> = <name>pTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTmp</name> = <name>pA</name>-&gt;<name>zSql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pA</name>-&gt;<name>zSql</name> = <name>pB</name>-&gt;<name>zSql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pB</name>-&gt;<name>zSql</name> = <name>zTmp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTmp</name> = <name>pA</name>-&gt;<name>nSql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pA</name>-&gt;<name>nSql</name> = <name>pB</name>-&gt;<name>nSql</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pB</name>-&gt;<name>nSql</name> = <name>nTmp</name></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Turn tracing on or off
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeTrace</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>trace</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>trace</name> = <name>trace</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Resize the Vdbe.aOp array so that it is at least one op larger than 
** it was.
**
** If an out-of-memory error occurs while resizing the array, return
** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain 
** unchanged (this is so that any opcodes already allocated can be 
** correctly deallocated along with the rest of the Vdbe).
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>growOpArray</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> =<init> <expr>(<name>p</name>-&gt;<name>nOpAlloc</name> ? <name>p</name>-&gt;<name>nOpAlloc</name>*2 : (<name>int</name>)(1024/<call><name>sizeof</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aOp</name></expr></argument>, <argument><expr><name>nNew</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>nOpAlloc</name> = <name>nNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>aOp</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>(<name>pNew</name> ? <name>SQLITE_OK</name> : <name>SQLITE_NOMEM</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Add a new instruction to the list of instructions current in the
** VDBE.  Return the address of the new instruction.
**
** Parameters:
**
**    p               Pointer to the VDBE
**
**    op              The opcode for this instruction
**
**    p1, p2, p3      Operands
**
** Use the sqlite3VdbeResolveLabel() function to fix an address and
** the sqlite3VdbeChangeP4() function to change the value of the P4
** operand.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp3</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>p1</name></decl></param>, <param><decl><type><name>int</name></type> <name>p2</name></decl></param>, <param><decl><type><name>int</name></type> <name>p3</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>nOp</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>&gt;0 &amp;&amp; <name>op</name>&lt;0xff</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nOpAlloc</name>&lt;=<name>i</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>nOp</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> = &amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = (<name>u8</name>)<name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p5</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p1</name> = <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p2</name> = <name>p2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p3</name> = <name>p3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_NOTUSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>expired</name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>zComment</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3VdbeAddopTrace</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>cycles</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>cnt</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp0</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp1</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>p1</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp2</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>p1</name></decl></param>, <param><decl><type><name>int</name></type> <name>p2</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*
** Add an opcode that includes the p4 value as a pointer.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOp4</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>,            <comment type="block">/* Add the opcode to this VM */</comment>
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,             <comment type="block">/* The new opcode */</comment>
  <param><decl><type><name>int</name></type> <name>p1</name></decl></param>,             <comment type="block">/* The P1 operand */</comment>
  <param><decl><type><name>int</name></type> <name>p2</name></decl></param>,             <comment type="block">/* The P2 operand */</comment>
  <param><decl><type><name>int</name></type> <name>p3</name></decl></param>,             <comment type="block">/* The P3 operand */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zP4</name></decl></param>,    <comment type="block">/* The P4 operand */</comment>
  <param><decl><type><name>int</name></type> <name>p4type</name></decl></param>          <comment type="block">/* P4 operand type */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name> =<init> <expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>p4type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>addr</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new symbolic label for an instruction that has yet to be
** coded.  The symbolic label is really just a negative number.  The
** label can be used as the P2 value of an operation.  Later, when
** the label is resolved to a specific address, the VDBE will scan
** through its operation list and change all values of P2 which match
** the label into the resolved address.
**
** The VDBE knows that a P2 value is a label because labels are
** always negative and P2 values are suppose to be non-negative.
** Hence, a negative P2 value is a label that has yet to be resolved.
**
** Zero is returned if a malloc() fails.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeMakeLabel</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>nLabel</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>i</name>&gt;=<name>p</name>-&gt;<name>nLabelAlloc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>p</name>-&gt;<name>nLabelAlloc</name>*2 + 5</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>aLabel</name> = <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aLabel</name></expr></argument>,
                                       <argument><expr><name>n</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>aLabel</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>nLabelAlloc</name> = <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aLabel</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>aLabel</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aLabel</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aLabel</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>-1-<name>i</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Resolve label "x" to be the address of the next instruction to
** be inserted.  The parameter "x" must have been obtained from
** a prior call to sqlite3VdbeMakeLabel().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeResolveLabel</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>-1-<name>x</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&gt;=0 &amp;&amp; <name>j</name>&lt;<name>p</name>-&gt;<name>nLabel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aLabel</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aLabel</name><index>[<expr><name>j</name></expr>]</index></name> = <name>p</name>-&gt;<name>nOp</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Loop through the program looking for P2 values that are negative
** on jump instructions.  Each such value is a label.  Resolve the
** label by setting the P2 value to its correct non-zero value.
**
** This routine is called once after all opcodes have been inserted.
**
** Variable *pMaxFuncArgs is set to the maximum value of any P2 argument 
** to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by 
** sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.
**
** This routine also does the following optimization:  It scans for
** instructions that might cause a statement rollback.  Such instructions
** are:
**
**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_Destroy
**   *  OP_VUpdate
**   *  OP_VRename
**
** If no such instruction is found, then every Statement instruction 
** is changed to a Noop.  In this way, we avoid creating the statement 
** journal file unnecessarily.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>resolveP2Values</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pMaxFuncArgs</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMaxArgs</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Op</name> *</type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> *</type><name>aLabel</name> =<init> <expr><name>p</name>-&gt;<name>aLabel</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>doesStatementRollback</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasStatementBegin</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>readOnly</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>usesStmtJournal</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>pOp</name>=<name>p</name>-&gt;<name>aOp</name></expr>, <expr><name>i</name>=<name>p</name>-&gt;<name>nOp</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOp</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>opcode</name> =<init> <expr><name>pOp</name>-&gt;<name>opcode</name></expr></init></decl>;</decl_stmt>

    <if>if<condition>( <expr><name>opcode</name>==<name>OP_Function</name> || <name>opcode</name>==<name>OP_AggStep</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p5</name>&gt;<name>nMaxArgs</name></expr> )</condition><then> <expr_stmt><expr><name>nMaxArgs</name> = <name>pOp</name>-&gt;<name>p5</name></expr>;</expr_stmt></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_VUpdate</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name>&gt;<name>nMaxArgs</name></expr> )</condition><then> <expr_stmt><expr><name>nMaxArgs</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if></else></if>
    <if>if<condition>( <expr><name>opcode</name>==<name>OP_Halt</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name>==<name>SQLITE_CONSTRAINT</name> &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>==<name>OE_Abort</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>doesStatementRollback</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_Statement</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>hasStatementBegin</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>usesStmtJournal</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_Destroy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>doesStatementRollback</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_Transaction</name> &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>readOnly</name> = 0</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_VUpdate</name> || <name>opcode</name>==<name>OP_VRename</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>doesStatementRollback</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>opcode</name>==<name>OP_VFilter</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nOp</name> - <name>i</name> &gt;= 3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>opcode</name>==<name>OP_Integer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> = <name><name>pOp</name><index>[<expr>-1</expr>]</index></name>.<name>p1</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>n</name>&gt;<name>nMaxArgs</name></expr> )</condition><then> <expr_stmt><expr><name>nMaxArgs</name> = <name>n</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if>

    <if>if<condition>( <expr><call><name>sqlite3VdbeOpcodeHasProperty</name><argument_list>(<argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>OPFLG_JUMP</name></expr></argument>)</argument_list></call> &amp;&amp; <name>pOp</name>-&gt;<name>p2</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>-1-<name>pOp</name>-&gt;<name>p2</name>&lt;<name>p</name>-&gt;<name>nLabel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>p2</name> = <name><name>aLabel</name><index>[<expr>-1-<name>pOp</name>-&gt;<name>p2</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>aLabel</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr>*<name>pMaxFuncArgs</name> = <name>nMaxArgs</name></expr>;</expr_stmt>

  <comment type="block">/* If we never rollback a statement transaction, then statement
  ** transactions are not needed.  So change every OP_Statement
  ** opcode into an OP_Noop.  This avoid a call to sqlite3OsOpenExclusive()
  ** which can be expensive on some platforms.
  */</comment>
  <if>if<condition>( <expr><name>hasStatementBegin</name> &amp;&amp; !<name>doesStatementRollback</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>usesStmtJournal</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>pOp</name>=<name>p</name>-&gt;<name>aOp</name></expr>, <expr><name>i</name>=<name>p</name>-&gt;<name>nOp</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOp</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Statement</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_Noop</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Return the address of the next instruction to be inserted.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCurrentAddr</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name>-&gt;<name>nOp</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add a whole list of operations to the operation stack.  Return the
** address of the first operation added.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeAddOpList</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>nOp</name></decl></param>, <param><decl><type><name>VdbeOpList</name> <name>const</name> *</type><name>aOp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nOp</name> + <name>nOp</name> &gt; <name>p</name>-&gt;<name>nOpAlloc</name> &amp;&amp; <call><name>growOpArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>addr</name> = <name>p</name>-&gt;<name>nOp</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nOp</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VdbeOpList</name> <name>const</name> *</type><name>pIn</name> =<init> <expr><name>aOp</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pIn</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>p2</name> =<init> <expr><name>pIn</name>-&gt;<name>p2</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOut</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name>+<name>addr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>opcode</name> = <name>pIn</name>-&gt;<name>opcode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>p1</name> = <name>pIn</name>-&gt;<name>p1</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p2</name>&lt;0 &amp;&amp; <call><name>sqlite3VdbeOpcodeHasProperty</name><argument_list>(<argument><expr><name>pOut</name>-&gt;<name>opcode</name></expr></argument>, <argument><expr><name>OPFLG_JUMP</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pOut</name>-&gt;<name>p2</name> = <name>addr</name> + <call><name>ADDR</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pOut</name>-&gt;<name>p2</name> = <name>p2</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>p3</name> = <name>pIn</name>-&gt;<name>p3</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>p4type</name> = <name>P4_NOTUSED</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>p4</name>.<name>p</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>p5</name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><name>pOut</name>-&gt;<name>zComment</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>sqlite3VdbeAddopTrace</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>i</name>+<name>addr</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name>+<name>addr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></for>
    <expr_stmt><expr><name>p</name>-&gt;<name>nOp</name> += <name>nOp</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>addr</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the value of the P1 operand for a specific instruction.
** This routine is useful when a large program is loaded from a
** static array using sqlite3VdbeAddOpList but we want to make a
** few minor changes to the program.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP1</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0 || <name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>addr</name>&gt;=0 &amp;&amp; <name>p</name>-&gt;<name>nOp</name>&gt;<name>addr</name> &amp;&amp; <name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name>.<name>p1</name> = <name>val</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Change the value of the P2 operand for a specific instruction.
** This routine is useful for setting a jump destination.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP2</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0 || <name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>addr</name>&gt;=0 &amp;&amp; <name>p</name>-&gt;<name>nOp</name>&gt;<name>addr</name> &amp;&amp; <name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name>.<name>p2</name> = <name>val</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Change the value of the P3 operand for a specific instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP3</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0 || <name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>addr</name>&gt;=0 &amp;&amp; <name>p</name>-&gt;<name>nOp</name>&gt;<name>addr</name> &amp;&amp; <name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name>.<name>p3</name> = <name>val</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Change the value of the P5 operand for the most recently
** added operation.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP5</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>u8</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==0 || <name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nOp</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>p</name>-&gt;<name>nOp</name>-1</expr>]</index></name>.<name>p5</name> = <name>val</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Change the P2 operand of instruction addr so that it points to
** the address of the next instruction to be coded.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeJumpHere</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** If the input FuncDef structure is ephemeral, then free it.  If
** the FuncDef is not ephermal, then do nothing.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>freeEphemeralFunction</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pDef</name> &amp;&amp; (<name>pDef</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_EPHEM</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Delete a P4 value if necessary.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>freeP4</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>p4type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p4</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p4</name></expr> )</condition><then><block>{
    <switch>switch<condition>( <expr><name>p4type</name></expr> )</condition><block>{
      <case>case <expr><name>P4_REAL</name></expr>:
      </case><case>case <expr><name>P4_INT64</name></expr>:
      </case><case>case <expr><name>P4_MPRINTF</name></expr>:
      </case><case>case <expr><name>P4_DYNAMIC</name></expr>:
      </case><case>case <expr><name>P4_KEYINFO</name></expr>:
      </case><case>case <expr><name>P4_INTARRAY</name></expr>:
      </case><case>case <expr><name>P4_KEYINFO_HANDOFF</name></expr>: <block>{
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>P4_VDBEFUNC</name></expr>: <block>{
        <decl_stmt><decl><type><name>VdbeFunc</name> *</type><name>pVdbeFunc</name> =<init> <expr>(<name>VdbeFunc</name> *)<name>p4</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVdbeFunc</name>-&gt;<name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeDeleteAuxData</name><argument_list>(<argument><expr><name>pVdbeFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVdbeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>P4_FUNCDEF</name></expr>: <block>{
        <expr_stmt><expr><call><name>freeEphemeralFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>FuncDef</name>*)<name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>P4_MEM</name></expr>: <block>{
        <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr>(<name>sqlite3_value</name>*)<name>p4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
    </case>}</block></switch>
  }</block></then></if>
}</block></function>


<comment type="block">/*
** Change N opcodes starting at addr to No-ops.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeToNoop</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>N</name>--</expr> )</condition><block>{
      <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4type</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>pOp</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_Noop</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name>++</expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Change the value of the P4 operand for a specific instruction.
** This routine is useful when a large program is loaded from a
** static array using sqlite3VdbeAddOpList but we want to make a
** few minor changes to the program.
**
** If n&gt;=0 then the P4 operand is dynamic, meaning that a copy of
** the string is made into memory obtained from sqlite3_malloc().
** A value of n==0 means copy bytes of zP4 up to and including the
** first null byte.  If n&gt;0 then copy n+1 bytes of zP4.
**
** If n==P4_KEYINFO it means that zP4 is a pointer to a KeyInfo structure.
** A copy is made of the KeyInfo structure into memory obtained from
** sqlite3_malloc, to be freed when the Vdbe is finalized.
** n==P4_KEYINFO_HANDOFF indicates that zP4 points to a KeyInfo structure
** stored in memory that the caller has obtained from sqlite3_malloc. The 
** caller should not free the allocation, it will be freed when the Vdbe is
** finalized.
** 
** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points
** to a string or structure that is guaranteed to exist for the lifetime of
** the Vdbe. In these cases we can just copy the pointer.
**
** If addr&lt;0 then change P4 on the most recently inserted instruction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeChangeP4</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zP4</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Op</name> *</type><name>pOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aOp</name>==0 || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <if>if <condition>(<expr><name>n</name> != <name>P4_KEYINFO</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>void</name>*)*(<name>char</name>**)&amp;<name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>addr</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>addr</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>addr</name> = <name>p</name>-&gt;<name>nOp</name> - 1</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>addr</name>&lt;0</expr> )</condition><then> <return>return;</return></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>pOp</name> = &amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4type</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>==<name>P4_INT32</name></expr> )</condition><then><block>{
    <comment type="block">/* Note: this cast is safe, because the origin data point was an int
    ** that was cast to a (const char *). */</comment>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>i</name> = <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_INT32</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>zP4</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_NOTUSED</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>n</name>==<name>P4_KEYINFO</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nField</name>, <name>nByte</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nField</name> = ((<name>KeyInfo</name>*)<name>zP4</name>)-&gt;<name>nField</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nByte</name> = <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pKeyInfo</name></expr></argument>)</argument_list></call> + (<name>nField</name>-1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>pKeyInfo</name>-&gt;<name><name>aColl</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> + <name>nField</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKeyInfo</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name> = <name>pKeyInfo</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pKeyInfo</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u8</name> *</type><name>aSortOrder</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pKeyInfo</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>aSortOrder</name> = <name>pKeyInfo</name>-&gt;<name>aSortOrder</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>aSortOrder</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pKeyInfo</name>-&gt;<name>aSortOrder</name> = (<name>unsigned</name> <name>char</name>*)&amp;<name>pKeyInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>nField</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pKeyInfo</name>-&gt;<name>aSortOrder</name></expr></argument>, <argument><expr><name>aSortOrder</name></expr></argument>, <argument><expr><name>nField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_KEYINFO</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_NOTUSED</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>n</name>==<name>P4_KEYINFO_HANDOFF</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name> = (<name>void</name>*)<name>zP4</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_KEYINFO</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>n</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name> = (<name>void</name>*)<name>zP4</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = (<name>signed</name> <name>char</name>)<name>n</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>n</name>==0</expr> )</condition><then> <expr_stmt><expr><name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zP4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOp</name>-&gt;<name>p4type</name> = <name>P4_DYNAMIC</name></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if></else></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Change the comment on the the most recently coded instruction.  Or
** insert a No-op and add the comment to that new instruction.  This
** makes the code easier to read during debugging.  None of this happens
** in a production build.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeComment</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nOp</name>&gt;0 || <name>p</name>-&gt;<name>aOp</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>aOp</name>==0 || <name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>p</name>-&gt;<name>nOp</name>-1</expr>]</index></name>.<name>zComment</name>==0 || <name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nOp</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> **</type><name>pz</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>p</name>-&gt;<name>nOp</name>-1</expr>]</index></name>.<name>zComment</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>*<name>pz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pz</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3VdbeNoopComment</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>OP_Noop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nOp</name>&gt;0 || <name>p</name>-&gt;<name>aOp</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>aOp</name>==0 || <name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>p</name>-&gt;<name>nOp</name>-1</expr>]</index></name>.<name>zComment</name>==0 || <name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nOp</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> **</type><name>pz</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>p</name>-&gt;<name>nOp</name>-1</expr>]</index></name>.<name>zComment</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>*<name>pz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pz</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NDEBUG */</comment>

<comment type="block">/*
** Return the opcode for a given address.
*/</comment>
<function><type><name>VdbeOp</name> *</type><name>sqlite3VdbeGetOp</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>addr</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>addr</name>&gt;=0 &amp;&amp; <name>addr</name>&lt;<name>p</name>-&gt;<name>nOp</name>) || <name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>((<name>addr</name>&gt;=0 &amp;&amp; <name>addr</name>&lt;<name>p</name>-&gt;<name>nOp</name>)?(&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>addr</name></expr>]</index></name>):0)</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_EXPLAIN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> \
     || <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Compute a string that describes the P4 parameter for an opcode.
** Use zTemp for any required temporary buffer space.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>displayP4</name><parameter_list>(<param><decl><type><name>Op</name> *</type><name>pOp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zTemp</name></decl></param>, <param><decl><type><name>int</name></type> <name>nTemp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zP4</name> =<init> <expr><name>zTemp</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTemp</name>&gt;=20</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>pOp</name>-&gt;<name>p4type</name></expr> )</condition><block>{
    <case>case <expr><name>P4_KEYINFO_STATIC</name></expr>:
    </case><case>case <expr><name>P4_KEYINFO</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pKeyInfo</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"keyinfo(%d"</expr></argument>, <argument><expr><name>pKeyInfo</name>-&gt;<name>nField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pKeyInfo</name>-&gt;<name>nField</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr><name>pKeyInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>i</name>+<name>n</name>&gt;<name>nTemp</name>-6</expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr>",..."</expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name>++</expr>]</index></name> = ','</expr>;</expr_stmt>
          <if>if<condition>( <expr><name>pKeyInfo</name>-&gt;<name>aSortOrder</name> &amp;&amp; <name>pKeyInfo</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name>++</expr>]</index></name> = '-'</expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>,<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> += <name>n</name></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>i</name>+4&lt;<name>nTemp</name>-6</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr>",nil"</expr></argument>,<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name> += 4</expr>;</expr_stmt>
        }</block></then></if></else></if>
      }</block></for>
      <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zTemp</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&lt;<name>nTemp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_COLLSEQ</name></expr>: <block>{
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pColl</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"collseq(%.20s)"</expr></argument>, <argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_FUNCDEF</name></expr>: <block>{
      <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pDef</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pFunc</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%s(%d)"</expr></argument>, <argument><expr><name>pDef</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pDef</name>-&gt;<name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_INT64</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%lld"</expr></argument>, <argument><expr>*<name>pOp</name>-&gt;<name>p4</name>.<name>pI64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_INT32</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_REAL</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%.16g"</expr></argument>, <argument><expr>*<name>pOp</name>-&gt;<name>p4</name>.<name>pReal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>P4_MEM</name></expr>: <block>{
      <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pMem</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Null</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Str</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zP4</name> = <name>pMem</name>-&gt;<name>z</name></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Int</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%lld"</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Real</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"%.16g"</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if>
      <break>break;</break>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    </case><case>case <expr><name>P4_VTAB</name></expr>: <block>{
      <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>pVtab</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"vtab:%p:%p"</expr></argument>, <argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>pModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr><name>P4_INTARRAY</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nTemp</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr>"intarray"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><name>zP4</name> = <name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zP4</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zP4</name> = <name>zTemp</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zTemp</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zP4</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zP4</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Declare to the Vdbe that the BTree object at db-&gt;aDb[i] is used.
**
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeUsesBtree</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>p</name>-&gt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&lt;(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>btreeMask</name></expr></argument>)</argument_list></call>*8</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> = 1&lt;&lt;<name>i</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>btreeMask</name> &amp; <name>mask</name>)==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>btreeMask</name> |= <name>mask</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayInsert</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print a single opcode.  This routine is used for debugging only.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintOp</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>pOut</name></decl></param>, <param><decl><type><name>int</name></type> <name>pc</name></decl></param>, <param><decl><type><name>Op</name> *</type><name>pOp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zP4</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zPtr</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name>zFormat1</name> =<init> <expr>"%4d %-13s %4d %4d %4d %-4s %.2X %s\n"</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pOut</name>==0</expr> )</condition><then> <expr_stmt><expr><name>pOut</name> = <name>stdout</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>zP4</name> = <call><name>displayP4</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>zPtr</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>zFormat1</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, 
      <argument><expr><call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>opcode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p2</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p3</name></expr></argument>, <argument><expr><name>zP4</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p5</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <argument><expr><name>pOp</name>-&gt;<name>zComment</name> ? <name>pOp</name>-&gt;<name>zComment</name> : ""
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      ""</expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Release an array of N Mem elements
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>releaseMemArray</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>N</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Mem</name> *</type><name>pEnd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>malloc_failed</name> =<init> <expr><name>db</name>-&gt;<name>mallocFailed</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>pEnd</name>=&amp;<name><name>p</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name>&lt;<name>pEnd</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(&amp;<name><name>p</name><index>[<expr>1</expr>]</index></name>)==<name>pEnd</name> || <name><name>p</name><index>[<expr>0</expr>]</index></name>.<name>db</name>==<name><name>p</name><index>[<expr>1</expr>]</index></name>.<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* This block is really an inlined version of sqlite3VdbeMemRelease()
      ** that takes advantage of the fact that the memory cell value is 
      ** being set to NULL after releasing any dynamic resources.
      **
      ** The justification for duplicating code is that according to 
      ** callgrind, this causes a certain test case to hit the CPU 4.7 
      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if 
      ** sqlite3MemRelease() were called from here. With -O2, this jumps
      ** to 6.6 percent. The test case is inserting 1000 rows into a table 
      ** with no indexes using a single prepared INSERT statement, bind() 
      ** and reset(). Inserts are grouped into a transaction.
      */</comment>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name>&amp;(<name>MEM_Agg</name>|<name>MEM_Dyn</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zMalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
      }</block></then></if></else></if>

      <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = <name>malloc_failed</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
<function><type><name>int</name></type> <name>sqlite3VdbeReleaseBuffers</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFree</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>ii</name>=1</expr>;</init> <condition><expr><name>ii</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pMem</name>-&gt;<name>z</name> &amp;&amp; <name>pMem</name>-&gt;<name>flags</name>&amp;<name>MEM_Dyn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pMem</name>-&gt;<name>xDel</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nFree</name> += <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>nFree</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
<comment type="block">/*
** Give a listing of the program in the virtual machine.
**
** The interface is the same as sqlite3VdbeExec().  But instead of
** running the code, it invokes the callback once for each instruction.
** This feature is used to implement "EXPLAIN".
**
** When p-&gt;explain==1, each instruction is listed.  When
** p-&gt;explain==2, only OP_Explain instructions are listed and these
** are shown in a different format.  p-&gt;explain==2 is used to implement
** EXPLAIN QUERY PLAN.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeList</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>                   <comment type="block">/* The VDBE */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name> =<init> <expr><name>p</name>-&gt;<name>pResultSet</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>explain</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>magic</name>!=<name>VDBE_MAGIC_RUN</name></expr> )</condition><then> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>magic</name>==<name>SQLITE_MAGIC_BUSY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name> || <name>p</name>-&gt;<name>rc</name>==<name>SQLITE_BUSY</name> || <name>p</name>-&gt;<name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Even though this opcode does not use dynamic strings for
  ** the result, result columns may become dynamic if the user calls
  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.
  */</comment>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
    <comment type="block">/* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */</comment>
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <do>do<block>{
    <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>pc</name>++</expr>;</expr_stmt>
  }</block>while<condition>( <expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name> &amp;&amp; <name>p</name>-&gt;<name>explain</name>==2 &amp;&amp; <name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>opcode</name>!=<name>OP_Explain</name></expr> )</condition>;</do>
  <if>if<condition>( <expr><name>i</name>&gt;=<name>p</name>-&gt;<name>nOp</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_DONE</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>db</name>-&gt;<name>u1</name>.<name>isInterrupted</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_INTERRUPT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SetString</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Op</name> *</type><name>pOp</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>explain</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>i</name></expr>;</expr_stmt>                                <comment type="block">/* Program counter */</comment>
      <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>
  
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Static</name>|<name>MEM_Str</name>|<name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = (<name>char</name>*)<call><name>sqlite3OpcodeName</name><argument_list>(<argument><expr><name>pOp</name>-&gt;<name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Opcode */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>z</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_TEXT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>pOp</name>-&gt;<name>p1</name></expr>;</expr_stmt>                          <comment type="block">/* P1 */</comment>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>

    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>pOp</name>-&gt;<name>p2</name></expr>;</expr_stmt>                          <comment type="block">/* P2 */</comment>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>

    <if>if<condition>( <expr><name>p</name>-&gt;<name>explain</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>pOp</name>-&gt;<name>p3</name></expr>;</expr_stmt>                          <comment type="block">/* P3 */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_INTEGER</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr>32</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{            <comment type="block">/* P4 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Dyn</name>|<name>MEM_Str</name>|<name>MEM_Term</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <call><name>displayP4</name><argument_list>(<argument><expr><name>pOp</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z</name>!=<name>pMem</name>-&gt;<name>z</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>z</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_TEXT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>

    <if>if<condition>( <expr><name>p</name>-&gt;<name>explain</name>==1</expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>sqlite3VdbeMemGrow</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Dyn</name>|<name>MEM_Str</name>|<name>MEM_Term</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = 2</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr>"%.2x"</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* P5 */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_TEXT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if>if<condition>( <expr><name>pOp</name>-&gt;<name>zComment</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Str</name>|<name>MEM_Term</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = <name>pOp</name>-&gt;<name>zComment</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_TEXT</name></expr>;</expr_stmt>
      }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>                       <comment type="block">/* Comment */</comment>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>type</name> = <name>SQLITE_NULL</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>p</name>-&gt;<name>nResColumn</name> = 8 - 5*(<name>p</name>-&gt;<name>explain</name>-1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ROW</name></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Print the SQL that was used to generate a VDBE program.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbePrintSql</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name> =<init> <expr><name>p</name>-&gt;<name>nOp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>nOp</name>&lt;1</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pOp</name> = &amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Trace</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>z</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><call><name>isspace</name><argument_list>(<argument><expr>*(<name>u8</name>*)<name>z</name></expr></argument>)</argument_list></call></expr> )</condition> <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SQL: [%s]\n"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Print an IOTRACE message showing SQL content.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeIOTraceSql</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name> =<init> <expr><name>p</name>-&gt;<name>nOp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>sqlite3IoTrace</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>nOp</name>&lt;1</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pOp</name> = &amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Trace</name> &amp;&amp; <name>pOp</name>-&gt;<name>p4</name>.<name>z</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>z</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><call><name>isspace</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{}</block></for>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <macro><name>isspace</name><argument_list>(<argument>(unsigned char)z[i]</argument>)</argument_list></macro> )</condition><then><block>{
        <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>-1</expr>]</index></name>!=' '</expr> )</condition><then><block>{
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IoTrace</name><argument_list>(<argument><expr>"SQL %s\n"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_TRACE &amp;&amp; SQLITE_ENABLE_IOTRACE */</comment>


<comment type="block">/*
** Prepare a virtual machine for execution.  This involves things such
** as allocating stack space and initializing the program counter.
** After the VDBE has be prepped, it can be executed by one or more
** calls to sqlite3VdbeExec().  
**
** This is the only way to move a VDBE from VDBE_MAGIC_INIT to
** VDBE_MAGIC_RUN.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeMakeReady</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>,                       <comment type="block">/* The VDBE */</comment>
  <param><decl><type><name>int</name></type> <name>nVar</name></decl></param>,                      <comment type="block">/* Number of '?' see in the SQL statement */</comment>
  <param><decl><type><name>int</name></type> <name>nMem</name></decl></param>,                      <comment type="block">/* Number of memory cells to allocate */</comment>
  <param><decl><type><name>int</name></type> <name>nCursor</name></decl></param>,                   <comment type="block">/* Number of cursors to allocate */</comment>
  <param><decl><type><name>int</name></type> <name>isExplain</name></decl></param>                  <comment type="block">/* True if the EXPLAIN keywords is present */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_INIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There should be at least one opcode.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nOp</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_RUN</name></expr>;</expr_stmt>

  <comment type="block">/* For each cursor required, also allocate a memory cell. Memory
  ** cells (nMem+1-nCursor)..nMem, inclusive, will never be used by
  ** the vdbe program. Instead they are used to allocate space for
  ** VdbeCursor/BtCursor structures. The blob of memory associated with 
  ** cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)
  ** stores the blob of memory associated with cursor 1, etc.
  **
  ** See also: allocateCursor().
  */</comment>
  <expr_stmt><expr><name>nMem</name> += <name>nCursor</name></expr>;</expr_stmt>

  <comment type="block">/*
  ** Allocation space for registers.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aMem</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>       <comment type="block">/* Maximum number of args passed to a user function. */</comment>
    <expr_stmt><expr><call><name>resolveP2Values</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>nArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nVar</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>isExplain</name> &amp;&amp; <name>nMem</name>&lt;10</expr> )</condition><then><block>{
      <expr_stmt><expr><name>nMem</name> = 10</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>aMem</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
        <argument><expr><name>nMem</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call>               <comment type="block">/* aMem */</comment>
      + <name>nVar</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call>               <comment type="block">/* aVar */</comment>
      + <name>nArg</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name>*</expr></argument>)</argument_list></call>              <comment type="block">/* apArg */</comment>
      + <name>nVar</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></call>             <comment type="block">/* azVar */</comment>
      + <name>nCursor</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>VdbeCursor</name>*</expr></argument>)</argument_list></call>+1</expr></argument>  <comment type="block">/* apCsr */</comment>
    )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>aMem</name>--</expr>;</expr_stmt>             <comment type="block">/* aMem[] goes from 1..nMem */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name>nMem</name> = <name>nMem</name></expr>;</expr_stmt>        <comment type="block">/*       not from 0..nMem-1 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name>aVar</name> = &amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>nMem</name>+1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nVar</name> = <name>nVar</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>okVar</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>apArg</name> = (<name>Mem</name>**)&amp;<name>p</name>-&gt;<name><name>aVar</name><index>[<expr><name>nVar</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>azVar</name> = (<name>char</name>**)&amp;<name>p</name>-&gt;<name><name>apArg</name><index>[<expr><name>nArg</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>apCsr</name> = (<name>VdbeCursor</name>**)&amp;<name>p</name>-&gt;<name><name>azVar</name><index>[<expr><name>nVar</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nCursor</name> = <name>nCursor</name></expr>;</expr_stmt>
      <for>for(<init><expr><name>n</name>=0</expr>;</init> <condition><expr><name>n</name>&lt;<name>nVar</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>p</name>-&gt;<name><name>aVar</name><index>[<expr><name>n</name></expr>]</index></name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name><name>aVar</name><index>[<expr><name>n</name></expr>]</index></name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
      }</block></for>
      <for>for(<init><expr><name>n</name>=1</expr>;</init> <condition><expr><name>n</name>&lt;=<name>nMem</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>n</name></expr>]</index></name>.<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>n</name></expr>]</index></name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <for>for(<init><expr><name>n</name>=1</expr>;</init> <condition><expr><name>n</name>&lt;<name>p</name>-&gt;<name>nMem</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name><name>aMem</name><index>[<expr><name>n</name></expr>]</index></name>.<name>db</name>==<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>p</name>-&gt;<name>pc</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>uniqueCnt</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>errorAction</name> = <name>OE_Abort</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>explain</name> |= <name>isExplain</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_RUN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>cacheCtr</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>minWriteFileFormat</name> = 255</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>openedStatement</name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cnt</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cycles</name> = 0</expr>;</expr_stmt>
    }</block></for>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Close a VDBE cursor and release all the resources that cursor 
** happens to hold.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeFreeCursor</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>VdbeCursor</name> *</type><name>pCx</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pCx</name>==0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCx</name>-&gt;<name>pBt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The pCx-&gt;pCursor will be close automatically, if it exists, by
    ** the call above. */</comment>
  }</block></then><else>else <if>if<condition>( <expr><name>pCx</name>-&gt;<name>pCursor</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeCloseCursor</name><argument_list>(<argument><expr><name>pCx</name>-&gt;<name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><name>pCx</name>-&gt;<name>pVtabCursor</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>pVtabCursor</name> =<init> <expr><name>pCx</name>-&gt;<name>pVtabCursor</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name> =<init> <expr><name>pCx</name>-&gt;<name>pModule</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pModule</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr><name>pVtabCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>inVtabMethod</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr>!<name>pCx</name>-&gt;<name>ephemPseudoTable</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pCx</name>-&gt;<name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Close all cursors except for VTab cursors that are currently
** in use.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>closeAllCursorsExceptActiveVtabs</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>apCsr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nCursor</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>VdbeCursor</name> *</type><name>pC</name> =<init> <expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pC</name> &amp;&amp; (!<name>p</name>-&gt;<name>inVtabMethod</name> || !<name>pC</name>-&gt;<name>pVtabCursor</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeFreeCursor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>apCsr</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Clean up the VM after execution.
**
** This routine will automatically close any cursors, lists, and/or
** sorters that were left open.  It also deletes the values of
** variables in the aVar[] array.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>Cleanup</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>closeAllCursorsExceptActiveVtabs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>pMem</name>=&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr>1</expr>]</index></name></expr>, <expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>p</name>-&gt;<name>nMem</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pMem</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_RowSet</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3RowSetClear</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>u</name>.<name>pRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>MemSetTypeFlag</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>MEM_Null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>contextStack</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>contextStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>contextStack</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>contextStackDepth</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>contextStackTop</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pResultSet</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the number of result columns that will be returned by this SQL
** statement. This is now set at compile time, rather than during
** execution of the vdbe program so that sqlite3_column_count() can
** be called on an SQL statement before sqlite3_step().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetNumCols</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>nResColumn</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pColName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aColName</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nResColumn</name>*<name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>nResColumn</name>*<name>COLNAME_N</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nResColumn</name> = <name>nResColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>aColName</name> = <name>pColName</name> = (<name>Mem</name>*)<call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call>*<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aColName</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <while>while<condition>( <expr><name>n</name>-- &gt; 0</expr> )</condition><block>{
    <expr_stmt><expr><name>pColName</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColName</name>-&gt;<name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColName</name>++</expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="block">/*
** Set the name of the idx'th column to be returned by the SQL statement.
** zName must be a pointer to a nul terminated string.
**
** This call must be made after a call to sqlite3VdbeSetNumCols().
**
** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC
** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed
** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSetColName</name><parameter_list>(
  <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>,                         <comment type="block">/* Vdbe being configured */</comment>
  <param><decl><type><name>int</name></type> <name>idx</name></decl></param>,                         <comment type="block">/* Index of column zName applies to */</comment>
  <param><decl><type><name>int</name></type> <name>var</name></decl></param>,                         <comment type="block">/* One of the COLNAME_* constants */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,               <comment type="block">/* Pointer to buffer containing name */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>              <comment type="block">/* Memory management strategy for zName */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pColName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name>&lt;<name>p</name>-&gt;<name>nResColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>var</name>&lt;<name>COLNAME_N</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>zName</name> || <name>xDel</name>!=<name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>aColName</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColName</name> = &amp;(<name>p</name>-&gt;<name><name>aColName</name><index>[<expr><name>idx</name>+<name>var</name>*<name>p</name>-&gt;<name>nResColumn</name></expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name>pColName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=0 || !<name>zName</name> || (<name>pColName</name>-&gt;<name>flags</name>&amp;<name>MEM_Term</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** A read or write transaction may or may not be active on database handle
** db. If a transaction is active, commit it. If there is a
** write-transaction spanning more than one database file, this routine
** takes care of the master journal trickery.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>vdbeCommit</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTrans</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of databases with an active write-transaction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needXcommit</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Before doing anything else, call the xSync() callback for any
  ** virtual module tables written in this transaction. This has to
  ** be done before determining whether a master journal file is 
  ** required, as an xSync() callback may add an attached database
  ** to the transaction.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VtabSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* This loop determines (a) if the commit hook should be invoked and
  ** (b) how many database files have open write transactions, not 
  ** including the temp database. (b) is important because if more than 
  ** one database file has an open write transaction, a master journal
  ** file is required for an atomic commit.
  */</comment> 
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ 
    <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>needXcommit</name> = 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>i</name>!=1</expr> )</condition><then> <expr_stmt><expr><name>nTrans</name>++</expr>;</expr_stmt></then></if>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* If there are any write-transactions at all, invoke the commit hook */</comment>
  <if>if<condition>( <expr><name>needXcommit</name> &amp;&amp; <name>db</name>-&gt;<name>xCommitCallback</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CommitBusy</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_CommitBusy</name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>db</name>-&gt;<call><name>xCommitCallback</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pCommitArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> &amp;= ~<name>SQLITE_CommitBusy</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CONSTRAINT</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* The simple case - no more than one database file (not counting the
  ** TEMP database) has a transaction active.   There is no need for the
  ** master-journal.
  **
  ** If the return value of sqlite3BtreeGetFilename() is a zero length
  ** string, it means the main database is :memory: or a temp file.  In 
  ** that case we do not support atomic multi-file commits, so use the 
  ** simple case then too.
  */</comment>
  <if>if<condition>( <expr>0==<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
   || <name>nTrans</name>&lt;=1</expr>
  )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ 
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* Do the commit only if all databases successfully complete phase 1. 
    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an
    ** IO error while deleting or truncating a journal file. It is unlikely,
    ** but could happen. In this case abandon processing and return the error.
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>

  <comment type="block">/* The complex case - There is a multi-file write-transaction active.
  ** This requires a master journal file to ensure the transaction is
  ** committed atomicly.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifndef>
  <else>else<block>{
    <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>db</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needSync</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zMaster</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* File-name for the master journal */</comment>
    <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zMainFile</name> =<init> <expr><call><name>sqlite3BtreeGetFilename</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>pMaster</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <comment type="block">/* Select a master journal file name */</comment>
    <do>do <block>{
      <decl_stmt><decl><type><name>u32</name></type> <name>iRandom</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>iRandom</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>iRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zMaster</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s-mj%08X"</expr></argument>, <argument><expr><name>zMainFile</name></expr></argument>, <argument><expr><name>iRandom</name>&amp;0x7fffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>zMaster</name></expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>while<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>res</name></expr> )</condition>;</do>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <comment type="block">/* Open the master journal. */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpenMalloc</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>&amp;<name>pMaster</name></expr></argument>, 
          <argument><expr><name>SQLITE_OPEN_READWRITE</name>|<name>SQLITE_OPEN_CREATE</name>|
          <name>SQLITE_OPEN_EXCLUSIVE</name>|<name>SQLITE_OPEN_MASTER_JOURNAL</name></expr></argument>, <argument><expr>0</expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
 
    <comment type="block">/* Write the name of each database file in the transaction into the new
    ** master journal file. If an error occurs at this point close
    ** and delete the master journal file. All the individual journal files
    ** still have 'null' as the master journal pointer, so they will roll
    ** back independently if a failure occurs.
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>i</name>==1</expr> )</condition><then> <continue>continue;</continue></then></if>   <comment type="block">/* Ignore the TEMP database */</comment>
      <if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zFile</name> =<init> <expr><call><name>sqlite3BtreeGetJournalname</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name><name>zFile</name><index>[<expr>0</expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>  <comment type="block">/* Ignore :memory: databases */</comment>
        <if>if<condition>( <expr>!<name>needSync</name> &amp;&amp; !<call><name>sqlite3BtreeSyncDisabled</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>needSync</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call>+1</expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call>+1</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* Sync the master journal file. If the IOCAP_SEQUENTIAL device
    ** flag is set this is not required.
    */</comment>
    <expr_stmt><expr><name>zMainFile</name> = <call><name>sqlite3BtreeGetDirname</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>needSync</name> 
     &amp;&amp; (0==(<call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call>&amp;<name>SQLITE_IOCAP_SEQUENTIAL</name>))
     &amp;&amp; (<name>rc</name>=<call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>SQLITE_SYNC_NORMAL</name></expr></argument>)</argument_list></call>)!=<name>SQLITE_OK</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Sync all the db files involved in the transaction. The same call
    ** sets the master journal pointer in each individual journal. If
    ** an error occurs here, do not delete the master journal file.
    **
    ** If the error occurs during the first call to
    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the
    ** master journal file will be orphaned. But we cannot delete it,
    ** in case the master journal file name was written into the journal
    ** file before the failure occured.
    */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ 
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeCommitPhaseOne</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3OsCloseFree</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Delete the master journal file. This commits the transaction. After
    ** doing this the directory is synced again before any individual
    ** transaction files are deleted.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zMaster</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* All files and directories have already been synced, so the following
    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
    ** deleting or truncating journals. If something goes wrong while
    ** this is happening we don't really care. The integrity of the
    ** transaction is already guaranteed, but some stray 'cold' journals
    ** may be lying around. Returning an error code won't help matters.
    */</comment>
    <expr_stmt><expr><call><name>disable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ 
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3BtreeCommitPhaseTwo</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VtabCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** This routine checks that the sqlite3.activeVdbeCnt count variable
** matches the number of vdbe's in the list sqlite3.pVdbe that are
** currently active. An assertion fails if the two counts do not match.
** This is an internal self-check only - it is not an essential processing
** step.
**
** This is a no-op if NDEBUG is defined.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>static</name> <name>void</name></type> <name>checkActiveVdbeCnt</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <name>db</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_RUN</name> &amp;&amp; <name>p</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>readOnly</name>==0</expr> )</condition><then> <expr_stmt><expr><name>nWrite</name>++</expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>cnt</name>==<name>db</name>-&gt;<name>activeVdbeCnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nWrite</name>==<name>db</name>-&gt;<name>writeVdbeCnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>checkActiveVdbeCnt</name>(x)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** For every Btree that in database connection db which 
** has been modified, "trip" or invalidate each cursor in
** that Btree might have been modified so that the cursor
** can never be used again.  This happens when a rollback
*** occurs.  We have to trip all the other cursors, even
** cursor from other VMs in different database connections,
** so that none of them try to use the data at which they
** were pointing and which now may have been changed due
** to the rollback.
**
** Remember that a rollback can delete tables complete and
** reorder rootpages.  So it is not sufficient just to save
** the state of the cursor.  We have to invalidate the cursor
** so that it is never used again.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>invalidateCursorsOnModifiedBtrees</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>p</name> &amp;&amp; <call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeTripAllCursors</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SQLITE_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** This routine is called the when a VDBE tries to halt.  If the VDBE
** has made changes and is in autocommit mode, then commit those
** changes.  If a rollback is needed, then do the rollback.
**
** This routine is the only way to move the state of a VM from
** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to
** call this on a VM that is in the SQLITE_MAGIC_HALT state.
**
** Return an error code.  If the commit could not complete because of
** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it
** means the close did not happen and needs to be repeated.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeHalt</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>Btree</name> *</type><name>pBt</name></decl></param>)</parameter_list> <specifier>= 0</specifier>;</function_decl>  <comment type="block">/* Function to call on each btree backend */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isSpecialError</name></decl>;</decl_stmt>            <comment type="block">/* Set to true if SQLITE_NOMEM or IOERR */</comment>

  <comment type="block">/* This function contains the logic that determines if a statement or
  ** transaction will be committed or rolled back as a result of the
  ** execution of this virtual machine. 
  **
  ** If any of the following errors occur:
  **
  **     SQLITE_NOMEM
  **     SQLITE_IOERR
  **     SQLITE_FULL
  **     SQLITE_INTERRUPT
  **
  ** Then the internal cache might have been left in an inconsistent
  ** state.  We need to rollback the statement transaction, if there is
  ** one, or the complete transaction if there is no statement transaction.
  */</comment>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>closeAllCursorsExceptActiveVtabs</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>magic</name>!=<name>VDBE_MAGIC_RUN</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No commit or rollback needed if the program never started */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>mrc</name></decl>;</decl_stmt>   <comment type="block">/* Primary error code from p-&gt;rc */</comment>

    <comment type="block">/* Lock all btrees used by the statement */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayEnter</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check for one of the special errors */</comment>
    <expr_stmt><expr><name>mrc</name> = <name>p</name>-&gt;<name>rc</name> &amp; 0xff</expr>;</expr_stmt>
    <expr_stmt><expr><name>isSpecialError</name> = <name>mrc</name>==<name>SQLITE_NOMEM</name> || <name>mrc</name>==<name>SQLITE_IOERR</name>
                     || <name>mrc</name>==<name>SQLITE_INTERRUPT</name> || <name>mrc</name>==<name>SQLITE_FULL</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>isSpecialError</name></expr> )</condition><then><block>{
      <comment type="block">/* If the query was read-only, we need do no rollback at all. Otherwise,
      ** proceed with the special handling.
      */</comment>
      <if>if<condition>( <expr>!<name>p</name>-&gt;<name>readOnly</name> || <name>mrc</name>!=<name>SQLITE_INTERRUPT</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_IOERR_BLOCKED</name> &amp;&amp; <name>p</name>-&gt;<name>usesStmtJournal</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>xFunc</name> = <name>sqlite3BtreeRollbackStmt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr>(<name>mrc</name>==<name>SQLITE_NOMEM</name> || <name>mrc</name>==<name>SQLITE_FULL</name>)
                   &amp;&amp; <name>p</name>-&gt;<name>usesStmtJournal</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>xFunc</name> = <name>sqlite3BtreeRollbackStmt</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <comment type="block">/* We are forced to roll back the active transaction. Before doing
          ** so, abort any other statements this handle currently has active.
          */</comment>
          <expr_stmt><expr><call><name>invalidateCursorsOnModifiedBtrees</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 1</expr>;</expr_stmt>
        }</block></else></if></else></if>
      }</block></then></if>
    }</block></then></if>
  
    <comment type="block">/* If the auto-commit flag is set and this is the only active vdbe, then
    ** we do either a commit or rollback of the current transaction. 
    **
    ** Note: This block also runs if one of the special errors handled 
    ** above has occurred. 
    */</comment>
    <if>if<condition>( <expr>!<call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> 
     &amp;&amp; <name>db</name>-&gt;<name>autoCommit</name> 
     &amp;&amp; <name>db</name>-&gt;<name>writeVdbeCnt</name>==(<name>p</name>-&gt;<name>readOnly</name>==0) 
     &amp;&amp; (<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CommitBusy</name>)==0</expr>
    )</condition><then><block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name> || (<name>p</name>-&gt;<name>errorAction</name>==<name>OE_Fail</name> &amp;&amp; !<name>isSpecialError</name>)</expr> )</condition><then><block>{
        <comment type="block">/* The auto-commit flag is true, and the vdbe program was 
        ** successful or hit an 'OR FAIL' constraint. This means a commit 
        ** is required.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>vdbeCommit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayLeave</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
        }</block></then><else>else <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3CommitInternalChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else <if>if<condition>( <expr>!<name>xFunc</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name> || <name>p</name>-&gt;<name>errorAction</name>==<name>OE_Fail</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>p</name>-&gt;<name>openedStatement</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>xFunc</name> = <name>sqlite3BtreeCommitStmt</name></expr>;</expr_stmt>
        }</block></then></if> 
      }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>errorAction</name>==<name>OE_Abort</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>xFunc</name> = <name>sqlite3BtreeRollbackStmt</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>invalidateCursorsOnModifiedBtrees</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3RollbackAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 1</expr>;</expr_stmt>
      }</block></else></if></else></if>
    }</block></then></if></else></if>
  
    <comment type="block">/* If xFunc is not NULL, then it is one of sqlite3BtreeRollbackStmt or
    ** sqlite3BtreeCommitStmt. Call it once on each backend. If an error occurs
    ** and the return code is still SQLITE_OK, set the return code to the new
    ** error value.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>xFunc</name> ||
      <name>xFunc</name>==<name>sqlite3BtreeCommitStmt</name> ||
      <name>xFunc</name>==<name>sqlite3BtreeRollbackStmt</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>xFunc</name> &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ 
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pBt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>xFunc</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name> &amp;&amp; (<name>p</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name> || <name>p</name>-&gt;<name>rc</name>==<name>SQLITE_CONSTRAINT</name>)</expr> )</condition><then><block>{
          <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>rc</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></for>
  
    <comment type="block">/* If this was an INSERT, UPDATE or DELETE and the statement was committed, 
    ** set the change counter. 
    */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>changeCntOn</name> &amp;&amp; <name>p</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>xFunc</name> || <name>xFunc</name>==<name>sqlite3BtreeCommitStmt</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nChange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeSetChanges</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>p</name>-&gt;<name>nChange</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  
    <comment type="block">/* Rollback or commit any schema changes that occurred. */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>db</name>-&gt;<name>flags</name>&amp;<name>SQLITE_InternChanges</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> = (<name>db</name>-&gt;<name>flags</name> | <name>SQLITE_InternChanges</name>)</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Release the locks */</comment>
    <expr_stmt><expr><call><name>sqlite3BtreeMutexArrayLeave</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>aMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* We have successfully halted and closed the VM.  Record this fact. */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>activeVdbeCnt</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>readOnly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>writeVdbeCnt</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>activeVdbeCnt</name>&gt;=<name>db</name>-&gt;<name>writeVdbeCnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_HALT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkActiveVdbeCnt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Each VDBE holds the result of the most recent sqlite3_step() call
** in p-&gt;rc.  This routine sets that result back to SQLITE_OK.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeResetStepResult</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Clean up a VDBE after execution but do not delete the VDBE just yet.
** Write any error messages into *pzErrMsg.  Return the result code.
**
** After this routine is run, the VDBE should be ready to be executed
** again.
**
** To look at it another way, this routine resets the state of the
** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to
** VDBE_MAGIC_INIT.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeReset</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>

  <comment type="block">/* If the VM did not run to completion or if it encountered an
  ** error, then it might not have been halted properly.  So halt
  ** it now.
  */</comment>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeHalt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the VDBE has be run even partially, then transfer the error code
  ** and error message from the VDBE into the main database structure.  But
  ** if the VDBE has just been set to run but has not actually executed any
  ** instructions yet, leave the main database error information unchanged.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pc</name>&gt;=0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>,<argument><expr>-1</expr></argument>,<argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>,<argument><expr><name>SQLITE_UTF8</name></expr></argument>,<argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>errCode</name> = <name>p</name>-&gt;<name>rc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>rc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>rc</name> &amp;&amp; <name>p</name>-&gt;<name>expired</name></expr> )</condition><then><block>{
    <comment type="block">/* The expired flag was set on the VDBE before the first call
    ** to sqlite3_step(). For consistency (since sqlite3_step() was
    ** called), set the database error in this case as well.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>rc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
  }</block></then></if></else></if>

  <comment type="block">/* Reclaim all memory used by the VDBE
  */</comment>
  <expr_stmt><expr><call><name>Cleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save profiling information from this VDBE run.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>VDBE_PROFILE</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>FILE</name> *</type><name>out</name> =<init> <expr><call><name>fopen</name><argument_list>(<argument><expr>"vdbe_profile.out"</expr></argument>, <argument><expr>"a"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>out</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"---- "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%02x"</expr></argument>, <argument><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>opcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%6d %10lld %8lld "</expr></argument>,
           <argument><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cnt</name></expr></argument>,
           <argument><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cycles</name></expr></argument>,
           <argument><expr><name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cnt</name>&gt;0 ? <name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cycles</name>/<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name>.<name>cnt</name> : 0</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbePrintOp</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_INIT</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name>-&gt;<name>rc</name> &amp; <name>db</name>-&gt;<name>errMask</name></expr>;</return>
}</block></function>
 
<comment type="block">/*
** Clean up and delete a VDBE after execution.  Return an integer which is
** the result code.  Write any error message text into *pzErrMsg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeFinalize</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_RUN</name> || <name>p</name>-&gt;<name>magic</name>==<name>VDBE_MAGIC_HALT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>rc</name> &amp; <name>p</name>-&gt;<name>db</name>-&gt;<name>errMask</name>)==<name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>magic</name>!=<name>VDBE_MAGIC_INIT</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if></else></if>
  <expr_stmt><expr><call><name>sqlite3VdbeDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Call the destructor for each auxdata entry in pVdbeFunc for which
** the corresponding bit in mask is clear.  Auxdata entries beyond 31
** are always destroyed.  To destroy all auxdata entries, call this
** routine with mask==0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDeleteAuxData</name><parameter_list>(<param><decl><type><name>VdbeFunc</name> *</type><name>pVdbeFunc</name></decl></param>, <param><decl><type><name>int</name></type> <name>mask</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pVdbeFunc</name>-&gt;<name>nAux</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>AuxData</name> *</type><name>pAux</name> =<init> <expr>&amp;<name>pVdbeFunc</name>-&gt;<name><name>apAux</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr>(<name>i</name>&gt;31 || !(<name>mask</name>&amp;(1&lt;&lt;<name>i</name>))) &amp;&amp; <name>pAux</name>-&gt;<name>pAux</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pAux</name>-&gt;<name>xDelete</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pAux</name>-&gt;<call><name>xDelete</name><argument_list>(<argument><expr><name>pAux</name>-&gt;<name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pAux</name>-&gt;<name>pAux</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Delete an entire VDBE.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDelete</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>pVdbe</name>==<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>pVdbe</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>p</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aOp</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Op</name> *</type><name>pOp</name> =<init> <expr><name>p</name>-&gt;<name>aOp</name></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOp</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pOp</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>freeP4</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4type</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>p4</name>.<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOp</name>-&gt;<name>zComment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aVar</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aLabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>aMem</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name><name>aMem</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>releaseMemArray</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>aColName</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nResColumn</name>*<name>COLNAME_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>aColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>magic</name> = <name>VDBE_MAGIC_DEAD</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** If a MoveTo operation is pending on the given cursor, then do that
** MoveTo now.  Return an error code.  If no MoveTo is pending, this
** routine does nothing and returns SQLITE_OK.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeCursorMoveto</name><parameter_list>(<param><decl><type><name>VdbeCursor</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>deferredMoveto</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>res</name>, <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <decl_stmt><decl><type><name>extern</name> <name>int</name></type> <name>sqlite3_search_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>isTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeMovetoUnpacked</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name>-&gt;<name>movetoTarget</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>lastRowid</name> = <call><name>keyToInt</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>movetoTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>rowidIsValid</name> = <name>res</name>==0 ?1:0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>res</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeNext</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_search_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>p</name>-&gt;<name>deferredMoveto</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>pCursor</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>hasMoved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3BtreeCursorHasMoved</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>&amp;<name>hasMoved</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <if>if<condition>( <expr><name>hasMoved</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>cacheStatus</name> = <name>CACHE_STALE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>nullRow</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The following functions:
**
** sqlite3VdbeSerialType()
** sqlite3VdbeSerialTypeLen()
** sqlite3VdbeSerialLen()
** sqlite3VdbeSerialPut()
** sqlite3VdbeSerialGet()
**
** encapsulate the code that serializes values for storage in SQLite
** data and index records. Each serialized value consists of a
** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned
** integer, stored as a varint.
**
** In an SQLite index record, the serial type is stored directly before
** the blob of data that it corresponds to. In a table record, all serial
** types are stored at the start of the record, and the blobs of data at
** the end. Hence these functions allow the caller to handle the
** serial-type and data blob seperately.
**
** The following table describes the various storage classes for data:
**
**   serial type        bytes of data      type
**   --------------     ---------------    ---------------
**      0                     0            NULL
**      1                     1            signed integer
**      2                     2            signed integer
**      3                     3            signed integer
**      4                     4            signed integer
**      5                     6            signed integer
**      6                     8            signed integer
**      7                     8            IEEE float
**      8                     0            Integer constant 0
**      9                     0            Integer constant 1
**     10,11                               reserved for expansion
**    N&gt;=12 and even       (N-12)/2        BLOB
**    N&gt;=13 and odd        (N-13)/2        text
**
** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions
** of SQLite will not understand those serial types.
*/</comment>

<comment type="block">/*
** Return the serial-type for the value stored in pMem.
*/</comment>
<function><type><name>u32</name></type> <name>sqlite3VdbeSerialType</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>file_format</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><name>pMem</name>-&gt;<name>flags</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>flags</name>&amp;<name>MEM_Null</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>flags</name>&amp;<name>MEM_Int</name></expr> )</condition><then><block>{
    <comment type="block">/* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <name>MAX_6BYTE</name> ((((i64)0x00008000)&lt;&lt;32)-1)</cpp:define>
    <decl_stmt><decl><type><name>i64</name></type> <name>i</name> =<init> <expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u64</name></type> <name>u</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>file_format</name>&gt;=4 &amp;&amp; (<name>i</name>&amp;1)==<name>i</name></expr> )</condition><then><block>{
      <return>return <expr>8+(<name>u32</name>)<name>i</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>u</name> = <name>i</name>&lt;0 ? -<name>i</name> : <name>i</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>u</name>&lt;=127</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
    <if>if<condition>( <expr><name>u</name>&lt;=32767</expr> )</condition><then> <return>return <expr>2</expr>;</return></then></if>
    <if>if<condition>( <expr><name>u</name>&lt;=8388607</expr> )</condition><then> <return>return <expr>3</expr>;</return></then></if>
    <if>if<condition>( <expr><name>u</name>&lt;=2147483647</expr> )</condition><then> <return>return <expr>4</expr>;</return></then></if>
    <if>if<condition>( <expr><name>u</name>&lt;=<name>MAX_6BYTE</name></expr> )</condition><then> <return>return <expr>5</expr>;</return></then></if>
    <return>return <expr>6</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>flags</name>&amp;<name>MEM_Real</name></expr> )</condition><then><block>{
    <return>return <expr>7</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> || <name>flags</name>&amp;(<name>MEM_Str</name>|<name>MEM_Blob</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <name>pMem</name>-&gt;<name>n</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name> += <name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>((<name>n</name>*2) + 12 + ((<name>flags</name>&amp;<name>MEM_Str</name>)!=0))</expr>;</return>
}</block></function>

<comment type="block">/*
** Return the length of the data corresponding to the supplied serial-type.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeSerialTypeLen</name><parameter_list>(<param><decl><type><name>u32</name></type> <name>serial_type</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>serial_type</name>&gt;=12</expr> )</condition><then><block>{
    <return>return <expr>(<name>serial_type</name>-12)/2</expr>;</return>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>aSize</name><index>[]</index></name> =<init> <expr><block>{ <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>6</expr>, <expr>8</expr>, <expr>8</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>aSize</name><index>[<expr><name>serial_type</name></expr>]</index></name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** If we are on an architecture with mixed-endian floating 
** points (ex: ARM7) then swap the lower 4 bytes with the 
** upper 4 bytes.  Return the result.
**
** For most architectures, this is a no-op.
**
** (later):  It is reported to me that the mixed-endian problem
** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems
** that early versions of GCC stored the two words of a 64-bit
** float in the wrong order.  And that error has been propagated
** ever since.  The blame is not necessarily with GCC, though.
** GCC might have just copying the problem from a prior compiler.
** I am also told that newer versions of GCC that follow a different
** ABI get the byte order right.
**
** Developers using SQLite on an ARM7 should compile and run their
** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG
** enabled, some asserts below will ensure that the byte order of
** floating point values is correct.
**
** (2007-08-30)  Frank van Vugt has studied this problem closely
** and has send his findings to the SQLite developers.  Frank
** writes that some Linux kernels offer floating point hardware
** emulation that uses only 32-bit mantissas instead of a full 
** 48-bits as required by the IEEE standard.  (This is the
** CONFIG_FPE_FASTFPE option.)  On such systems, floating point
** byte swapping becomes very complicated.  To avoid problems,
** the necessary byte swapping is carried out using a 64-bit integer
** rather than a 64-bit float.  Frank assures us that the code here
** works for him.  We, the developers, have no way to independently
** verify this, but Frank seems to know what he is talking about
** so we trust him.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_MIXED_ENDIAN_64BIT_FLOAT</name></cpp:ifdef>
<function><type><name>static</name> <name>u64</name></type> <name>floatSwap</name><parameter_list>(<param><decl><type><name>u64</name></type> <name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><struct>union <block>{<public type="default"/>
    <decl_stmt><decl><type><name>u64</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u32</name></type> <name><name>i</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>u</name>.<name>r</name> = <name>in</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> = <name>u</name>.<name><name>i</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>u</name>.<name><name>i</name><index>[<expr>0</expr>]</index></name> = <name>u</name>.<name><name>i</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>u</name>.<name><name>i</name><index>[<expr>1</expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
  <return>return <expr><name>u</name>.<name>r</name></expr>;</return>
}</block></function>
<cpp:define># <cpp:directive>define</cpp:directive> <name>swapMixedEndianFloat</name>(X)  X = floatSwap(X)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>swapMixedEndianFloat</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write the serialized data blob for the value stored in pMem into 
** buf. It is assumed that the caller has allocated sufficient space.
** Return the number of bytes written.
**
** nBuf is the amount of space left in buf[].  nBuf must always be
** large enough to hold the entire field.  Except, if the field is
** a blob with a zero-filled tail, then buf[] might be just the right
** size to hold everything except for the zero-filled tail.  If buf[]
** is only big enough to hold the non-zero prefix, then only write that
** prefix into buf[].  But if buf[] is large enough to hold both the
** prefix and the tail then write the prefix and set the tail to all
** zeros.
**
** Return the number of bytes actually written into buf[].  The number
** of bytes in the zero-filled tail is included in the return value only
** if those bytes were zeroed in buf[].
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3VdbeSerialPut</name><parameter_list>(<param><decl><type><name>u8</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>file_format</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name> =<init> <expr><call><name>sqlite3VdbeSerialType</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>file_format</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Integer and Real */</comment>
  <if>if<condition>( <expr><name>serial_type</name>&lt;=7 &amp;&amp; <name>serial_type</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u64</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>serial_type</name>==7</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>pMem</name>-&gt;<name>r</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>v</name> = <name>pMem</name>-&gt;<name>u</name>.<name>i</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>len</name> = <name>i</name> = <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name>&lt;=<name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>i</name>--</expr> )</condition><block>{
      <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>u8</name>)(<name>v</name>&amp;0xFF)</expr>;</expr_stmt>
      <expr_stmt><expr><name>v</name> &gt;&gt;= 8</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><name>len</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* String or blob */</comment>
  <if>if<condition>( <expr><name>serial_type</name>&gt;=12</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>n</name> + ((<name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name>)?<name>pMem</name>-&gt;<name>u</name>.<name>nZero</name>:0)
             == <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMem</name>-&gt;<name>n</name>&lt;=<name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <name>pMem</name>-&gt;<name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pMem</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pMem</name>-&gt;<name>flags</name> &amp; <name>MEM_Zero</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>len</name> += <name>pMem</name>-&gt;<name>u</name>.<name>nZero</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>len</name>&gt;<name>nBuf</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>len</name> = <name>nBuf</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>buf</name><index>[<expr><name>pMem</name>-&gt;<name>n</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>len</name>-<name>pMem</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>len</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* NULL or constants 0 or 1 */</comment>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Deserialize the data blob pointed to by buf as serial type serial_type
** and store the result in pMem.  Return the number of bytes read.
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3VdbeSerialGet</name><parameter_list>(
  <param><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>,     <comment type="block">/* Buffer to deserialize from */</comment>
  <param><decl><type><name>u32</name></type> <name>serial_type</name></decl></param>,              <comment type="block">/* Serial type to deserialize */</comment>
  <param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>                     <comment type="block">/* Memory cell to write value into */</comment>
)</parameter_list><block>{
  <switch>switch<condition>( <expr><name>serial_type</name></expr> )</condition><block>{
    <case>case <expr>10</expr>:   <comment type="block">/* Reserved for future use */</comment>
    </case><case>case <expr>11</expr>:   <comment type="block">/* Reserved for future use */</comment>
    </case><case>case <expr>0</expr>: <block>{  <comment type="block">/* NULL */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Null</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr>1</expr>: <block>{ <comment type="block">/* 1-byte signed integer */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = (<name>signed</name> <name>char</name>)<name><name>buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block>
    </case><case>case <expr>2</expr>: <block>{ <comment type="block">/* 2-byte signed integer */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = (((<name>signed</name> <name>char</name>)<name><name>buf</name><index>[<expr>0</expr>]</index></name>)&lt;&lt;8) | <name><name>buf</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>2</expr>;</return>
    }</block>
    </case><case>case <expr>3</expr>: <block>{ <comment type="block">/* 3-byte signed integer */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = (((<name>signed</name> <name>char</name>)<name><name>buf</name><index>[<expr>0</expr>]</index></name>)&lt;&lt;16) | (<name><name>buf</name><index>[<expr>1</expr>]</index></name>&lt;&lt;8) | <name><name>buf</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>3</expr>;</return>
    }</block>
    </case><case>case <expr>4</expr>: <block>{ <comment type="block">/* 4-byte signed integer */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = (<name><name>buf</name><index>[<expr>0</expr>]</index></name>&lt;&lt;24) | (<name><name>buf</name><index>[<expr>1</expr>]</index></name>&lt;&lt;16) | (<name><name>buf</name><index>[<expr>2</expr>]</index></name>&lt;&lt;8) | <name><name>buf</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>4</expr>;</return>
    }</block>
    </case><case>case <expr>5</expr>: <block>{ <comment type="block">/* 6-byte signed integer */</comment>
      <decl_stmt><decl><type><name>u64</name></type> <name>x</name> =<init> <expr>(((<name>signed</name> <name>char</name>)<name><name>buf</name><index>[<expr>0</expr>]</index></name>)&lt;&lt;8) | <name><name>buf</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>y</name> =<init> <expr>(<name><name>buf</name><index>[<expr>2</expr>]</index></name>&lt;&lt;24) | (<name><name>buf</name><index>[<expr>3</expr>]</index></name>&lt;&lt;16) | (<name><name>buf</name><index>[<expr>4</expr>]</index></name>&lt;&lt;8) | <name><name>buf</name><index>[<expr>5</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;32) | <name>y</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = *(<name>i64</name>*)&amp;<name>x</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>6</expr>;</return>
    }</block>
    </case><case>case <expr>6</expr>:   <comment type="block">/* 8-byte signed integer */</comment>
    </case><case>case <expr>7</expr>: <block>{ <comment type="block">/* IEEE floating point */</comment>
      <decl_stmt><decl><type><name>u64</name></type> <name>x</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>y</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_FLOATING_POINT</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <comment type="block">/* Verify that integers and floating point values use the same
      ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is
      ** defined that 64-bit floating point values really are mixed
      ** endian.
      */</comment>
      <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u64</name></type> <name>t1</name> =<init> <expr>((<name>u64</name>)0x3ff00000)&lt;&lt;32</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>static</name> <name>const</name> <name>double</name></type> <name>r1</name> =<init> <expr>1.0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>t2</name> =<init> <expr><name>t1</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>r1</name></expr></argument>, <argument><expr>&amp;<name>t2</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>x</name> = (<name><name>buf</name><index>[<expr>0</expr>]</index></name>&lt;&lt;24) | (<name><name>buf</name><index>[<expr>1</expr>]</index></name>&lt;&lt;16) | (<name><name>buf</name><index>[<expr>2</expr>]</index></name>&lt;&lt;8) | <name><name>buf</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>y</name> = (<name><name>buf</name><index>[<expr>4</expr>]</index></name>&lt;&lt;24) | (<name><name>buf</name><index>[<expr>5</expr>]</index></name>&lt;&lt;16) | (<name><name>buf</name><index>[<expr>6</expr>]</index></name>&lt;&lt;8) | <name><name>buf</name><index>[<expr>7</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;32) | <name>y</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>serial_type</name>==6</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = *(<name>i64</name>*)&amp;<name>x</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>==8 &amp;&amp; <call><name>sizeof</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call>==8</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>swapMixedEndianFloat</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pMem</name>-&gt;<name>r</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>pMem</name>-&gt;<name>r</name></expr></argument>)</argument_list></call> ? <name>MEM_Null</name> : <name>MEM_Real</name></expr>;</expr_stmt>
      }</block></else></if>
      <return>return <expr>8</expr>;</return>
    }</block>
    </case><case>case <expr>8</expr>:    <comment type="block">/* Integer 0 */</comment>
    </case><case>case <expr>9</expr>: <block>{  <comment type="block">/* Integer 1 */</comment>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>u</name>.<name>i</name> = <name>serial_type</name>-8</expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Int</name></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block>
    </case><default>default: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>(<name>serial_type</name>-12)/2</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>z</name> = (<name>char</name> *)<name>buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>n</name> = <name>len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pMem</name>-&gt;<name>xDel</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>serial_type</name>&amp;0x01</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Str</name> | <name>MEM_Ephem</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = <name>MEM_Blob</name> | <name>MEM_Ephem</name></expr>;</expr_stmt>
      }</block></else></if>
      <return>return <expr><name>len</name></expr>;</return>
    }</block>
  </default>}</block></switch>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Given the nKey-byte encoding of a record in pKey[], parse the
** record into a UnpackedRecord structure.  Return a pointer to
** that structure.
**
** The calling function might provide szSpace bytes of memory
** space at pSpace.  This space can be used to hold the returned
** VDbeParsedRecord structure if it is large enough.  If it is
** not big enough, space is obtained from sqlite3_malloc().
**
** The returned structure should be closed by a call to
** sqlite3VdbeDeleteUnpackedRecord().
*/</comment> 
<function><type><name>UnpackedRecord</name> *</type><name>sqlite3VdbeRecordUnpack</name><parameter_list>(
  <param><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl></param>,     <comment type="block">/* Information about the record format */</comment>
  <param><decl><type><name>int</name></type> <name>nKey</name></decl></param>,              <comment type="block">/* Size of the binary record */</comment>
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey</name></decl></param>,      <comment type="block">/* The binary record */</comment>
  <param><decl><type><name>UnpackedRecord</name> *</type><name>pSpace</name></decl></param>,<comment type="block">/* Space available to hold resulting object */</comment>
  <param><decl><type><name>int</name></type> <name>szSpace</name></decl></param>            <comment type="block">/* Size of pSpace[] in bytes */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>aKey</name> =<init> <expr>(<name>const</name> <name>unsigned</name> <name>char</name> *)<name>pKey</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnpackedRecord</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name>, <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>u</name></decl>;</decl_stmt>                 <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call>&gt;<call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nByte</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call>*(<name>pKeyInfo</name>-&gt;<name>nField</name>+2)</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nByte</name>&gt;<name>szSpace</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>pKeyInfo</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> = <name>UNPACKED_NEED_FREE</name> | <name>UNPACKED_NEED_DESTROY</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p</name> = <name>pSpace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> = <name>UNPACKED_NEED_DESTROY</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pKeyInfo</name> = <name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nField</name> = <name>pKeyInfo</name>-&gt;<name>nField</name> + 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>aMem</name> = <name>pMem</name> = &amp;((<name>Mem</name>*)<name>p</name>)[1]</expr>;</expr_stmt>
  <expr_stmt><expr><name>idx</name> = <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> = <name>szHdr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>u</name> = 0</expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx</name>&lt;<name>szHdr</name> &amp;&amp; <name>u</name>&lt;<name>p</name>-&gt;<name>nField</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>idx</name> += <call><name>getVarint32</name><argument_list>(<argument><expr>&amp;<name><name>aKey</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>d</name>&gt;=<name>nKey</name> &amp;&amp; <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type</name></expr></argument>)</argument_list></call>&gt;0</expr> )</condition><then> <break>break;</break></then></if>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>enc</name> = <name>pKeyInfo</name>-&gt;<name>enc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>db</name> = <name>pKeyInfo</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>flags</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>-&gt;<name>zMalloc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> += <call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr>&amp;<name><name>aKey</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type</name></expr></argument>, <argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMem</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>u</name>++</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name>&lt;=<name>pKeyInfo</name>-&gt;<name>nField</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nField</name> = <name>u</name></expr>;</expr_stmt>
  <return>return <expr>(<name>void</name>*)<name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine destroys a UnpackedRecord object
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeDeleteUnpackedRecord</name><parameter_list>(<param><decl><type><name>UnpackedRecord</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_NEED_DESTROY</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pMem</name>=<name>p</name>-&gt;<name>aMem</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nField</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pMem</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>pMem</name>-&gt;<name>zMalloc</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_NEED_FREE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pKeyInfo</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** This function compares the two table rows or index records
** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero
** or positive integer if key1 is less than, equal to or 
** greater than key2.  The {nKey1, pKey1} key must be a blob
** created by th OP_MakeRecord opcode of the VDBE.  The pPKey2
** key must be a parsed key such as obtained from
** sqlite3VdbeParseRecord.
**
** Key1 and Key2 do not have to contain the same number of fields.
** The key with fewer fields is usually compares less than the 
** longer key.  However if the UNPACKED_INCRKEY flags in pPKey2 is set
** and the common prefixes are equal, then key1 is less than key2.
** Or if the UNPACKED_MATCH_PREFIX flag is set and the prefixes are
** equal, then the keys are considered to be equal and
** the parts beyond the common prefix are ignored.
**
** If the UNPACKED_IGNORE_ROWID flag is set, then the last byte of
** the header of pKey1 is ignored.  It is assumed that pKey1 is
** an index key, and thus ends with a rowid value.  The last byte
** of the header will therefore be the serial type of the rowid:
** one of 1, 2, 3, 4, 5, 6, 8, or 9 - the integer serial types.
** The serial type of the final rowid will always be a single byte.
** By ignoring this last byte of the header, we force the comparison
** to ignore the rowid at the end of key1.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeRecordCompare</name><parameter_list>(
  <param><decl><type><name>int</name></type> <name>nKey1</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey1</name></decl></param>, <comment type="block">/* Left key */</comment>
  <param><decl><type><name>UnpackedRecord</name> *</type><name>pPKey2</name></decl></param>        <comment type="block">/* Right key */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>d1</name></decl>;</decl_stmt>            <comment type="block">/* Offset into aKey[] of next data element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>idx1</name></decl>;</decl_stmt>          <comment type="block">/* Offset into aKey[] of next header element */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr1</name></decl>;</decl_stmt>        <comment type="block">/* Number of bytes in header */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>aKey1</name> =<init> <expr>(<name>const</name> <name>unsigned</name> <name>char</name> *)<name>pKey1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>mem1</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pKeyInfo</name> = <name>pPKey2</name>-&gt;<name>pKeyInfo</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem1</name>.<name>enc</name> = <name>pKeyInfo</name>-&gt;<name>enc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem1</name>.<name>db</name> = <name>pKeyInfo</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem1</name>.<name>flags</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>mem1</name>.<name>zMalloc</name> = 0</expr>;</expr_stmt>
  
  <expr_stmt><expr><name>idx1</name> = <call><name>getVarint32</name><argument_list>(<argument><expr><name>aKey1</name></expr></argument>, <argument><expr><name>szHdr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d1</name> = <name>szHdr1</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPKey2</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_IGNORE_ROWID</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>szHdr1</name>--</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>nField</name> = <name>pKeyInfo</name>-&gt;<name>nField</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>idx1</name>&lt;<name>szHdr1</name> &amp;&amp; <name>i</name>&lt;<name>pPKey2</name>-&gt;<name>nField</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>u32</name></type> <name>serial_type1</name></decl>;</decl_stmt>

    <comment type="block">/* Read the serial types for the next element in each key. */</comment>
    <expr_stmt><expr><name>idx1</name> += <call><name>getVarint32</name><argument_list>( <argument><expr><name>aKey1</name>+<name>idx1</name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>d1</name>&gt;=<name>nKey1</name> &amp;&amp; <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>serial_type1</name></expr></argument>)</argument_list></call>&gt;0</expr> )</condition><then> <break>break;</break></then></if>

    <comment type="block">/* Extract the values to be compared.
    */</comment>
    <expr_stmt><expr><name>d1</name> += <call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr>&amp;<name><name>aKey1</name><index>[<expr><name>d1</name></expr>]</index></name></expr></argument>, <argument><expr><name>serial_type1</name></expr></argument>, <argument><expr>&amp;<name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Do the comparison
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr>&amp;<name>mem1</name></expr></argument>, <argument><expr>&amp;<name>pPKey2</name>-&gt;<name><name>aMem</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                           <argument><expr><name>i</name>&lt;<name>nField</name> ? <name>pKeyInfo</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then><block>{
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><name>mem1</name>.<name>zMalloc</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>mem1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if<condition>( <expr><name>rc</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* rc==0 here means that one of the keys ran out of fields and
    ** all the fields up to that point were equal. If the UNPACKED_INCRKEY
    ** flag is set, then break the tie by treating key2 as larger.
    ** If the UPACKED_PREFIX_MATCH flag is set, then keys with common prefixes
    ** are considered to be equal.  Otherwise, the longer key is the 
    ** larger.  As it happens, the pPKey2 will always be the longer
    ** if there is a difference.
    */</comment>
    <if>if<condition>( <expr><name>pPKey2</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_INCRKEY</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pPKey2</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_PREFIX_MATCH</name></expr> )</condition><then><block>{
      <comment type="block">/* Leave rc==0 */</comment>
    }</block></then><else>else <if>if<condition>( <expr><name>idx1</name>&lt;<name>szHdr1</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>pKeyInfo</name>-&gt;<name>aSortOrder</name> &amp;&amp; <name>i</name>&lt;<name>pKeyInfo</name>-&gt;<name>nField</name>
               &amp;&amp; <name>pKeyInfo</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = -<name>rc</name></expr>;</expr_stmt>
  }</block></then></if></else></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
 

<comment type="block">/*
** pCur points at an index entry created using the OP_MakeRecord opcode.
** Read the rowid (the last field in the record) and store it in *rowid.
** Return SQLITE_OK if everything works, or an error code otherwise.
**
** pCur might be pointing to text obtained from a corrupt database file.
** So the content cannot be trusted.  Do appropriate checks on the content.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxRowid</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>i64</name> *</type><name>rowid</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>szHdr</name></decl>;</decl_stmt>        <comment type="block">/* Size of the header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>typeRowid</name></decl>;</decl_stmt>    <comment type="block">/* Serial type of the rowid */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>lenRowid</name></decl>;</decl_stmt>     <comment type="block">/* Size of the rowid */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name>, <name>v</name></decl>;</decl_stmt>

  <comment type="block">/* Get the size of the index entry.  Only indices entries of less
  ** than 2GiB are support - anything large must be database corruption */</comment>
  <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name>nCellKey</name>&lt;=0 || <name>nCellKey</name>&gt;0x7fffffff</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Read in the complete content of the index entry */</comment>
  <expr_stmt><expr><name>m</name>.<name>flags</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>m</name>.<name>db</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>m</name>.<name>zMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* The index entry must begin with a header size */</comment>
  <expr_stmt><expr>(<name>void</name>)<call><name>getVarint32</name><argument_list>(<argument><expr>(<name>u8</name>*)<name>m</name>.<name>z</name></expr></argument>, <argument><expr><name>szHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>szHdr</name>==<name>m</name>.<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name>szHdr</name>&lt;2 || (<name>int</name>)<name>szHdr</name>&gt;<name>m</name>.<name>n</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  }</block></then></if>

  <comment type="block">/* The last field of the index should be an integer - the ROWID.
  ** Verify that the last entry really is an integer. */</comment>
  <expr_stmt><expr>(<name>void</name>)<call><name>getVarint32</name><argument_list>(<argument><expr>(<name>u8</name>*)&amp;<name>m</name>.<name><name>z</name><index>[<expr><name>szHdr</name>-1</expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==5</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==6</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==8</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>typeRowid</name>==9</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name>typeRowid</name>&lt;1 || <name>typeRowid</name>&gt;9 || <name>typeRowid</name>==7</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>lenRowid</name> = <call><name>sqlite3VdbeSerialTypeLen</name><argument_list>(<argument><expr><name>typeRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>m</name>.<name>n</name>-<name>lenRowid</name>==<name>szHdr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>unlikely</name><argument_list>(<argument><expr><name>m</name>.<name>n</name>-<name>lenRowid</name>&lt;<name>szHdr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>idx_rowid_corruption</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Fetch the integer off the end of the index record */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeSerialGet</name><argument_list>(<argument><expr>(<name>u8</name>*)&amp;<name>m</name>.<name><name>z</name><index>[<expr><name>m</name>.<name>n</name>-<name>lenRowid</name></expr>]</index></name></expr></argument>, <argument><expr><name>typeRowid</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rowid</name> = <name>v</name>.<name>u</name>.<name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  <comment type="block">/* Jump here if database corruption is detected after m has been
  ** allocated.  Free the m object and return SQLITE_CORRUPT. */</comment>
<label><name>idx_rowid_corruption</name>:</label>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>m</name>.<name>zMalloc</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Compare the key of the index entry that cursor pC is point to against
** the key string in pKey (of length nKey).  Write into *pRes a number
** that is negative, zero, or positive if pC is less than, equal to,
** or greater than pKey.  Return SQLITE_OK on success.
**
** pKey is either created without a rowid or is truncated so that it
** omits the rowid at the end.  The rowid at the end of the index entry
** is ignored as well.  Hence, this routine only compares the prefixes 
** of the keys prior to the final rowid, not the entire key.
**
** pUnpacked may be an unpacked version of pKey,nKey.  If pUnpacked is
** supplied it is used in place of pKey,nKey.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VdbeIdxKeyCompare</name><parameter_list>(
  <param><decl><type><name>VdbeCursor</name> *</type><name>pC</name></decl></param>,             <comment type="block">/* The cursor to compare against */</comment>
  <param><decl><type><name>UnpackedRecord</name> *</type><name>pUnpacked</name></decl></param>,  <comment type="block">/* Unpacked version of pKey and nKey */</comment>
  <param><decl><type><name>int</name> *</type><name>res</name></decl></param>                    <comment type="block">/* Write the comparison result here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>nCellKey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCur</name> =<init> <expr><name>pC</name>-&gt;<name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name></type> <name>m</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3BtreeKeySize</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr>&amp;<name>nCellKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nCellKey</name>&lt;=0 || <name>nCellKey</name>&gt;0x7fffffff</expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>res</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>m</name>.<name>db</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>m</name>.<name>flags</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>m</name>.<name>zMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3VdbeMemFromBtree</name><argument_list>(<argument><expr><name>pC</name>-&gt;<name>pCursor</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>int</name>)<name>nCellKey</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pUnpacked</name>-&gt;<name>flags</name> &amp; <name>UNPACKED_IGNORE_ROWID</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>res</name> = <call><name>sqlite3VdbeRecordCompare</name><argument_list>(<argument><expr><name>m</name>.<name>n</name></expr></argument>, <argument><expr><name>m</name>.<name>z</name></expr></argument>, <argument><expr><name>pUnpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine sets the value to be returned by subsequent calls to
** sqlite3_changes() on the database handle 'db'. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeSetChanges</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>nChange</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nChange</name> = <name>nChange</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nTotalChange</name> += <name>nChange</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set a flag in the vdbe to update the change counter when it is finalised
** or reset.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VdbeCountChanges</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>v</name>-&gt;<name>changeCntOn</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Mark every prepared statement associated with a database connection
** as expired.
**
** An expired statement means that recompilation of the statement is
** recommend.  Statements expire when things happen that make their
** programs obsolete.  Removing user-defined functions or collating
** sequences, or changing an authorization function are the types of
** things that make prepared statements obsolete.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ExpirePreparedStatements</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>p</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name> = <name>db</name>-&gt;<name>pVdbe</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>expired</name> = 1</expr>;</expr_stmt>
  }</block></for>
}</block></function>

<comment type="block">/*
** Return the database associated with the Vdbe.
*/</comment>
<function><type><name>sqlite3</name> *</type><name>sqlite3VdbeDb</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>v</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>v</name>-&gt;<name>db</name></expr>;</return>
}</block></function>
</unit>
