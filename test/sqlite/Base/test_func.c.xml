<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="test_func.c" filename=""><comment type="block">/*
** 2008 March 19
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Code for testing all sorts of SQLite interfaces.  This code
** implements new SQL functions used by the test scripts.
**
** $Id: test_func.c,v 1.13 2008/08/28 02:26:07 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>


<comment type="block">/*
** Allocate nByte bytes of space using sqlite3_malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>testContextMalloc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>z</name> &amp;&amp; <name>nByte</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function generates a string of random characters.  Used for
** generating test data.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>randStr</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>zSrc</name><index>[]</index></name> =<init> 
     <expr>"abcdefghijklmnopqrstuvwxyz"
     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
     "0123456789"
     ".-!,:*^+=_|?/&lt;&gt; "</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMin</name>, <name>iMax</name>, <name>n</name>, <name>r</name>, <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBuf</name><index>[<expr>1000</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* It used to be possible to call randstr() with any number of arguments,
  ** but now it is registered with SQLite as requiring exactly 2.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>argc</name>==2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iMin</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iMin</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>iMin</name> = 0</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>iMin</name>&gt;=<call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr> )</condition><then> <expr_stmt><expr><name>iMin</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call>-1</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>iMax</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iMax</name>&lt;<name>iMin</name></expr> )</condition><then> <expr_stmt><expr><name>iMax</name> = <name>iMin</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>iMax</name>&gt;=<call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr> )</condition><then> <expr_stmt><expr><name>iMax</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call>-1</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>n</name> = <name>iMin</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iMax</name>&gt;<name>iMin</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> &amp;= 0x7fffffff</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> += <name>r</name>%(<name>iMax</name> + 1 - <name>iMin</name>)</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>zSrc</name><index>[<expr><name><name>zBuf</name><index>[<expr><name>i</name></expr>]</index></name>%(<call><name>sizeof</name><argument_list>(<argument><expr><name>zSrc</name></expr></argument>)</argument_list></call>-1)</expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The following two SQL functions are used to test returning a text
** result with a destructor. Function 'test_destructor' takes one argument
** and returns the same argument interpreted as TEXT. A destructor is
** passed with the sqlite3_result_text() call.
**
** SQL function 'test_destructor_count' returns the number of outstanding 
** allocations made by 'test_destructor';
**
** WARNING: Not threadsafe.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>test_destructor_count_var</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>static</name> <name>void</name></type> <name>destructor</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zVal</name> =<init> <expr>(<name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>test_destructor_count_var</name>--</expr>;</expr_stmt>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>test_destructor</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>test_destructor_count_var</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>len</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>zVal</name> = <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>len</name>+3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zVal</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name>+2</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>static</name> <name>void</name></type> <name>test_destructor16</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>test_destructor_count_var</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>len</name> = <call><name>sqlite3_value_bytes16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>zVal</name> = <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>len</name>+3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zVal</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zVal</name><index>[<expr><name>len</name>+2</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>zVal</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>, <argument><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text16</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>static</name> <name>void</name></type> <name>test_destructor_count</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>test_destructor_count_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()
** interface.
**
** The test_auxdata() SQL function attempts to register each of its arguments
** as auxiliary data.  If there are no prior registrations of aux data for
** that argument (meaning the argument is not a constant or this is its first
** call) then the result for that argument is 0.  If there is a prior
** registration, the result for that argument is 1.  The overall result
** is the individual argument results separated by spaces.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>free_test_auxdata</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>test_auxdata</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zRet</name> =<init> <expr><call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>nArg</name>*2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>zRet</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zRet</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nArg</name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>z</name> =<init> <expr>(<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>z</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zAux</name> =<init> <expr><call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>zAux</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name>*2</expr>]</index></name> = '1'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zAux</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <block>{
        <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name>*2</expr>]</index></name> = '0'</expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>zAux</name> = <call><name>testContextMalloc</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zAux</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zAux</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zAux</name></expr></argument>, <argument><expr><name>free_test_auxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>zRet</name><index>[<expr><name>i</name>*2+1</expr>]</index></name> = ' '</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr>2*<name>nArg</name>-1</expr></argument>, <argument><expr><name>free_test_auxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** A function to test error reporting from user functions. This function
** returns a copy of its first argument as the error message.  If the
** second argument exists, it becomes the error code.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>test_error</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr>(<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nArg</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the counter(X) function.  If X is an integer
** constant, then the first invocation will return X.  The second X+1.
** and so forth.  Can be used (for example) to provide a sequence number
** in a result set.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>counterFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>,   <comment type="block">/* Function context */</comment>
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,                <comment type="block">/* Number of function arguments */</comment>
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>     <comment type="block">/* Values for all function arguments */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name> *</type><name>pCounter</name> =<init> <expr>(<name>int</name>*)<call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pCounter</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCounter</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCounter</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCounter</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>pCounter</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pCounter</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr>++*<name>pCounter</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr>*<name>pCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** This function takes two arguments.  It performance UTF-8/16 type
** conversions on the first argument then returns a copy of the second
** argument.
**
** This function is used in cases such as the following:
**
**      SELECT test_isolation(x,x) FROM t1;
**
** We want to verify that the type conversions that occur on the
** first argument do not invalidate the second argument.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>test_isolation</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Invoke an SQL statement recursively.  The function result is the 
** first column of the first row of the result set.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>test_eval</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>pCtx</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>zSql</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_ROW</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStmt</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErr</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"sqlite3_prepare_v2() error: %s"</expr></argument>,<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<function><type><name>static</name> <name>int</name></type> <name>registerTestFunctions</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <struct>struct <block>{<public type="default"/>
     <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>nArg</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>eTextRep</name></decl>;</decl_stmt> <comment type="block">/* 1: UTF-16.  0: UTF-8 */</comment>
     <function_decl><type><name>void</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name> **</type></decl></param>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFuncs</name><index>[]</index></name> =<init> <expr><block>{
    <expr><block>{ <expr>"randstr"</expr>,               <expr>2</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>randStr</name></expr>    }</block></expr>,
    <expr><block>{ <expr>"test_destructor"</expr>,       <expr>1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
    <expr><block>{ <expr>"test_destructor16"</expr>,     <expr>1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor16</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{ <expr>"test_destructor_count"</expr>, <expr>0</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_destructor_count</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_auxdata"</expr>,         <expr>-1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_auxdata</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_error"</expr>,            <expr>1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_error</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_error"</expr>,            <expr>2</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_error</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_eval"</expr>,             <expr>1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_eval</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_isolation"</expr>,        <expr>2</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>test_isolation</name></expr>}</block></expr>,
    <expr><block>{ <expr>"test_counter"</expr>,          <expr>1</expr>, <expr><name>SQLITE_UTF8</name></expr>, <expr><name>counterFunc</name></expr>}</block></expr>,
  }</block></expr></init></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>aFuncs</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>aFuncs</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>nArg</name></expr></argument>,
        <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>eTextRep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>aFuncs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>xFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** TCLCMD:  autoinstall_test_functions
**
** Invoke this TCL command to use sqlite3_auto_extension() to cause
** the standard set of test functions to be loaded into each new
** database connection.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>autoinstall_test_funcs</name><parameter_list>(
  <param><decl><type><name>void</name> *</type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <function_decl><type><name>extern</name> <name>int</name></type> <name>Md5_Register</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr>(<name>void</name>*)<name>registerTestFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr>(<name>void</name>*)<name>Md5_Register</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** A bogus step function and finalizer function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>tStep</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>a</name></decl></param>, <param><decl><type><name>int</name></type> <name>b</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>c</name></decl></param>)</parameter_list><block>{}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>tFinal</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>a</name></decl></param>)</parameter_list><block>{}</block></function>


<comment type="block">/*
** tclcmd:  abuse_create_function
**
** Make various calls to sqlite3_create_function that do not have valid
** parameters.  Verify that the error condition is detected and reported.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>abuse_create_function</name><parameter_list>(
  <param><decl><type><name>void</name> *</type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
  <function_decl><type><name>extern</name> <name>int</name></type> <name>getDbPointer</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>char</name>*</type></decl></param>, <param><decl><type><name>sqlite3</name>**</type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mxArg</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>getDbPointer</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>,<argument><expr><name>tStep</name></expr></argument>,<argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>-2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tx"</expr></argument>, <argument><expr>128</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"funcxx"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"</expr></argument>,
       <argument><expr>1</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_ERROR</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call>!=0</expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>

  <comment type="block">/* This last function registration should actually work.  Generate
  ** a no-op function (that always returns NULL) and which has the
  ** maximum-length function name and the maximum number of parameters.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr></argument>, <argument><expr>10000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mxArg</name> = <call><name>sqlite3_limit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LIMIT_FUNCTION_ARG</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"nullx"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"
       "_123456789_123456789_123456789_123456789_123456789"</expr></argument>,
       <argument><expr><name>mxArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tStep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>abuse_err</name>;</goto></then></if>
                                
  <return>return <expr><name>TCL_OK</name></expr>;</return>

<label><name>abuse_err</name>:</label>
  <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlite3_create_function abused test failed"</expr></argument>, 
                   <argument><expr>(<name>char</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/*
** Register commands with the TCL interpreter.
*/</comment>
<function><type><name>int</name></type> <name>Sqlitetest_func_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <struct>struct <block>{<public type="default"/>
     <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>Tcl_ObjCmdProc</name> *</type><name>xProc</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aObjCmd</name><index>[]</index></name> =<init> <expr><block>{
     <expr><block>{ <expr>"autoinstall_test_functions"</expr>,    <expr><name>autoinstall_test_funcs</name></expr> }</block></expr>,
     <expr><block>{ <expr>"abuse_create_function"</expr>,         <expr><name>abuse_create_function</name></expr>  }</block></expr>,
  }</block></expr></init></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <function_decl><type><name>extern</name> <name>int</name></type> <name>Md5_Register</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>aObjCmd</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>aObjCmd</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name><name>aObjCmd</name><index>[<expr><name>i</name></expr>]</index></name>.<name>xProc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr>(<name>void</name>*)<name>registerTestFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_auto_extension</name><argument_list>(<argument><expr>(<name>void</name>*)<name>Md5_Register</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
</unit>
