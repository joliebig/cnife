<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="malloc.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** Memory allocation functions used throughout sqlite.
**
** $Id: malloc.c,v 1.53 2008/12/16 17:20:38 shane Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** This routine runs when the memory allocator sees that the
** total memory allocation is about to exceed the soft heap
** limit.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>softHeapLimitEnforcer</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>, 
  <param><decl><type><name>sqlite3_int64</name></type> <name>NotUsed2</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>allocSize</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_release_memory</name><argument_list>(<argument><expr><name>allocSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the soft heap-size limit for the library. Passing a zero or 
** negative value indicates no limit.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_soft_heap_limit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>iLimit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>overage</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>n</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>iLimit</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>iLimit</name> = <name>n</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iLimit</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3MemoryAlarm</name><argument_list>(<argument><expr><name>softHeapLimitEnforcer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3MemoryAlarm</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>overage</name> = (<name>int</name>)(<call><name>sqlite3_memory_used</name><argument_list>()</argument_list></call> - (<name>i64</name>)<name>n</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>overage</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_release_memory</name><argument_list>(<argument><expr><name>overage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Attempt to release up to n bytes of non-essential memory currently
** held by SQLite. An example of non-essential memory is memory used to
** cache database pages that are not currently in use.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_release_memory</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nRet</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  nRet += sqlite3VdbeReleaseMemory(n);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>nRet</name> += <call><name>sqlite3PcacheReleaseMemory</name><argument_list>(<argument><expr><name>n</name>-<name>nRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nRet</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** State information local to the memory allocation subsystem.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>SQLITE_WSD</name> struct</type> <name>Mem0Global</name> <block>{
  <comment type="block">/* Number of free pages for scratch and page-cache memory */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nScratchFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPageFree</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutex</name></decl>;</decl_stmt>         <comment type="block">/* Mutex to serialize access */</comment>

  <comment type="block">/*
  ** The alarm callback and its arguments.  The mem0.mutex lock will
  ** be held while the callback is running.  Recursive calls into
  ** the memory subsystem are allowed, but no new callbacks will be
  ** issued.  The alarmBusy variable is set to prevent recursive
  ** callbacks.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>alarmThreshold</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (*<name>alarmCallback</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>, <param><decl><type><name>sqlite3_int64</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> *</type><name>alarmArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>alarmBusy</name></decl>;</decl_stmt>

  <comment type="block">/*
  ** Pointers to the end of sqlite3GlobalConfig.pScratch and
  ** sqlite3GlobalConfig.pPage to a block of memory that records
  ** which pages are available.
  */</comment>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aScratchFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aPageFree</name></decl>;</decl_stmt>
}</block></decl></decl_stmt> <expr_stmt><expr><name>mem0</name> = <block>{ <expr>62560955</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>mem0</name> <name>GLOBAL</name>(struct Mem0Global, mem0)</cpp:define>

<comment type="block">/*
** Initialize the memory allocation subsystem.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MallocInit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<name>xMalloc</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3MemSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>mem0</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>mem0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>mem0</name>.<name>mutex</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pScratch</name> &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>szScratch</name>&gt;=100
      &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>nScratch</name>&gt;=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szScratch</name> = (<name>sqlite3GlobalConfig</name>.<name>szScratch</name> - 4) &amp; ~7</expr>;</expr_stmt>
    <expr_stmt><expr><name>mem0</name>.<name>aScratchFree</name> = (<name>u32</name>*)&amp;((<name>char</name>*)<name>sqlite3GlobalConfig</name>.<name>pScratch</name>)
                  [<name>sqlite3GlobalConfig</name>.<name>szScratch</name>*<name>sqlite3GlobalConfig</name>.<name>nScratch</name>]</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>sqlite3GlobalConfig</name>.<name>nScratch</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ <expr_stmt><expr><name>mem0</name>.<name><name>aScratchFree</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt> }</block></for>
    <expr_stmt><expr><name>mem0</name>.<name>nScratchFree</name> = <name>sqlite3GlobalConfig</name>.<name>nScratch</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pScratch</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szScratch</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pPage</name> &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>szPage</name>&gt;=512
      &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>nPage</name>&gt;=1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>overhead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sz</name> =<init> <expr><name>sqlite3GlobalConfig</name>.<name>szPage</name> &amp; ~7</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>sqlite3GlobalConfig</name>.<name>nPage</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>overhead</name> = (4*<name>n</name> + <name>sz</name> - 1)/<name>sz</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nPage</name> -= <name>overhead</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mem0</name>.<name>aPageFree</name> = (<name>u32</name>*)&amp;((<name>char</name>*)<name>sqlite3GlobalConfig</name>.<name>pPage</name>)
                  [<name>sqlite3GlobalConfig</name>.<name>szPage</name>*<name>sqlite3GlobalConfig</name>.<name>nPage</name>]</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>sqlite3GlobalConfig</name>.<name>nPage</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ <expr_stmt><expr><name>mem0</name>.<name><name>aPageFree</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt> }</block></for>
    <expr_stmt><expr><name>mem0</name>.<name>nPageFree</name> = <name>sqlite3GlobalConfig</name>.<name>nPage</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pPage</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szPage</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xInit</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<name>pAppData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Deinitialize the memory allocation subsystem.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MallocEnd</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xShutdown</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<name>pAppData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>mem0</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>mem0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the amount of memory currently checked out.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_memory_used</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>mx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_status</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>mx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = (<name>sqlite3_int64</name>)<name>n</name></expr>;</expr_stmt>  <comment type="block">/* Work around bug in Borland C. Ticket #3216 */</comment>
  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the maximum amount of memory that has ever been
** checked out since either the beginning of this process
** or since the most recent reset.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3_memory_highwater</name><parameter_list>(<param><decl><type><name>int</name></type> <name>resetFlag</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>mx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_status</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>mx</name></expr></argument>, <argument><expr><name>resetFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>res</name> = (<name>sqlite3_int64</name>)<name>mx</name></expr>;</expr_stmt>  <comment type="block">/* Work around bug in Borland C. Ticket #3216 */</comment>
  <return>return <expr><name>res</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the alarm callback
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MemoryAlarm</name><parameter_list>(
  <param><function_decl><type><name>void</name></type>(*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>, <param><decl><type><name>sqlite3_int64</name></type> <name>used</name></decl></param>,<param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>,
  <param><decl><type><name>sqlite3_int64</name></type> <name>iThreshold</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem0</name>.<name>alarmCallback</name> = <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem0</name>.<name>alarmArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem0</name>.<name>alarmThreshold</name> = <name>iThreshold</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Deprecated external interface.  Internal/core SQLite code
** should call sqlite3MemoryAlarm.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_memory_alarm</name><parameter_list>(
  <param><function_decl><type><name>void</name></type>(*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>, <param><decl><type><name>sqlite3_int64</name></type> <name>used</name></decl></param>,<param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>,
  <param><decl><type><name>sqlite3_int64</name></type> <name>iThreshold</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3MemoryAlarm</name><argument_list>(<argument><expr><name>xCallback</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>iThreshold</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Trigger the alarm 
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqlite3MallocAlarm</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <function_decl><type><name>void</name></type> (*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>sqlite3_int64</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nowUsed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>pArg</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>mem0</name>.<name>alarmCallback</name>==0 || <name>mem0</name>.<name>alarmBusy</name></expr>  )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>mem0</name>.<name>alarmBusy</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>xCallback</name> = <name>mem0</name>.<name>alarmCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nowUsed</name> = <call><name>sqlite3StatusValue</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pArg</name> = <name>mem0</name>.<name>alarmArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xCallback</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>nowUsed</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mem0</name>.<name>alarmBusy</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Do a memory allocation with statistics and alarms.  Assume the
** lock is already held.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>mallocWithAlarm</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nFull</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFull</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xRoundup</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StatusSet</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MALLOC_SIZE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>mem0</name>.<name>alarmCallback</name>!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nUsed</name> =<init> <expr><call><name>sqlite3StatusValue</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>nUsed</name>+<name>nFull</name> &gt;= <name>mem0</name>.<name>alarmThreshold</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3MallocAlarm</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>p</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xMalloc</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0 &amp;&amp; <name>mem0</name>.<name>alarmCallback</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3MallocAlarm</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xMalloc</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nFull</name> = <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr>*<name>pp</name> = <name>p</name></expr>;</expr_stmt>
  <return>return <expr><name>nFull</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate memory.  This routine is like sqlite3_malloc() except that it
** assumes the memory subsystem has already been initialized.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3Malloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>n</name>&lt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mallocWithAlarm</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xMalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This version of the memory allocation is for use by the application.
** First make sure the memory subsystem is initialized, then do the
** allocation.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_malloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Each thread may only have a single outstanding allocation from
** xScratchMalloc().  We verify this constraint in the single-threaded
** case by setting scratchAllocOut to 1 when an allocation
** is outstanding clearing it when the allocation is freed.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name>==0 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>scratchAllocOut</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Allocate memory that is to be used and released right away.
** This routine is similar to alloca() in that it is not intended
** for situations where the memory might be held long-term.  This
** routine is intended to get memory to old large transient data
** structures that would not normally fit on the stack of an
** embedded processor.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3ScratchMalloc</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name>==0 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Verify that no more than one scratch allocation per thread
  ** is outstanding at one time.  (This is only checked in the
  ** single-threaded case since checking in the multi-threaded case
  ** would be much more complicated.) */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>scratchAllocOut</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>szScratch</name>&lt;<name>n</name></expr> )</condition><then><block>{
    <goto>goto <name>scratch_overflow</name>;</goto>
  }</block></then><else>else<block>{  
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>mem0</name>.<name>nScratchFree</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>scratch_overflow</name>;</goto>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> = <name>mem0</name>.<name><name>aScratchFree</name><index>[<expr>--<name>mem0</name>.<name>nScratchFree</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> *= <name>sqlite3GlobalConfig</name>.<name>szScratch</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_USED</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusSet</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_SIZE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> = (<name>void</name>*)&amp;((<name>char</name>*)<name>sqlite3GlobalConfig</name>.<name>pScratch</name>)[<name>i</name>]</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(  <argument><expr>(((<name>u8</name>*)<name>p</name> - (<name>u8</name>*)0) &amp; 7)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name>==0 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>scratchAllocOut</name> = <name>p</name>!=0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>p</name></expr>;</return>

<label><name>scratch_overflow</name>:</label>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusSet</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_SIZE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <call><name>mallocWithAlarm</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_OVERFLOW</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xMalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name>==0 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>scratchAllocOut</name> = <name>p</name>!=0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>p</name></expr>;</return>    
}</block></function>
<function><type><name>void</name></type> <name>sqlite3ScratchFree</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name>==0 &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="block">/* Verify that no more than one scratch allocation per thread
    ** is outstanding at one time.  (This is only checked in the
    ** single-threaded case since checking in the multi-threaded case
    ** would be much more complicated.) */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>scratchAllocOut</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scratchAllocOut</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pScratch</name>==0
           || <name>p</name>&lt;<name>sqlite3GlobalConfig</name>.<name>pScratch</name>
           || <name>p</name>&gt;=(<name>void</name>*)<name>mem0</name>.<name>aScratchFree</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>iSize</name> =<init> <expr><call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_OVERFLOW</name></expr></argument>, <argument><expr>-<name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr>-<name>iSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> = (<name>int</name>)((<name>u8</name>*)<name>p</name> - (<name>u8</name>*)<name>sqlite3GlobalConfig</name>.<name>pScratch</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> /= <name>sqlite3GlobalConfig</name>.<name>szScratch</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>&gt;=0 &amp;&amp; <name>i</name>&lt;<name>sqlite3GlobalConfig</name>.<name>nScratch</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mem0</name>.<name>nScratchFree</name>&lt;(<name>u32</name>)<name>sqlite3GlobalConfig</name>.<name>nScratch</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mem0</name>.<name><name>aScratchFree</name><index>[<expr><name>mem0</name>.<name>nScratchFree</name>++</expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_SCRATCH_USED</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Allocate memory to be used by the page cache.  Make use of the
** memory buffer provided by SQLITE_CONFIG_PAGECACHE if there is one
** and that memory is of the right size and is not completely
** consumed.  Otherwise, failover to sqlite3Malloc().
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
void *sqlite3PageMalloc(int n){
  void *p;
  assert( n&gt;0 );
  assert( (n &amp; (n-1))==0 );
  assert( n&gt;=512 &amp;&amp; n&lt;=32768 );

  if( sqlite3GlobalConfig.szPage&lt;n ){
    goto page_overflow;
  }else{  
    sqlite3_mutex_enter(mem0.mutex);
    if( mem0.nPageFree==0 ){
      sqlite3_mutex_leave(mem0.mutex);
      goto page_overflow;
    }else{
      int i;
      i = mem0.aPageFree[--mem0.nPageFree];
      sqlite3_mutex_leave(mem0.mutex);
      i *= sqlite3GlobalConfig.szPage;
      sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, n);
      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, 1);
      p = (void*)&amp;((char*)sqlite3GlobalConfig.pPage)[i];
    }
  }
  return p;

page_overflow:
  if( sqlite3GlobalConfig.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, n);
    n = mallocWithAlarm(n, &amp;p);
    if( p ) sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, n);
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    p = sqlite3GlobalConfig.m.xMalloc(n);
  }
  return p;    
}
void sqlite3PageFree(void *p){
  if( p ){
    if( sqlite3GlobalConfig.pPage==0
           || p&lt;sqlite3GlobalConfig.pPage
           || p&gt;=(void*)mem0.aPageFree ){
      <comment type="block">/* In this case, the page allocation was obtained from a regular 
      ** call to sqlite3_mem_methods.xMalloc() (a page-cache-memory 
      ** "overflow"). Free the block with sqlite3_mem_methods.xFree().
      */</comment>
      if( sqlite3GlobalConfig.bMemstat ){
        int iSize = sqlite3MallocSize(p);
        sqlite3_mutex_enter(mem0.mutex);
        sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize);
        sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize);
        sqlite3GlobalConfig.m.xFree(p);
        sqlite3_mutex_leave(mem0.mutex);
      }else{
        sqlite3GlobalConfig.m.xFree(p);
      }
    }else{
      <comment type="block">/* The page allocation was allocated from the sqlite3GlobalConfig.pPage
      ** buffer. In this case all that is add the index of the page in
      ** the sqlite3GlobalConfig.pPage array to the set of free indexes stored
      ** in the mem0.aPageFree[] array.
      */</comment>
      int i;
      i = (u8 *)p - (u8 *)sqlite3GlobalConfig.pPage;
      i /= sqlite3GlobalConfig.szPage;
      assert( i&gt;=0 &amp;&amp; i&lt;sqlite3GlobalConfig.nPage );
      sqlite3_mutex_enter(mem0.mutex);
      assert( mem0.nPageFree&lt;sqlite3GlobalConfig.nPage );
      mem0.aPageFree[mem0.nPageFree++] = i;
      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, -1);
      sqlite3_mutex_leave(mem0.mutex);
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; 0</expr></cpp:if>
      <comment type="block">/* Assert that a duplicate was not just inserted into aPageFree[]. */</comment>
      for(i=0; i&lt;mem0.nPageFree-1; i++){
        assert( mem0.aPageFree[i]!=mem0.aPageFree[mem0.nPageFree-1] );
      }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }
  }
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** TRUE if p is a lookaside memory allocation from db
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOOKASIDE</name></cpp:ifndef>
<function><type><name>static</name> <name>int</name></type> <name>isLookaside</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name> &amp;&amp; <name>p</name> &amp;&amp; <name>p</name>&gt;=<name>db</name>-&gt;<name>lookaside</name>.<name>pStart</name> &amp;&amp; <name>p</name>&lt;<name>db</name>-&gt;<name>lookaside</name>.<name>pEnd</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>isLookaside</name>(A,B) 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the size of a memory allocation previously obtained from
** sqlite3Malloc() or sqlite3_malloc().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3MallocSize</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3DbMallocSize</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><call><name>isLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>db</name>-&gt;<name>lookaside</name>.<name>sz</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="block">/*
** Free memory previously obtained from sqlite3Malloc().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_free</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr>-<call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xFree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Free memory that might be associated with a particular database
** connection.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DbFree</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><call><name>isLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>LookasideSlot</name> *</type><name>pBuf</name> =<init> <expr>(<name>LookasideSlot</name>*)<name>p</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pBuf</name>-&gt;<name>pNext</name> = <name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name> = <name>pBuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name>--</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Change the size of an existing memory allocation
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3Realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pOld</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBytes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nOld</name>, <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pOld</name>==0</expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>nBytes</name>&lt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>nOld</name> = <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StatusSet</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MALLOC_SIZE</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nNew</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xRoundup</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nOld</name>==<name>nNew</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pNew</name> = <name>pOld</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr><call><name>sqlite3StatusValue</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>)</argument_list></call>+<name>nNew</name>-<name>nOld</name> &gt;= 
            <name>mem0</name>.<name>alarmThreshold</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3MallocAlarm</name><argument_list>(<argument><expr><name>nNew</name>-<name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pNew</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xRealloc</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pNew</name>==0 &amp;&amp; <name>mem0</name>.<name>alarmCallback</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3MallocAlarm</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xRealloc</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>nNew</name> = <call><name>sqlite3MallocSize</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3StatusAdd</name><argument_list>(<argument><expr><name>SQLITE_STATUS_MEMORY_USED</name></expr></argument>, <argument><expr><name>nNew</name>-<name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mem0</name>.<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pNew</name> = <name>sqlite3GlobalConfig</name>.<name>m</name>.<call><name>xRealloc</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The public interface to sqlite3Realloc.  Make sure that the memory
** subsystem is initialized prior to invoking sqliteRealloc.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_realloc</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pOld</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>sqlite3Realloc</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*
** Allocate and zero memory.
*/</comment> 
<function><type><name>void</name> *</type><name>sqlite3MallocZero</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name> =<init> <expr><call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate and zero memory.  If the allocation fails, make
** the mallocFailed flag in the connection pointer.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3DbMallocZero</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name> =<init> <expr><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Allocate and zero memory.  If the allocation fails, make
** the mallocFailed flag in the connection pointer.
**
** If db!=0 and db-&gt;mallocFailed is true (indicating a prior malloc
** failure on the same database connection) then always return 0.
** Hence for a particular database connection, once malloc starts
** failing, it fails consistently until mallocFailed is reset.
** This is an important assumption.  There are many places in the
** code that do things like this:
**
**         int *a = (int*)sqlite3DbMallocRaw(db, 100);
**         int *b = (int*)sqlite3DbMallocRaw(db, 200);
**         if( b ) a[10] = 9;
**
** In other words, if a subsequent malloc (ex: "b") worked, it is assumed
** that all prior mallocs (ex: "a") worked too.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3DbMallocRaw</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOOKASIDE</name></cpp:ifndef>
  <if>if<condition>( <expr><name>db</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>LookasideSlot</name> *</type><name>pBuf</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>lookaside</name>.<name>bEnabled</name> &amp;&amp; <name>n</name>&lt;=<name>db</name>-&gt;<name>lookaside</name>.<name>sz</name>
         &amp;&amp; (<name>pBuf</name> = <name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name> = <name>pBuf</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name>&gt;<name>db</name>-&gt;<name>lookaside</name>.<name>mxOut</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>mxOut</name> = <name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name></expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr>(<name>void</name>*)<name>pBuf</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if>if<condition>( <expr><name>db</name> &amp;&amp; <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>p</name> &amp;&amp; <name>db</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Resize the block of memory pointed to by p to n bytes. If the
** resize fails, set the mallocFailed flag in the connection object.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3DbRealloc</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pNew</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
      <return>return <expr><call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>isLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>n</name>&lt;=<name>db</name>-&gt;<name>lookaside</name>.<name>sz</name></expr> )</condition><then><block>{
        <return>return <expr><name>p</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name>lookaside</name>.<name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Attempt to reallocate p.  If the reallocation fails, then free p
** and set the mallocFailed flag in the database connection.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3DbReallocOrFree</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pNew</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Make a copy of a string in memory obtained from sqliteMalloc(). These 
** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). This
** is because when memory debugging is turned on, these two functions are 
** called via macros that record the current file and line number in the
** ThreadData structure.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3DbStrDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>n</name> = (<name>db</name> ? <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call> : <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)+1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>n</name>&amp;0x7fffffff)==<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zNew</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>zNew</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>sqlite3DbStrNDup</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zNew</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>n</name>&amp;0x7fffffff)==<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zNew</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zNew</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>zNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a string from the zFromat argument and the va_list that follows.
** Store the string in memory obtained from sqliteMalloc() and make *pz
** point to that string.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SetString</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>pz</name></decl></param>, <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>*<name>pz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pz</name> = <name>z</name></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** This function must be called before exiting any API function (i.e. 
** returning control to the user) that has called sqlite3_malloc or
** sqlite3_realloc.
**
** The returned value is normally a copy of the second argument to this
** function. However, if a malloc() failure has occured since the previous
** invocation SQLITE_NOMEM is returned instead. 
**
** If the first argument, db, is not NULL and a malloc() error has occured,
** then the connection error-code (the value returned by sqlite3_errcode())
** is set to SQLITE_NOMEM.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ApiExit</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type> <name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* If the db handle is not NULL, then we must hold the connection handle
  ** mutex here. Otherwise the read (and possible write) of db-&gt;mallocFailed 
  ** is unsafe, as is the call to sqlite3Error().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name> || <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name> &amp;&amp; (<name>db</name>-&gt;<name>mallocFailed</name> || <name>rc</name>==<name>SQLITE_IOERR_NOMEM</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name> &amp; (<name>db</name> ? <name>db</name>-&gt;<name>errMask</name> : 0xff)</expr>;</return>
}</block></function>
</unit>
