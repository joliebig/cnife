<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="complete.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** An tokenizer for SQL
**
** This file contains C code that implements the sqlite3_complete() API.
** This code used to be part of the tokenizer.c source file.  But by
** separating it out, the code will be automatically omitted from
** static links that do not use it.
**
** $Id: complete.c,v 1.7 2008/06/13 18:24:27 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPLETE</name></cpp:ifndef>

<comment type="block">/*
** This is defined in tokenize.c.  We just have to import the definition.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ASCII</name></cpp:ifdef>
<decl_stmt><decl><type><name>extern</name> <name>const</name> <name>char</name></type> <name><name>sqlite3IsAsciiIdChar</name><index>[]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IdChar</name>(C)  (((c=C)&amp;0x80)!=0 || (c&gt;0x1f &amp;&amp; sqlite3IsAsciiIdChar[c-0x20]))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
<decl_stmt><decl><type><name>extern</name> <name>const</name> <name>char</name></type> <name><name>sqlite3IsEbcdicIdChar</name><index>[]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IdChar</name>(C)  (((c=C)&gt;=0x42 &amp;&amp; sqlite3IsEbcdicIdChar[c-0x40]))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_AMALGAMATION */</comment>


<comment type="block">/*
** Token types used by the sqlite3_complete() routine.  See the header
** comments on that procedure for additional information.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkSEMI</name>    0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkWS</name>      1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkOTHER</name>   2</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkEXPLAIN</name> 3</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkCREATE</name>  4</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkTEMP</name>    5</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkTRIGGER</name> 6</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>tkEND</name>     7</cpp:define>

<comment type="block">/*
** Return TRUE if the given SQL string ends in a semicolon.
**
** Special handling is require for CREATE TRIGGER statements.
** Whenever the CREATE TRIGGER keywords are seen, the statement
** must end with ";END;".
**
** This implementation uses a state machine with 7 states:
**
**   (0) START     At the beginning or end of an SQL statement.  This routine
**                 returns 1 if it ends in the START state and 0 if it ends
**                 in any other state.
**
**   (1) NORMAL    We are in the middle of statement which ends with a single
**                 semicolon.
**
**   (2) EXPLAIN   The keyword EXPLAIN has been seen at the beginning of 
**                 a statement.
**
**   (3) CREATE    The keyword CREATE has been seen at the beginning of a
**                 statement, possibly preceeded by EXPLAIN and/or followed by
**                 TEMP or TEMPORARY
**
**   (4) TRIGGER   We are in the middle of a trigger definition that must be
**                 ended by a semicolon, the keyword END, and another semicolon.
**
**   (5) SEMI      We've seen the first semicolon in the ";END;" that occurs at
**                 the end of a trigger definition.
**
**   (6) END       We've seen the ";END" of the ";END;" that occurs at the end
**                 of a trigger difinition.
**
** Transitions between states above are determined by tokens extracted
** from the input.  The following tokens are significant:
**
**   (0) tkSEMI      A semicolon.
**   (1) tkWS        Whitespace
**   (2) tkOTHER     Any other SQL token.
**   (3) tkEXPLAIN   The "explain" keyword.
**   (4) tkCREATE    The "create" keyword.
**   (5) tkTEMP      The "temp" or "temporary" keyword.
**   (6) tkTRIGGER   The "trigger" keyword.
**   (7) tkEND       The "end" keyword.
**
** Whitespace never causes a state transition and is always ignored.
**
** If we compile with SQLITE_OMIT_TRIGGER, all of the computation needed
** to recognize the end of a trigger can be omitted.  All we have to do
** is look for a semicolon that is not part of an string or comment.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_complete</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>state</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Current state, using numbers defined in header comment */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>token</name></decl>;</decl_stmt>       <comment type="block">/* Value of the next token */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* A complex statement machine used to detect the end of a CREATE TRIGGER
  ** statement.  This is the normal case.
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>trans</name><index>[<expr>7</expr>]</index><index>[<expr>8</expr>]</index></name> =<init> <expr><block>{
                     <comment type="block">/* Token:                                                */</comment>
     <comment type="block">/* State:       **  SEMI  WS  OTHER EXPLAIN  CREATE  TEMP  TRIGGER  END  */</comment>
     <comment type="block">/* 0   START: */</comment> <expr><block>{    <expr>0</expr>,  <expr>0</expr>,     <expr>1</expr>,      <expr>2</expr>,      <expr>3</expr>,    <expr>1</expr>,       <expr>1</expr>,   <expr>1</expr>,  }</block></expr>,
     <comment type="block">/* 1  NORMAL: */</comment> <expr><block>{    <expr>0</expr>,  <expr>1</expr>,     <expr>1</expr>,      <expr>1</expr>,      <expr>1</expr>,    <expr>1</expr>,       <expr>1</expr>,   <expr>1</expr>,  }</block></expr>,
     <comment type="block">/* 2 EXPLAIN: */</comment> <expr><block>{    <expr>0</expr>,  <expr>2</expr>,     <expr>1</expr>,      <expr>1</expr>,      <expr>3</expr>,    <expr>1</expr>,       <expr>1</expr>,   <expr>1</expr>,  }</block></expr>,
     <comment type="block">/* 3  CREATE: */</comment> <expr><block>{    <expr>0</expr>,  <expr>3</expr>,     <expr>1</expr>,      <expr>1</expr>,      <expr>1</expr>,    <expr>3</expr>,       <expr>4</expr>,   <expr>1</expr>,  }</block></expr>,
     <comment type="block">/* 4 TRIGGER: */</comment> <expr><block>{    <expr>5</expr>,  <expr>4</expr>,     <expr>4</expr>,      <expr>4</expr>,      <expr>4</expr>,    <expr>4</expr>,       <expr>4</expr>,   <expr>4</expr>,  }</block></expr>,
     <comment type="block">/* 5    SEMI: */</comment> <expr><block>{    <expr>5</expr>,  <expr>5</expr>,     <expr>4</expr>,      <expr>4</expr>,      <expr>4</expr>,    <expr>4</expr>,       <expr>4</expr>,   <expr>6</expr>,  }</block></expr>,
     <comment type="block">/* 6     END: */</comment> <expr><block>{    <expr>0</expr>,  <expr>6</expr>,     <expr>4</expr>,      <expr>4</expr>,      <expr>4</expr>,    <expr>4</expr>,       <expr>4</expr>,   <expr>4</expr>,  }</block></expr>,
  }</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* If triggers are not suppored by this compile then the statement machine
  ** used to detect the end of a statement is much simplier
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>trans</name><index>[<expr>2</expr>]</index><index>[<expr>3</expr>]</index></name> =<init> <expr><block>{
                     <comment type="block">/* Token:           */</comment>
     <comment type="block">/* State:       **  SEMI  WS  OTHER */</comment>
     <comment type="block">/* 0   START: */</comment> <expr><block>{    <expr>0</expr>,  <expr>0</expr>,     <expr>1</expr>, }</block></expr>,
     <comment type="block">/* 1  NORMAL: */</comment> <expr><block>{    <expr>0</expr>,  <expr>1</expr>,     <expr>1</expr>, }</block></expr>,
  }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRIGGER */</comment>

  <while>while<condition>( <expr>*<name>zSql</name></expr> )</condition><block>{
    <switch>switch<condition>( <expr>*<name>zSql</name></expr> )</condition><block>{
      <case>case <expr>';'</expr>: <block>{  <comment type="block">/* A semicolon */</comment>
        <expr_stmt><expr><name>token</name> = <name>tkSEMI</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr>' '</expr>:
      </case><case>case <expr>'\r'</expr>:
      </case><case>case <expr>'\t'</expr>:
      </case><case>case <expr>'\n'</expr>:
      </case><case>case <expr>'\f'</expr>: <block>{  <comment type="block">/* White space is ignored */</comment>
        <expr_stmt><expr><name>token</name> = <name>tkWS</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr>'/'</expr>: <block>{   <comment type="block">/* C-style comments */</comment>
        <if>if<condition>( <expr><name><name>zSql</name><index>[<expr>1</expr>]</index></name>!='*'</expr> )</condition><then><block>{
          <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>zSql</name> += 2</expr>;</expr_stmt>
        <while>while<condition>( <expr><name><name>zSql</name><index>[<expr>0</expr>]</index></name> &amp;&amp; (<name><name>zSql</name><index>[<expr>0</expr>]</index></name>!='*' || <name><name>zSql</name><index>[<expr>1</expr>]</index></name>!='/')</expr> )</condition><block>{ <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr><name><name>zSql</name><index>[<expr>0</expr>]</index></name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>token</name> = <name>tkWS</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr>'-'</expr>: <block>{   <comment type="block">/* SQL-style comments from "--" to end of line */</comment>
        <if>if<condition>( <expr><name><name>zSql</name><index>[<expr>1</expr>]</index></name>!='-'</expr> )</condition><then><block>{
          <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <while>while<condition>( <expr>*<name>zSql</name> &amp;&amp; *<name>zSql</name>!='\n'</expr> )</condition><block>{ <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr>*<name>zSql</name>==0</expr> )</condition><then> <return>return <expr><name>state</name>==0</expr>;</return></then></if>
        <expr_stmt><expr><name>token</name> = <name>tkWS</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr>'['</expr>: <block>{   <comment type="block">/* Microsoft-style identifiers in [...] */</comment>
        <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt>
        <while>while<condition>( <expr>*<name>zSql</name> &amp;&amp; *<name>zSql</name>!=']'</expr> )</condition><block>{ <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr>*<name>zSql</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr>'`'</expr>:     <comment type="block">/* Grave-accent quoted symbols used by MySQL */</comment>
      </case><case>case <expr>'"'</expr>:     <comment type="block">/* single- and double-quoted strings */</comment>
      </case><case>case <expr>'\''</expr>: <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> =<init> <expr>*<name>zSql</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt>
        <while>while<condition>( <expr>*<name>zSql</name> &amp;&amp; *<name>zSql</name>!=<name>c</name></expr> )</condition><block>{ <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr>*<name>zSql</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
        <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><default>default: <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
        <if>if<condition>( <expr><call><name>IdChar</name><argument_list>(<argument><expr>(<name>u8</name>)*<name>zSql</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <comment type="block">/* Keywords and unquoted identifiers */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nId</name></decl>;</decl_stmt>
          <for>for(<init><expr><name>nId</name>=1</expr>;</init> <condition><expr><call><name>IdChar</name><argument_list>(<argument><expr><name><name>zSql</name><index>[<expr><name>nId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>nId</name>++</expr></incr>)<block>{}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifdef>
          <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <switch>switch<condition>( <expr>*<name>zSql</name></expr> )</condition><block>{
            <case>case <expr>'c'</expr>: </case><case>case <expr>'C'</expr>: <block>{
              <if>if<condition>( <expr><name>nId</name>==6 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"create"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkCREATE</name></expr>;</expr_stmt>
              }</block></then><else>else<block>{
                <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
              }</block></else></if>
              <break>break;</break>
            }</block>
            </case><case>case <expr>'t'</expr>: </case><case>case <expr>'T'</expr>: <block>{
              <if>if<condition>( <expr><name>nId</name>==7 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"trigger"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkTRIGGER</name></expr>;</expr_stmt>
              }</block></then><else>else <if>if<condition>( <expr><name>nId</name>==4 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"temp"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkTEMP</name></expr>;</expr_stmt>
              }</block></then><else>else <if>if<condition>( <expr><name>nId</name>==9 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"temporary"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkTEMP</name></expr>;</expr_stmt>
              }</block></then><else>else<block>{
                <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
              }</block></else></if></else></if></else></if>
              <break>break;</break>
            }</block>
            </case><case>case <expr>'e'</expr>:  </case><case>case <expr>'E'</expr>: <block>{
              <if>if<condition>( <expr><name>nId</name>==3 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"end"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkEND</name></expr>;</expr_stmt>
              }</block></then><else>else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
              <if>if<condition>( <expr><name>nId</name>==7 &amp;&amp; <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"explain"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
                <expr_stmt><expr><name>token</name> = <name>tkEXPLAIN</name></expr>;</expr_stmt>
              }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <block>{
                <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
              }</block></else></if></else></if>
              <break>break;</break>
            }</block>
            </case><default>default: <block>{
              <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
          </default>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRIGGER */</comment>
          <expr_stmt><expr><name>zSql</name> += <name>nId</name>-1</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <comment type="block">/* Operators and special symbols */</comment>
          <expr_stmt><expr><name>token</name> = <name>tkOTHER</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      }</block>
    </default>}</block></switch>
    <expr_stmt><expr><name>state</name> = <name><name>trans</name><index>[<expr><name>state</name></expr>]</index><index>[<expr><name>token</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name>++</expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>state</name>==0</expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** This routine is the same as the sqlite3_complete() routine described
** above, except that the parameter is required to be UTF-16 encoded, not
** UTF-8.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_complete16</name><parameter_list>(<param><decl><type><name>const</name> <name>void</name> *</type><name>zSql</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zSql8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pVal</name> = <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql8</name> = <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zSql8</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zSql8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ApiExit</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPLETE */</comment>
</unit>
