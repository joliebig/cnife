<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="shell.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "sqlite" command line
** utility for accessing SQLite databases.
**
** $Id: shell.c,v 1.198 2009/01/14 23:38:03 drh Exp $
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* This needs to come before any includes for MSVC compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>_CRT_SECURE_NO_WARNINGS</name></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:if># <cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__OS2__</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_READLINE</name>==1</expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/history.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>readline</name>(p) local_getline(p,stdin)</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>add_history</name>(X)</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>read_history</name>(X)</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>write_history</name>(X)</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>stifle_history</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>isatty</name>(h) _isatty(h)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>access</name>(f,m) _access((f),(m))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Make sure isatty() has a prototype.
*/</comment>
<function_decl><type><name>extern</name> <name>int</name></type> <name>isatty</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
 * thus we always assume that we have a console. That can be
 * overridden with the -batch command line option.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>isatty</name>(x) 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Saved resource information for the beginning of an operation */</comment>
<decl_stmt><decl><type><name>static</name> struct <name>rusage</name></type> <name>sBegin</name></decl>;</decl_stmt>

<comment type="block">/* True if the timer is enabled */</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>enableTimer</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Begin timing an operation
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>beginTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>enableTimer</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr>&amp;<name>sBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/* Return the difference of two time_structs in seconds */</comment>
<function><type><name>static</name> <name>double</name></type> <name>timeDiff</name><parameter_list>(<param><decl><type>struct <name>timeval</name> *</type><name>pStart</name></decl></param>, <param><decl><type>struct <name>timeval</name> *</type><name>pEnd</name></decl></param>)</parameter_list><block>{
  <return>return <expr>(<name>pEnd</name>-&gt;<name>tv_usec</name> - <name>pStart</name>-&gt;<name>tv_usec</name>)*0.000001 + 
         (<name>double</name>)(<name>pEnd</name>-&gt;<name>tv_sec</name> - <name>pStart</name>-&gt;<name>tv_sec</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Print the timing results.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>endTimer</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>enableTimer</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>rusage</name></type> <name>sEnd</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr>&amp;<name>sEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"CPU Time: user %f sys %f\n"</expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr>&amp;<name>sBegin</name>.<name>ru_utime</name></expr></argument>, <argument><expr>&amp;<name>sEnd</name>.<name>ru_utime</name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>timeDiff</name><argument_list>(<argument><expr>&amp;<name>sBegin</name>.<name>ru_stime</name></expr></argument>, <argument><expr>&amp;<name>sEnd</name>.<name>ru_stime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>BEGIN_TIMER</name> <name>beginTimer</name>()</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>END_TIMER</name> <name>endTimer</name>()</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>HAS_TIMER</name> 1</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>BEGIN_TIMER</name></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <name>END_TIMER</name></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>HAS_TIMER</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Used to prevent warnings about unused parameters
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>UNUSED_PARAMETER</name>(x) (void)(x)</cpp:define>

<comment type="block">/*
** If the following flag is set, then command execution stops
** at an error if we are not interactive.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>bail_on_error</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Threat stdin as an interactive input if the following variable
** is true.  Otherwise, assume stdin is connected to a file or pipe.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>stdin_is_interactive</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The following is the open SQLite database.  We make a pointer
** to this database a static variable so that it can be accessed
** by the SIGINT handler to interrupt database processing.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>sqlite3</name> *</type><name>db</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** True if an interrupt (Control-C) has been received.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>volatile</name> <name>int</name></type> <name>seenInterrupt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** This is the name of our program. It is set in main(), used
** in a number of other places, mostly for error messages.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>char</name> *</type><name>Argv0</name></decl>;</decl_stmt>

<comment type="block">/*
** Prompt strings. Initialized in main. Settable with
**   .prompt main continue
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>mainPrompt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* First line prompt. default: "sqlite&gt; "*/</comment>
<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>continuePrompt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Continuation prompt. default: "   ...&gt; " */</comment>

<comment type="block">/*
** Write I/O traces to the following stream.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
<decl_stmt><decl><type><name>static</name> <name>FILE</name> *</type><name>iotrace</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine works like printf in that its first argument is a
** format string and subsequent arguments are values to be substituted
** in place of % fields.  The result of formatting this string
** is written to iotrace.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
<function><type><name>static</name> <name>void</name></type> <name>iotracePrintf</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>iotrace</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>iotrace</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Determines if a string is a number of not.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>isNumber</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name> *</type><name>realnum</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>*<name>z</name>=='-' || *<name>z</name>=='+'</expr> )</condition><then> <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr>!<call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>realnum</name></expr> )</condition><then> <expr_stmt><expr>*<name>realnum</name> = 0</expr>;</expr_stmt></then></if>
  <while>while<condition>( <expr><call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></while>
  <if>if<condition>( <expr>*<name>z</name>=='.'</expr> )</condition><then><block>{
    <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <while>while<condition>( <expr><call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></while>
    <if>if<condition>( <expr><name>realnum</name></expr> )</condition><then> <expr_stmt><expr>*<name>realnum</name> = 1</expr>;</expr_stmt></then></if>
  }</block></then></if>
  <if>if<condition>( <expr>*<name>z</name>=='e' || *<name>z</name>=='E'</expr> )</condition><then><block>{
    <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr>*<name>z</name>=='+' || *<name>z</name>=='-'</expr> )</condition><then> <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr>!<call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <while>while<condition>( <expr><call><name>isdigit</name><argument_list>(<argument><expr>*<name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></while>
    <if>if<condition>( <expr><name>realnum</name></expr> )</condition><then> <expr_stmt><expr>*<name>realnum</name> = 1</expr>;</expr_stmt></then></if>
  }</block></then></if>
  <return>return <expr>*<name>z</name>==0</expr>;</return>
}</block></function>

<comment type="block">/*
** A global char* and an SQL function to access its current value 
** from within an SQL statement. This program used to use the 
** sqlite_exec_printf() API to substitue a string into an SQL statement.
** The correct way to do this with sqlite3 is to use the bind API, but
** since the shell is built around the callback paradigm it would be a lot
** of work. Instead just use this hack, which is quite harmless.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name>zShellStatic</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<function><type><name>static</name> <name>void</name></type> <name>shellstaticFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==<name>argc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zShellStatic</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zShellStatic</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** The interface is like "readline" but no command-line editing
** is done.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>local_getline</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zPrompt</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eol</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>zPrompt</name> &amp;&amp; *<name>zPrompt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s"</expr></argument>,<argument><expr><name>zPrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>nLine</name> = 100</expr>;</expr_stmt>
  <expr_stmt><expr><name>zLine</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nLine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zLine</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>eol</name> = 0</expr>;</expr_stmt>
  <while>while<condition>( <expr>!<name>eol</name></expr> )</condition><block>{
    <if>if<condition>( <expr><name>n</name>+100&gt;<name>nLine</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nLine</name> = <name>nLine</name>*2 + 100</expr>;</expr_stmt>
      <expr_stmt><expr><name>zLine</name> = <call><name>realloc</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zLine</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr>&amp;<name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>nLine</name> - <name>n</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>n</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>eol</name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr> )</condition><block>{ <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt> }</block></while>
    <if>if<condition>( <expr><name>n</name>&gt;0 &amp;&amp; <name><name>zLine</name><index>[<expr><name>n</name>-1</expr>]</index></name>=='\n'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>eol</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>
  <expr_stmt><expr><name>zLine</name> = <call><name>realloc</name><argument_list>( <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zLine</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Retrieve a single line of input text.
**
** zPrior is a string of prior text retrieved.  If not the empty
** string, then issue a continuation prompt.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>one_input_line</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zPrior</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zPrompt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zResult</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>in</name>!=0</expr> )</condition><then><block>{
    <return>return <expr><call><name>local_getline</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>zPrior</name> &amp;&amp; <name><name>zPrior</name><index>[<expr>0</expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zPrompt</name> = <name>continuePrompt</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zPrompt</name> = <name>mainPrompt</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>zResult</name> = <call><name>readline</name><argument_list>(<argument><expr><name>zPrompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_READLINE</name>==1</expr></cpp:if>
  <if>if<condition>( <expr><name>zResult</name> &amp;&amp; *<name>zResult</name></expr> )</condition><then> <expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>zResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>zResult</name></expr>;</return>
}</block></function>

<struct>struct <name>previous_mode_data</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>valid</name></decl>;</decl_stmt>        <comment type="block">/* Is there legit data in here? */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>showHeader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>colWidth</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
** An pointer to an instance of this structure is passed from
** the main program to the callback.  This is used to communicate
** state and mode information.
*/</comment>
<struct>struct <name>callback_data</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>            <comment type="block">/* The database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>echoOn</name></decl>;</decl_stmt>            <comment type="block">/* True to echo input commands */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>               <comment type="block">/* Number of records displayed so far */</comment>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>out</name></decl>;</decl_stmt>             <comment type="block">/* Write results here */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>              <comment type="block">/* An output mode setting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>writableSchema</name></decl>;</decl_stmt>    <comment type="block">/* True if PRAGMA writable_schema=ON */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>showHeader</name></decl>;</decl_stmt>        <comment type="block">/* True to show column names in List or Column mode */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zDestTable</name></decl>;</decl_stmt>      <comment type="block">/* Name of destination table when MODE_Insert */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>separator</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Separator character for MODE_List */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>colWidth</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* Requested width of each column when in column mode*/</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>actualWidth</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Actual width of each column */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>nullvalue</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* The text to print when a NULL comes back from
                         ** the database */</comment>
  <decl_stmt><decl><type>struct <name>previous_mode_data</name></type> <name>explainPrev</name></decl>;</decl_stmt>
                         <comment type="block">/* Holds the mode information just before
                         ** .explain ON */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>outfile</name><index>[<expr><name>FILENAME_MAX</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Filename for *out */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDbFilename</name></decl>;</decl_stmt>    <comment type="block">/* name of the database file */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** These are the allowed modes.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Line</name>     0</cpp:define>  <comment type="block">/* One column per line.  Blank line between records */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Column</name>   1</cpp:define>  <comment type="block">/* One record per line in neat columns */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_List</name>     2</cpp:define>  <comment type="block">/* One record per line with a separator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Semi</name>     3</cpp:define>  <comment type="block">/* Same as MODE_List but append ";" to each line */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Html</name>     4</cpp:define>  <comment type="block">/* Generate an XHTML table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Insert</name>   5</cpp:define>  <comment type="block">/* Generate SQL "insert" statements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Tcl</name>      6</cpp:define>  <comment type="block">/* Generate ANSI-C or TCL quoted elements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Csv</name>      7</cpp:define>  <comment type="block">/* Quote strings, numbers are plain */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MODE_Explain</name>  8</cpp:define>  <comment type="block">/* Like MODE_Column, but do not truncate data */</comment>

<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>modeDescr</name><index>[]</index></name> =<init> <expr><block>{
  <expr>"line"</expr>,
  <expr>"column"</expr>,
  <expr>"list"</expr>,
  <expr>"semi"</expr>,
  <expr>"html"</expr>,
  <expr>"insert"</expr>,
  <expr>"tcl"</expr>,
  <expr>"csv"</expr>,
  <expr>"explain"</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Number of elements in an array
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ArraySize</name>(X)  (int)(sizeof(X)/sizeof(X[0]))</cpp:define>

<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>strlen30</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name> =<init> <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr>*<name>z2</name></expr> )</condition><block>{ <expr_stmt><expr><name>z2</name>++</expr>;</expr_stmt> }</block></while>
  <return>return <expr>0x3fffffff &amp; (<name>int</name>)(<name>z2</name> - <name>z</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Output the given string as a quoted string using SQL quoting conventions.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>output_quoted_string</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSingle</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then> <expr_stmt><expr><name>nSingle</name>++</expr>;</expr_stmt></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>nSingle</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"'%s'"</expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr>*<name>z</name></expr> )</condition><block>{
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>!='\''</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{}</block></for>
      <if>if<condition>( <expr><name>i</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"''"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"%.*s''"</expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>z</name> += <name>i</name>+1</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"%s"</expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></else></if></else></if>
    }</block></while>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Output the given string as a quoted according to C or TCL quoting rules.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>output_c_string</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'"'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr>(<name>c</name> = *(<name>z</name>++))!=0</expr> )</condition><block>{
    <if>if<condition>( <expr><name>c</name>=='\\'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='\t'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'t'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='\n'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'n'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='\r'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'\\'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'r'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>!<call><name>isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"\\%03o"</expr></argument>, <argument><expr><name>c</name>&amp;0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if>
  }</block></while>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr>'"'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Output the given string with characters that are special to
** HTML escaped.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>output_html_string</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <while>while<condition>( <expr>*<name>z</name></expr> )</condition><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>!='&lt;' &amp;&amp; <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>!='&amp;'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{}</block></for>
    <if>if<condition>( <expr><name>i</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"%.*s"</expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='&lt;'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"&amp;lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='&amp;'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"&amp;amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <break>break;</break>
    }</block></else></if></else></if>
    <expr_stmt><expr><name>z</name> += <name>i</name> + 1</expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="block">/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>needCsvQuote</name><index>[]</index></name> =<init> <expr><block>{
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, 
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, 
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, 
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, 
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, 
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, 
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Output a single term of CSV.  Actually, p-&gt;separator is used for
** the separator, which may or may not be a comma.  p-&gt;nullvalue is
** the null value.  Strings are quoted using ANSI-C rules.  Numbers
** appear outside of quotes.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>output_csv</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>bSep</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>FILE</name> *</type><name>out</name> =<init> <expr><name>p</name>-&gt;<name>out</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>,<argument><expr>"%s"</expr></argument>,<argument><expr><name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nSep</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>needCsvQuote</name><index>[<expr>((<name>unsigned</name> <name>char</name>*)<name>z</name>)</expr></index></name>[<name>i</name>]] 
         || (<name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>==<name>p</name>-&gt;<name><name>separator</name><index>[<expr>0</expr>]</index></name> &amp;&amp; 
             (<name>nSep</name>==1 || <call><name>memcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>, <argument><expr><name>nSep</name></expr></argument>)</argument_list></call>==0))</expr> )</condition><then><block>{
        <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>i</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'"'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='"'</expr> )</condition><then> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'"'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr>'"'</expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <if>if<condition>( <expr><name>bSep</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
<comment type="block">/*
** This routine runs when the user presses Ctrl-C
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>interrupt_handler</name><parameter_list>(<param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>seenInterrupt</name> = 1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This is the callback routine that the SQLite library
** invokes for each row of a query result.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>, <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>, <param><decl><type><name>char</name> **</type><name>azArg</name></decl></param>, <param><decl><type><name>char</name> **</type><name>azCol</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>callback_data</name> *</type><name>p</name> =<init> <expr>(struct <name>callback_data</name>*)<name>pArg</name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>p</name>-&gt;<name>mode</name></expr> )</condition><block>{
    <case>case <expr><name>MODE_Line</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>w</name> =<init> <expr>5</expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> : ""</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>len</name>&gt;<name>w</name></expr> )</condition><then> <expr_stmt><expr><name>w</name> = <name>len</name></expr>;</expr_stmt></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++&gt;0</expr> )</condition><then> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%*s = %s\n"</expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> : <name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Explain</name></expr>:
    </case><case>case <expr><name>MODE_Column</name></expr>: <block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++==0</expr> )</condition><then><block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>int</name></type> <name>w</name>, <name>n</name></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>i</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><name>w</name> = <name>p</name>-&gt;<name><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>w</name> = 0</expr>;</expr_stmt>
          }</block></else></if>
          <if>if<condition>( <expr><name>w</name>&lt;=0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>w</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>w</name>&lt;10</expr> )</condition><then> <expr_stmt><expr><name>w</name> = 10</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>n</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>azArg</name> &amp;&amp; <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> : <name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>w</name>&lt;<name>n</name></expr> )</condition><then> <expr_stmt><expr><name>w</name> = <name>n</name></expr>;</expr_stmt></then></if>
          }</block></then></if>
          <if>if<condition>( <expr><name>i</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>actualWidth</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><name>p</name>-&gt;<name><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name> = <name>w</name></expr>;</expr_stmt>
          }</block></then></if>
          <if>if<condition>( <expr><name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%-*.*s%s"</expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name>==<name>nArg</name>-1 ? "\n": "  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
          <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
            <decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>
            <if>if<condition>( <expr><name>i</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>actualWidth</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
               <expr_stmt><expr><name>w</name> = <name>p</name>-&gt;<name><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then><else>else<block>{
               <expr_stmt><expr><name>w</name> = 10</expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%-*.*s%s"</expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr>"-----------------------------------"
                   "----------------------------------------------------------"</expr></argument>,
                    <argument><expr><name>i</name>==<name>nArg</name>-1 ? "\n": "  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        }</block></then></if>
      }</block></then></if>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>i</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>actualWidth</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
           <expr_stmt><expr><name>w</name> = <name>p</name>-&gt;<name><name>actualWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
           <expr_stmt><expr><name>w</name> = 10</expr>;</expr_stmt>
        }</block></else></if>
        <if>if<condition>( <expr><name>p</name>-&gt;<name>mode</name>==<name>MODE_Explain</name> &amp;&amp; <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; 
           <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>&gt;<name>w</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>w</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%-*.*s%s"</expr></argument>,<argument><expr><name>w</name></expr></argument>,<argument><expr><name>w</name></expr></argument>,
            <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> : <name>p</name>-&gt;<name>nullvalue</name></expr></argument>, <argument><expr><name>i</name>==<name>nArg</name>-1 ? "\n": "  "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Semi</name></expr>:
    </case><case>case <expr><name>MODE_List</name></expr>: <block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++==0 &amp;&amp; <name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%s%s"</expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name>==<name>nArg</name>-1 ? "\n" : <name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      }</block></then></if>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <expr_stmt><expr><name>z</name> = <name>p</name>-&gt;<name>nullvalue</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>i</name>&lt;<name>nArg</name>-1</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>mode</name>==<name>MODE_Semi</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>";\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
      }</block></for>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Html</name></expr>: <block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++==0 &amp;&amp; <name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;TR&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;TH&gt;%s&lt;/TH&gt;"</expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;/TR&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;TR&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;TD&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>output_html_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> : <name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;/TD&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"&lt;/TR&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Tcl</name></expr>: <block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++==0 &amp;&amp; <name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> : <name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Csv</name></expr>: <block>{
      <if>if<condition>( <expr><name>p</name>-&gt;<name>cnt</name>++==0 &amp;&amp; <name>p</name>-&gt;<name>showHeader</name></expr> )</condition><then><block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>output_csv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> ? <name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> : ""</expr></argument>, <argument><expr><name>i</name>&lt;<name>nArg</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>output_csv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name>&lt;<name>nArg</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>MODE_Insert</name></expr>: <block>{
      <if>if<condition>( <expr><name>azArg</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"INSERT INTO %s VALUES("</expr></argument>,<argument><expr><name>p</name>-&gt;<name>zDestTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zSep</name> =<init> <expr><name>i</name>&gt;0 ? ",": ""</expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%sNULL"</expr></argument>,<argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><call><name>isNumber</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%s%s"</expr></argument>,<argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <if>if<condition>( <expr><name><name>zSep</name><index>[<expr>0</expr>]</index></name></expr> )</condition><then> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%s"</expr></argument>,<argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>output_quoted_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
      }</block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>");\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </case>}</block></switch>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Set the destination table field of the callback_data structure to
** the name of the table given.  Escape any quote characters in the
** table name.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>set_table_name</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needQuote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>p</name>-&gt;<name>zDestTable</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zDestTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zDestTable</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>zName</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>needQuote</name> = !<call><name>isalpha</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)*<name>zName</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>zName</name>!='_'</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>n</name>=0</expr>;</init> <condition><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>n</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>!<call><name>isalnum</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name>!='_'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>needQuote</name> = 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then> <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>
    }</block></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name>n</name> += 2</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>z</name> = <name>p</name>-&gt;<name>zDestTable</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>n</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Out of memory!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name>++</expr>]</index></name> = '\''</expr>;</expr_stmt></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name>++</expr>]</index></name> = '\''</expr>;</expr_stmt></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name>++</expr>]</index></name> = '\''</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* zIn is either a pointer to a NULL-terminated string in memory obtained
** from malloc(), or a NULL pointer. The string pointed to by zAppend is
** added to zIn, and the result returned in memory obtained from malloc().
** zIn, if it was not NULL, is freed.
**
** If the third argument, quote, is not '\0', then it is used as a 
** quote character for zAppend.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>appendText</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zIn</name></decl></param>, <param><decl><type><name>char</name> <name>const</name> *</type><name>zAppend</name></decl></param>, <param><decl><type><name>char</name></type> <name>quote</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAppend</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name> =<init> <expr>(<name>zIn</name>?<call><name>strlen30</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call>:0)</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> = <name>nAppend</name>+<name>nIn</name>+1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>quote</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>len</name> += 2</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nAppend</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name>==<name>quote</name></expr> )</condition><then> <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt></then></if>
    }</block></for>
  }</block></then></if>

  <expr_stmt><expr><name>zIn</name> = (<name>char</name> *)<call><name>realloc</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zIn</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>quote</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zCsr</name> =<init> <expr>&amp;<name><name>zIn</name><index>[<expr><name>nIn</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>zCsr</name>++ = <name>quote</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nAppend</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr>*<name>zCsr</name>++ = <name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name><name>zAppend</name><index>[<expr><name>i</name></expr>]</index></name>==<name>quote</name></expr> )</condition><then> <expr_stmt><expr>*<name>zCsr</name>++ = <name>quote</name></expr>;</expr_stmt></then></if>
    }</block></for>
    <expr_stmt><expr>*<name>zCsr</name>++ = <name>quote</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>zCsr</name>++ = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>zCsr</name>-<name>zIn</name>)==<name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zIn</name><index>[<expr><name>nIn</name></expr>]</index></name></expr></argument>, <argument><expr><name>zAppend</name></expr></argument>, <argument><expr><name>nAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>len</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>zIn</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Execute a query statement that has a single result column.  Print
** that result column on a line by itself with a semicolon terminator.
**
** This is used, for example, to show the schema of the database by
** querying the SQLITE_MASTER table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>run_table_dump_query</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>out</name></decl></param>, <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zSelect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pSelect</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSelect</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pSelect</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || !<name>pSelect</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_ROW</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr>"%s;\n"</expr></argument>, <argument><expr><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*
** This is a different callback routine used for dumping the database.
** Each row received by this callback consists of a table name,
** the table type ("index" or "table") and SQL to create the table.
** This routine should print text sufficient to recreate the table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dump_callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>, <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>, <param><decl><type><name>char</name> **</type><name>azArg</name></decl></param>, <param><decl><type><name>char</name> **</type><name>azCol</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>callback_data</name> *</type><name>p</name> =<init> <expr>(struct <name>callback_data</name> *)<name>pArg</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nArg</name>!=3</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <expr_stmt><expr><name>zTable</name> = <name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zType</name> = <name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> = <name><name>azArg</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
  
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr>"sqlite_sequence"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"DELETE FROM sqlite_sequence;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr>"sqlite_stat1"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"ANALYZE sqlite_master;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zTable</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr>"CREATE VIRTUAL TABLE"</expr></argument>, <argument><expr>20</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zIns</name></decl>;</decl_stmt>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>writableSchema</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"PRAGMA writable_schema=ON;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>writableSchema</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zIns</name> = <call><name>sqlite3_mprintf</name><argument_list>(
       <argument><expr>"INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"
       "VALUES('table','%q','%q',0,'%q');"</expr></argument>,
       <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>zIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zIns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"%s;\n"</expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if>

  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr>"table"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pTableInfo</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zSelect</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zTableInfo</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zTmp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
   
    <expr_stmt><expr><name>zTableInfo</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zTableInfo</name></expr></argument>, <argument><expr>"PRAGMA table_info("</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTableInfo</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zTableInfo</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTableInfo</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zTableInfo</name></expr></argument>, <argument><expr>");"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zTableInfo</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pTableInfo</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zTableInfo</name></expr> )</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || !<name>pTableInfo</name></expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>"SELECT 'INSERT INTO ' || "</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTmp</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zTmp</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zTmp</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr><name>zTmp</name></expr></argument>, <argument><expr>'\''</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>" || ' VALUES(' || "</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_ROW</name></expr> )</condition><block>{
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zText</name> =<init> <expr>(<name>const</name> <name>char</name> *)<call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pTableInfo</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>"quote("</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_ROW</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>") || ',' || "</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>") "</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></while>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>zSelect</name></expr> )</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>"|| ')' FROM  "</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>run_table_dump_query</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_CORRUPT</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zSelect</name> = <call><name>appendText</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>, <argument><expr>" ORDER BY rowid DESC"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>run_table_dump_query</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>zSelect</name></expr> )</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Run zQuery.  Use dump_callback() as the callback routine so that
** the contents of the query are output as SQL statements.
**
** If we get a SQLITE_CORRUPT error, rerun the query after appending
** "ORDER BY rowid DESC" to the end.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>run_schema_dump_query</name><parameter_list>(
  <param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zQuery</name></decl></param>,
  <param><decl><type><name>char</name> **</type><name>pzErrMsg</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><name>dump_callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_CORRUPT</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zQ2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pzErrMsg</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr>*<name>pzErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>zQ2</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>len</name>+100</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zQ2</name>==0</expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zQ2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zQ2</name></expr></argument>, <argument><expr>"%s ORDER BY rowid DESC"</expr></argument>, <argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zQ2</name></expr></argument>, <argument><expr><name>dump_callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pzErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zQ2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Text of a help message
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>zHelp</name><index>[]</index></name> =<init>
  <expr>".bail ON|OFF           Stop after hitting an error.  Default OFF\n"
  ".databases             List names and files of attached databases\n"
  ".dump ?TABLE? ...      Dump the database in an SQL text format\n"
  ".echo ON|OFF           Turn command echo on or off\n"
  ".exit                  Exit this program\n"
  ".explain ON|OFF        Turn output mode suitable for EXPLAIN on or off.\n"
  ".header(s) ON|OFF      Turn display of headers on or off\n"
  ".help                  Show this message\n"
  ".import FILE TABLE     Import data from FILE into TABLE\n"
  ".indices TABLE         Show names of all indices on TABLE\n"
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
  ".iotrace FILE          Enable I/O diagnostic logging to FILE\n"
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
  ".load FILE ?ENTRY?     Load an extension library\n"
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  ".mode MODE ?TABLE?     Set output mode where MODE is one of:\n"
  "                         csv      Comma-separated values\n"
  "                         column   Left-aligned columns.  (See .width)\n"
  "                         html     HTML &lt;table&gt; code\n"
  "                         insert   SQL insert statements for TABLE\n"
  "                         line     One value per line\n"
  "                         list     Values delimited by .separator string\n"
  "                         tabs     Tab-separated values\n"
  "                         tcl      TCL list elements\n"
  ".nullvalue STRING      Print STRING in place of NULL values\n"
  ".output FILENAME       Send output to FILENAME\n"
  ".output stdout         Send output to the screen\n"
  ".prompt MAIN CONTINUE  Replace the standard prompts\n"
  ".quit                  Exit this program\n"
  ".read FILENAME         Execute SQL in FILENAME\n"
  ".schema ?TABLE?        Show the CREATE statements\n"
  ".separator STRING      Change separator used by output mode and .import\n"
  ".show                  Show the current values for various settings\n"
  ".tables ?PATTERN?      List names of tables matching a LIKE pattern\n"
  ".timeout MS            Try opening locked tables for MS milliseconds\n"
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAS_TIMER</name></expr></cpp:if>
  ".timer ON|OFF          Turn the CPU timer measurement on or off\n"
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  ".width NUM NUM ...     Set column widths for \"column\" mode\n"</expr></init></decl>
;</decl_stmt>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>process_input</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>in</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Make sure the database is open.  If it is not, then open it.  If
** the database fails to open, print an error message and exit.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>open_db</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_open</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zDbFilename</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> = <name>p</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name> &amp;&amp; <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"shellstatic"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>,
          <argument><expr><name>shellstaticFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>db</name>==0 || <name>SQLITE_OK</name>!=<call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Unable to open database \"%s\": %s\n"</expr></argument>, 
          <argument><expr><name>p</name>-&gt;<name>zDbFilename</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3_enable_load_extension</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Do C-language style dequoting.
**
**    \t    -&gt; tab
**    \n    -&gt; newline
**    \r    -&gt; carriage return
**    \NNN  -&gt; ascii character NNN in octal
**    \\    -&gt; backslash
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>resolve_backslashes</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr>(<name>c</name> = <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>)!=0</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>c</name>=='\\'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>c</name> = <name><name>z</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c</name>=='n'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>c</name> = '\n'</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='t'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>c</name> = '\t'</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='r'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>c</name> = '\r'</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>c</name>&gt;='0' &amp;&amp; <name>c</name>&lt;='7'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>c</name> -= '0'</expr>;</expr_stmt>
        <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>&gt;='0' &amp;&amp; <name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>&lt;='7'</expr> )</condition><then><block>{
          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> = (<name>c</name>&lt;&lt;3) + <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> - '0'</expr>;</expr_stmt>
          <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>&gt;='0' &amp;&amp; <name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>&lt;='7'</expr> )</condition><then><block>{
            <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> = (<name>c</name>&lt;&lt;3) + <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> - '0'</expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if></else></if></else></if></else></if>
    }</block></then></if>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Interpret zArg as a boolean value.  Return either 0 or 1.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>booleanValue</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> =<init> <expr><call><name>atoi</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>char</name>)<call><name>tolower</name><argument_list>(<argument><expr><name><name>zArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr>"on"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr>"yes"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>val</name> = 1</expr>;</expr_stmt>
  }</block></then></if></else></if>
  <return>return <expr><name>val</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If an input line begins with "." then invoke this routine to
** process that line.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>do_meta_command</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zLine</name></decl></param>, <param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name><name>azArg</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Parse the input line into tokens.
  */</comment>
  <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name>nArg</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>azArg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
    <while>while<condition>( <macro><name>isspace</name><argument_list>(<argument>(unsigned char)zLine[i]</argument>)</argument_list></macro> )</condition><block>{ <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt> }</block></while>
    <if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then> <break>break;</break></then></if>
    <if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>=='\'' || <name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>=='"'</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>delim</name> =<init> <expr><name><name>zLine</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>nArg</name>++</expr>]</index></name> = &amp;<name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>!=<name>delim</name></expr> )</condition><block>{ <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt> }</block></while>
      <if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>==<name>delim</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>i</name>++</expr>]</index></name> = 0</expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>delim</name>=='"'</expr> )</condition><then> <expr_stmt><expr><call><name>resolve_backslashes</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>nArg</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>nArg</name>++</expr>]</index></name> = &amp;<name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; !<call><name>isspace</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{ <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt> }</block></while>
      <if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><then> <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>i</name>++</expr>]</index></name> = 0</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>resolve_backslashes</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>nArg</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>

  <comment type="block">/* Process the input line.
  */</comment>
  <if>if<condition>( <expr><name>nArg</name>==0</expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>n</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> = <name><name>azArg</name><index>[<expr>0</expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>c</name>=='b' &amp;&amp; <name>n</name>&gt;1 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"bail"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>bail_on_error</name> = <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='d' &amp;&amp; <name>n</name>&gt;1 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"databases"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>callback_data</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>showHeader</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Column</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name><name>colWidth</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name><name>colWidth</name><index>[<expr>1</expr>]</index></name> = 15</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name><name>colWidth</name><index>[<expr>2</expr>]</index></name> = 58</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>cnt</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"PRAGMA database_list; "</expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='d' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"dump"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"BEGIN TRANSACTION;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>writableSchema</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"PRAGMA writable_schema=ON"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nArg</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>run_schema_dump_query</name><argument_list>(<argument><expr><name>p</name></expr></argument>, 
        <argument><expr>"SELECT name, type, sql FROM sqlite_master "
        "WHERE sql NOT NULL AND type=='table'"</expr></argument>, <argument><expr>0</expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>run_table_dump_query</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
        <argument><expr>"SELECT sql FROM sqlite_master "
        "WHERE sql NOT NULL AND type IN ('index','trigger','view')"</expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>nArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name>zShellStatic</name> = <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>run_schema_dump_query</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
          <argument><expr>"SELECT name, type, sql FROM sqlite_master "
          "WHERE tbl_name LIKE shellstatic() AND type=='table'"
          "  AND sql NOT NULL"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>run_table_dump_query</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
          <argument><expr>"SELECT sql FROM sqlite_master "
          "WHERE sql NOT NULL"
          "  AND type IN ('index','trigger','view')"
          "  AND tbl_name LIKE shellstatic()"</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zShellStatic</name> = 0</expr>;</expr_stmt>
      }</block></for>
    }</block></else></if>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>writableSchema</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"PRAGMA writable_schema=OFF;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>writableSchema</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"PRAGMA writable_schema=OFF"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"COMMIT;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='e' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"echo"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>echoOn</name> = <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='e' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"exit"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = 2</expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='e' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"explain"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>val</name> =<init> <expr><name>nArg</name>&gt;=2 ? <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> : 1</expr></init></decl>;</decl_stmt>
    <if>if<condition>(<expr><name>val</name> == 1</expr>)</condition><then> <block>{
      <if>if<condition>(<expr>!<name>p</name>-&gt;<name>explainPrev</name>.<name>valid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>valid</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>mode</name> = <name>p</name>-&gt;<name>mode</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>showHeader</name> = <name>p</name>-&gt;<name>showHeader</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>colWidth</name></expr></argument>,<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>,<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <comment type="block">/* We could put this code under the !p-&gt;explainValid
      ** condition so that it does not execute if we are already in
      ** explain mode. However, always executing it allows us an easy
      ** was to reset to explain mode in case the user previously
      ** did an .explain followed by a .width, .mode or .header
      ** command.
      */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Explain</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>showHeader</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>0</expr>]</index></name> = 4</expr>;</expr_stmt>                  <comment type="block">/* addr */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>1</expr>]</index></name> = 13</expr>;</expr_stmt>                 <comment type="block">/* opcode */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>2</expr>]</index></name> = 4</expr>;</expr_stmt>                  <comment type="block">/* P1 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>3</expr>]</index></name> = 4</expr>;</expr_stmt>                  <comment type="block">/* P2 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>4</expr>]</index></name> = 4</expr>;</expr_stmt>                  <comment type="block">/* P3 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>5</expr>]</index></name> = 13</expr>;</expr_stmt>                 <comment type="block">/* P4 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>6</expr>]</index></name> = 2</expr>;</expr_stmt>                  <comment type="block">/* P5 */</comment>
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr>7</expr>]</index></name> = 13</expr>;</expr_stmt>                  <comment type="block">/* Comment */</comment>
    }</block></then><else>else <if>if <condition>(<expr><name>p</name>-&gt;<name>explainPrev</name>.<name>valid</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>valid</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>p</name>-&gt;<name>explainPrev</name>.<name>mode</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>showHeader</name> = <name>p</name>-&gt;<name>explainPrev</name>.<name>showHeader</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>,<argument><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>colWidth</name></expr></argument>,<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='h' &amp;&amp; (<call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"header"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 ||
                 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"headers"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 )&amp;&amp; <name>nArg</name>&gt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>showHeader</name> = <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='h' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"help"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s"</expr></argument>,<argument><expr><name>zHelp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='i' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"import"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;=3</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zTable</name> =<init> <expr><name><name>azArg</name><index>[<expr>2</expr>]</index></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Insert data into this table */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zFile</name> =<init> <expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>     <comment type="block">/* The file from which to extract data */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>        <comment type="block">/* A statement */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                     <comment type="block">/* Result code */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in an SQL string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counters */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSep</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes in p-&gt;separator[] */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>                 <comment type="block">/* An SQL statement */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zLine</name></decl>;</decl_stmt>                <comment type="block">/* A single line of input from the file */</comment>
    <decl_stmt><decl><type><name>char</name> **</type><name>azCol</name></decl>;</decl_stmt>               <comment type="block">/* zLine[] broken up into columns */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zCommit</name></decl>;</decl_stmt>              <comment type="block">/* How to commit changes */</comment>   
    <decl_stmt><decl><type><name>FILE</name> *</type><name>in</name></decl>;</decl_stmt>                   <comment type="block">/* The input file */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* Line number of input file */</comment>

    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSep</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nSep</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"non-null separator required for import\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"SELECT * FROM '%q'"</expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>nByte</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nCol</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nCol</name> = <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nCol</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>zSql</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nByte</name> + 20 + <name>nCol</name>*2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name>+20</expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>"INSERT INTO '%q' VALUES(?"</expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = ','</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = '?'</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>in</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>in</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"cannot open file: %s\n"</expr></argument>, <argument><expr><name>zFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>azCol</name> = <call><name>malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*(<name>nCol</name>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>azCol</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"BEGIN"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCommit</name> = "COMMIT"</expr>;</expr_stmt>
    <while>while<condition>( <expr>(<name>zLine</name> = <call><name>local_getline</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>azCol</name><index>[<expr>0</expr>]</index></name> = <name>zLine</name></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>z</name>=<name>zLine</name></expr>;</init> <condition><expr>*<name>z</name> &amp;&amp; *<name>z</name>!='\n' &amp;&amp; *<name>z</name>!='\r'</expr>;</condition> <incr><expr><name>z</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr>*<name>z</name>==<name>p</name>-&gt;<name><name>separator</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>, <argument><expr><name>nSep</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
          <expr_stmt><expr>*<name>z</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
          <if>if<condition>( <expr><name>i</name>&lt;<name>nCol</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>z</name><index>[<expr><name>nSep</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>z</name> += <name>nSep</name>-1</expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
      <expr_stmt><expr>*<name>z</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>i</name>+1!=<name>nCol</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s line %d: expected %d columns of data but found %d\n"</expr></argument>,
           <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zCommit</name> = "ROLLBACK"</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zCommit</name> = "ROLLBACK"</expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></while>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zCommit</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='i' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"indices"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;1</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>callback_data</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>showHeader</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_List</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zShellStatic</name> = <name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
      <argument><expr>"SELECT name FROM sqlite_master "
      "WHERE type='index' AND tbl_name LIKE shellstatic() "
      "UNION ALL "
      "SELECT name FROM sqlite_temp_master "
      "WHERE type='index' AND tbl_name LIKE shellstatic() "
      "ORDER BY 1"</expr></argument>,
      <argument><expr><name>callback</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zShellStatic</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_IOTRACE</name></cpp:ifdef>
  <if>if<condition>( <expr><name>c</name>=='i' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"iotrace"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <function_decl><type><name>extern</name> <name>void</name></type> (*<name>sqlite3IoTrace</name>)<parameter_list>(<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>, <param>...</param>)</parameter_list>;</function_decl>
    <if>if<condition>( <expr><name>iotrace</name> &amp;&amp; <name>iotrace</name>!=<name>stdout</name></expr> )</condition><then> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>iotrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>iotrace</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nArg</name>&lt;2</expr> )</condition><then><block>{
      <expr_stmt><expr><name>sqlite3IoTrace</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"-"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>sqlite3IoTrace</name> = <name>iotracePrintf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iotrace</name> = <name>stdout</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>iotrace</name> = <call><name>fopen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"w"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>iotrace</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"cannot open \"%s\"\n"</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sqlite3IoTrace</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>sqlite3IoTrace</name> = <name>iotracePrintf</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
  <if>if<condition>( <expr><name>c</name>=='l' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"load"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;=2</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFile</name>, *<name>zProc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zFile</name> = <name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zProc</name> = <name>nArg</name>&gt;=3 ? <name><name>azArg</name><index>[<expr>2</expr>]</index></name> : 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_load_extension</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zProc</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>c</name>=='m' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"mode"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;=2</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n2</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"line"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0
        ||
        <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"lines"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Line</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"column"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0
              ||
              <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"columns"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Column</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"list"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_List</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"html"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Html</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"tcl"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Tcl</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"csv"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Csv</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"tabs"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_List</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>, <argument><expr>"\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"insert"</expr></argument>,<argument><expr><name>n2</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>mode</name> = <name>MODE_Insert</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nArg</name>&gt;=3</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>set_table_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>set_table_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"mode should be one of: "
         "column csv html insert line list tabs tcl\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='n' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"nullvalue"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>==2</expr> )</condition><then> <block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nullvalue</name></expr></argument>,
                     <argument><expr>"%.*s"</expr></argument>, <argument><expr>(<name>int</name>)<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call>-1</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='o' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"output"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>==2</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>out</name>!=<name>stdout</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"stdout"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>out</name> = <name>stdout</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>outfile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>outfile</name></expr></argument>, <argument><expr>"stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>out</name> = <call><name>fopen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>out</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"can't write to \"%s\"\n"</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>out</name> = <name>stdout</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
         <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>outfile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>outfile</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='p' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"prompt"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; (<name>nArg</name>==2 || <name>nArg</name>==3)</expr>)</condition><then><block>{
    <if>if<condition>( <expr><name>nArg</name> &gt;= 2</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>,<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>(<name>int</name>)<call><name>ArraySize</name><argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>)</argument_list></call>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>nArg</name> &gt;= 3</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>,<argument><expr><name><name>azArg</name><index>[<expr>2</expr>]</index></name></expr></argument>,<argument><expr>(<name>int</name>)<call><name>ArraySize</name><argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>)</argument_list></call>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='q' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"quit"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = 2</expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='r' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"read"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>==2</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>FILE</name> *</type><name>alt</name> =<init> <expr><call><name>fopen</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>alt</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"can't open \"%s\"\n"</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>process_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='s' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"schema"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>callback_data</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>showHeader</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Semi</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nArg</name>&gt;1</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>azArg</name><index>[<expr>1</expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>azArg</name><index>[<expr>1</expr>]</index><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>)<call><name>tolower</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
      <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"sqlite_master"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> *</type><name><name>new_argv</name><index>[<expr>2</expr>]</index></name>, *<name><name>new_colv</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>0</expr>]</index></name> = "CREATE TABLE sqlite_master (\n"
                      "  type text,\n"
                      "  name text,\n"
                      "  tbl_name text,\n"
                      "  rootpage integer,\n"
                      "  sql text\n"
                      ")"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr>0</expr>]</index></name> = "sql"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>new_argv</name></expr></argument>, <argument><expr><name>new_colv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr>"sqlite_temp_master"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> *</type><name><name>new_argv</name><index>[<expr>2</expr>]</index></name>, *<name><name>new_colv</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>0</expr>]</index></name> = "CREATE TEMP TABLE sqlite_temp_master (\n"
                      "  type text,\n"
                      "  name text,\n"
                      "  tbl_name text,\n"
                      "  rootpage integer,\n"
                      "  sql text\n"
                      ")"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr>0</expr>]</index></name> = "sql"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_colv</name><index>[<expr>1</expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>new_argv</name></expr></argument>, <argument><expr><name>new_colv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zShellStatic</name> = <name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
          <argument><expr>"SELECT sql FROM "
          "  (SELECT sql sql, type type, tbl_name tbl_name, name name"
          "     FROM sqlite_master UNION ALL"
          "   SELECT sql, type, tbl_name, name FROM sqlite_temp_master) "
          "WHERE tbl_name LIKE shellstatic() AND type!='meta' AND sql NOTNULL "
          "ORDER BY substr(type,2,1), name"</expr></argument>,
          <argument><expr><name>callback</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zShellStatic</name> = 0</expr>;</expr_stmt>
      }</block></else></if></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
         <argument><expr>"SELECT sql FROM "
         "  (SELECT sql sql, type type, tbl_name tbl_name, name name"
         "     FROM sqlite_master UNION ALL"
         "   SELECT sql, type, tbl_name, name FROM sqlite_temp_master) "
         "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%'"
         "ORDER BY substr(type,2,1), name"</expr></argument>,
         <argument><expr><name>callback</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='s' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"separator"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>,
                     <argument><expr>"%.*s"</expr></argument>, <argument><expr>(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call>-1</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='s' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"show"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr>)</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: %s\n"</expr></argument>,<argument><expr>"echo"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>echoOn</name> ? "on" : "off"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: %s\n"</expr></argument>,<argument><expr>"explain"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>explainPrev</name>.<name>valid</name> ? "on" :"off"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: %s\n"</expr></argument>,<argument><expr>"headers"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>showHeader</name> ? "on" : "off"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: %s\n"</expr></argument>,<argument><expr>"mode"</expr></argument>, <argument><expr><name><name>modeDescr</name><index>[<expr><name>p</name>-&gt;<name>mode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: "</expr></argument>, <argument><expr>"nullvalue"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nullvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: %s\n"</expr></argument>,<argument><expr>"output"</expr></argument>,
            <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>outfile</name></expr></argument>)</argument_list></call> ? <name>p</name>-&gt;<name>outfile</name> : "stdout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: "</expr></argument>, <argument><expr>"separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>output_c_string</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%9.9s: "</expr></argument>,<argument><expr>"width"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name>=0</expr>;</init><condition><expr><name>i</name>&lt;(<name>int</name>)<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call> &amp;&amp; <name>p</name>-&gt;<name><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name> != 0</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"%d "</expr></argument>,<argument><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>,<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='t' &amp;&amp; <name>n</name>&gt;1 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"tables"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> **</type><name>azResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRow</name>, <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nArg</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_get_table</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
        <argument><expr>"SELECT name FROM sqlite_master "
        "WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%'"
        "UNION ALL "
        "SELECT name FROM sqlite_temp_master "
        "WHERE type IN ('table','view') "
        "ORDER BY 1"</expr></argument>,
        <argument><expr>&amp;<name>azResult</name></expr></argument>, <argument><expr>&amp;<name>nRow</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>zShellStatic</name> = <name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_get_table</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>,
        <argument><expr>"SELECT name FROM sqlite_master "
        "WHERE type IN ('table','view') AND name LIKE '%'||shellstatic()||'%' "
        "UNION ALL "
        "SELECT name FROM sqlite_temp_master "
        "WHERE type IN ('table','view') AND name LIKE '%'||shellstatic()||'%' "
        "ORDER BY 1"</expr></argument>,
        <argument><expr>&amp;<name>azResult</name></expr></argument>, <argument><expr>&amp;<name>nRow</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zShellStatic</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>len</name>, <name>maxlen</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nPrintCol</name>, <name>nPrintRow</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>nRow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name><name>azResult</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
        <expr_stmt><expr><name>len</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azResult</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>len</name>&gt;<name>maxlen</name></expr> )</condition><then> <expr_stmt><expr><name>maxlen</name> = <name>len</name></expr>;</expr_stmt></then></if>
      }</block></for>
      <expr_stmt><expr><name>nPrintCol</name> = 80/(<name>maxlen</name>+2)</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nPrintCol</name>&lt;1</expr> )</condition><then> <expr_stmt><expr><name>nPrintCol</name> = 1</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>nPrintRow</name> = (<name>nRow</name> + <name>nPrintCol</name> - 1)/<name>nPrintCol</name></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nPrintRow</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <for>for(<init><expr><name>j</name>=<name>i</name>+1</expr>;</init> <condition><expr><name>j</name>&lt;=<name>nRow</name></expr>;</condition> <incr><expr><name>j</name>+=<name>nPrintRow</name></expr></incr>)<block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>zSp</name> =<init> <expr><name>j</name>&lt;=<name>nPrintRow</name> ? "" : "  "</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s%-*s"</expr></argument>, <argument><expr><name>zSp</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><name><name>azResult</name><index>[<expr><name>j</name></expr>]</index></name> ? <name><name>azResult</name><index>[<expr><name>j</name></expr>]</index></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3_free_table</name><argument_list>(<argument><expr><name>azResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else

  <if>if<condition>( <expr><name>c</name>=='t' &amp;&amp; <name>n</name>&gt;4 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"timeout"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;=2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_busy_timeout</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAS_TIMER</name></expr></cpp:if>  
  <if>if<condition>( <expr><name>c</name>=='t' &amp;&amp; <name>n</name>&gt;=5 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"timer"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>nArg</name>&gt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>enableTimer</name> = <call><name>booleanValue</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>c</name>=='w' &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>"width"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name>&lt;=<call><name>ArraySize</name><argument_list>(<argument><expr><name>azArg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=1</expr>;</init> <condition><expr><name>j</name>&lt;<name>nArg</name> &amp;&amp; <name>j</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>colWidth</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>colWidth</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <call><name>atoi</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then><else>else


  <block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"unknown command or invalid arguments: "
      " \"%s\". Enter \".help\" for help\n"</expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if a semicolon occurs anywhere in the first N characters
** of string z[].
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>_contains_semicolon</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>N</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{  <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>==';'</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if> }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Test to see if a line consists entirely of whitespace.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>_all_whitespace</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <for>for(<init>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>z</name>++</expr></incr>)<block>{
    <if>if<condition>( <macro><name>isspace</name><argument_list>(<argument>*(unsigned char*)z</argument>)</argument_list></macro> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr>*<name>z</name>=='/' &amp;&amp; <name><name>z</name><index>[<expr>1</expr>]</index></name>=='*'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>z</name> += 2</expr>;</expr_stmt>
      <while>while<condition>( <expr>*<name>z</name> &amp;&amp; (*<name>z</name>!='*' || <name><name>z</name><index>[<expr>1</expr>]</index></name>!='/')</expr> )</condition><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></while>
      <if>if<condition>( <expr>*<name>z</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
      <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt>
      <continue>continue;</continue>
    }</block></then></if>
    <if>if<condition>( <expr>*<name>z</name>=='-' &amp;&amp; <name><name>z</name><index>[<expr>1</expr>]</index></name>=='-'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>z</name> += 2</expr>;</expr_stmt>
      <while>while<condition>( <expr>*<name>z</name> &amp;&amp; *<name>z</name>!='\n'</expr> )</condition><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></while>
      <if>if<condition>( <expr>*<name>z</name>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
      <continue>continue;</continue>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
  }</block></for>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the line typed in is an SQL command terminator other
** than a semi-colon.  The SQL Server style "go" command is understood
** as is the Oracle "/".
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>_is_command_terminator</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zLine</name></decl></param>)</parameter_list><block>{
  <while>while<condition>( <macro><name>isspace</name><argument_list>(<argument>*(unsigned char*)zLine</argument>)</argument_list></macro> )</condition><block>{ <expr_stmt><expr><name>zLine</name>++</expr>;</expr_stmt> }</block></while><empty_stmt>;</empty_stmt>
  <if>if<condition>( <expr><name><name>zLine</name><index>[<expr>0</expr>]</index></name>=='/' &amp;&amp; <call><name>_all_whitespace</name><argument_list>(<argument><expr>&amp;<name><name>zLine</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>  <comment type="block">/* Oracle */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>tolower</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>=='g' &amp;&amp; <call><name>tolower</name><argument_list>(<argument><expr><name><name>zLine</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>=='o'
         &amp;&amp; <call><name>_all_whitespace</name><argument_list>(<argument><expr>&amp;<name><name>zLine</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>  <comment type="block">/* SQL Server */</comment>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Return true if zSql is a complete SQL statement.  Return false if it
** ends in the middle of a string literal or C-style comment.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>_is_complete</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zSql</name></decl></param>, <param><decl><type><name>int</name></type> <name>nSql</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name> = ';'</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read input from *in and process it.  If *in==0 then input
** is interactive - the user is typing it it.  Otherwise, input
** is coming from a file or device.  A prompt is issued and history
** is saved only if input is interactive.  An interrupt signal will
** cause this routine to exit immediately, unless input is interactive.
**
** Return the number of errors.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>process_input</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zLine</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSql</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nSqlPrior</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errCnt</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>startline</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>errCnt</name>==0 || !<name>bail_on_error</name> || (<name>in</name>==0 &amp;&amp; <name>stdin_is_interactive</name>)</expr> )</condition><block>{
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zLine</name> = <call><name>one_input_line</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zLine</name>==0</expr> )</condition><then><block>{
      <break>break;</break>  <comment type="block">/* We have reached EOF */</comment>
    }</block></then></if>
    <if>if<condition>( <expr><name>seenInterrupt</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>in</name>!=0</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><name>seenInterrupt</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>echoOn</name></expr> )</condition><then> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr>(<name>zSql</name>==0 || <name><name>zSql</name><index>[<expr>0</expr>]</index></name>==0) &amp;&amp; <call><name>_all_whitespace</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><name>zLine</name> &amp;&amp; <name><name>zLine</name><index>[<expr>0</expr>]</index></name>=='.' &amp;&amp; <name>nSql</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>do_meta_command</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==2</expr> )</condition><then><block>{
        <break>break;</break>
      }</block></then><else>else <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>errCnt</name>++</expr>;</expr_stmt>
      }</block></then></if></else></if>
      <continue>continue;</continue>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>_is_command_terminator</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>_is_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nSql</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>,<argument><expr>";"</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>nSqlPrior</name> = <name>nSql</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{}</block></for>
      <if>if<condition>( <expr><name><name>zLine</name><index>[<expr><name>i</name></expr>]</index></name>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>nSql</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zSql</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nSql</name>+3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"out of memory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nSql</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>startline</name> = <name>lineno</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zSql</name> = <call><name>realloc</name><argument_list>( <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>nSql</name> + <name>len</name> + 4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: out of memory!\n"</expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>nSql</name>++</expr>]</index></name> = '\n'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zSql</name><index>[<expr><name>nSql</name></expr>]</index></name></expr></argument>, <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> += <name>len</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>zSql</name> &amp;&amp; <call><name>_contains_semicolon</name><argument_list>(<argument><expr>&amp;<name><name>zSql</name><index>[<expr><name>nSqlPrior</name></expr>]</index></name></expr></argument>, <argument><expr><name>nSql</name>-<name>nSqlPrior</name></expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>sqlite3_complete</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>cnt</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>BEGIN_TIMER</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>END_TIMER</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name> || <name>zErrMsg</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>zPrefix</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>in</name>!=0 || !<name>stdin_is_interactive</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, 
                           <argument><expr>"SQL error near line %d:"</expr></argument>, <argument><expr><name>startline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zPrefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr>"SQL error:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if<condition>( <expr><name>zErrMsg</name>!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s %s\n"</expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>zErrMsg</name> = 0</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s %s\n"</expr></argument>, <argument><expr><name>zPrefix</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>errCnt</name>++</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zSql</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>nSql</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>
  <if>if<condition>( <expr><name>zSql</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<call><name>_all_whitespace</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr> )</condition><then> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Incomplete SQL: %s\n"</expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errCnt</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a pathname which is the user's home directory.  A
** 0 return indicates an error of some kind.  Space to hold the
** resulting string is obtained from malloc().  The calling
** function should free the result.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>find_home_dir</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>home_dir</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type>struct <name>passwd</name> *</type><name>pwent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name> =<init> <expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>pwent</name>=<call><name>getpwuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>home_dir</name> = <name>pwent</name>-&gt;<name>pw_dir</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()
   */</comment>
  <expr_stmt><expr><name>home_dir</name> = <call><name>strdup</name><argument_list>(<argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if <condition>(<expr>!<name>home_dir</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>home_dir</name> = <call><name>getenv</name><argument_list>(<argument><expr>"USERPROFILE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<name>home_dir</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>home_dir</name> = <call><name>getenv</name><argument_list>(<argument><expr>"HOME"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__OS2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if <condition>(<expr>!<name>home_dir</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zDrive</name>, *<name>zPath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zDrive</name> = <call><name>getenv</name><argument_list>(<argument><expr>"HOMEDRIVE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zPath</name> = <call><name>getenv</name><argument_list>(<argument><expr>"HOMEPATH"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zDrive</name> &amp;&amp; <name>zPath</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zDrive</name></expr></argument>)</argument_list></call> + <call><name>strlen30</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>home_dir</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>home_dir</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>home_dir</name></expr></argument>, <argument><expr>"%s%s"</expr></argument>, <argument><expr><name>zDrive</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>home_dir</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>home_dir</name> = "c:\\"</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !_WIN32_WCE */</comment>

  <if>if<condition>( <expr><name>home_dir</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr><call><name>malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>z</name></expr> )</condition><then> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>home_dir</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>home_dir</name> = <name>z</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>home_dir</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read input from the file given by sqliterc_override.  Or if that
** parameter is NULL, take input from ~/.sqliterc
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>process_sqliterc</name><parameter_list>(
  <param><decl><type>struct <name>callback_data</name> *</type><name>p</name></decl></param>,        <comment type="block">/* Configuration data */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>sqliterc_override</name></decl></param>   <comment type="block">/* Name of config file. NULL to use default */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>home_dir</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>sqliterc</name> =<init> <expr><name>sqliterc_override</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zBuf</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>in</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuf</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>sqliterc</name> == <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>home_dir</name> = <call><name>find_home_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>home_dir</name>==0</expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: cannot locate your home directory!\n"</expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nBuf</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call> + 16</expr>;</expr_stmt>
    <expr_stmt><expr><name>zBuf</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zBuf</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: out of memory!\n"</expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>,<argument><expr>"%s/.sqliterc"</expr></argument>,<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>home_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqliterc</name> = (<name>const</name> <name>char</name>*)<name>zBuf</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>in</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>sqliterc</name></expr></argument>,<argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>in</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>stdin_is_interactive</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"-- Loading resources from %s\n"</expr></argument>,<argument><expr><name>sqliterc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>process_input</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** Show available command line options
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>zOptions</name><index>[]</index></name> =<init> 
  <expr>"   -init filename       read/process named file\n"
  "   -echo                print commands before execution\n"
  "   -[no]header          turn headers on or off\n"
  "   -bail                stop after hitting an error\n"
  "   -interactive         force interactive I/O\n"
  "   -batch               force batch I/O\n"
  "   -column              set output mode to 'column'\n"
  "   -csv                 set output mode to 'csv'\n"
  "   -html                set output mode to HTML\n"
  "   -line                set output mode to 'line'\n"
  "   -list                set output mode to 'list'\n"
  "   -separator 'x'       set output field separator (|)\n"
  "   -nullvalue 'text'    set text string for NULL values\n"
  "   -version             show SQLite version\n"</expr></init></decl>
;</decl_stmt>
<function><type><name>static</name> <name>void</name></type> <name>usage</name><parameter_list>(<param><decl><type><name>int</name></type> <name>showDetail</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr>"Usage: %s [OPTIONS] FILENAME [SQL]\n"  
      "FILENAME is the name of an SQLite database. A new database is created\n"
      "if the file does not previously exist.\n"</expr></argument>, <argument><expr><name>Argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>showDetail</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"OPTIONS include:\n%s"</expr></argument>, <argument><expr><name>zOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Use the -help option for additional information\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Initialize the state information in data
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>main_init</name><parameter_list>(<param><decl><type>struct <name>callback_data</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name>-&gt;<name>mode</name> = <name>MODE_List</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>separator</name></expr></argument>,<argument><expr>"|"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>data</name>-&gt;<name>showHeader</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>mainPrompt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mainPrompt</name></expr></argument>,<argument><expr>"sqlite&gt; "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>continuePrompt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>continuePrompt</name></expr></argument>,<argument><expr>"   ...&gt; "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>callback_data</name></type> <name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zInitFile</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFirstCmd</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>Argv0</name> = <name><name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>main_init</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stdin_is_interactive</name> = <call><name>isatty</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure we have a valid signal handler early, before anything
  ** else is done.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>interrupt_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Do an initial pass through the command-line argument to locate
  ** the name of the database file, the name of the initialization file,
  ** and the first command to execute.
  */</comment>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name>!='-'</expr> )</condition><then> <break>break;</break></then></if>
    <expr_stmt><expr><name>z</name> = <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name><name>z</name><index>[<expr>0</expr>]</index></name>=='-' &amp;&amp; <name><name>z</name><index>[<expr>1</expr>]</index></name>=='-'</expr> )</condition><then> <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr>"-separator"</expr></argument>)</argument_list></call>==0 || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr>"-nullvalue"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr>"-init"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>zInitFile</name> = <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
  <if>if<condition>( <expr><name>i</name>&lt;<name>argc</name></expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_OS_OS2</name></expr></cpp:if>
    <expr_stmt><expr><name>data</name>.<name>zDbFilename</name> = (<name>const</name> <name>char</name> *)<call><name>convertCpPathToUtf8</name><argument_list>( <argument><expr><name><name>argv</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>data</name>.<name>zDbFilename</name> = <name><name>argv</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then><else>else<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifndef>
    <expr_stmt><expr><name>data</name>.<name>zDbFilename</name> = ":memory:"</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>data</name>.<name>zDbFilename</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if>
  <if>if<condition>( <expr><name>i</name>&lt;<name>argc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zFirstCmd</name> = <name><name>argv</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>data</name>.<name>out</name> = <name>stdout</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifdef>
  <if>if<condition>( <expr><name>data</name>.<name>zDbFilename</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: no database filename specified\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Go ahead and open the database file if it already exists.  If the
  ** file does not exist, delay opening it.  This prevents empty database
  ** files from being created if a user mistypes the database name argument
  ** to the sqlite command-line tool.
  */</comment>
  <if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>data</name>.<name>zDbFilename</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Process the initialization file if there is one.  If no -init option
  ** is given on the command line, look for a file named ~/.sqliterc and
  ** try to process it.
  */</comment>
  <expr_stmt><expr><call><name>process_sqliterc</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>,<argument><expr><name>zInitFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a second pass through the command-line argument and set
  ** options.  This second pass is delayed until after the initialization
  ** file is processed so that the command-line arguments will override
  ** settings in the initialization file.
  */</comment>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name> &amp;&amp; <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name>=='-'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name> =<init> <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name><name>z</name><index>[<expr>1</expr>]</index></name>=='-'</expr> )</condition><then><block>{ <expr_stmt><expr><name>z</name>++</expr>;</expr_stmt> }</block></then></if>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-init"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-html"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Html</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-list"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_List</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-line"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Line</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-column"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Column</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-csv"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>mode</name> = <name>MODE_Csv</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name>.<name>separator</name></expr></argument>,<argument><expr>","</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-separator"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>.<name>separator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name>.<name>separator</name></expr></argument>,
                       <argument><expr>"%.*s"</expr></argument>,<argument><expr>(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>.<name>separator</name></expr></argument>)</argument_list></call>-1</expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-nullvalue"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>.<name>nullvalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name>.<name>nullvalue</name></expr></argument>,
                       <argument><expr>"%.*s"</expr></argument>,<argument><expr>(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>.<name>nullvalue</name></expr></argument>)</argument_list></call>-1</expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-header"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>showHeader</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-noheader"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>showHeader</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-echo"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>data</name>.<name>echoOn</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-bail"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>bail_on_error</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-version"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-interactive"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>stdin_is_interactive</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-batch"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>stdin_is_interactive</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>,<argument><expr>"-help"</expr></argument>)</argument_list></call>==0 || <call><name>strcmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>"--help"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: unknown option: %s\n"</expr></argument>, <argument><expr><name>Argv0</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Use -help for a list of options.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
  }</block></for>

  <if>if<condition>( <expr><name>zFirstCmd</name></expr> )</condition><then><block>{
    <comment type="block">/* Run just the command that follows the database name
    */</comment>
    <if>if<condition>( <expr><name><name>zFirstCmd</name><index>[<expr>0</expr>]</index></name>=='.'</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>do_meta_command</name><argument_list>(<argument><expr><name>zFirstCmd</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>open_db</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>data</name>.<name>db</name></expr></argument>, <argument><expr><name>zFirstCmd</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=0 &amp;&amp; <name>zErrMsg</name>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"SQL error: %s\n"</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then><else>else<block>{
    <comment type="block">/* Run commands received from standard input
    */</comment>
    <if>if<condition>( <expr><name>stdin_is_interactive</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zHome</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zHistory</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nHistory</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(
        <argument><expr>"SQLite version %s\n"
        "Enter \".help\" for instructions\n"
        "Enter SQL statements terminated with a \";\"\n"</expr></argument>,
        <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zHome</name> = <call><name>find_home_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zHome</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>nHistory</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zHome</name></expr></argument>)</argument_list></call> + 20</expr>;</expr_stmt>
        <if>if<condition>( <expr>(<name>zHistory</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>nHistory</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nHistory</name></expr></argument>, <argument><expr><name>zHistory</name></expr></argument>,<argument><expr>"%s/.sqlite_history"</expr></argument>, <argument><expr><name>zHome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_READLINE</name>==1</expr></cpp:if>
      <if>if<condition>( <expr><name>zHistory</name></expr> )</condition><then> <expr_stmt><expr><call><name>read_history</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> = <call><name>process_input</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zHistory</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>stifle_history</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>write_history</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zHome</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>process_input</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></else></if>
  <expr_stmt><expr><call><name>set_table_name</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"error closing database: %s\n"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
</unit>
