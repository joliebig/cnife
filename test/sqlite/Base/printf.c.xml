<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="printf.c" filename=""><comment type="block">/*
** The "printf" code that follows dates from the 1980's.  It is in
** the public domain.  The original comments are included here for
** completeness.  They are very out-of-date but might be useful as
** an historical reference.  Most of the "enhancements" have been backed
** out so that the functionality is now the same as standard printf().
**
** $Id: printf.c,v 1.99 2008/12/10 19:26:24 drh Exp $
**
**************************************************************************
**
** The following modules is an enhanced replacement for the "printf" subroutines
** found in the standard C library.  The following enhancements are
** supported:
**
**      +  Additional functions.  The standard set of "printf" functions
**         includes printf, fprintf, sprintf, vprintf, vfprintf, and
**         vsprintf.  This module adds the following:
**
**           *  snprintf -- Works like sprintf, but has an extra argument
**                          which is the size of the buffer written to.
**
**           *  mprintf --  Similar to sprintf.  Writes output to memory
**                          obtained from malloc.
**
**           *  xprintf --  Calls a function to dispose of output.
**
**           *  nprintf --  No output, but returns the number of characters
**                          that would have been output by printf.
**
**           *  A v- version (ex: vsnprintf) of every function is also
**              supplied.
**
**      +  A few extensions to the formatting notation are supported:
**
**           *  The "=" flag (similar to "-") causes the output to be
**              be centered in the appropriately sized field.
**
**           *  The %b field outputs an integer in binary notation.
**
**           *  The %c field now accepts a precision.  The character output
**              is repeated by the number of times the precision specifies.
**
**           *  The %' field works like %c, but takes as its character the
**              next character of the format string, instead of the next
**              argument.  For example,  printf("%.78'-")  prints 78 minus
**              signs, the same as  printf("%.78c",'-').
**
**      +  When compiled using GCC on a SPARC, this version of printf is
**         faster than the library printf for SUN OS 4.1.
**
**      +  All functions are fully reentrant.
**
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etRADIX</name>       1</cpp:define> <comment type="block">/* Integer types.  %d, %x, %o, and so forth */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etFLOAT</name>       2</cpp:define> <comment type="block">/* Floating point.  %f */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etEXP</name>         3</cpp:define> <comment type="block">/* Exponentional notation. %e and %E */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etGENERIC</name>     4</cpp:define> <comment type="block">/* Floating or exponential, depending on exponent. %g */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSIZE</name>        5</cpp:define> <comment type="block">/* Return number of characters processed so far. %n */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSTRING</name>      6</cpp:define> <comment type="block">/* Strings. %s */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etDYNSTRING</name>   7</cpp:define> <comment type="block">/* Dynamically allocated strings. %z */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etPERCENT</name>     8</cpp:define> <comment type="block">/* Percent symbol. %% */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etCHARX</name>       9</cpp:define> <comment type="block">/* Characters. %c */</comment>
<comment type="block">/* The rest are extensions, not normally found in printf() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSQLESCAPE</name>  10</cpp:define> <comment type="block">/* Strings with '\'' doubled.  %q */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSQLESCAPE2</name> 11</cpp:define> <comment type="block">/* Strings with '\'' doubled and enclosed in '',
                          NULL pointers replaced by SQL NULL.  %Q */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etTOKEN</name>      12</cpp:define> <comment type="block">/* a pointer to a Token structure */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSRCLIST</name>    13</cpp:define> <comment type="block">/* a pointer to a SrcList */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etPOINTER</name>    14</cpp:define> <comment type="block">/* The %p conversion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etSQLESCAPE3</name> 15</cpp:define> <comment type="block">/* %w -&gt; Strings with '\"' doubled */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etORDINAL</name>    16</cpp:define> <comment type="block">/* %r -&gt; 1st, 2nd, 3rd, 4th, etc.  English only */</comment>


<comment type="block">/*
** An "etByte" is an 8-bit unsigned value.
*/</comment>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>etByte</name>;</typedef>

<comment type="block">/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/</comment>
<typedef>typedef <type><struct>struct <name>et_info</name> <block>{<public type="default">   <comment type="block">/* Information about each format field */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>fmttype</name></decl>;</decl_stmt>            <comment type="block">/* The format field code letter */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>base</name></decl>;</decl_stmt>             <comment type="block">/* The base for radix conversion */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flags</name></decl>;</decl_stmt>            <comment type="block">/* One or more of FLAG_ constants below */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>type</name></decl>;</decl_stmt>             <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>charset</name></decl>;</decl_stmt>          <comment type="block">/* Offset into aDigits[] of the digits string */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>prefix</name></decl>;</decl_stmt>           <comment type="block">/* Offset into aPrefix[] of the prefix string */</comment>
</public>}</block></struct></type> <name>et_info</name>;</typedef>

<comment type="block">/*
** Allowed values for et_info.flags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FLAG_SIGNED</name>  1</cpp:define>     <comment type="block">/* True if the value to convert is signed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FLAG_INTERN</name>  2</cpp:define>     <comment type="block">/* True if for internal use only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FLAG_STRING</name>  4</cpp:define>     <comment type="block">/* Allow infinity precision */</comment>


<comment type="block">/*
** The following table is searched linearly, so it is good to put the
** most frequently used conversion types first.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>aDigits</name><index>[]</index></name> =<init> <expr>"0123456789ABCDEF0123456789abcdef"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>aPrefix</name><index>[]</index></name> =<init> <expr>"-x0\000X0"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>et_info</name></type> <name><name>fmtinfo</name><index>[]</index></name> =<init> <expr><block>{
  <expr><block>{  <expr>'d'</expr>, <expr>10</expr>, <expr>1</expr>, <expr><name>etRADIX</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'s'</expr>,  <expr>0</expr>, <expr>4</expr>, <expr><name>etSTRING</name></expr>,     <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'g'</expr>,  <expr>0</expr>, <expr>1</expr>, <expr><name>etGENERIC</name></expr>,    <expr>30</expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'z'</expr>,  <expr>0</expr>, <expr>4</expr>, <expr><name>etDYNSTRING</name></expr>,  <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'q'</expr>,  <expr>0</expr>, <expr>4</expr>, <expr><name>etSQLESCAPE</name></expr>,  <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'Q'</expr>,  <expr>0</expr>, <expr>4</expr>, <expr><name>etSQLESCAPE2</name></expr>, <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'w'</expr>,  <expr>0</expr>, <expr>4</expr>, <expr><name>etSQLESCAPE3</name></expr>, <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'c'</expr>,  <expr>0</expr>, <expr>0</expr>, <expr><name>etCHARX</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'o'</expr>,  <expr>8</expr>, <expr>0</expr>, <expr><name>etRADIX</name></expr>,      <expr>0</expr>,  <expr>2</expr> }</block></expr>,
  <expr><block>{  <expr>'u'</expr>, <expr>10</expr>, <expr>0</expr>, <expr><name>etRADIX</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'x'</expr>, <expr>16</expr>, <expr>0</expr>, <expr><name>etRADIX</name></expr>,      <expr>16</expr>, <expr>1</expr> }</block></expr>,
  <expr><block>{  <expr>'X'</expr>, <expr>16</expr>, <expr>0</expr>, <expr><name>etRADIX</name></expr>,      <expr>0</expr>,  <expr>4</expr> }</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <expr><block>{  <expr>'f'</expr>,  <expr>0</expr>, <expr>1</expr>, <expr><name>etFLOAT</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'e'</expr>,  <expr>0</expr>, <expr>1</expr>, <expr><name>etEXP</name></expr>,        <expr>30</expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'E'</expr>,  <expr>0</expr>, <expr>1</expr>, <expr><name>etEXP</name></expr>,        <expr>14</expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'G'</expr>,  <expr>0</expr>, <expr>1</expr>, <expr><name>etGENERIC</name></expr>,    <expr>14</expr>, <expr>0</expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{  <expr>'i'</expr>, <expr>10</expr>, <expr>1</expr>, <expr><name>etRADIX</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'n'</expr>,  <expr>0</expr>, <expr>0</expr>, <expr><name>etSIZE</name></expr>,       <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'%'</expr>,  <expr>0</expr>, <expr>0</expr>, <expr><name>etPERCENT</name></expr>,    <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'p'</expr>, <expr>16</expr>, <expr>0</expr>, <expr><name>etPOINTER</name></expr>,    <expr>0</expr>,  <expr>1</expr> }</block></expr>,
  <expr><block>{  <expr>'T'</expr>,  <expr>0</expr>, <expr>2</expr>, <expr><name>etTOKEN</name></expr>,      <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'S'</expr>,  <expr>0</expr>, <expr>2</expr>, <expr><name>etSRCLIST</name></expr>,    <expr>0</expr>,  <expr>0</expr> }</block></expr>,
  <expr><block>{  <expr>'r'</expr>, <expr>10</expr>, <expr>3</expr>, <expr><name>etORDINAL</name></expr>,    <expr>0</expr>,  <expr>0</expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point
** conversions will work.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<comment type="block">/*
** "*val" is a double such that 0.1 &lt;= *val &lt; 10.0
** Return the ascii code for the leading digit of *val, then
** multiply "*val" by 10.0 to renormalize.
**
** Example:
**     input:     *val = 3.14159
**     output:    *val = 1.4159    function return = '3'
**
** The counter *cnt is incremented each time.  After counter exceeds
** 16 (the number of significant digits in a 64-bit float) '0' is
** always returned.
*/</comment>
<function><type><name>static</name> <name>char</name></type> <name>et_getdigit</name><parameter_list>(<param><decl><type><name>LONGDOUBLE_TYPE</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name> *</type><name>cnt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>digit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>d</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>(*<name>cnt</name>)++ &gt;= 16</expr> )</condition><then> <return>return <expr>'0'</expr>;</return></then></if>
  <expr_stmt><expr><name>digit</name> = (<name>int</name>)*<name>val</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> = <name>digit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>digit</name> += '0'</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>val</name> = (*<name>val</name> - <name>d</name>)*10.0</expr>;</expr_stmt>
  <return>return <expr>(<name>char</name>)<name>digit</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_FLOATING_POINT */</comment>

<comment type="block">/*
** Append N space characters to the given string buffer.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>appendSpace</name><parameter_list>(<param><decl><type><name>StrAccum</name> *</type><name>pAccum</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>zSpaces</name><index>[]</index></name> =<init> <expr>"                             "</expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>N</name>&gt;=(<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr><name>zSpaces</name></expr></argument>)</argument_list></call>-1</expr> )</condition><block>{
    <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zSpaces</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zSpaces</name></expr></argument>)</argument_list></call>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>N</name> -= <call><name>sizeof</name><argument_list>(<argument><expr><name>zSpaces</name></expr></argument>)</argument_list></call>-1</expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><name>N</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zSpaces</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** On machines with a small stack size, you can redefine the
** SQLITE_PRINT_BUF_SIZE to be less than 350.  But beware - for
** smaller values some %f conversions may go into an infinite loop.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PRINT_BUF_SIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SQLITE_PRINT_BUF_SIZE</name> 350</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>etBUFSIZE</name> <name>SQLITE_PRINT_BUF_SIZE</name></cpp:define>  <comment type="block">/* Size of the output buffer */</comment>

<comment type="block">/*
** The root program.  All variations call this core.
**
** INPUTS:
**   func   This is a pointer to a function taking three arguments
**            1. A pointer to anything.  Same as the "arg" parameter.
**            2. A pointer to the list of characters to be output
**               (Note, this list is NOT null terminated.)
**            3. An integer number of characters to be output.
**               (Note: This number might be zero.)
**
**   arg    This is the pointer to anything which will be passed as the
**          first argument to "func".  Use it for whatever you like.
**
**   fmt    This is the format string, as in the usual print.
**
**   ap     This is a pointer to a list of arguments.  Same as in
**          vfprint.
**
** OUTPUTS:
**          The return value is the total number of characters sent to
**          the function "func".  Returns -1 on a error.
**
** Note that the order in which automatic variables are declared below
** seems to make a big difference in determining how fast this beast
** will run.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VXPrintf</name><parameter_list>(
  <param><decl><type><name>StrAccum</name> *</type><name>pAccum</name></decl></param>,                  <comment type="block">/* Accumulate results here */</comment>
  <param><decl><type><name>int</name></type> <name>useExtended</name></decl></param>,                   <comment type="block">/* Allow extended %-conversions */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>fmt</name></decl></param>,                   <comment type="block">/* Format string */</comment>
  <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>                         <comment type="block">/* arguments */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>                     <comment type="block">/* Next character in the format string */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>bufpt</name></decl>;</decl_stmt>               <comment type="block">/* Pointer to the conversion buffer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>precision</name></decl>;</decl_stmt>             <comment type="block">/* Precision of the current field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>                <comment type="block">/* Length of the field */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                   <comment type="block">/* A general purpose loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>                 <comment type="block">/* Width of the current field */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_leftjustify</name></decl>;</decl_stmt>   <comment type="block">/* True if "-" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_plussign</name></decl>;</decl_stmt>      <comment type="block">/* True if "+" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_blanksign</name></decl>;</decl_stmt>     <comment type="block">/* True if " " flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_alternateform</name></decl>;</decl_stmt> <comment type="block">/* True if "#" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_altform2</name></decl>;</decl_stmt>      <comment type="block">/* True if "!" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_zeropad</name></decl>;</decl_stmt>       <comment type="block">/* True if field width constant starts with zero */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_long</name></decl>;</decl_stmt>          <comment type="block">/* True if "l" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_longlong</name></decl>;</decl_stmt>      <comment type="block">/* True if the "ll" flag is present */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>done</name></decl>;</decl_stmt>               <comment type="block">/* Loop termination flag */</comment>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>longvalue</name></decl>;</decl_stmt>   <comment type="block">/* Value for integer types */</comment>
  <decl_stmt><decl><type><name>LONGDOUBLE_TYPE</name></type> <name>realvalue</name></decl>;</decl_stmt> <comment type="block">/* Value for real types */</comment>
  <decl_stmt><decl><type><name>const</name> <name>et_info</name> *</type><name>infop</name></decl>;</decl_stmt>      <comment type="block">/* Pointer to the appropriate info structure */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>etBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Conversion buffer */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>prefix</name></decl>;</decl_stmt>               <comment type="block">/* Prefix character.  "+" or "-" or " " or '\0'. */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>xtype</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* Conversion paradigm */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zExtra</name></decl>;</decl_stmt>              <comment type="block">/* Extra memory used for etTCLESCAPE conversions */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type>  <name>exp</name>, <name>e2</name></decl>;</decl_stmt>              <comment type="block">/* exponent of real numbers */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rounder</name></decl>;</decl_stmt>            <comment type="block">/* Used for rounding floating point values */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_dp</name></decl>;</decl_stmt>            <comment type="block">/* True if decimal point should be shown */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_rtz</name></decl>;</decl_stmt>           <comment type="block">/* True if trailing zeros should be removed */</comment>
  <decl_stmt><decl><type><name>etByte</name></type> <name>flag_exp</name></decl>;</decl_stmt>           <comment type="block">/* True to force display of the exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nsd</name></decl>;</decl_stmt>                   <comment type="block">/* Number of significant digits returned */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>length</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>bufpt</name> = 0</expr>;</expr_stmt>
  <for>for(<init>;</init> <condition><expr>(<name>c</name>=(*<name>fmt</name>))!=0</expr>;</condition> <incr><expr>++<name>fmt</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>c</name>!='%'</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>amt</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>bufpt</name> = (<name>char</name> *)<name>fmt</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> = 1</expr>;</expr_stmt>
      <while>while<condition>( <expr>(<name>c</name>=(*++<name>fmt</name>))!='%' &amp;&amp; <name>c</name>!=0</expr> )</condition> <expr_stmt><expr><name>amt</name>++</expr>;</expr_stmt></while>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c</name>==0</expr> )</condition><then> <break>break;</break></then></if>
    }</block></then></if>
    <if>if<condition>( <expr>(<name>c</name>=(*++<name>fmt</name>))==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr>"%"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <comment type="block">/* Find out what flags are present */</comment>
    <expr_stmt><expr><name>flag_leftjustify</name> = <name>flag_plussign</name> = <name>flag_blanksign</name> = 
     <name>flag_alternateform</name> = <name>flag_altform2</name> = <name>flag_zeropad</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>done</name> = 0</expr>;</expr_stmt>
    <do>do<block>{
      <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{
        <case>case <expr>'-'</expr>:   <expr_stmt><expr><name>flag_leftjustify</name> = 1</expr>;</expr_stmt>     <break>break;</break>
        </case><case>case <expr>'+'</expr>:   <expr_stmt><expr><name>flag_plussign</name> = 1</expr>;</expr_stmt>        <break>break;</break>
        </case><case>case <expr>' '</expr>:   <expr_stmt><expr><name>flag_blanksign</name> = 1</expr>;</expr_stmt>       <break>break;</break>
        </case><case>case <expr>'#'</expr>:   <expr_stmt><expr><name>flag_alternateform</name> = 1</expr>;</expr_stmt>   <break>break;</break>
        </case><case>case <expr>'!'</expr>:   <expr_stmt><expr><name>flag_altform2</name> = 1</expr>;</expr_stmt>        <break>break;</break>
        </case><case>case <expr>'0'</expr>:   <expr_stmt><expr><name>flag_zeropad</name> = 1</expr>;</expr_stmt>         <break>break;</break>
        </case><default>default:    <expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>                 <break>break;</break>
      </default>}</block></switch>
    }</block>while<condition>( <expr>!<name>done</name> &amp;&amp; (<name>c</name>=(*++<name>fmt</name>))!=0</expr> )</condition>;</do>
    <comment type="block">/* Get the field width */</comment>
    <expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>c</name>=='*'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>width</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>width</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>flag_leftjustify</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>width</name> = -<name>width</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <while>while<condition>( <expr><name>c</name>&gt;='0' &amp;&amp; <name>c</name>&lt;='9'</expr> )</condition><block>{
        <expr_stmt><expr><name>width</name> = <name>width</name>*10 + <name>c</name> - '0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
      }</block></while>
    }</block></else></if>
    <if>if<condition>( <expr><name>width</name> &gt; <name>etBUFSIZE</name>-10</expr> )</condition><then><block>{
      <expr_stmt><expr><name>width</name> = <name>etBUFSIZE</name>-10</expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* Get the precision */</comment>
    <if>if<condition>( <expr><name>c</name>=='.'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>precision</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c</name>=='*'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>precision</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>precision</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>precision</name> = -<name>precision</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <while>while<condition>( <expr><name>c</name>&gt;='0' &amp;&amp; <name>c</name>&lt;='9'</expr> )</condition><block>{
          <expr_stmt><expr><name>precision</name> = <name>precision</name>*10 + <name>c</name> - '0'</expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
        }</block></while>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>precision</name> = -1</expr>;</expr_stmt>
    }</block></else></if>
    <comment type="block">/* Get the conversion type modifier */</comment>
    <if>if<condition>( <expr><name>c</name>=='l'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>flag_long</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c</name>=='l'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>flag_longlong</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = *++<name>fmt</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>flag_longlong</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>flag_long</name> = <name>flag_longlong</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <comment type="block">/* Fetch the info entry for the field */</comment>
    <expr_stmt><expr><name>infop</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>idx</name>=0</expr>;</init> <condition><expr><name>idx</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>fmtinfo</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>c</name>==<name><name>fmtinfo</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>fmttype</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>infop</name> = &amp;<name><name>fmtinfo</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>useExtended</name> || (<name>infop</name>-&gt;<name>flags</name> &amp; <name>FLAG_INTERN</name>)==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>xtype</name> = <name>infop</name>-&gt;<name>type</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <return>return;</return>
        }</block></else></if>
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>zExtra</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>infop</name>==0</expr> )</condition><then><block>{
      <return>return;</return>
    }</block></then></if>


    <comment type="block">/* Limit the precision to prevent overflowing buf[] during conversion */</comment>
    <if>if<condition>( <expr><name>precision</name>&gt;<name>etBUFSIZE</name>-40 &amp;&amp; (<name>infop</name>-&gt;<name>flags</name> &amp; <name>FLAG_STRING</name>)==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>precision</name> = <name>etBUFSIZE</name>-40</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_altform2               TRUE if a '!' is present.
    **   flag_plussign               TRUE if a '+' is present.
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   TRUE if the letter 'l' (ell) prefixed
    **                               the conversion character.
    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed
    **                               the conversion character.
    **   flag_blanksign              TRUE if a ' ' is present.
    **   width                       The specified field width.  This is
    **                               always non-negative.  Zero is the default.
    **   precision                   The specified precision.  The default
    **                               is -1.
    **   xtype                       The class of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */</comment>
    <switch>switch<condition>( <expr><name>xtype</name></expr> )</condition><block>{
      <case>case <expr><name>etPOINTER</name></expr>:
        <expr_stmt><expr><name>flag_longlong</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>flag_long</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>long</name> <name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Fall through into the next case */</comment>
      </case><case>case <expr><name>etORDINAL</name></expr>:
      </case><case>case <expr><name>etRADIX</name></expr>:
        <if>if<condition>( <expr><name>infop</name>-&gt;<name>flags</name> &amp; <name>FLAG_SIGNED</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>i64</name></type> <name>v</name></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>flag_longlong</name></expr> )</condition><then>   <expr_stmt><expr><name>v</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>i64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else <if>if<condition>( <expr><name>flag_long</name></expr> )</condition><then>  <expr_stmt><expr><name>v</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>long</name> <name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else                  <expr_stmt><expr><name>v</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
          <if>if<condition>( <expr><name>v</name>&lt;0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>longvalue</name> = -<name>v</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prefix</name> = '-'</expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>longvalue</name> = <name>v</name></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>flag_plussign</name></expr> )</condition><then>        <expr_stmt><expr><name>prefix</name> = '+'</expr>;</expr_stmt></then>
            <else>else <if>if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><then>  <expr_stmt><expr><name>prefix</name> = ' '</expr>;</expr_stmt></then>
            <else>else                       <expr_stmt><expr><name>prefix</name> = 0</expr>;</expr_stmt></else></if></else></if>
          }</block></else></if>
        }</block></then><else>else<block>{
          <if>if<condition>( <expr><name>flag_longlong</name></expr> )</condition><then>   <expr_stmt><expr><name>longvalue</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>u64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else <if>if<condition>( <expr><name>flag_long</name></expr> )</condition><then>  <expr_stmt><expr><name>longvalue</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>unsigned</name> <name>long</name> <name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else                  <expr_stmt><expr><name>longvalue</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>unsigned</name> <name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
          <expr_stmt><expr><name>prefix</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
        <if>if<condition>( <expr><name>longvalue</name>==0</expr> )</condition><then> <expr_stmt><expr><name>flag_alternateform</name> = 0</expr>;</expr_stmt></then></if>
        <if>if<condition>( <expr><name>flag_zeropad</name> &amp;&amp; <name>precision</name>&lt;<name>width</name>-(<name>prefix</name>!=0)</expr> )</condition><then><block>{
          <expr_stmt><expr><name>precision</name> = <name>width</name>-(<name>prefix</name>!=0)</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>bufpt</name> = &amp;<name><name>buf</name><index>[<expr><name>etBUFSIZE</name>-1</expr>]</index></name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>xtype</name>==<name>etORDINAL</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>zOrd</name><index>[]</index></name> =<init> <expr>"thstndrd"</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>x</name> =<init> <expr>(<name>int</name>)(<name>longvalue</name> % 10)</expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>x</name>&gt;=4 || (<name>longvalue</name>/10)%10==1</expr> )</condition><then><block>{
            <expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>etBUFSIZE</name>-3</expr>]</index></name> = <name><name>zOrd</name><index>[<expr><name>x</name>*2</expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>etBUFSIZE</name>-2</expr>]</index></name> = <name><name>zOrd</name><index>[<expr><name>x</name>*2+1</expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>bufpt</name> -= 2</expr>;</expr_stmt>
        }</block></then></if>
        <block>{
          <decl_stmt><decl><type><name>register</name> <name>const</name> <name>char</name> *</type><name>cset</name></decl>;</decl_stmt>      <comment type="block">/* Use registers for speed */</comment>
          <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>base</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>cset</name> = &amp;<name><name>aDigits</name><index>[<expr><name>infop</name>-&gt;<name>charset</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base</name> = <name>infop</name>-&gt;<name>base</name></expr>;</expr_stmt>
          <do>do<block>{                                           <comment type="block">/* Convert to ascii */</comment>
            <expr_stmt><expr>*(--<name>bufpt</name>) = <name><name>cset</name><index>[<expr><name>longvalue</name>%<name>base</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>longvalue</name> = <name>longvalue</name>/<name>base</name></expr>;</expr_stmt>
          }</block>while<condition>( <expr><name>longvalue</name>&gt;0</expr> )</condition>;</do>
        }</block>
        <expr_stmt><expr><name>length</name> = (<name>int</name>)(&amp;<name><name>buf</name><index>[<expr><name>etBUFSIZE</name>-1</expr>]</index></name>-<name>bufpt</name>)</expr>;</expr_stmt>
        <for>for(<init><expr><name>idx</name>=<name>precision</name>-<name>length</name></expr>;</init> <condition><expr><name>idx</name>&gt;0</expr>;</condition> <incr><expr><name>idx</name>--</expr></incr>)<block>{
          <expr_stmt><expr>*(--<name>bufpt</name>) = '0'</expr>;</expr_stmt>                             <comment type="block">/* Zero pad */</comment>
        }</block></for>
        <if>if<condition>( <expr><name>prefix</name></expr> )</condition><then> <expr_stmt><expr>*(--<name>bufpt</name>) = <name>prefix</name></expr>;</expr_stmt></then></if>               <comment type="block">/* Add sign */</comment>
        <if>if<condition>( <expr><name>flag_alternateform</name> &amp;&amp; <name>infop</name>-&gt;<name>prefix</name></expr> )</condition><then><block>{      <comment type="block">/* Add "0" or "0x" */</comment>
          <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>pre</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name></type> <name>x</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>pre</name> = &amp;<name><name>aPrefix</name><index>[<expr><name>infop</name>-&gt;<name>prefix</name></expr>]</index></name></expr>;</expr_stmt>
          <for>for(<init>;</init> <condition><expr>(<name>x</name>=(*<name>pre</name>))!=0</expr>;</condition> <incr><expr><name>pre</name>++</expr></incr>) <expr_stmt><expr>*(--<name>bufpt</name>) = <name>x</name></expr>;</expr_stmt></for>
        }</block></then></if>
        <expr_stmt><expr><name>length</name> = (<name>int</name>)(&amp;<name><name>buf</name><index>[<expr><name>etBUFSIZE</name>-1</expr>]</index></name>-<name>bufpt</name>)</expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>etFLOAT</name></expr>:
      </case><case>case <expr><name>etEXP</name></expr>:
      </case><case>case <expr><name>etGENERIC</name></expr>:
        <expr_stmt><expr><name>realvalue</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
        <if>if<condition>( <expr><name>precision</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>precision</name> = 6</expr>;</expr_stmt></then></if>         <comment type="block">/* Set default precision */</comment>
        <if>if<condition>( <expr><name>precision</name>&gt;<name>etBUFSIZE</name>/2-10</expr> )</condition><then> <expr_stmt><expr><name>precision</name> = <name>etBUFSIZE</name>/2-10</expr>;</expr_stmt></then></if>
        <if>if<condition>( <expr><name>realvalue</name>&lt;0.0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>realvalue</name> = -<name>realvalue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> = '-'</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <if>if<condition>( <expr><name>flag_plussign</name></expr> )</condition><then>          <expr_stmt><expr><name>prefix</name> = '+'</expr>;</expr_stmt></then>
          <else>else <if>if<condition>( <expr><name>flag_blanksign</name></expr> )</condition><then>    <expr_stmt><expr><name>prefix</name> = ' '</expr>;</expr_stmt></then>
          <else>else                         <expr_stmt><expr><name>prefix</name> = 0</expr>;</expr_stmt></else></if></else></if>
        }</block></else></if>
        <if>if<condition>( <expr><name>xtype</name>==<name>etGENERIC</name> &amp;&amp; <name>precision</name>&gt;0</expr> )</condition><then> <expr_stmt><expr><name>precision</name>--</expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
        <comment type="block">/* Rounding works like BSD when the constant 0.4999 is used.  Wierd! */</comment>
        for(idx=precision, rounder=0.4999; idx&gt;0; idx--, rounder*=0.1);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* It makes more sense to use 0.5 */</comment>
        <for>for(<init><expr><name>idx</name>=<name>precision</name></expr>, <expr><name>rounder</name>=0.5</expr>;</init> <condition><expr><name>idx</name>&gt;0</expr>;</condition> <incr><expr><name>idx</name>--</expr>, <expr><name>rounder</name>*=0.1</expr></incr>)<block>{}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if<condition>( <expr><name>xtype</name>==<name>etFLOAT</name></expr> )</condition><then> <expr_stmt><expr><name>realvalue</name> += <name>rounder</name></expr>;</expr_stmt></then></if>
        <comment type="block">/* Normalize realvalue to within 10.0 &gt; realvalue &gt;= 1.0 */</comment>
        <expr_stmt><expr><name>exp</name> = 0</expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr>(<name>double</name>)<name>realvalue</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>bufpt</name> = "NaN"</expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name> = 3</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <if>if<condition>( <expr><name>realvalue</name>&gt;0.0</expr> )</condition><then><block>{
          <while>while<condition>( <expr><name>realvalue</name>&gt;=1e32 &amp;&amp; <name>exp</name>&lt;=350</expr> )</condition><block>{ <expr_stmt><expr><name>realvalue</name> *= 1e-32</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>+=32</expr>;</expr_stmt> }</block></while>
          <while>while<condition>( <expr><name>realvalue</name>&gt;=1e8 &amp;&amp; <name>exp</name>&lt;=350</expr> )</condition><block>{ <expr_stmt><expr><name>realvalue</name> *= 1e-8</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>+=8</expr>;</expr_stmt> }</block></while>
          <while>while<condition>( <expr><name>realvalue</name>&gt;=10.0 &amp;&amp; <name>exp</name>&lt;=350</expr> )</condition><block>{ <expr_stmt><expr><name>realvalue</name> *= 0.1</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>++</expr>;</expr_stmt> }</block></while>
          <while>while<condition>( <expr><name>realvalue</name>&lt;1e-8</expr> )</condition><block>{ <expr_stmt><expr><name>realvalue</name> *= 1e8</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>-=8</expr>;</expr_stmt> }</block></while>
          <while>while<condition>( <expr><name>realvalue</name>&lt;1.0</expr> )</condition><block>{ <expr_stmt><expr><name>realvalue</name> *= 10.0</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>--</expr>;</expr_stmt> }</block></while>
          <if>if<condition>( <expr><name>exp</name>&gt;350</expr> )</condition><then><block>{
            <if>if<condition>( <expr><name>prefix</name>=='-'</expr> )</condition><then><block>{
              <expr_stmt><expr><name>bufpt</name> = "-Inf"</expr>;</expr_stmt>
            }</block></then><else>else <if>if<condition>( <expr><name>prefix</name>=='+'</expr> )</condition><then><block>{
              <expr_stmt><expr><name>bufpt</name> = "+Inf"</expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><name>bufpt</name> = "Inf"</expr>;</expr_stmt>
            }</block></else></if></else></if>
            <expr_stmt><expr><name>length</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>bufpt</name> = <name>buf</name></expr>;</expr_stmt>
        <comment type="block">/*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */</comment>
        <expr_stmt><expr><name>flag_exp</name> = <name>xtype</name>==<name>etEXP</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>xtype</name>!=<name>etFLOAT</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>realvalue</name> += <name>rounder</name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>realvalue</name>&gt;=10.0</expr> )</condition><then><block>{ <expr_stmt><expr><name>realvalue</name> *= 0.1</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name>++</expr>;</expr_stmt> }</block></then></if>
        }</block></then></if>
        <if>if<condition>( <expr><name>xtype</name>==<name>etGENERIC</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>flag_rtz</name> = !<name>flag_alternateform</name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>exp</name>&lt;-4 || <name>exp</name>&gt;<name>precision</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>xtype</name> = <name>etEXP</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>precision</name> = <name>precision</name> - <name>exp</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xtype</name> = <name>etFLOAT</name></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>flag_rtz</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
        <if>if<condition>( <expr><name>xtype</name>==<name>etEXP</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>e2</name> = 0</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>e2</name> = <name>exp</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>nsd</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>flag_dp</name> = (<name>precision</name>&gt;0 ?1:0) | <name>flag_alternateform</name> | <name>flag_altform2</name></expr>;</expr_stmt>
        <comment type="block">/* The sign in front of the number */</comment>
        <if>if<condition>( <expr><name>prefix</name></expr> )</condition><then><block>{
          <expr_stmt><expr>*(<name>bufpt</name>++) = <name>prefix</name></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* Digits prior to the decimal point */</comment>
        <if>if<condition>( <expr><name>e2</name>&lt;0</expr> )</condition><then><block>{
          <expr_stmt><expr>*(<name>bufpt</name>++) = '0'</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <for>for(<init>;</init> <condition><expr><name>e2</name>&gt;=0</expr>;</condition> <incr><expr><name>e2</name>--</expr></incr>)<block>{
            <expr_stmt><expr>*(<name>bufpt</name>++) = <call><name>et_getdigit</name><argument_list>(<argument><expr>&amp;<name>realvalue</name></expr></argument>,<argument><expr>&amp;<name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        }</block></else></if>
        <comment type="block">/* The decimal point */</comment>
        <if>if<condition>( <expr><name>flag_dp</name></expr> )</condition><then><block>{
          <expr_stmt><expr>*(<name>bufpt</name>++) = '.'</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* "0" digits after the decimal point but before the first
        ** significant digit of the number */</comment>
        <for>for(<init><expr><name>e2</name>++</expr>;</init> <condition><expr><name>e2</name>&lt;0</expr>;</condition> <incr><expr><name>precision</name>--</expr>, <expr><name>e2</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>precision</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*(<name>bufpt</name>++) = '0'</expr>;</expr_stmt>
        }</block></for>
        <comment type="block">/* Significant digits after the decimal point */</comment>
        <while>while<condition>( <expr>(<name>precision</name>--)&gt;0</expr> )</condition><block>{
          <expr_stmt><expr>*(<name>bufpt</name>++) = <call><name>et_getdigit</name><argument_list>(<argument><expr>&amp;<name>realvalue</name></expr></argument>,<argument><expr>&amp;<name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <comment type="block">/* Remove trailing zeros and the "." if no digits follow the "." */</comment>
        <if>if<condition>( <expr><name>flag_rtz</name> &amp;&amp; <name>flag_dp</name></expr> )</condition><then><block>{
          <while>while<condition>( <expr><name><name>bufpt</name><index>[<expr>-1</expr>]</index></name>=='0'</expr> )</condition> <expr_stmt><expr>*(--<name>bufpt</name>) = 0</expr>;</expr_stmt></while>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bufpt</name>&gt;<name>buf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name><name>bufpt</name><index>[<expr>-1</expr>]</index></name>=='.'</expr> )</condition><then><block>{
            <if>if<condition>( <expr><name>flag_altform2</name></expr> )</condition><then><block>{
              <expr_stmt><expr>*(<name>bufpt</name>++) = '0'</expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr>*(--<name>bufpt</name>) = 0</expr>;</expr_stmt>
            }</block></else></if>
          }</block></then></if>
        }</block></then></if>
        <comment type="block">/* Add the "eNNN" suffix */</comment>
        <if>if<condition>( <expr><name>flag_exp</name> || <name>xtype</name>==<name>etEXP</name></expr> )</condition><then><block>{
          <expr_stmt><expr>*(<name>bufpt</name>++) = <name><name>aDigits</name><index>[<expr><name>infop</name>-&gt;<name>charset</name></expr>]</index></name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>exp</name>&lt;0</expr> )</condition><then><block>{
            <expr_stmt><expr>*(<name>bufpt</name>++) = '-'</expr>;</expr_stmt> <expr_stmt><expr><name>exp</name> = -<name>exp</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr>*(<name>bufpt</name>++) = '+'</expr>;</expr_stmt>
          }</block></else></if>
          <if>if<condition>( <expr><name>exp</name>&gt;=100</expr> )</condition><then><block>{
            <expr_stmt><expr>*(<name>bufpt</name>++) = (<name>char</name>)((<name>exp</name>/100)+'0')</expr>;</expr_stmt>        <comment type="block">/* 100's digit */</comment>
            <expr_stmt><expr><name>exp</name> %= 100</expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr>*(<name>bufpt</name>++) = (<name>char</name>)(<name>exp</name>/10+'0')</expr>;</expr_stmt>             <comment type="block">/* 10's digit */</comment>
          <expr_stmt><expr>*(<name>bufpt</name>++) = (<name>char</name>)(<name>exp</name>%10+'0')</expr>;</expr_stmt>             <comment type="block">/* 1's digit */</comment>
        }</block></then></if>
        <expr_stmt><expr>*<name>bufpt</name> = 0</expr>;</expr_stmt>

        <comment type="block">/* The converted number is in buf[] and zero terminated. Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions. */</comment>
        <expr_stmt><expr><name>length</name> = (<name>int</name>)(<name>bufpt</name>-<name>buf</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> = <name>buf</name></expr>;</expr_stmt>

        <comment type="block">/* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */</comment>
        <if>if<condition>( <expr><name>flag_zeropad</name> &amp;&amp; !<name>flag_leftjustify</name> &amp;&amp; <name>length</name> &lt; <name>width</name></expr>)</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nPad</name> =<init> <expr><name>width</name> - <name>length</name></expr></init></decl>;</decl_stmt>
          <for>for(<init><expr><name>i</name>=<name>width</name></expr>;</init> <condition><expr><name>i</name>&gt;=<name>nPad</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
            <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>bufpt</name><index>[<expr><name>i</name>-<name>nPad</name></expr>]</index></name></expr>;</expr_stmt>
          }</block></for>
          <expr_stmt><expr><name>i</name> = <name>prefix</name>!=0</expr>;</expr_stmt>
          <while>while<condition>( <expr><name>nPad</name>--</expr> )</condition> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>i</name>++</expr>]</index></name> = '0'</expr>;</expr_stmt></while>
          <expr_stmt><expr><name>length</name> = <name>width</name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
      </case><case>case <expr><name>etSIZE</name></expr>:
        <expr_stmt><expr>*(<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name>*</expr></argument>)</argument_list></call>) = <name>pAccum</name>-&gt;<name>nChar</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <name>width</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>etPERCENT</name></expr>:
        <expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '%'</expr>;</expr_stmt>
        <expr_stmt><expr><name>bufpt</name> = <name>buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = 1</expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>etCHARX</name></expr>:
        <expr_stmt><expr><name>c</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>precision</name>&gt;=0</expr> )</condition><then><block>{
          <for>for(<init><expr><name>idx</name>=1</expr>;</init> <condition><expr><name>idx</name>&lt;<name>precision</name></expr>;</condition> <incr><expr><name>idx</name>++</expr></incr>) <expr_stmt><expr><name><name>buf</name><index>[<expr><name>idx</name></expr>]</index></name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt></for>
          <expr_stmt><expr><name>length</name> = <name>precision</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>length</name> =1</expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>bufpt</name> = <name>buf</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>etSTRING</name></expr>:
      </case><case>case <expr><name>etDYNSTRING</name></expr>:
        <expr_stmt><expr><name>bufpt</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>bufpt</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>bufpt</name> = ""</expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>xtype</name>==<name>etDYNSTRING</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>zExtra</name> = <name>bufpt</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <if>if<condition>( <expr><name>precision</name>&gt;=0</expr> )</condition><then><block>{
          <for>for(<init><expr><name>length</name>=0</expr>;</init> <condition><expr><name>length</name>&lt;<name>precision</name> &amp;&amp; <name><name>bufpt</name><index>[<expr><name>length</name></expr>]</index></name></expr>;</condition> <incr><expr><name>length</name>++</expr></incr>)<block>{}</block></for>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>length</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>bufpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>etSQLESCAPE</name></expr>:
      </case><case>case <expr><name>etSQLESCAPE2</name></expr>:
      </case><case>case <expr><name>etSQLESCAPE3</name></expr>: <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>n</name>, <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>needQuote</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>q</name> =<init> <expr>((<name>xtype</name>==<name>etSQLESCAPE3</name>)?'"':'\'')</expr></init></decl>;</decl_stmt>   <comment type="block">/* Quote character */</comment>
        <decl_stmt><decl><type><name>char</name> *</type><name>escarg</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>isnull</name> = <name>escarg</name>==0</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>isnull</name></expr> )</condition><then> <expr_stmt><expr><name>escarg</name> = (<name>xtype</name>==<name>etSQLESCAPE2</name> ? "NULL" : "(NULL)")</expr>;</expr_stmt></then></if>
        <for>for(<init><expr><name>i</name>=<name>n</name>=0</expr>;</init> <condition><expr>(<name>ch</name>=<name><name>escarg</name><index>[<expr><name>i</name></expr>]</index></name>)!=0</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><name>ch</name>==<name>q</name></expr> )</condition><then>  <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if>
        }</block></for>
        <expr_stmt><expr><name>needQuote</name> = !<name>isnull</name> &amp;&amp; <name>xtype</name>==<name>etSQLESCAPE2</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> += <name>i</name> + 1 + <name>needQuote</name>*2</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>n</name>&gt;<name>etBUFSIZE</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>bufpt</name> = <name>zExtra</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>bufpt</name>==0</expr> )</condition><then><block>{
            <expr_stmt><expr><name>pAccum</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
            <return>return;</return>
          }</block></then></if>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>bufpt</name> = <name>buf</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>q</name></expr>;</expr_stmt></then></if>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr>(<name>ch</name>=<name><name>escarg</name><index>[<expr><name>i</name></expr>]</index></name>)!=0</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>ch</name>==<name>q</name></expr> )</condition><then> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>ch</name></expr>;</expr_stmt></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>q</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>bufpt</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <name>j</name></expr>;</expr_stmt>
        <comment type="block">/* The precision is ignored on %q and %Q */</comment>
        <comment type="block">/* if( precision&gt;=0 &amp;&amp; precision&lt;length ) length = precision; */</comment>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>etTOKEN</name></expr>: <block>{
        <decl_stmt><decl><type><name>Token</name> *</type><name>pToken</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>Token</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pToken</name></expr> )</condition><then><block>{
          <macro><name>sqlite3StrAccumAppend</name><argument_list>(<argument>pAccum</argument>, <argument>(const char*)pToken-&gt;z</argument>, <argument>pToken-&gt;n</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>length</name> = <name>width</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
      }</block>
      </case><case>case <expr><name>etSRCLIST</name></expr>: <block>{
        <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSrc</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>SrcList</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>k</name>&gt;=0 &amp;&amp; <name>k</name>&lt;<name>pSrc</name>-&gt;<name>nSrc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pItem</name>-&gt;<name>zDatabase</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zDatabase</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr>"."</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = <name>width</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
      }</block>
    </case>}</block></switch><comment type="block">/* End switch over the format type */</comment>
    <comment type="block">/*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.  The field width is "width".  Do
    ** the output.
    */</comment>
    <if>if<condition>( <expr>!<name>flag_leftjustify</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> = <name>width</name>-<name>length</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nspace</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>appendSpace</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>nspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>length</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>bufpt</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>flag_leftjustify</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>nspace</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>nspace</name> = <name>width</name>-<name>length</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nspace</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>appendSpace</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>nspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>zExtra</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for><comment type="block">/* End for loop over the format string */</comment>
}</block></function> <comment type="block">/* End of function */</comment>

<comment type="block">/*
** Append N bytes of text from z to the StrAccum object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StrAccumAppend</name><parameter_list>(<param><decl><type><name>StrAccum</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>tooBig</name> | <name>p</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>N</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>N</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>N</name>==0 || <name>z</name>==0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nChar</name>+<name>N</name> &gt;= <name>p</name>-&gt;<name>nAlloc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zNew</name></decl>;</decl_stmt>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>useMalloc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>tooBig</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>N</name> = <name>p</name>-&gt;<name>nAlloc</name> - <name>p</name>-&gt;<name>nChar</name> - 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>N</name>&lt;=0</expr> )</condition><then><block>{
        <return>return;</return>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>szNew</name> =<init> <expr><name>p</name>-&gt;<name>nChar</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>szNew</name> += <name>N</name> + 1</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>szNew</name> &gt; <name>p</name>-&gt;<name>mxAlloc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3StrAccumReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>tooBig</name> = 1</expr>;</expr_stmt>
        <return>return;</return>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>nAlloc</name> = (<name>int</name>)<name>szNew</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>zNew</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nAlloc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zText</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3StrAccumReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>zText</name> = <name>zNew</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3StrAccumReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></else></if>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name><name>zText</name><index>[<expr><name>p</name>-&gt;<name>nChar</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nChar</name> += <name>N</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Finish off a string by making sure it is zero-terminated.
** Return a pointer to the resulting string.  Return a NULL
** pointer if any kind of error was encountered.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3StrAccumFinish</name><parameter_list>(<param><decl><type><name>StrAccum</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>zText</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name><name>zText</name><index>[<expr><name>p</name>-&gt;<name>nChar</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>useMalloc</name> &amp;&amp; <name>p</name>-&gt;<name>zText</name>==<name>p</name>-&gt;<name>zBase</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>zText</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nChar</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>zText</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zText</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zBase</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nChar</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>p</name>-&gt;<name>zText</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Reset an StrAccum string.  Reclaim all malloced memory.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StrAccumReset</name><parameter_list>(<param><decl><type><name>StrAccum</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>zText</name>!=<name>p</name>-&gt;<name>zBase</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>zText</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Initialize a string accumulator
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StrAccumInit</name><parameter_list>(<param><decl><type><name>StrAccum</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBase</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>mx</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>p</name>-&gt;<name>zText</name> = <name>p</name>-&gt;<name>zBase</name> = <name>zBase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nChar</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nAlloc</name> = <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>mxAlloc</name> = <name>mx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>useMalloc</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>tooBig</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>mallocFailed</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3VMPrintf</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBase</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr><name>zBase</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zBase</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>db</name> ? <name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name> : <name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>acc</name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VXPrintf</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>acc</name>.<name>mallocFailed</name> &amp;&amp; <name>db</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3MPrintf</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Like sqlite3MPrintf(), but call sqlite3DbFree() on zStr after formatting
** the string and before returnning.  This routine is intended to be used
** to modify an existing string.  For example:
**
**       x = sqlite3MPrintf(db, x, "prefix %s suffix", x);
**
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3MAppendf</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zStr</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Print into memory obtained from sqlite3_malloc().  Omit the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3_vmprintf</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBase</name><index>[<expr><name>SQLITE_PRINT_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr><name>zBase</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zBase</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VXPrintf</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Print into memory obtained from sqlite3_malloc()().  Omit the internal
** %-conversion extensions.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3_mprintf</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3_vmprintf</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** sqlite3_snprintf() works like snprintf() except that it ignores the
** current locale settings.  This is important for SQLite because we
** are not able to use a "," as the decimal point in place of "." as
** specified by some locales.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3_snprintf</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>n</name>&lt;=0</expr> )</condition><then><block>{
    <return>return <expr><name>zBuf</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>acc</name>.<name>useMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VXPrintf</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** A version of printf() that understands %lld.  Used for debugging.
** The printf() built into some versions of windows does not understand %lld
** and segfaults if you give it a long long int.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DebugPrintf</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>acc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr>500</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>acc</name>.<name>useMalloc</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VXPrintf</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr>&amp;<name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>,<argument><expr>"%s"</expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
