<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="pager.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This is the implementation of the page cache subsystem or "pager".
** 
** The pager is used to access a database disk file.  It implements
** atomic commit and rollback through the use of a journal file that
** is separate from the database file.  The pager also implements file
** locking to prevent two processes from writing the same database
** file simultaneously, or one process from reading the database while
** another is writing.
**
** @(#) $Id: pager.c,v 1.551 2009/01/14 23:03:41 drh Exp $
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Macros for troubleshooting.  Normally turned off
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
int sqlite3PagerTrace=1;  <comment type="block">/* True to enable tracing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>sqlite3DebugPrintf</name> <name>printf</name></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGERTRACE</name>(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGERTRACE</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following two macros are used within the PAGERTRACE() macros above
** to print out file-descriptors. 
**
** PAGERID() takes a pointer to a Pager struct as its argument. The
** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file
** struct as its argument.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGERID</name>(p) ((int)(p-&gt;fd))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FILEHANDLEID</name>(fd) ((int)fd)</cpp:define>

<comment type="block">/*
** The page cache as a whole is always in one of the following
** states:
**
**   PAGER_UNLOCK        The page cache is not currently reading or 
**                       writing the database file.  There is no
**                       data held in memory.  This is the initial
**                       state.
**
**   PAGER_SHARED        The page cache is reading the database.
**                       Writing is not permitted.  There can be
**                       multiple readers accessing the same database
**                       file at the same time.
**
**   PAGER_RESERVED      This process has reserved the database for writing
**                       but has not yet made any changes.  Only one process
**                       at a time can reserve the database.  The original
**                       database file has not been modified so other
**                       processes may still be reading the on-disk
**                       database file.
**
**   PAGER_EXCLUSIVE     The page cache is writing the database.
**                       Access is exclusive.  No other processes or
**                       threads can be reading or writing while one
**                       process is writing.
**
**   PAGER_SYNCED        The pager moves to this state from PAGER_EXCLUSIVE
**                       after all dirty pages have been written to the
**                       database file and the file has been synced to
**                       disk. All that remains to do is to remove or
**                       truncate the journal file and the transaction 
**                       will be committed.
**
** The page cache comes up in PAGER_UNLOCK.  The first time a
** sqlite3PagerGet() occurs, the state transitions to PAGER_SHARED.
** After all pages have been released using sqlite_page_unref(),
** the state transitions back to PAGER_UNLOCK.  The first time
** that sqlite3PagerWrite() is called, the state transitions to
** PAGER_RESERVED.  (Note that sqlite3PagerWrite() can only be
** called on an outstanding page which means that the pager must
** be in PAGER_SHARED before it transitions to PAGER_RESERVED.)
** PAGER_RESERVED means that there is an open rollback journal.
** The transition to PAGER_EXCLUSIVE occurs before any changes
** are made to the database file, though writes to the rollback
** journal occurs with just PAGER_RESERVED.  After an sqlite3PagerRollback()
** or sqlite3PagerCommitPhaseTwo(), the state can go back to PAGER_SHARED,
** or it can stay at PAGER_EXCLUSIVE if we are in exclusive access mode.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_UNLOCK</name>      0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_SHARED</name>      1</cpp:define>   <comment type="block">/* same as SHARED_LOCK */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_RESERVED</name>    2</cpp:define>   <comment type="block">/* same as RESERVED_LOCK */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_EXCLUSIVE</name>   4</cpp:define>   <comment type="block">/* same as EXCLUSIVE_LOCK */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_SYNCED</name>      5</cpp:define>

<comment type="block">/*
** This macro rounds values up so that if the value is an address it
** is guaranteed to be an address that is aligned to an 8-byte boundary.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORCE_ALIGNMENT</name>(X)   (((X)+7)&amp;~7)</cpp:define>

<comment type="block">/*
** A macro used for invoking the codec if there is one
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CODEC1</name>(P,D,N,X) if( P-&gt;xCodec!=0 ){ P-&gt;xCodec(P-&gt;pCodecArg,D,N,X); }</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CODEC2</name>(P,D,N,X) ((char*)(P-&gt;xCodec!=0?P-&gt;xCodec(P-&gt;pCodecArg,D,N,X):D))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CODEC1</name>(P,D,N,X)</cpp:define> <comment type="block">/* NO-OP */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CODEC2</name>(P,D,N,X) ((char*)D)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The maximum allowed sector size. 16MB. If the xSectorsize() method 
** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.
** This could conceivably cause corruption following a power failure on
** such a system. This is currently an undocumented limit.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_SECTOR_SIZE</name> 0x0100000</cpp:define>

<comment type="block">/*
** An instance of the following structure is allocated for each active
** savepoint and statement transaction in the system. All such structures
** are stored in the Pager.aSavepoint[] array, which is allocated and
** resized using sqlite3Realloc().
**
** When a savepoint is created, the PagerSavepoint.iHdrOffset field is
** set to 0. If a journal-header is written into the main journal while
** the savepoint is active, then iHdrOffset is set to the byte offset 
** immediately following the last journal record written into the main
** journal before the journal-header. This is required during savepoint
** rollback (see pagerPlaybackSavepoint()).
*/</comment>
<typedef>typedef <type><struct>struct <name>PagerSavepoint</name> PagerSavepoint;</struct></type></typedef>
<struct>struct <name>PagerSavepoint</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>i64</name></type> <name>iOffset</name></decl>;</decl_stmt>                 <comment type="block">/* Starting offset in main journal */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOffset</name></decl>;</decl_stmt>              <comment type="block">/* See above */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> *</type><name>pInSavepoint</name></decl>;</decl_stmt>        <comment type="block">/* Set of pages in this savepoint */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nOrig</name></decl>;</decl_stmt>                  <comment type="block">/* Original number of pages in file */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iSubRec</name></decl>;</decl_stmt>                <comment type="block">/* Index of first record in sub-journal */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A open page cache is an instance of the following structure.
**
** Pager.errCode may be set to SQLITE_IOERR, SQLITE_CORRUPT, or
** or SQLITE_FULL. Once one of the first three errors occurs, it persists
** and is returned as the result of every major pager API call.  The
** SQLITE_FULL return code is slightly different. It persists only until the
** next successful rollback is performed on the pager cache. Also,
** SQLITE_FULL does not affect the sqlite3PagerGet() and sqlite3PagerLookup()
** APIs, they may still be used successfully.
**
** Managing the size of the database file in pages is a little complicated.
** The variable Pager.dbSize contains the number of pages that the database
** image currently contains. As the database image grows or shrinks this
** variable is updated. The variable Pager.dbFileSize contains the number
** of pages in the database file. This may be different from Pager.dbSize
** if some pages have been appended to the database image but not yet written
** out from the cache to the actual file on disk. Or if the image has been
** truncated by an incremental-vacuum operation. The Pager.dbOrigSize variable
** contains the number of pages in the database image when the current
** transaction was opened. The contents of all three of these variables is
** only guaranteed to be correct if the boolean Pager.dbSizeValid is true.
*/</comment>
<struct>struct <name>Pager</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl>;</decl_stmt>          <comment type="block">/* OS functions to use for IO */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>journalOpen</name></decl>;</decl_stmt>             <comment type="block">/* True if journal file descriptors is valid */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>journalStarted</name></decl>;</decl_stmt>          <comment type="block">/* True if header of journal is synced */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>useJournal</name></decl>;</decl_stmt>              <comment type="block">/* Use a rollback journal on this file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noReadlock</name></decl>;</decl_stmt>              <comment type="block">/* Do not bother to obtain readlocks */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noSync</name></decl>;</decl_stmt>                  <comment type="block">/* Do not sync the journal if true */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>fullSync</name></decl>;</decl_stmt>                <comment type="block">/* Do extra syncs of the journal for robustness */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sync_flags</name></decl>;</decl_stmt>              <comment type="block">/* One of SYNC_NORMAL or SYNC_FULL */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>state</name></decl>;</decl_stmt>                   <comment type="block">/* PAGER_UNLOCK, _SHARED, _RESERVED, etc. */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>tempFile</name></decl>;</decl_stmt>                <comment type="block">/* zFilename is a temporary file */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>readOnly</name></decl>;</decl_stmt>                <comment type="block">/* True for a read-only database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>needSync</name></decl>;</decl_stmt>                <comment type="block">/* True if an fsync() is needed on the journal */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>dirtyCache</name></decl>;</decl_stmt>              <comment type="block">/* True if cached pages have changed */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>memDb</name></decl>;</decl_stmt>                   <comment type="block">/* True to inhibit all file I/O */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>setMaster</name></decl>;</decl_stmt>               <comment type="block">/* True if a m-j name has been written to jrnl */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>doNotSync</name></decl>;</decl_stmt>               <comment type="block">/* Boolean. While true, do not spill the cache */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>exclusiveMode</name></decl>;</decl_stmt>           <comment type="block">/* Boolean. True if locking_mode==EXCLUSIVE */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>journalMode</name></decl>;</decl_stmt>             <comment type="block">/* On of the PAGER_JOURNALMODE_* values */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>dbModified</name></decl>;</decl_stmt>              <comment type="block">/* True if there are any changes to the Db */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>changeCountDone</name></decl>;</decl_stmt>         <comment type="block">/* Set after incrementing the change-counter */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>dbSizeValid</name></decl>;</decl_stmt>             <comment type="block">/* Set when dbSize is correct */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbSize</name></decl>;</decl_stmt>                <comment type="block">/* Number of pages in the database */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbOrigSize</name></decl>;</decl_stmt>            <comment type="block">/* dbSize before the current transaction */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>dbFileSize</name></decl>;</decl_stmt>            <comment type="block">/* Number of pages in the database file */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>vfsFlags</name></decl>;</decl_stmt>               <comment type="block">/* Flags for sqlite3_vfs.xOpen() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errCode</name></decl>;</decl_stmt>                <comment type="block">/* One of several kinds of errors */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRec</name></decl>;</decl_stmt>                   <comment type="block">/* Number of pages written to the journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksumInit</name></decl>;</decl_stmt>              <comment type="block">/* Quasi-random value added to every checksum */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>stmtNRec</name></decl>;</decl_stmt>               <comment type="block">/* Number of records in stmt subjournal */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name></decl>;</decl_stmt>                 <comment type="block">/* Add this many bytes to each in-memory page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pageSize</name></decl>;</decl_stmt>               <comment type="block">/* Number of bytes in a page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                  <comment type="block">/* Total number of in-memory pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxPage</name></decl>;</decl_stmt>                 <comment type="block">/* Maximum number of pages to hold in cache */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>mxPgno</name></decl>;</decl_stmt>                <comment type="block">/* Maximum allowed size of the database */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> *</type><name>pInJournal</name></decl>;</decl_stmt>         <comment type="block">/* One bit for each page in the database file */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> *</type><name>pAlwaysRollback</name></decl>;</decl_stmt>    <comment type="block">/* One bit for each page marked always-rollback */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFilename</name></decl>;</decl_stmt>            <comment type="block">/* Name of the database file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zJournal</name></decl>;</decl_stmt>             <comment type="block">/* Name of the journal file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zDirectory</name></decl>;</decl_stmt>           <comment type="block">/* Directory hold database and journal files */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>fd</name>, *<name>jfd</name></decl>;</decl_stmt>     <comment type="block">/* File descriptors for database and journal */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>sjfd</name></decl>;</decl_stmt>         <comment type="block">/* File descriptor for the sub-journal*/</comment>
  <function_decl><type><name>int</name></type> (*<name>xBusyHandler</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Function to call when busy */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pBusyHandlerArg</name></decl>;</decl_stmt>      <comment type="block">/* Context argument for xBusyHandler */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalOff</name></decl>;</decl_stmt>             <comment type="block">/* Current byte offset in the journal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalHdr</name></decl>;</decl_stmt>             <comment type="block">/* Byte offset to previous journal header */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>sectorSize</name></decl>;</decl_stmt>             <comment type="block">/* Assumed sector size during rollback */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>nHit</name>, <name>nMiss</name></decl>;</decl_stmt>            <comment type="block">/* Cache hits and missing */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name>, <name>nWrite</name></decl>;</decl_stmt>          <comment type="block">/* Database pages read/written */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <function_decl><type><name>void</name></type> (*<name>xReiniter</name>)<parameter_list>(<param><decl><type><name>DbPage</name>*</type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Call this routine when reloading pages */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <function_decl><type><name>void</name> *</type>(*<name>xCodec</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>Pgno</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl> <comment type="block">/* Routine for en/decoding data */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pCodecArg</name></decl>;</decl_stmt>            <comment type="block">/* First argument to xCodec() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>char</name> *</type><name>pTmpSpace</name></decl>;</decl_stmt>            <comment type="block">/* Pager.pageSize bytes of space for tmp use */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>dbFileVers</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Changes whenever database file changes */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>journalSizeLimit</name></decl>;</decl_stmt>       <comment type="block">/* Size limit for persistent journal files */</comment>
  <decl_stmt><decl><type><name>PCache</name> *</type><name>pPCache</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to page cache object */</comment>
  <decl_stmt><decl><type><name>PagerSavepoint</name> *</type><name>aSavepoint</name></decl>;</decl_stmt> <comment type="block">/* Array of active savepoints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSavepoint</name></decl>;</decl_stmt>             <comment type="block">/* Number of elements in aSavepoint[] */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** The following global variables hold counters used for
** testing purposes only.  These variables do not exist in
** a non-testing build.  These variables are not thread-safe.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_readdb_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of full pages read from DB */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_writedb_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of full pages written to DB */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_writej_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Number of pages written to journal */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <name>PAGER_INCR</name>(v)  v++</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>PAGER_INCR</name>(v)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
** Journal files begin with the following magic string.  The data
** was obtained from /dev/random.  It is used only as a sanity check.
**
** Since version 2.8.0, the journal format contains additional sanity
** checking information.  If the power fails while the journal is being
** written, semi-random garbage data might appear in the journal
** file after power is restored.  If an attempt is then made
** to roll the journal back, the database could be corrupted.  The additional
** sanity checking data is an attempt to discover the garbage in the
** journal and ignore it.
**
** The sanity checking information for the new journal format consists
** of a 32-bit checksum on each page of data.  The checksum covers both
** the page number and the pPager-&gt;pageSize bytes of data for the page.
** This cksum is initialized to a 32-bit random value that appears in the
** journal file right after the header.  The random initializer is important,
** because garbage data that appears at the end of a journal is likely
** data that was once in other files that have now been deleted.  If the
** garbage data came from an obsolete journal file, the checksums might
** be correct.  But by initializing the checksum to random value which
** is different for every journal, we minimize that risk.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>aJournalMagic</name><index>[]</index></name> =<init> <expr><block>{
  <expr>0xd9</expr>, <expr>0xd5</expr>, <expr>0x05</expr>, <expr>0xf9</expr>, <expr>0x20</expr>, <expr>0xa1</expr>, <expr>0x63</expr>, <expr>0xd7</expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The size of the header and of each page in the journal is determined
** by the following macros.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>JOURNAL_PG_SZ</name>(pPager)  ((pPager-&gt;pageSize) + 8)</cpp:define>

<comment type="block">/*
** The journal header size for this pager. In the future, this could be
** set to some value read from the disk controller. The important
** characteristic is that it is the same size as a disk sector.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>JOURNAL_HDR_SZ</name>(pPager) (pPager-&gt;sectorSize)</cpp:define>

<comment type="block">/*
** The macro MEMDB is true if we are dealing with an in-memory database.
** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,
** the value of MEMDB will be a constant and the compiler will optimize
** out code that would never execute.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>MEMDB</name> 0</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>MEMDB</name> <name>pPager</name>-&gt;memDb</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Page number PAGER_MJ_PGNO is never used in an SQLite database (it is
** reserved for working around a windows/posix incompatibility). It is
** used in the journal to signify that the remainder of the journal file 
** is devoted to storing a master journal name - there are no more pages to
** roll back. See comments for function writeMasterJournal() for details.
*/</comment>
<comment type="block">/* #define PAGER_MJ_PGNO(x) (PENDING_BYTE/((x)-&gt;pageSize)) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_MJ_PGNO</name>(x) ((Pgno)((PENDING_BYTE/((x)-&gt;pageSize))+1))</cpp:define>

<comment type="block">/*
** The maximum legal page number is (2^31 - 1).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PAGER_MAX_PGNO</name> 2147483647</cpp:define>

<comment type="block">/*
** Return true if it is necessary to write page *pPg into the sub-journal.
** A page needs to be written into the sub-journal if there exists one
** or more open savepoints for which:
**
**   * The page-number is less than or equal to PagerSavepoint.nOrig, and
**   * The bit corresponding to the page-number is not set in
**     PagerSavepoint.pInSavepoint.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>subjRequiresPage</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name> =<init> <expr><name>pPg</name>-&gt;<name>pgno</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>PagerSavepoint</name> *</type><name>p</name> =<init> <expr>&amp;<name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>nOrig</name>&gt;=<name>pgno</name> &amp;&amp; 0==<call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pInSavepoint</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Return true if the page is already in the journal file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pageInJournal</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pPg</name>-&gt;<name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Read a 32-bit integer from the given file descriptor.  Store the integer
** that is read in *pRes.  Return SQLITE_OK if everything worked, or an
** error code is something goes wrong.
**
** All values are stored on disk as big-endian.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>read32bits</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>i64</name></type> <name>offset</name></decl></param>, <param><decl><type><name>u32</name> *</type><name>pRes</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ac</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pRes</name> = <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Write a 32-bit integer into a string buffer in big-endian byte order.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>put32bits</name>(A,B)  sqlite3Put4byte((u8*)A,B)</cpp:define>

<comment type="block">/*
** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK
** on success or an error code is something goes wrong.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>write32bits</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>fd</name></decl></param>, <param><decl><type><name>i64</name></type> <name>offset</name></decl></param>, <param><decl><type><name>u32</name></type> <name>val</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>ac</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** If file pFd is open, call sqlite3OsUnlock() on it.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>osUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>pFd</name></decl></param>, <param><decl><type><name>int</name></type> <name>eLock</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>pFd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><call><name>sqlite3OsUnlock</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><name>eLock</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** This function determines whether or not the atomic-write optimization
** can be used with this pager. The optimization can be used if:
**
**  (a) the value returned by OsDeviceCharacteristics() indicates that
**      a database page may be written atomically, and
**  (b) the value returned by OsSectorSize() is less than or equal
**      to the page size.
**
** If the optimization cannot be used, 0 is returned. If it can be used,
** then the value returned is the size of the journal file when it
** contains rollback data for exactly one page.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
<function><type><name>static</name> <name>int</name></type> <name>jrnlBufferSize</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>dc</name></decl>;</decl_stmt>           <comment type="block">/* Device characteristics */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSector</name></decl>;</decl_stmt>      <comment type="block">/* Sector size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>        <comment type="block">/* Page size */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>fd</name> =<init> <expr><name>pPager</name>-&gt;<name>fd</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>dc</name> = <call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSector</name> = <name>pPager</name>-&gt;<name>sectorSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>szPage</name> = <name>pPager</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC512</name>==(512&gt;&gt;8)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC64K</name>==(65536&gt;&gt;8)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>fd</name>-&gt;<name>pMethods</name> || 
       (<name>dc</name> &amp; (<name>SQLITE_IOCAP_ATOMIC</name>|(<name>szPage</name>&gt;&gt;8)) &amp;&amp; <name>nSector</name>&lt;=<name>szPage</name>)</expr> )</condition><then><block>{
    <return>return <expr><call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> + <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This function should be called when an error occurs within the pager
** code. The first argument is a pointer to the pager structure, the
** second the error-code about to be returned by a pager API function. 
** The value returned is a copy of the second argument to this function. 
**
** If the second argument is SQLITE_IOERR, SQLITE_CORRUPT, or SQLITE_FULL
** the error becomes persistent. Until the persisten error is cleared,
** subsequent API calls on this Pager will immediately return the same 
** error code.
**
** A persistent error indicates that the contents of the pager-cache 
** cannot be trusted. This state can be cleared by completely discarding 
** the contents of the pager-cache. If a transaction was active when
** the persistent error occured, then the rollback journal may need
** to be replayed.
*/</comment>
<function_decl><type><name>static</name> <name>void</name></type> <name>pager_unlock</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list>;</function_decl>
<function><type><name>static</name> <name>int</name></type> <name>pager_error</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> =<init> <expr><name>rc</name> &amp; 0xff</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(
       <argument><expr><name>pPager</name>-&gt;<name>errCode</name>==<name>SQLITE_FULL</name> ||
       <name>pPager</name>-&gt;<name>errCode</name>==<name>SQLITE_OK</name> ||
       (<name>pPager</name>-&gt;<name>errCode</name> &amp; 0xff)==<name>SQLITE_IOERR</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(
    <expr><name>rc2</name>==<name>SQLITE_FULL</name> ||
    <name>rc2</name>==<name>SQLITE_IOERR</name> ||
    <name>rc2</name>==<name>SQLITE_CORRUPT</name></expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>errCode</name> = <name>rc</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_UNLOCK</name> 
     &amp;&amp; <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>==0</expr> 
    )</condition><then><block>{
      <comment type="block">/* If the pager is already unlocked, call pager_unlock() now to
      ** clear the error state and ensure that the pager-cache is 
      ** completely empty.
      */</comment>
      <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If SQLITE_CHECK_PAGES is defined then we do some sanity checking
** on the cache using a hash function.  This is used for testing
** and debugging only.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
<comment type="block">/*
** Return a 32-bit hash of the page data for pPage.
*/</comment>
<function><type><name>static</name> <name>u32</name></type> <name>pager_datahash</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nByte</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>pData</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>hash</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nByte</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>hash</name> = (<name>hash</name>*1039) + <name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>hash</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>u32</name></type> <name>pager_pagehash</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <return>return <macro><name>pager_datahash</name><argument_list>(<argument>pPage-&gt;pPager-&gt;pageSize</argument>, <argument>(unsigned char *)pPage-&gt;pData</argument>)</argument_list></macro>;</return>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>pager_set_pagehash</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pageHash</name> = <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES
** is defined, and NDEBUG is not defined, an assert() statement checks
** that the page is either dirty or still matches the calculated page-hash.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CHECK_PAGE</name>(x) checkPage(x)</cpp:define>
<function><type><name>static</name> <name>void</name></type> <name>checkPage</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPg</name>-&gt;<name>pageHash</name> || <name>pPager</name>-&gt;<name>errCode</name>
      || (<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name>) || <name>pPg</name>-&gt;<name>pageHash</name>==<call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>pager_datahash</name>(X,Y)  0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>pager_pagehash</name>(X)  0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CHECK_PAGE</name>(x)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_CHECK_PAGES */</comment>

<comment type="block">/*
** When this is called the journal file for pager pPager must be open.
** The master journal file name is read from the end of the file and 
** written into memory supplied by the caller. 
**
** zMaster must point to a buffer of at least nMaster bytes allocated by
** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there is
** enough space to write the master journal name). If the master journal
** name in the journal is longer than nMaster bytes (including a
** nul-terminator), then this is handled as if no master journal name
** were present in the journal.
**
** If no master journal file name is present zMaster[0] is set to 0 and
** SQLITE_OK returned.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>readMasterJournal</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>pJrnl</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zMaster</name></decl></param>, <param><decl><type><name>u32</name></type> <name>nMaster</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>u</name></decl>;</decl_stmt>                   <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aMagic</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* A buffer to hold the magic header */</comment>

  <expr_stmt><expr><name><name>zMaster</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr>&amp;<name>szJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>szJ</name>&lt;16</expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>szJ</name>-16</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <if>if<condition>( <expr><name>len</name>&gt;=<name>nMaster</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>szJ</name>-12</expr></argument>, <argument><expr>&amp;<name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>aMagic</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name>szJ</name>-8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || <call><name>memcmp</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pJrnl</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>szJ</name>-16-<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name><name>zMaster</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <comment type="block">/* See if the checksum matches the master journal name */</comment>
  <for>for(<init><expr><name>u</name>=0</expr>;</init> <condition><expr><name>u</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>u</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>cksum</name> -= <name><name>zMaster</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
   }</block></for>
  <if>if<condition>( <expr><name>cksum</name></expr> )</condition><then><block>{
    <comment type="block">/* If the checksum doesn't add up, then one or more of the disk sectors
    ** containing the master journal filename is corrupted. This means
    ** definitely roll back, so just return SQLITE_OK and report a (nul)
    ** master-journal filename.
    */</comment>
    <expr_stmt><expr><name><name>zMaster</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  }</block></then></if>
   
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Seek the journal file descriptor to the next sector boundary where a
** journal header may be read or written. Pager.journalOff is updated with
** the new seek offset.
**
** i.e for a sector size of 512:
**
** Input Offset              Output Offset
** ---------------------------------------
** 0                         0
** 512                       512
** 100                       512
** 2000                      2048
** 
*/</comment>
<function><type><name>static</name> <name>i64</name></type> <name>journalHdrOffset</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>c</name> =<init> <expr><name>pPager</name>-&gt;<name>journalOff</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>c</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>offset</name> = ((<name>c</name>-1)/<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> + 1) * <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name>%<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name>&gt;=<name>c</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>offset</name>-<name>c</name>)&lt;<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>offset</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>seekJournalHdr</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = <call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Write zeros over the header of the journal file.  This has the
** effect of invalidating the journal file and committing the
** transaction.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>zeroJournalHdr</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>doTruncate</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>zeroHdr</name><index>[<expr>28</expr>]</index></name> =<init> <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOff</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>iLimit</name> =<init> <expr><name>pPager</name>-&gt;<name>journalSizeLimit</name></expr></init></decl>;</decl_stmt>

    <macro><name>IOTRACE</name><argument_list>(<argument>("JZEROHDR %p\n", pPager)</argument>)</argument_list></macro>
    <if>if<condition>( <expr><name>doTruncate</name> || <name>iLimit</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zeroHdr</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zeroHdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !<name>pPager</name>-&gt;<name>noSync</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>SQLITE_SYNC_DATAONLY</name>|<name>pPager</name>-&gt;<name>sync_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* At this point the transaction is committed but the write lock 
    ** is still held on the file. If there is a size limit configured for 
    ** the persistent journal and the journal file currently consumes more
    ** space than that limit allows for, truncate it now. There is no need
    ** to sync the file following this operation.
    */</comment>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>iLimit</name>&gt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>sz</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>&amp;<name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>sz</name>&gt;<name>iLimit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>iLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The journal file must be open when this routine is called. A journal
** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the
** current location.
**
** The format for the journal header is as follows:
** - 8 bytes: Magic identifying journal format.
** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.
** - 4 bytes: Random number used for page hash.
** - 4 bytes: Initial database page count.
** - 4 bytes: Sector size used by the process that wrote this journal.
** - 4 bytes: Database page size.
** 
** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>writeJournalHdr</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zHeader</name> =<init> <expr><name>pPager</name>-&gt;<name>pTmpSpace</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nHeader</name> =<init> <expr><name>pPager</name>-&gt;<name>pageSize</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>nWrite</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>nHeader</name>&gt;<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nHeader</name> = <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If there are active savepoints and any of them were created since the
  ** most recent journal header was written, update the PagerSavepoint.iHdrOff
  ** fields now.
  */</comment>
  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iHdrOffset</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iHdrOffset</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><call><name>seekJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalHdr</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zHeader</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* 
  ** Write the nRec Field - the number of page records that follow this
  ** journal header. Normally, zero is written to this value at this time.
  ** After the records are added to the journal (and the journal synced, 
  ** if in full-sync mode), the zero is overwritten with the true number
  ** of records (see syncJournal()).
  **
  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. When
  ** reading the journal this value tells SQLite to assume that the
  ** rest of the journal file contains valid page records. This assumption
  ** is dangerous, as if a failure occured whilst writing to the journal
  ** file it may contain some garbage data. There are two scenarios
  ** where this risk can be ignored:
  **
  **   * When the pager is in no-sync mode. Corruption can follow a
  **     power failure in this case anyway.
  **
  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees
  **     that garbage data is never appended to the journal file.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>pPager</name>-&gt;<name>noSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pPager</name>-&gt;<name>noSync</name>) || (<name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name>)
   || (<call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call>&amp;<name>SQLITE_IOCAP_SAFE_APPEND</name>)</expr> 
  )</condition><then><block>{
    <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr>0xffffffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* The random check-hash initialiser */</comment> 
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>cksumInit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>pPager</name>-&gt;<name>cksumInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+4</expr>]</index></name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>cksumInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The initial database size */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+8</expr>]</index></name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>dbOrigSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* The assumed sector size for this process */</comment>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+12</expr>]</index></name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initializing the tail of the buffer is not necessary.  Everything
  ** works find if the following memset() is omitted.  But initializing
  ** the memory prevents valgrind from complaining, so we are willing to
  ** take the performance hit.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+16</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
         <argument><expr><name>nHeader</name>-(<call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+16)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalHdr</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* The page size */</comment>
    <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zHeader</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+16</expr>]</index></name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <for>for(<init><expr><name>nWrite</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name>&amp;&amp;<name>nWrite</name>&lt;<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>nWrite</name>+=<name>nHeader</name></expr></incr>)<block>{
    <macro><name>IOTRACE</name><argument_list>(<argument>("JHDR %p %lld %d\n", pPager, pPager-&gt;journalHdr, nHeader)</argument>)</argument_list></macro>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zHeader</name></expr></argument>, <argument><expr><name>nHeader</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> += <name>nHeader</name></expr>;</expr_stmt>
  }</block></for>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The journal file must be open when this is called. A journal header file
** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal
** file. The current location in the journal file is given by
** pPager-&gt;journalOff.  See comments above function writeJournalHdr() for
** a description of the journal header format.
**
** If the header is read successfully, *nRec is set to the number of
** page records following this header and *dbSize is set to the size of the
** database before the transaction began, in pages. Also, pPager-&gt;cksumInit
** is set to the value read from the journal header. SQLITE_OK is returned
** in this case.
**
** If the journal header file appears to be corrupted, SQLITE_DONE is
** returned and *nRec and *dbSize are undefined.  If JOURNAL_HDR_SZ bytes
** cannot be read from the journal file an error code is returned.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>readJournalHdr</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, 
  <param><decl><type><name>i64</name></type> <name>journalSize</name></decl></param>,
  <param><decl><type><name>u32</name> *</type><name>pNRec</name></decl></param>, 
  <param><decl><type><name>u32</name> *</type><name>pDbSize</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>aMagic</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* A buffer to hold the magic header */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>jrnlOff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iPageSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iSectorSize</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>seekJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOff</name>+<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> &gt; <name>journalSize</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>jrnlOff</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>aMagic</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>jrnlOff</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aMagic</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>, <argument><expr><name>pNRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name>+4</expr></argument>, <argument><expr>&amp;<name>pPager</name>-&gt;<name>cksumInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name>+8</expr></argument>, <argument><expr><name>pDbSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOff</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name>+16</expr></argument>, <argument><expr>&amp;<name>iPageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

    <if>if<condition>( <expr><name>iPageSize</name>&lt;512 
     || <name>iPageSize</name>&gt;<name>SQLITE_MAX_PAGE_SIZE</name> 
     || ((<name>iPageSize</name>-1)&amp;<name>iPageSize</name>)!=0</expr> 
    )</condition><then><block>{
      <comment type="block">/* If the page-size in the journal-header is invalid, then the process
      ** that wrote the journal-header must have crashed before the header
      ** was synced. In this case stop reading the journal file here.
      */</comment>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_DONE</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>u16</name></type> <name>pagesize</name> =<init> <expr>(<name>u16</name>)<name>iPageSize</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerSetPagesize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>&amp;<name>pagesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pagesize</name>==(<name>u16</name>)<name>iPageSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  
    <comment type="block">/* Update the assumed sector-size to match the value used by 
    ** the process that created this journal. If this journal was
    ** created by a process other than this one, then this routine
    ** is being called from within pager_playback(). The local value
    ** of Pager.sectorSize is restored at the end of that routine.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name>+12</expr></argument>, <argument><expr>&amp;<name>iSectorSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <if>if<condition>( <expr>(<name>iSectorSize</name>&amp;(<name>iSectorSize</name>-1))
      || <name>iSectorSize</name>&lt;512
      || <name>iSectorSize</name>&gt;<name>MAX_SECTOR_SIZE</name></expr>
    )</condition><then><block>{
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>sectorSize</name> = <name>iSectorSize</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> += <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Write the supplied master journal name into the journal file for pager
** pPager at the current location. The master journal name must be the last
** thing written to a journal file. If the pager is in full-sync mode, the
** journal file descriptor is advanced to the next sector boundary before
** anything is written. The format is:
**
** + 4 bytes: PAGER_MJ_PGNO.
** + N bytes: length of master journal name.
** + 4 bytes: N
** + 4 bytes: Master journal name checksum.
** + 8 bytes: aJournalMagic[].
**
** The master journal page checksum is the sum of the bytes in the master
** journal name.
**
** If zMaster is a NULL pointer (occurs for a single database transaction), 
** this call is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>writeMasterJournal</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zMaster</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>i64</name></type> <name>jrnlOff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>jrnlSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call>+2*4</expr>]</index></name></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>zMaster</name> || <name>pPager</name>-&gt;<name>setMaster</name></expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>setMaster</name> = 1</expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>cksum</name> += <name><name>zMaster</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* If in full-sync mode, advance to the next disk sector before writing
  ** the master journal name. This is in case the previous page written to
  ** the journal has already been synced.
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>fullSync</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>seekJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>jrnlOff</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> += (<name>len</name>+20)</expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>, <argument><expr><call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>jrnlOff</name> += 4</expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>jrnlOff</name> += <name>len</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr><name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr>8</expr>]</index></name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr>8+<call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jrnlOff</name> += 8+<call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = !<name>pPager</name>-&gt;<name>noSync</name></expr>;</expr_stmt>

  <comment type="block">/* If the pager is in peristent-journal mode, then the physical 
  ** journal-file may extend past the end of the master-journal name
  ** and 8 bytes of magic data just written to the file. This is 
  ** dangerous because the code to rollback a hot-journal file
  ** will not be able to find the master-journal name to determine 
  ** whether or not the journal is hot. 
  **
  ** Easiest thing to do in this scenario is to truncate the journal 
  ** file to the required size.
  */</comment> 
  <if>if<condition>( <expr>(<name>rc</name>==<name>SQLITE_OK</name>)
   &amp;&amp; (<name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>&amp;<name>jrnlSize</name></expr></argument>)</argument_list></call>)==<name>SQLITE_OK</name>
   &amp;&amp; <name>jrnlSize</name>&gt;<name>jrnlOff</name></expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Find a page in the hash table given its page number.  Return
** a pointer to the page or NULL if not found.
*/</comment>
<function><type><name>static</name> <name>PgHdr</name> *</type><name>pager_lookup</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheFetch</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Clear the in-memory cache.  This routine
** sets the state of the pager back to what it was when it was first
** opened.  Any outstanding pages are invalidated and subsequent attempts
** to access those pages will likely result in a coredump.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pager_reset</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3PcacheClear</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Free all structures in the Pager.aSavepoint[] array and set both
** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal
** if it is open and the pager is not in exclusive mode.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>releaseAllSavepoint</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>pInSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>exclusiveMode</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>aSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>aSavepoint</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>nSavepoint</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>stmtNRec</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the bit number pgno in the PagerSavepoint.pInSavepoint bitvecs of
** all open savepoints.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>addToSavepointBitvecs</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Result code */</comment>

  <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>PagerSavepoint</name> *</type><name>p</name> =<init> <expr>&amp;<name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pgno</name>&lt;=<name>p</name>-&gt;<name>nOrig</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> |= <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pInSavepoint</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name> || <name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Unlock the database file. 
**
** If the pager is currently in error state, discard the contents of 
** the cache and reset the Pager structure internal state. If there is
** an open journal-file, then the next time a shared-lock is obtained
** on the pager file (by this or any other process), it will be
** treated as a hot-journal and rolled back.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pager_unlock</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>exclusiveMode</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/* Always close the journal file when dropping the database lock.
    ** Otherwise, another connection with journal_mode=delete might
    ** delete the file out from under us.
    */</comment>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOpen</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>pInJournal</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>rc</name> = <call><name>osUnlock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <expr_stmt><expr><name>pPager</name>-&gt;<name>errCode</name> = <name>rc</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSizeValid</name> = 0</expr>;</expr_stmt>
    <macro><name>IOTRACE</name><argument_list>(<argument>("UNLOCK %p\n", pPager)</argument>)</argument_list></macro>

    <comment type="block">/* If Pager.errCode is set, the contents of the pager cache cannot be
    ** trusted. Now that the pager file is unlocked, the contents of the
    ** cache can be discarded and the error code safely cleared.
    */</comment>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then> <expr_stmt><expr><name>pPager</name>-&gt;<name>errCode</name> = <name>SQLITE_OK</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>releaseAllSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbOrigSize</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_UNLOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>changeCountDone</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Execute a rollback if a transaction is active and unlock the 
** database file. If the pager has already entered the error state, 
** do not attempt the rollback.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pagerUnlockAndRollback</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>errCode</name>==<name>SQLITE_OK</name> &amp;&amp; <name>p</name>-&gt;<name>state</name>&gt;=<name>PAGER_RESERVED</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerRollback</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine ends a transaction.  A transaction is ended by either
** a COMMIT or a ROLLBACK.
**
** When this routine is called, the pager has the journal file open and
** a RESERVED or EXCLUSIVE lock on the database.  This routine will release
** the database lock and acquires a SHARED lock in its place if that is
** the appropriate thing to do.  Release locks usually is appropriate,
** unless we are in exclusive access mode or unless this is a 
** COMMIT AND BEGIN or ROLLBACK AND BEGIN operation.
**
** The journal file is either deleted or truncated.
**
** TODO: Consider keeping the journal file open for temporary databases.
** This might give a performance improvement on windows where opening
** a file is an expensive operation.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_end_transaction</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>hasMaster</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&lt;<name>PAGER_RESERVED</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>releaseAllSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>isMemoryJournal</name> =<init> <expr><call><name>sqlite3IsMemJournal</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOpen</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>isMemoryJournal</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_TRUNCATE</name>
         &amp;&amp; (<name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>exclusiveMode</name> 
     || <name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_PERSIST</name></expr>
    )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>zeroJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>hasMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_DELETE</name> || <name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOpen</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !<name>pPager</name>-&gt;<name>tempFile</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>pInJournal</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name> = 0</expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>sqlite3PcacheIterateDirty</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pager_set_pagehash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3PcacheCleanAll</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dirtyCache</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>nRec</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>exclusiveMode</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc2</name> = <call><name>osUnlock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_SHARED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>changeCountDone</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_SYNCED</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_EXCLUSIVE</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbOrigSize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>setMaster</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 0</expr>;</expr_stmt>
  <comment type="block">/* lruListSetFirstSynced(pPager); */</comment>
  <expr_stmt><expr><call><name>sqlite3PcacheTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>dbSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>MEMDB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSizeValid</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbModified</name> = 0</expr>;</expr_stmt>

  <return>return <expr>(<name>rc</name>==<name>SQLITE_OK</name>?<name>rc2</name>:<name>rc</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Compute and return a checksum for the page of data.
**
** This is not a real checksum.  It is really just the sum of the 
** random initial value and the page number.  We experimented with
** a checksum of the entire data, but that was found to be too slow.
**
** Note that the page number is stored at the beginning of data and
** the checksum is stored at the end.  This is important.  If journal
** corruption occurs due to a power failure, the most likely scenario
** is that one end or the other of the record will be changed.  It is
** much less likely that the two ends of the journal record will be
** correct and the middle be corrupt.  Thus, this "checksum" scheme,
** though fast and simple, catches the mostly likely kind of corruption.
**
** FIX ME:  Consider adding every 200th (or so) byte of the data to the
** checksum.  That way if a single page spans 3 or more disk sectors and
** only the middle sector is corrupt, we will still have a reasonable
** chance of failing the checksum and thus detecting the problem.
*/</comment>
<function><type><name>static</name> <name>u32</name></type> <name>pager_cksum</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>const</name> <name>u8</name> *</type><name>aData</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name> =<init> <expr><name>pPager</name>-&gt;<name>cksumInit</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pPager</name>-&gt;<name>pageSize</name>-200</expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>i</name>&gt;0</expr> )</condition><block>{
    <expr_stmt><expr><name>cksum</name> += <name><name>aData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> -= 200</expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>cksum</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read a single page from either the journal file (if isMainJrnl==1) or
** from the sub-journal (if isMainJrnl==0) and playback that page.
** The page begins at offset *pOffset into the file.  The  *pOffset
** value is increased to the start of the next page in the journal.
**
** The isMainJrnl flag is true if this is the main rollback journal and
** false for the statement journal.  The main rollback journal uses
** checksums - the statement journal does not.
**
** If pDone is not NULL, then it is a record of pages that have already
** been played back.  If the page at *pOffset has already been played back
** (if the corresponding pDone bit is set) then skip the playback.
** Make sure the pDone bit corresponding to the *pOffset page is set
** prior to returning.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_playback_one_page</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>,                <comment type="block">/* The pager being played back */</comment>
  <param><decl><type><name>int</name></type> <name>isMainJrnl</name></decl></param>,               <comment type="block">/* 1 -&gt; main journal. 0 -&gt; sub-journal. */</comment>
  <param><decl><type><name>i64</name> *</type><name>pOffset</name></decl></param>,                 <comment type="block">/* Offset of record to playback */</comment>
  <param><decl><type><name>int</name></type> <name>isSavepnt</name></decl></param>,                <comment type="block">/* True for a savepoint rollback */</comment>
  <param><decl><type><name>Bitvec</name> *</type><name>pDone</name></decl></param>                 <comment type="block">/* Bitvec of pages already played back */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl>;</decl_stmt>                   <comment type="block">/* An existing page in the cache */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>                    <comment type="block">/* The page number of a page in journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>                    <comment type="block">/* Checksum used for sanity checking */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aData</name></decl>;</decl_stmt>                    <comment type="block">/* Temporary storage for the page */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>jfd</name></decl>;</decl_stmt>            <comment type="block">/* The file descriptor for the journal file */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>isMainJrnl</name>&amp;~1)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* isMainJrnl is 0 or 1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>isSavepnt</name>&amp;~1)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* isSavepnt is 0 or 1 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isMainJrnl</name> || <name>pDone</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* pDone always used on sub-journals */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isSavepnt</name> || <name>pDone</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* pDone never used on non-savepoint */</comment>

  <expr_stmt><expr><name>aData</name> = (<name>u8</name>*)<name>pPager</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>aData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Temp storage must have already been allocated */</comment>

  <expr_stmt><expr><name>jfd</name> = <name>isMainJrnl</name> ? <name>pPager</name>-&gt;<name>jfd</name> : <name>pPager</name>-&gt;<name>sjfd</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr>*<name>pOffset</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr>(*<name>pOffset</name>)+4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
  <expr_stmt><expr>*<name>pOffset</name> += <name>pPager</name>-&gt;<name>pageSize</name> + 4 + <name>isMainJrnl</name>*4</expr>;</expr_stmt>

  <comment type="block">/* Sanity checking on the page.  This is more important that I originally
  ** thought.  If a power failure occurs while the journal is being written,
  ** it could cause invalid data to be written into the journal.  We need to
  ** detect this invalid data (with high probability) and ignore it.
  */</comment>
  <if>if<condition>( <expr><name>pgno</name>==0 || <name>pgno</name>==<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pgno</name>&gt;(<name>Pgno</name>)<name>pPager</name>-&gt;<name>dbSize</name> || <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>isMainJrnl</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>jfd</name></expr></argument>, <argument><expr>(*<name>pOffset</name>)-4</expr></argument>, <argument><expr>&amp;<name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    <if>if<condition>( <expr>!<name>isSavepnt</name> &amp;&amp; <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call>!=<name>cksum</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDone</name> &amp;&amp; (<name>rc</name> = <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_RESERVED</name> || <name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the pager is in RESERVED state, then there must be a copy of this
  ** page in the pager cache. In this case just update the pager cache,
  ** not the database file. The page is left marked dirty in this case.
  **
  ** An exception to the above rule: If the database is in no-sync mode
  ** and a page is moved during an incremental vacuum then the page may
  ** not be in the pager cache. Later: if a malloc() or IO error occurs
  ** during a Movepage() call, then the page may not be in the cache
  ** either. So the condition described in the above paragraph is not
  ** assert()able.
  **
  ** If in EXCLUSIVE state, then we update the pager cache if it exists
  ** and the main file. The page is then marked not dirty.
  **
  ** Ticket #1171:  The statement journal might contain page content that is
  ** different from the page content at the start of the transaction.
  ** This occurs when a page is changed prior to the start of a statement
  ** then changed again within the statement.  When rolling back such a
  ** statement we must not write to the original database unless we know
  ** for certain that original page contents are synced into the main rollback
  ** journal.  Otherwise, a power loss might leave modified data in the
  ** database file without an entry in the rollback journal that can
  ** restore the database to its original form.  Two conditions must be
  ** met before writing to the database files. (1) the database must be
  ** locked.  (2) we know that the original page content is fully synced
  ** in the main journal either because the page is not in cache or else
  ** the page is marked as needSync==0.
  **
  ** 2008-04-14:  When attempting to vacuum a corrupt database file, it
  ** is possible to fail a statement on a database that does not yet exist.
  ** Do not attempt to write if database file has never been opened.
  */</comment>
  <expr_stmt><expr><name>pPg</name> = <call><name>pager_lookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("PLAYBACK %d page %d hash(%08x) %s\n",
               <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pgno</name>, <call><name>pager_datahash</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call>,
               (<name>isMainJrnl</name>?"main-journal":"sub-journal")
  )</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_EXCLUSIVE</name>)
   &amp;&amp; (<name>pPg</name>==0 || 0==(<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>))
   &amp;&amp; (<name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>)</expr>
  )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>ofst</name> =<init> <expr>(<name>pgno</name>-1)*(<name>i64</name>)<name>pPager</name>-&gt;<name>pageSize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbFileSize</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbFileSize</name> = <name>pgno</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr>!<name>isMainJrnl</name> &amp;&amp; <name>pPg</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* If this is a rollback of a savepoint and data was not written to
    ** the database and the page is not in-memory, there is a potential
    ** problem. When the page is next fetched by the b-tree layer, it 
    ** will be read from the database file, which may or may not be 
    ** current. 
    **
    ** There are a couple of different ways this can happen. All are quite
    ** obscure. When running in synchronous mode, this can only happen 
    ** if the page is on the free-list at the start of the transaction, then
    ** populated, then moved using sqlite3PagerMovepage().
    **
    ** The solution is to add an in-memory page to the cache containing
    ** the data just read from the sub-journal. Mark the page as dirty 
    ** and if the pager requires a journal-sync, then mark the page as 
    ** requiring a journal-sync before it is written.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isSavepnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>rc</name> = <call><name>sqlite3PagerAcquire</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pPg</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_NEED_READ</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>pPg</name></expr> )</condition><then><block>{
    <comment type="block">/* No page should ever be explicitly rolled back that is in use, except
    ** for page 1 which is held in use in order to keep the lock on the
    ** database active. However such a page may be rolled back as a result
    ** of an internal error resulting in an automatic call to
    ** sqlite3PagerRollback().
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>pData</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pData</name> = <name>pPg</name>-&gt;<name>pData</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>xReiniter</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<call><name>xReiniter</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>isMainJrnl</name> &amp;&amp; (!<name>isSavepnt</name> || <name>pPager</name>-&gt;<name>journalOff</name>&lt;=<name>pPager</name>-&gt;<name>journalHdr</name>)</expr> )</condition><then><block>{
      <comment type="block">/* If the contents of this page were just restored from the main 
      ** journal file, then its content must be as they were when the 
      ** transaction was first opened. In this case we can mark the page
      ** as clean, since there will be no need to write it out to the.
      **
      ** There is one exception to this rule. If the page is being rolled
      ** back as part of a savepoint (or statement) rollback from an 
      ** unsynced portion of the main journal file, then it is not safe
      ** to mark the page as clean. This is because marking the page as
      ** clean will clear the PGHDR_NEED_SYNC flag. Since the page is
      ** already in the journal file (recorded in Pager.pInJournal) and
      ** the PGHDR_NEED_SYNC flag is cleared, if the page is written to
      ** again within this transaction, it will be marked as dirty but
      ** the PGHDR_NEED_SYNC flag will not be set. It could then potentially
      ** be written out into the database file before its journal file
      ** segment is synced. If a crash occurs during or following this,
      ** database corruption may ensue.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
    <expr_stmt><expr><name>pPg</name>-&gt;<name>pageHash</name> = <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* If this was page 1, then restore the value of Pager.dbFileVers.
    ** Do this before any decoding. */</comment>
    <if>if<condition>( <expr><name>pgno</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>, <argument><expr>&amp;((<name>u8</name>*)<name>pData</name>)[24]</expr></argument>,<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Decode the page just read from disk */</comment>
    <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_COVERAGE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This routine looks ahead into the main journal file and determines
** whether or not the next record (the record that begins at file
** offset pPager-&gt;journalOff) is a well-formed page record consisting
** of a valid page number, pPage-&gt;pageSize bytes of content, followed
** by a valid checksum.
**
** The pager never needs to know this in order to do its job.   This
** routine is only used from with assert() and testcase() macros.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pagerNextJournalPageIsValid</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>           <comment type="block">/* The page number of the page */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>           <comment type="block">/* The page checksum */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>              <comment type="block">/* Return code from read operations */</comment>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>fd</name></decl>;</decl_stmt>    <comment type="block">/* The file descriptor from which we are reading */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aData</name></decl>;</decl_stmt>           <comment type="block">/* Content of the page */</comment>

  <comment type="block">/* Read the page number header */</comment>
  <expr_stmt><expr><name>fd</name> = <name>pPager</name>-&gt;<name>jfd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>                                  <comment type="block">/*NO_TEST*/</comment>
  <if>if<condition>( <expr><name>pgno</name>==0 || <name>pgno</name>==<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>         <comment type="block">/*NO_TEST*/</comment>
  <if>if<condition>( <expr><name>pgno</name>&gt;(<name>Pgno</name>)<name>pPager</name>-&gt;<name>dbSize</name></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>                      <comment type="block">/*NO_TEST*/</comment>

  <comment type="block">/* Read the checksum */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>read32bits</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name>+<name>pPager</name>-&gt;<name>pageSize</name>+4</expr></argument>, <argument><expr>&amp;<name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>                                  <comment type="block">/*NO_TEST*/</comment>

  <comment type="block">/* Read the data and verify the checksum */</comment>
  <expr_stmt><expr><name>aData</name> = (<name>u8</name>*)<name>pPager</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name>+4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>                                  <comment type="block">/*NO_TEST*/</comment>
  <if>if<condition>( <expr><call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>aData</name></expr></argument>)</argument_list></call>!=<name>cksum</name></expr> )</condition><then><block>{ <return>return <expr>0</expr>;</return> }</block></then></if>              <comment type="block">/*NO_TEST*/</comment>

  <comment type="block">/* Reach this point only if the page is valid */</comment>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST) */</comment>

<comment type="block">/*
** Parameter zMaster is the name of a master journal file. A single journal
** file that referred to the master journal file has just been rolled back.
** This routine checks if it is possible to delete the master journal file,
** and does so if it is.
**
** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not 
** available for use within this function.
**
**
** The master journal file contains the names of all child journals.
** To tell if a master journal can be deleted, check to each of the
** children.  If all children are either missing or do not refer to
** a different master journal, then this master journal can be deleted.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_delmaster</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zMaster</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>master_open</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>pMaster</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>pJournal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zMasterJournal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Contents of master journal file */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nMasterJournal</name></decl>;</decl_stmt>       <comment type="block">/* Size of master journal file */</comment>

  <comment type="block">/* Open the master journal file exclusively in case some other process
  ** is running this routine also. Not that it makes too much difference.
  */</comment>
  <expr_stmt><expr><name>pMaster</name> = (<name>sqlite3_file</name> *)<call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>pVfs</name>-&gt;<name>szOsFile</name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pJournal</name> = (<name>sqlite3_file</name> *)(((<name>u8</name> *)<name>pMaster</name>) + <name>pVfs</name>-&gt;<name>szOsFile</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pMaster</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>(<name>SQLITE_OPEN_READONLY</name>|<name>SQLITE_OPEN_MASTER_JOURNAL</name>)</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>delmaster_out</name>;</goto></then></if>
  <expr_stmt><expr><name>master_open</name> = 1</expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr>&amp;<name>nMasterJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>delmaster_out</name>;</goto></then></if>

  <if>if<condition>( <expr><name>nMasterJournal</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zJournal</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zMasterPtr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nMasterPtr</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name>-&gt;<name>mxPathname</name>+1</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Load the entire master journal file into space obtained from
    ** sqlite3_malloc() and pointed to by zMasterJournal. 
    */</comment>
    <expr_stmt><expr><name>zMasterJournal</name> = (<name>char</name> *)<call><name>sqlite3Malloc</name><argument_list>(<argument><expr>(<name>int</name>)<name>nMasterJournal</name> + <name>nMasterPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zMasterJournal</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>delmaster_out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>zMasterPtr</name> = &amp;<name><name>zMasterJournal</name><index>[<expr><name>nMasterJournal</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>, <argument><expr><name>zMasterJournal</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nMasterJournal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>delmaster_out</name>;</goto></then></if>

    <expr_stmt><expr><name>zJournal</name> = <name>zMasterJournal</name></expr>;</expr_stmt>
    <while>while<condition>( <expr>(<name>zJournal</name>-<name>zMasterJournal</name>)&lt;<name>nMasterJournal</name></expr> )</condition><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zJournal</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr>&amp;<name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>delmaster_out</name>;</goto>
      }</block></then></if>
      <if>if<condition>( <expr><name>exists</name></expr> )</condition><then><block>{
        <comment type="block">/* One of the journals pointed to by the master journal exists.
        ** Open it and check if it points at the master journal. If
        ** so, return without deleting the master journal file.
        */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>(<name>SQLITE_OPEN_READONLY</name>|<name>SQLITE_OPEN_MAIN_JOURNAL</name>)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zJournal</name></expr></argument>, <argument><expr><name>pJournal</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <goto>goto <name>delmaster_out</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name>rc</name> = <call><name>readMasterJournal</name><argument_list>(<argument><expr><name>pJournal</name></expr></argument>, <argument><expr><name>zMasterPtr</name></expr></argument>, <argument><expr><name>nMasterPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <goto>goto <name>delmaster_out</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name>c</name> = <name><name>zMasterPtr</name><index>[<expr>0</expr>]</index></name>!=0 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zMasterPtr</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call>==0</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>c</name></expr> )</condition><then><block>{
          <comment type="block">/* We have a match. Do not delete the master journal file. */</comment>
          <goto>goto <name>delmaster_out</name>;</goto>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>zJournal</name> += (<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zJournal</name></expr></argument>)</argument_list></call>+1)</expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
  
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>delmaster_out</name>:</label>
  <if>if<condition>( <expr><name>zMasterJournal</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMasterJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>  
  <if>if<condition>( <expr><name>master_open</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** If the main database file is open and an exclusive lock is held, 
** truncate the main file of the given pager to the specified number 
** of pages.
**
** It might might be the case that the file on disk is smaller than nPage.
** This can happen, for example, if we are in the middle of a transaction
** which has extended the file size and the new pages are still all held
** in cache, then an INSERT or UPDATE does a statement rollback.  Some
** operating system implementations can get confused if you try to
** truncate a file to some size that is larger than it currently is,
** so detect this case and write a single zero byte to the end of the new
** file instead.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_truncate</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>nPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_EXCLUSIVE</name> &amp;&amp; <name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>currentSize</name>, <name>newSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>currentSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSize</name> = <name>pPager</name>-&gt;<name>pageSize</name>*(<name>i64</name>)<name>nPage</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>currentSize</name>!=<name>newSize</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>currentSize</name>&gt;<name>newSize</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>newSize</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pPager</name>-&gt;<name>dbFileSize</name> = <name>nPage</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set the sectorSize for the given pager.
**
** The sector size is at least as big as the sector size reported
** by sqlite3OsSectorSize(). The minimum sector size is 512.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>setSectorSize</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>pPager</name>-&gt;<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>tempFile</name></expr> )</condition><then><block>{
    <comment type="block">/* Sector size doesn't matter for temporary files. Also, the file
    ** may not have been opened yet, in whcih case the OsSectorSize()
    ** call will segfault.
    */</comment>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>sectorSize</name> = <call><name>sqlite3OsSectorSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>sectorSize</name>&lt;512</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>sectorSize</name> = 512</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>sectorSize</name>&gt;<name>MAX_SECTOR_SIZE</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>sectorSize</name> = <name>MAX_SECTOR_SIZE</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Playback the journal and thus restore the database file to
** the state it was in before we started making changes.  
**
** The journal file format is as follows: 
**
**  (1)  8 byte prefix.  A copy of aJournalMagic[].
**  (2)  4 byte big-endian integer which is the number of valid page records
**       in the journal.  If this value is 0xffffffff, then compute the
**       number of page records from the journal size.
**  (3)  4 byte big-endian integer which is the initial value for the 
**       sanity checksum.
**  (4)  4 byte integer which is the number of pages to truncate the
**       database to during a rollback.
**  (5)  4 byte big-endian integer which is the sector size.  The header
**       is this many bytes in size.
**  (6)  4 byte big-endian integer which is the page case.
**  (7)  4 byte integer which is the number of bytes in the master journal
**       name.  The value may be zero (indicate that there is no master
**       journal.)
**  (8)  N bytes of the master journal name.  The name will be nul-terminated
**       and might be shorter than the value read from (5).  If the first byte
**       of the name is \000 then there is no master journal.  The master
**       journal name is stored in UTF-8.
**  (9)  Zero or more pages instances, each as follows:
**        +  4 byte page number.
**        +  pPager-&gt;pageSize bytes of data.
**        +  4 byte checksum
**
** When we speak of the journal header, we mean the first 8 items above.
** Each entry in the journal is an instance of the 9th item.
**
** Call the value from the second bullet "nRec".  nRec is the number of
** valid page entries in the journal.  In most cases, you can compute the
** value of nRec from the size of the journal file.  But if a power
** failure occurred while the journal was being written, it could be the
** case that the size of the journal file had already been increased but
** the extra entries had not yet made it safely to disk.  In such a case,
** the value of nRec computed from the file size would be too large.  For
** that reason, we always use the nRec value in the header.
**
** If the nRec value is 0xffffffff it means that nRec should be computed
** from the file size.  This value is used when the user selects the
** no-sync option for the journal.  A power failure could lead to corruption
** in this case.  But for things like temporary table (which will be
** deleted when the power is restored) we don't care.  
**
** If the file opened as the journal file is not a well-formed
** journal file then all pages up to the first corrupted page are rolled
** back (or no pages if the journal header is corrupted). The journal file
** is then deleted and SQLITE_OK returned, just as if no corruption had
** been encountered.
**
** If an I/O or malloc() error occurs, the journal-file is not deleted
** and an error code is returned.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_playback</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>isHot</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>                 <comment type="block">/* Size of the journal file in bytes */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nRec</name></decl>;</decl_stmt>                <comment type="block">/* Number of Records in the journal */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>u</name></decl>;</decl_stmt>                   <comment type="block">/* Unsigned loop counter */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>mxPg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>           <comment type="block">/* Size of the original file in pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                  <comment type="block">/* Result code of a subroutine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>             <comment type="block">/* Value returned by sqlite3OsAccess() */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zMaster</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* Name of master journal file if any */</comment>

  <comment type="block">/* Figure out how many records are in the journal.  Abort early if
  ** the journal is empty.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>journalOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>&amp;<name>szJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>szJ</name>==0</expr> )</condition><then><block>{
    <goto>goto <name>end_playback</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Read the master journal name from the journal, if it is present.
  ** If a master journal file name is specified, but the file is not
  ** present on disk, then the journal is not hot and does not need to be
  ** played back.
  */</comment>
  <expr_stmt><expr><name>zMaster</name> = <name>pPager</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>readMasterJournal</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pVfs</name>-&gt;<name>mxPathname</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name><name>zMaster</name><index>[<expr>0</expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>zMaster</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> || !<name>res</name></expr> )</condition><then><block>{
    <goto>goto <name>end_playback</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* This loop terminates either when the readJournalHdr() call returns
  ** SQLITE_DONE or an IO error occurs. */</comment>
  <while>while<condition>( <expr>1</expr> )</condition><block>{

    <comment type="block">/* Read the next journal header from the journal file.  If there are
    ** not enough bytes left in the journal file for a complete header, or
    ** it is corrupted, then a process must of failed while writing it.
    ** This indicates nothing more needs to be rolled back.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>readJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>szJ</name></expr></argument>, <argument><expr>&amp;<name>nRec</name></expr></argument>, <argument><expr>&amp;<name>mxPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{ 
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DONE</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
      }</block></then></if>
      <goto>goto <name>end_playback</name>;</goto>
    }</block></then></if>

    <comment type="block">/* If nRec is 0xffffffff, then this journal was created by a process
    ** working in no-sync mode. This means that the rest of the journal
    ** file consists of pages, there are no more journal headers. Compute
    ** the value of nRec based on this assumption.
    */</comment>
    <if>if<condition>( <expr><name>nRec</name>==0xffffffff</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>journalOff</name>==<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRec</name> = (<name>int</name>)((<name>szJ</name> - <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)/<call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If nRec is 0 and this rollback is of a transaction created by this
    ** process and if this is the final header in the journal, then it means
    ** that this part of the journal was being filled but has not yet been
    ** synced to disk.  Compute the number of pages based on the remaining
    ** size of the file.
    **
    ** The third term of the test was added to fix ticket #2565.
    ** When rolling back a hot journal, nRec==0 always means that the next
    ** chunk of the journal contains zero pages to be rolled back.  But
    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
    ** the journal, it means that the journal might contain additional
    ** pages that need to be rolled back and that the number of pages 
    ** should be computed based on the journal file size.
    */</comment>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nRec</name>==0 &amp;&amp; !<name>isHot</name>
         &amp;&amp; <name>pPager</name>-&gt;<name>journalHdr</name>+<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>!=<name>pPager</name>-&gt;<name>journalOff</name>
         &amp;&amp; ((<name>szJ</name> - <name>pPager</name>-&gt;<name>journalOff</name>) / <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)&gt;0
         &amp;&amp; <call><name>pagerNextJournalPageIsValid</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nRec</name>==0 &amp;&amp; !<name>isHot</name> &amp;&amp;
        <name>pPager</name>-&gt;<name>journalHdr</name>+<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>==<name>pPager</name>-&gt;<name>journalOff</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nRec</name> = (<name>int</name>)((<name>szJ</name> - <name>pPager</name>-&gt;<name>journalOff</name>) / <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If this is the first header read from the journal, truncate the
    ** database file back to its original size.
    */</comment>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOff</name>==<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_truncate</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>mxPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>end_playback</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>mxPg</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Copy original pages out of the journal and back into the database file.
    */</comment>
    <for>for(<init><expr><name>u</name>=0</expr>;</init> <condition><expr><name>u</name>&lt;<name>nRec</name></expr>;</condition> <incr><expr><name>u</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_DONE</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = <name>szJ</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then><else>else<block>{
          <comment type="block">/* If we are unable to rollback, then the database is probably
          ** going to end up being corrupt.  It is corrupt to us, anyhow.
          ** Perhaps the next process to come along can fix it....
          */</comment>
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_CORRUPT_BKPT</name></expr>;</expr_stmt>
          <goto>goto <name>end_playback</name>;</goto>
        }</block></else></if>
      }</block></then></if>
    }</block></for>
  }</block></while>
  <comment type="block">/*NOTREACHED*/</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

<label><name>end_playback</name>:</label>
  <comment type="block">/* Following a rollback, the database file should be back in its original
  ** state prior to the start of the transaction, so invoke the
  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
  ** assertion that the transaction counter was modified.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(
    <argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>==0 ||
    <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>,<argument><expr><name>SQLITE_FCNTL_DB_UNCHANGED</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>&gt;=<name>SQLITE_OK</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zMaster</name> = <name>pPager</name>-&gt;<name>pTmpSpace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>readMasterJournal</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pVfs</name>-&gt;<name>mxPathname</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name><name>zMaster</name><index>[<expr>0</expr>]</index></name>!='\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name><name>zMaster</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name>res</name></expr> )</condition><then><block>{
    <comment type="block">/* If there was a master journal and this routine will return success,
    ** see if it is possible to delete the master journal.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>pager_delmaster</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* The Pager.sectorSize variable may have been updated while rolling
  ** back a journal created by a process with a different sector size
  ** value. Reset it to the correct value for this process.
  */</comment>
  <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Playback savepoint pSavepoint.  Or, if pSavepoint==NULL, then playback
** the entire master journal file.
**
** The case pSavepoint==NULL occurs when a ROLLBACK TO command is invoked
** on a SAVEPOINT that is a transaction savepoint.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pagerPlaybackSavepoint</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>PagerSavepoint</name> *</type><name>pSavepoint</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>szJ</name></decl>;</decl_stmt>                 <comment type="block">/* Effective size of the main journal */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iHdrOff</name></decl>;</decl_stmt>             <comment type="block">/* End of first segment of main-journal records */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>ii</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>Bitvec</name> *</type><name>pDone</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* Bitvec to ensure pages played back only once */</comment>

  <comment type="block">/* Allocate a bitvec to use to store the set of pages rolled back */</comment>
  <if>if<condition>( <expr><name>pSavepoint</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pDone</name> = <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name>pSavepoint</name>-&gt;<name>nOrig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pDone</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Truncate the database back to the size it was before the 
  ** savepoint being reverted was opened.
  */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>pSavepoint</name> ? <name>pSavepoint</name>-&gt;<name>nOrig</name> : <name>pPager</name>-&gt;<name>dbOrigSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_SHARED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use pPager-&gt;journalOff as the effective size of the main rollback
  ** journal.  The actual file might be larger than this in
  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything
  ** past pPager-&gt;journalOff is off-limits to us.
  */</comment>
  <expr_stmt><expr><name>szJ</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>

  <comment type="block">/* Begin by rolling back records from the main journal starting at
  ** PagerSavepoint.iOffset and continuing to the next journal header.
  ** There might be records in the main journal that have a page number
  ** greater than the current database size (pPager-&gt;dbSize) but those
  ** will be skipped automatically.  Pages are added to pDone as they
  ** are played back.
  */</comment>
  <if>if<condition>( <expr><name>pSavepoint</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iHdrOff</name> = <name>pSavepoint</name>-&gt;<name>iHdrOffset</name> ? <name>pSavepoint</name>-&gt;<name>iHdrOffset</name> : <name>szJ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = <name>pSavepoint</name>-&gt;<name>iOffset</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOff</name>&lt;<name>iHdrOff</name></expr> )</condition><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Continue rolling back records out of the main journal starting at
  ** the first journal header seen and continuing until the effective end
  ** of the main journal file.  Continue to skip out-of-range pages and
  ** continue adding pages rolled back to pDone.
  */</comment>
  <while>while<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOff</name>&lt;<name>szJ</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>u32</name></type> <name>nJRec</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of Journal Records */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>dummy</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>readJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>szJ</name></expr></argument>, <argument><expr>&amp;<name>nJRec</name></expr></argument>, <argument><expr>&amp;<name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
    ** The "pPager-&gt;journalHdr+JOURNAL_HDR_SZ(pPager)==pPager-&gt;journalOff"
    ** test is related to ticket #2565.  See the discussion in the
    ** pager_playback() function for additional information.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(<name>nJRec</name>==0
         &amp;&amp; <name>pPager</name>-&gt;<name>journalHdr</name>+<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>!=<name>pPager</name>-&gt;<name>journalOff</name>
         &amp;&amp; ((<name>szJ</name> - <name>pPager</name>-&gt;<name>journalOff</name>) / <call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)&gt;0
         &amp;&amp; <call><name>pagerNextJournalPageIsValid</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nJRec</name>==0 
     &amp;&amp; <name>pPager</name>-&gt;<name>journalHdr</name>+<call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>==<name>pPager</name>-&gt;<name>journalOff</name></expr>
    )</condition><then><block>{
      <expr_stmt><expr><name>nJRec</name> = (<name>szJ</name> - <name>pPager</name>-&gt;<name>journalOff</name>)/<call><name>JOURNAL_PG_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>ii</name>&lt;<name>nJRec</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOff</name>&lt;<name>szJ</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></while>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pPager</name>-&gt;<name>journalOff</name>==<name>szJ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finally,  rollback pages from the sub-journal.  Page that were
  ** previously rolled back out of the main journal (and are hence in pDone)
  ** will be skipped.  Out-of-range pages are also skipped.
  */</comment>
  <if>if<condition>( <expr><name>pSavepoint</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> =<init> <expr><name>pSavepoint</name>-&gt;<name>iSubRec</name>*(4+<name>pPager</name>-&gt;<name>pageSize</name>)</expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>ii</name>=<name>pSavepoint</name>-&gt;<name>iSubRec</name></expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name>&amp;&amp;<name>ii</name>&lt;(<name>u32</name>)<name>pPager</name>-&gt;<name>stmtNRec</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name> == <name>ii</name>*(4+<name>pPager</name>-&gt;<name>pageSize</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback_one_page</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_DONE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = <name>szJ</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Change the maximum number of in-memory pages that are allowed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetCachesize</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>mxPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3PcacheSetCachesize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Adjust the robustness of the database to damage due to OS crashes
** or power failures by changing the number of syncs()s when writing
** the rollback journal.  There are three levels:
**
**    OFF       sqlite3OsSync() is never called.  This is the default
**              for temporary and transient files.
**
**    NORMAL    The journal is synced once before writes begin on the
**              database.  This is normally adequate protection, but
**              it is theoretically possible, though very unlikely,
**              that an inopertune power failure could leave the journal
**              in a state which would cause damage to the database
**              when it is rolled back.
**
**    FULL      The journal is synced twice before writes begin on the
**              database (with some additional information - the nRec field
**              of the journal header - being written in between the two
**              syncs).  If we assume that writing a
**              single disk sector is atomic, then this mode provides
**              assurance that the journal will not be corrupted to the
**              point of causing damage to the database during rollback.
**
** Numeric values associated with these states are OFF==1, NORMAL=2,
** and FULL=3.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PAGER_PRAGMAS</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3PagerSetSafetyLevel</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><name>int</name></type> <name>bFullFsync</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pPager</name>-&gt;<name>noSync</name> =  (<name>level</name>==1 || <name>pPager</name>-&gt;<name>tempFile</name>) ?1:0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>fullSync</name> = (<name>level</name>==3 &amp;&amp; !<name>pPager</name>-&gt;<name>tempFile</name>) ?1:0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>sync_flags</name> = (<name>bFullFsync</name>?<name>SQLITE_SYNC_FULL</name>:<name>SQLITE_SYNC_NORMAL</name>)</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>noSync</name></expr> )</condition><then> <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 0</expr>;</expr_stmt></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following global variable is incremented whenever the library
** attempts to open a temporary file.  This information is used for
** testing and analysis only.  
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_opentemp_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Open a temporary file. 
**
** Write the file descriptor into *fd.  Return SQLITE_OK on success or some
** other error code if we fail. The OS will automatically delete the temporary
** file when it is closed.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqlite3PagerOpentemp</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>,        <comment type="block">/* The pager object */</comment>
  <param><decl><type><name>sqlite3_file</name> *</type><name>pFile</name></decl></param>,  <comment type="block">/* Write the file descriptor here */</comment>
  <param><decl><type><name>int</name></type> <name>vfsFlags</name></decl></param>          <comment type="block">/* Flags passed through to the VFS */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <expr_stmt><expr><name>sqlite3_opentemp_count</name>++</expr>;</expr_stmt>  <comment type="block">/* Used for testing and analysis only */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>vfsFlags</name> |=  <name>SQLITE_OPEN_READWRITE</name> | <name>SQLITE_OPEN_CREATE</name> |
            <name>SQLITE_OPEN_EXCLUSIVE</name> | <name>SQLITE_OPEN_DELETEONCLOSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pFile</name>-&gt;<name>pMethods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<function_decl><type><name>static</name> <name>int</name></type> <name>pagerStress</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>,<param><decl><type><name>PgHdr</name> *</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Create a new page cache and put a pointer to the page cache in *ppPager.
** The file to be cached need not exist.  The file is not locked until
** the first call to sqlite3PagerGet() and is only held open until the
** last page is released using sqlite3PagerUnref().
**
** If zFilename is NULL then a randomly-named temporary file is created
** and used as the file to be cached.  The file will be deleted
** automatically when it is closed.
**
** If zFilename is ":memory:" then all information is held in cache.
** It is never written to disk.  This can be used to implement an
** in-memory database.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerOpen</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,       <comment type="block">/* The virtual file system to use */</comment>
  <param><decl><type><name>Pager</name> **</type><name>ppPager</name></decl></param>,         <comment type="block">/* Return the Pager structure here */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,   <comment type="block">/* Name of the database file to open */</comment>
  <param><decl><type><name>int</name></type> <name>nExtra</name></decl></param>,              <comment type="block">/* Extra bytes append to each in-memory page */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,               <comment type="block">/* flags controlling this file */</comment>
  <param><decl><type><name>int</name></type> <name>vfsFlags</name></decl></param>             <comment type="block">/* flags passed through to sqlite3_vfs.xOpen() */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>u8</name> *</type><name>pPtr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tempFile</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>memDb</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>readOnly</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>useJournal</name> =<init> <expr>(<name>flags</name> &amp; <name>PAGER_OMIT_JOURNAL</name>)==0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>noReadlock</name> =<init> <expr>(<name>flags</name> &amp; <name>PAGER_NO_READLOCK</name>)!=0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>journalFileSize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pcacheSize</name> =<init> <expr><call><name>sqlite3PcacheSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>szPageDflt</name> =<init> <expr><name>SQLITE_DEFAULT_PAGE_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zPathname</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPathname</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><call><name>sqlite3JournalSize</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call>&gt;<call><name>sqlite3MemJournalSize</name><argument_list>()</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>journalFileSize</name> = <call><name>sqlite3JournalSize</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>journalFileSize</name> = <call><name>sqlite3MemJournalSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* The default return is a NULL pointer */</comment>
  <expr_stmt><expr>*<name>ppPager</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Compute and store the full pathname in an allocated buffer pointed
  ** to by zPathname, length nPathname. Or, if this is a temporary file,
  ** leave both nPathname and zPathname set to 0.
  */</comment>
  <if>if<condition>( <expr><name>zFilename</name> &amp;&amp; <name><name>zFilename</name><index>[<expr>0</expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nPathname</name> = <name>pVfs</name>-&gt;<name>mxPathname</name>+1</expr>;</expr_stmt>
    <expr_stmt><expr><name>zPathname</name> = <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nPathname</name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zPathname</name>==0</expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifndef>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>,<argument><expr>":memory:"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>memDb</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zPathname</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nPathname</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Allocate memory for the pager structure */</comment>
  <expr_stmt><expr><name>pPager</name> = <call><name>sqlite3MallocZero</name><argument_list>(
    <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pPager</name></expr></argument>)</argument_list></call> +           <comment type="block">/* Pager structure */</comment>
    <name>pcacheSize</name>      +           <comment type="block">/* PCache object */</comment>
    <name>journalFileSize</name> +           <comment type="block">/* The journal file structure */</comment> 
    <name>pVfs</name>-&gt;<name>szOsFile</name>  +           <comment type="block">/* The main db file */</comment>
    <name>journalFileSize</name> * 2 +       <comment type="block">/* The two journal files */</comment> 
    3*<name>nPathname</name> + 40</expr></argument>            <comment type="block">/* zFilename, zDirectory, zJournal */</comment>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPager</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pPCache</name> = (<name>PCache</name> *)&amp;<name><name>pPager</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPtr</name> = ((<name>u8</name> *)&amp;<name><name>pPager</name><index>[<expr>1</expr>]</index></name>) + <name>pcacheSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>vfsFlags</name> = <name>vfsFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>fd</name> = (<name>sqlite3_file</name>*)&amp;<name><name>pPtr</name><index>[<expr><name>pVfs</name>-&gt;<name>szOsFile</name>*0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>sjfd</name> = (<name>sqlite3_file</name>*)&amp;<name><name>pPtr</name><index>[<expr><name>pVfs</name>-&gt;<name>szOsFile</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>jfd</name> = (<name>sqlite3_file</name>*)&amp;<name><name>pPtr</name><index>[<expr><name>pVfs</name>-&gt;<name>szOsFile</name>+<name>journalFileSize</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>zFilename</name> = (<name>char</name>*)&amp;<name><name>pPtr</name><index>[<expr><name>pVfs</name>-&gt;<name>szOsFile</name>+2*<name>journalFileSize</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>zDirectory</name> = &amp;<name>pPager</name>-&gt;<name><name>zFilename</name><index>[<expr><name>nPathname</name>+1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>zJournal</name> = &amp;<name>pPager</name>-&gt;<name><name>zDirectory</name><index>[<expr><name>nPathname</name>+1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pVfs</name> = <name>pVfs</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zPathname</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>zFilename</name></expr></argument>, <argument><expr><name>zPathname</name></expr></argument>, <argument><expr><name>nPathname</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Open the pager file.
  */</comment>
  <if>if<condition>( <expr><name>zFilename</name> &amp;&amp; <name><name>zFilename</name><index>[<expr>0</expr>]</index></name> &amp;&amp; !<name>memDb</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>nPathname</name>&gt;(<name>pVfs</name>-&gt;<name>mxPathname</name> - (<name>int</name>)<call><name>sizeof</name><argument_list>(<argument><expr>"-journal"</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>fout</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zFilename</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>,
                         <argument><expr><name>pPager</name>-&gt;<name>vfsFlags</name></expr></argument>, <argument><expr>&amp;<name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>readOnly</name> = (<name>fout</name>&amp;<name>SQLITE_OPEN_READONLY</name>)</expr>;</expr_stmt>

      <comment type="block">/* If the file was successfully opened for read/write access,
      ** choose a default page size in case we have to create the
      ** database file. The default page size is the maximum of:
      **
      **    + SQLITE_DEFAULT_PAGE_SIZE,
      **    + The value returned by sqlite3OsSectorSize()
      **    + The largest page size that can be written atomically.
      */</comment>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !<name>readOnly</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>szPageDflt</name>&lt;<name>pPager</name>-&gt;<name>sectorSize</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>szPageDflt</name> = <name>pPager</name>-&gt;<name>sectorSize</name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>iDc</name> =<init> <expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC512</name>==(512&gt;&gt;8)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_IOCAP_ATOMIC64K</name>==(65536&gt;&gt;8)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name>&lt;=65536</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for(<init><expr><name>ii</name>=<name>szPageDflt</name></expr>;</init> <condition><expr><name>ii</name>&lt;=<name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr>;</condition> <incr><expr><name>ii</name>=<name>ii</name>*2</expr></incr>)<block>{
            <if>if<condition>( <expr><name>iDc</name>&amp;(<name>SQLITE_IOCAP_ATOMIC</name>|(<name>ii</name>&gt;&gt;8))</expr> )</condition><then> <expr_stmt><expr><name>szPageDflt</name> = <name>ii</name></expr>;</expr_stmt></then></if>
          }</block></for>
        }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if<condition>( <expr><name>szPageDflt</name>&gt;<name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>szPageDflt</name> = <name>SQLITE_MAX_DEFAULT_PAGE_SIZE</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></else></if>
  }</block></then><else>else<block>{
    <comment type="block">/* If a temporary file is requested, it is not opened immediately.
    ** In this case we accept the default page size and delay actually
    ** opening the file until the first call to OsWrite().
    **
    ** This branch is also run for an in-memory database. An in-memory
    ** database is the same as a temp-file that is never written out to
    ** disk and uses an in-memory rollback journal.
    */</comment> 
    <expr_stmt><expr><name>tempFile</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_EXCLUSIVE</name></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>pPager</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>pTmpSpace</name> = <call><name>sqlite3PageMalloc</name><argument_list>(<argument><expr><name>szPageDflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If an error occured in either of the blocks above.
  ** Free the Pager structure and close the file.
  ** Since the pager is not allocated there is no need to set 
  ** any Pager.errMask variables.
  */</comment>
  <if>if<condition>( <expr>!<name>pPager</name> || !<name>pPager</name>-&gt;<name>pTmpSpace</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>((<name>rc</name>==<name>SQLITE_OK</name>)?<name>SQLITE_NOMEM</name>:<name>rc</name>)</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>nExtra</name> = <call><name>FORCE_ALIGNMENT</name><argument_list>(<argument><expr><name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheOpen</name><argument_list>(<argument><expr><name>szPageDflt</name></expr></argument>, <argument><expr><name>nExtra</name></expr></argument>, <argument><expr>!<name>memDb</name></expr></argument>,
                    <argument><expr>!<name>memDb</name>?<name>pagerStress</name>:0</expr></argument>, <argument><expr>(<name>void</name> *)<name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("OPEN %d %s\n", <call><name>FILEHANDLEID</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call>, <name>pPager</name>-&gt;<name>zFilename</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>("OPEN %p %s\n", pPager, pPager-&gt;zFilename)</argument>)</argument_list></macro>

  <comment type="block">/* Fill in Pager.zDirectory[] */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>zDirectory</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zFilename</name></expr></argument>, <argument><expr><name>nPathname</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>zDirectory</name></expr></argument>)</argument_list></call></expr>;</init> 
      <condition><expr><name>i</name>&gt;0 &amp;&amp; <name>pPager</name>-&gt;<name><name>zDirectory</name><index>[<expr><name>i</name>-1</expr>]</index></name>!='/'</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{}</block></for>
  <if>if<condition>( <expr><name>i</name>&gt;0</expr> )</condition><then> <expr_stmt><expr><name>pPager</name>-&gt;<name><name>zDirectory</name><index>[<expr><name>i</name>-1</expr>]</index></name> = 0</expr>;</expr_stmt></then></if>

  <comment type="block">/* Fill in Pager.zJournal[] */</comment>
  <if>if<condition>( <expr><name>zPathname</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zFilename</name></expr></argument>, <argument><expr><name>nPathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPager</name>-&gt;<name><name>zJournal</name><index>[<expr><name>nPathname</name></expr>]</index></name></expr></argument>, <argument><expr>"-journal"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>zJournal</name> = 0</expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* pPager-&gt;journalOpen = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>useJournal</name> = (<name>u8</name>)<name>useJournal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>noReadlock</name> = (<name>noReadlock</name> &amp;&amp; <name>readOnly</name>) ?1:0</expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;stmtOpen = 0; */</comment>
  <comment type="block">/* pPager-&gt;stmtInUse = 0; */</comment>
  <comment type="block">/* pPager-&gt;nRef = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSizeValid</name> = (<name>u8</name>)<name>memDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pageSize</name> = <name>szPageDflt</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;stmtSize = 0; */</comment>
  <comment type="block">/* pPager-&gt;stmtJSize = 0; */</comment>
  <comment type="block">/* pPager-&gt;nPage = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>mxPage</name> = 100</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>mxPgno</name> = <name>SQLITE_MAX_PAGE_COUNT</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;state = PAGER_UNLOCK; */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name> == (<name>tempFile</name> ? <name>PAGER_EXCLUSIVE</name> : <name>PAGER_UNLOCK</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;errMask = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>tempFile</name> = (<name>u8</name>)<name>tempFile</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>tempFile</name>==<name>PAGER_LOCKINGMODE_NORMAL</name> 
          || <name>tempFile</name>==<name>PAGER_LOCKINGMODE_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_EXCLUSIVE</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>exclusiveMode</name> = (<name>u8</name>)<name>tempFile</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>pPager</name>-&gt;<name>memDb</name> = (<name>u8</name>)<name>memDb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>readOnly</name> = (<name>u8</name>)<name>readOnly</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;needSync = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>noSync</name> = (<name>pPager</name>-&gt;<name>tempFile</name> || !<name>useJournal</name>) ?1:0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>fullSync</name> = <name>pPager</name>-&gt;<name>noSync</name> ?0:1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>sync_flags</name> = <name>SQLITE_SYNC_NORMAL</name></expr>;</expr_stmt>
  <comment type="block">/* pPager-&gt;pFirst = 0; */</comment>
  <comment type="block">/* pPager-&gt;pFirstSynced = 0; */</comment>
  <comment type="block">/* pPager-&gt;pLast = 0; */</comment>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>nExtra</name> = <name>nExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalSizeLimit</name> = <name>SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>memDb</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalMode</name> = <name>PAGER_JOURNALMODE_MEMORY</name></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="block">/* pPager-&gt;xBusyHandler = 0; */</comment>
  <comment type="block">/* pPager-&gt;pBusyHandlerArg = 0; */</comment>
  <comment type="block">/* memset(pPager-&gt;aHash, 0, sizeof(pPager-&gt;aHash)); */</comment>
  <expr_stmt><expr>*<name>ppPager</name> = <name>pPager</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set the busy handler function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetBusyhandler</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, 
  <param><function_decl><type><name>int</name></type> (*<name>xBusyHandler</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pBusyHandlerArg</name></decl></param></function_decl></param>
)</parameter_list><block>{  
  <expr_stmt><expr><name>pPager</name>-&gt;<name>xBusyHandler</name> = <name>xBusyHandler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pBusyHandlerArg</name> = <name>pBusyHandlerArg</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the reinitializer for this pager.  If not NULL, the reinitializer
** is called when the content of a page in cache is restored to its original
** value as a result of a rollback.  The callback gives higher-level code
** an opportunity to restore the EXTRA section to agree with the restored
** page data.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetReiniter</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>xReinit</name>)<parameter_list>(<param><decl><type><name>DbPage</name>*</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pPager</name>-&gt;<name>xReiniter</name> = <name>xReinit</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the page size to *pPageSize. If the suggest new page size is
** inappropriate, then an alternative page size is set to that
** value before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSetPagesize</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>u16</name> *</type><name>pPageSize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>pPager</name>-&gt;<name>errCode</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u16</name></type> <name>pageSize</name> =<init> <expr>*<name>pPageSize</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pageSize</name>==0 || (<name>pageSize</name>&gt;=512 &amp;&amp; <name>pageSize</name>&lt;=<name>SQLITE_MAX_PAGE_SIZE</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pageSize</name> &amp;&amp; <name>pageSize</name>!=<name>pPager</name>-&gt;<name>pageSize</name> 
     &amp;&amp; (<name>pPager</name>-&gt;<name>memDb</name>==0 || <name>pPager</name>-&gt;<name>dbSize</name>==0)
     &amp;&amp; <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>==0</expr> 
    )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>pNew</name> =<init> <expr>(<name>char</name> *)<call><name>sqlite3PageMalloc</name><argument_list>(<argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>!<name>pNew</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPager</name>-&gt;<name>pageSize</name> = <name>pageSize</name></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>memDb</name></expr> )</condition><then> <expr_stmt><expr><call><name>setSectorSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPager</name>-&gt;<name>pTmpSpace</name> = <name>pNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PcacheSetPageSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr>*<name>pPageSize</name> = (<name>u16</name>)<name>pPager</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a pointer to the "temporary page" buffer held internally
** by the pager.  This is a buffer that is big enough to hold the
** entire content of a database page.  This buffer is used internally
** during rollback and will be overwritten whenever a rollback
** occurs.  But other modules are free to use it too, as long as
** no rollbacks are happening.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3PagerTempSpace</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>pTmpSpace</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Attempt to set the maximum database page count if mxPage is positive. 
** Make no changes if mxPage is zero or negative.  And never reduce the
** maximum page count below the current size of the database.
**
** Regardless of mxPage, return the current maximum page count.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerMaxPageCount</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>mxPage</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>mxPage</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>mxPgno</name> = <name>mxPage</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPager</name>-&gt;<name>mxPgno</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The following set of routines are used to disable the simulated
** I/O error mechanism.  These routines are used to avoid simulated
** errors in places where we do not care about errors.
**
** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops
** and generate no code.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>extern</name> <name>int</name></type> <name>sqlite3_io_error_pending</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>extern</name> <name>int</name></type> <name>sqlite3_io_error_hit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>saved_cnt</name></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>disable_simulated_io_errors</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>saved_cnt</name> = <name>sqlite3_io_error_pending</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3_io_error_pending</name> = -1</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>enable_simulated_io_errors</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>sqlite3_io_error_pending</name> = <name>saved_cnt</name></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>disable_simulated_io_errors</name>()</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>enable_simulated_io_errors</name>()</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Read the first N bytes from the beginning of the file into memory
** that pDest points to. 
**
** No error checking is done. The rational for this is that this function 
** may be called even if the file does not exist or contain a header. In 
** these cases sqlite3OsRead() will return an error, to which the correct 
** response is to zero the memory at pDest and continue.  A real IO error 
** will presumably recur and be picked up later (Todo: Think about this).
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerReadFileheader</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>pDest</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pDest</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>pPager</name>-&gt;<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <macro><name>IOTRACE</name><argument_list>(<argument>("DBHDR %p 0 %d\n", pPager, N)</argument>)</argument_list></macro>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pDest</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the total number of pages in the disk file associated with
** pPager. 
**
** If the PENDING_BYTE lies on the page directly after the end of the
** file, then consider this page part of the file too. For example, if
** PENDING_BYTE is byte 4096 (the first byte of page 5) and the size of the
** file is 4096 bytes, 5 is returned instead of 4.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerPagecount</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pnPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>pPager</name>-&gt;<name>errCode</name></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSizeValid</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name> = <name>pPager</name>-&gt;<name>dbSize</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>pPager</name>-&gt;<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>)
     &amp;&amp; (<name>rc</name> = <call><name>sqlite3OsFileSize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call>)!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>n</name>&gt;0 &amp;&amp; <name>n</name>&lt;<name>pPager</name>-&gt;<name>pageSize</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>n</name> /= <name>pPager</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_UNLOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = (<name>Pgno</name>)<name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbFileSize</name> = (<name>Pgno</name>)<name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSizeValid</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <if>if<condition>( <expr><name>n</name>==(<name>PENDING_BYTE</name>/<name>pPager</name>-&gt;<name>pageSize</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>n</name>&gt;<name>pPager</name>-&gt;<name>mxPgno</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>mxPgno</name> = (<name>Pgno</name>)<name>n</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pnPage</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pnPage</name> = (<name>int</name>)<name>n</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Forward declaration
*/</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>syncJournal</name><parameter_list>(<param><decl><type><name>Pager</name>*</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Try to obtain a lock on a file.  Invoke the busy callback if the lock
** is currently not available.  Repeat until the busy callback returns
** false or until the lock succeeds.
**
** Return SQLITE_OK on success and an error code if we cannot obtain
** the lock.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_wait_on_lock</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* The OS lock values must be the same as the Pager lock values */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_SHARED</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_RESERVED</name>==<name>RESERVED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_EXCLUSIVE</name>==<name>EXCLUSIVE_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the file is currently unlocked then the size must be unknown */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_SHARED</name> || <name>pPager</name>-&gt;<name>dbSizeValid</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>locktype</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <do>do <block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsLock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>while<condition>( <expr><name>rc</name>==<name>SQLITE_BUSY</name> &amp;&amp; <name>pPager</name>-&gt;<call><name>xBusyHandler</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pBusyHandlerArg</name></expr></argument>)</argument_list></call></expr> )</condition>;</do>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = (<name>u8</name>)<name>locktype</name></expr>;</expr_stmt>
      <macro><name>IOTRACE</name><argument_list>(<argument>("LOCK %p %d\n", pPager, locktype)</argument>)</argument_list></macro>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Truncate the in-memory database file image to nPage pages. This 
** function does not actually modify the database file on disk. It 
** just sets the internal state of the pager object so that the 
** truncation will be done when the current transaction is committed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerTruncateImage</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>nPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSizeValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSize</name>&gt;=<name>nPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>nPage</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the current size of the database file image in pages. This
** function differs from sqlite3PagerPagecount() in two ways:
**
**  a) It may only be called when at least one reference to a database
**     page is held. This guarantees that the database size is already
**     known and a call to sqlite3OsFileSize() is not required.
**
**  b) The return value is not adjusted for the locking page.
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3PagerImageSize</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSizeValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPager</name>-&gt;<name>dbSize</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* ifndef SQLITE_OMIT_AUTOVACUUM */</comment>

<comment type="block">/*
** Shutdown the page cache.  Free all memory and close all files.
**
** If a transaction was in progress when this routine is called, that
** transaction is rolled back.  All outstanding pages are invalidated
** and their memory is freed.  Any attempt to use a page associated
** with this page cache after this function returns will likely
** result in a coredump.
**
** This function always succeeds. If a transaction is active an attempt
** is made to roll it back. If an error occurs during the rollback 
** a hot journal may be left in the filesystem but no error is returned
** to the caller.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerClose</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{

  <expr_stmt><expr><call><name>disable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>errCode</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>exclusiveMode</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>MEMDB</name></expr> )</condition><then><block>{
    <comment type="block">/* Set Pager.journalHdr to -1 for the benefit of the pager_playback() 
    ** call which may be made from within pagerUnlockAndRollback(). If it
    ** is not -1, then the unsynced portion of an open journal file may
    ** be played back into the database. If a power failure occurs while
    ** this is happening, the database may become corrupt.
    */</comment>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalHdr</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerUnlockAndRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>enable_simulated_io_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("CLOSE %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>("CLOSE %p\n", pPager)</argument>)</argument_list></macro>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>releaseAllSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Temp files are automatically deleted by the OS
  ** if( pPager-&gt;tempFile ){
  **   sqlite3OsDelete(pPager-&gt;zFilename);
  ** }
  */</comment>

  <expr_stmt><expr><call><name>sqlite3PageFree</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pTmpSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Return the page number for the given page data.
*/</comment>
<function><type><name>Pgno</name></type> <name>sqlite3PagerPagenumber</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>p</name>-&gt;<name>pgno</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Increment the reference count for a page.  The input pointer is
** a reference to the page data.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerRef</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3PcacheRef</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sync the journal.  In other words, make sure all the pages that have
** been written to the journal have actually reached the surface of the
** disk.  It is not safe to modify the original database file until after
** the journal has been synced.  If the original database is modified before
** the journal is synced and a power failure occurs, the unsynced journal
** data would be lost and we would be unable to completely rollback the
** database changes.  Database corruption would occur.
** 
** This routine also updates the nRec field in the header of the journal.
** (See comments on the pager_playback() routine for additional information.)
** If the sync mode is FULL, two syncs will occur.  First the whole journal
** is synced, then the nRec field is updated, then a second sync occurs.
**
** For temporary databases, we do not care if we are able to rollback
** after a power failure, so no sync occurs.
**
** If the IOCAP_SEQUENTIAL flag is set for the persistent media on which
** the database is stored, then OsSync() is never called on the journal
** file. In this case all that is required is to update the nRec field in
** the journal header.
**
** This routine clears the needSync field of every page current held in
** memory.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>syncJournal</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Sync the journal before modifying the main database
  ** (assuming there is a journal and it needs to be synced.)
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>needSync</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPager</name>-&gt;<name>tempFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iDc</name> =<init> <expr><call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>journalOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if>if<condition>( <expr>0==(<name>iDc</name>&amp;<name>SQLITE_IOCAP_SAFE_APPEND</name>)</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>i64</name></type> <name>jrnlOff</name> =<init> <expr><call><name>journalHdrOffset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u8</name></type> <name><name>zMagic</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* This block deals with an obscure problem. If the last connection
        ** that wrote to this database was operating in persistent-journal
        ** mode, then the journal file may at this point actually be larger
        ** than Pager.journalOff bytes. If the next thing in the journal
        ** file happens to be a journal-header (written as part of the
        ** previous connections transaction), and a crash or power-failure 
        ** occurs after nRec is updated but before this connection writes 
        ** anything else to the journal file (or commits/rolls back its 
        ** transaction), then SQLite may become confused when doing the 
        ** hot-journal rollback following recovery. It may roll back all
        ** of this connections data, then proceed to rolling back the old,
        ** out-of-date data that follows it. Database corruption.
        **
        ** To work around this, if the journal file does appear to contain
        ** a valid header following Pager.journalOff, then write a 0x00
        ** byte to the start of it to prevent it from being recognized.
        */</comment>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>zMagic</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; 0==<call><name>memcmp</name><argument_list>(<argument><expr><name>zMagic</name></expr></argument>, <argument><expr><name>aJournalMagic</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name>zerobyte</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr>&amp;<name>zerobyte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Write the nRec value into the journal file header. If in
        ** full-synchronous mode, sync the journal first. This ensures that
        ** all data has really hit the disk before nRec is updated to mark
        ** it as a candidate for rollback.
        **
        ** This is not required if the persistent media supports the
        ** SAFE_APPEND property. Because in this case it is not possible 
        ** for garbage data to be appended to the file, the nRec field
        ** is populated with 0xFFFFFFFF when the journal header is written
        ** and never needs to be updated.
        */</comment>
        <if>if<condition>( <expr><name>pPager</name>-&gt;<name>fullSync</name> &amp;&amp; 0==(<name>iDc</name>&amp;<name>SQLITE_IOCAP_SEQUENTIAL</name>)</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("SYNC journal of %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <macro><name>IOTRACE</name><argument_list>(<argument>("JSYNC %p\n", pPager)</argument>)</argument_list></macro>
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sync_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
        }</block></then></if>

        <expr_stmt><expr><name>jrnlOff</name> = <name>pPager</name>-&gt;<name>journalHdr</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("JHDR %p %lld %d\n", <name>pPager</name>, <name>jrnlOff</name>, 4)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>jrnlOff</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      }</block></then></if>
      <if>if<condition>( <expr>0==(<name>iDc</name>&amp;<name>SQLITE_IOCAP_SEQUENTIAL</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("SYNC journal of %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>IOTRACE</name><argument_list>(<argument>("JSYNC %p\n", pPager)</argument>)</argument_list></macro>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sync_flags</name>| 
          (<name>pPager</name>-&gt;<name>sync_flags</name>==<name>SQLITE_SYNC_FULL</name>?<name>SQLITE_SYNC_DATAONLY</name>:0)</expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 0</expr>;</expr_stmt>

    <comment type="block">/* Erase the needSync flag from every page.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3PcacheClearSyncFlags</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Given a list of pages (connected by the PgHdr.pDirty pointer) write
** every one of those pages out to the database file. No calls are made
** to the page-cache to mark the pages as clean. It is the responsibility
** of the caller to use PcacheCleanAll() or PcacheMakeClean() to mark
** the pages as clean.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_write_pagelist</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pPager</name> = <name>pList</name>-&gt;<name>pPager</name></expr>;</expr_stmt>

  <comment type="block">/* At this point there may be either a RESERVED or EXCLUSIVE lock on the
  ** database file. If there is already an EXCLUSIVE lock, the following
  ** calls to sqlite3OsLock() are no-ops.
  **
  ** Moving the lock from RESERVED to EXCLUSIVE actually involves going
  ** through an intermediate state PENDING.   A PENDING lock prevents new
  ** readers from attaching to the database but is unsufficient for us to
  ** write.  The idea of a PENDING lock is to prevent new readers from
  ** coming in while we wait for existing readers to clear.
  **
  ** While the pager is in the RESERVED state, the original database file
  ** is unchanged and we can rollback without having to playback the
  ** journal into the original database file.  Once we transition to
  ** EXCLUSIVE, it means the database file has been changed and any rollback
  ** will require a journal playback.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <while>while<condition>( <expr><name>pList</name></expr> )</condition><block>{

    <comment type="block">/* If the file has not yet been opened, open it now. */</comment>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerOpentemp</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>vfsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/* If there are dirty pages in the page cache with page numbers greater
    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to
    ** make the file smaller (presumably by auto-vacuum code). Do not write
    ** any such pages to the file.
    */</comment>
    <if>if<condition>( <expr><name>pList</name>-&gt;<name>pgno</name>&lt;=<name>pPager</name>-&gt;<name>dbSize</name> &amp;&amp; 0==(<name>pList</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DONT_WRITE</name>)</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> =<init> <expr>(<name>pList</name>-&gt;<name>pgno</name>-1)*(<name>i64</name>)<name>pPager</name>-&gt;<name>pageSize</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>pData</name> =<init> <expr><call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name>pData</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("STORE %d page %d hash(%08x)\n",
                   <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pList</name>-&gt;<name>pgno</name>, <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("PGOUT %p %d\n", <name>pPager</name>, <name>pList</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_writedb_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>nWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pList</name>-&gt;<name>pgno</name>==1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>, <argument><expr>&amp;<name><name>pData</name><index>[<expr>24</expr>]</index></name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>pList</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbFileSize</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pPager</name>-&gt;<name>dbFileSize</name> = <name>pList</name>-&gt;<name>pgno</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <else>else<block>{
      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("NOSTORE %d page %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pList</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
    <expr_stmt><expr><name>pList</name>-&gt;<name>pageHash</name> = <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pList</name> = <name>pList</name>-&gt;<name>pDirty</name></expr>;</expr_stmt>
  }</block></while>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add the page to the sub-journal. It is the callers responsibility to
** use subjRequiresPage() to check that it is really required before 
** calling this function.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>subjournalPage</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>pData</name> =<init> <expr><name>pPg</name>-&gt;<name>pData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>offset</name> =<init> <expr><name>pPager</name>-&gt;<name>stmtNRec</name>*(4+<name>pPager</name>-&gt;<name>pageSize</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>pData2</name> =<init> <expr><call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("STMT-JOURNAL %d page %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call> || <name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>, <argument><expr><name>pData2</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>offset</name>+4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>stmtNRec</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>nSavepoint</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** This function is called by the pcache layer when it has reached some
** soft memory limit. The argument is a pointer to a purgeable Pager 
** object. This function attempts to make a single dirty page that has no
** outstanding references (if one exists) clean so that it can be recycled 
** by the pcache layer.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pagerStress</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr>(<name>Pager</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>doNotSync</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>syncJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pPager</name>-&gt;<name>fullSync</name> &amp;&amp; 
        !(<name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name>) &amp;&amp;
        !(<call><name>sqlite3OsDeviceCharacteristics</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>)</argument_list></call>&amp;<name>SQLITE_IOCAP_SAFE_APPEND</name>)</expr>
      )</condition><then><block>{
        <expr_stmt><expr><name>pPager</name>-&gt;<name>nRec</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>writeJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPg</name>-&gt;<name>pDirty</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbSize</name> &amp;&amp; <call><name>subjRequiresPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>subjournalPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>pager_write_pagelist</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("STRESS %d page %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Return 1 if there is a hot journal on the given pager.
** A hot journal is one that needs to be played back.
**
** If the current size of the database file is 0 but a journal file
** exists, that is probably an old journal left over from a prior
** database with the same name.  Just delete the journal.
**
** Return negative if unable to determine the status of the journal.
**
** This routine does not open the journal file to examine its
** content.  Hence, the journal might contain the name of a master
** journal file that has been deleted, and hence not be hot.  Or
** the header of the journal might be zeroed out.  This routine
** does not discover these cases of a non-hot journal - if the
** journal file exists and is not empty this routine assumes it
** is hot.  The pager_playback() routine will discover that the
** journal file is not really hot and will no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>hasHotJournal</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pExists</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exists</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>locked</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>useJournal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pExists</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>, <argument><expr>&amp;<name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>exists</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsCheckReservedLock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>locked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>exists</name> &amp;&amp; !<name>locked</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
     <if>if<condition>( <expr><name>nPage</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr>*<name>pExists</name> = 1</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read the content of page pPg out of the database file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>readDbPage</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>offset</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>MEMDB</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name>||<name>pPager</name>-&gt;<name>tempFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>offset</name> = (<name>pgno</name>-1)*(<name>i64</name>)<name>pPager</name>-&gt;<name>pageSize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pData</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_readdb_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("PGIN %p %d\n", <name>pPager</name>, <name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pgno</name>==1</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>, <argument><expr>&amp;((<name>u8</name>*)<name>pPg</name>-&gt;<name>pData</name>)[24]</expr></argument>,
                                              <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>CODEC1</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pData</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("FETCH %d page %d hash(%08x)\n",
               <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>, <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** This function is called to obtain the shared lock required before
** data may be read from the pager cache. If the shared lock has already
** been obtained, this function is a no-op.
**
** Immediately after obtaining the shared lock (if required), this function
** checks for a hot-journal file. If one is found, an emergency rollback
** is performed immediately.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pagerSharedLock</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isErrorReset</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* If this database is opened for exclusive access, has no outstanding 
  ** page references and is in an error-state, now is the chance to clear
  ** the error. Discard the contents of the pager-cache and treat any
  ** open journal file as a hot-journal.
  */</comment>
  <if>if<condition>( <expr>!<name>MEMDB</name> &amp;&amp; <name>pPager</name>-&gt;<name>exclusiveMode</name> 
   &amp;&amp; <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>==0 &amp;&amp; <name>pPager</name>-&gt;<name>errCode</name></expr> 
  )</condition><then><block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>isErrorReset</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>errCode</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the pager is still in an error state, do not proceed. The error 
  ** state will be cleared at some point in the future when all page 
  ** references are dropped and the cache can be discarded.
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name> &amp;&amp; <name>pPager</name>-&gt;<name>errCode</name>!=<name>SQLITE_FULL</name></expr> )</condition><then><block>{
    <return>return <expr><name>pPager</name>-&gt;<name>errCode</name></expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_UNLOCK</name> || <name>isErrorReset</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isHotJournal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>noReadlock</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_UNLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_UNLOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_SHARED</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If a journal file exists, and there is no RESERVED lock on the
    ** database file, then it either needs to be played back or deleted.
    */</comment>
    <if>if<condition>( <expr>!<name>isErrorReset</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>hasHotJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>&amp;<name>isHotJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>failed</name>;</goto>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>isErrorReset</name> || <name>isHotJournal</name></expr> )</condition><then><block>{
      <comment type="block">/* Get an EXCLUSIVE lock on the database file. At this point it is
      ** important that a RESERVED lock is not obtained on the way to the
      ** EXCLUSIVE lock. If it were, another process might open the
      ** database file, detect the RESERVED lock, and conclude that the
      ** database is safe to read while this process is still rolling it 
      ** back.
      ** 
      ** Because the intermediate RESERVED lock is not requested, the
      ** second process will get to this point in the code and fail to
      ** obtain its own EXCLUSIVE lock on the database file.
      */</comment>
      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&lt;<name>EXCLUSIVE_LOCK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsLock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>failed</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_EXCLUSIVE</name></expr>;</expr_stmt>
      }</block></then></if>
 
      <comment type="block">/* Open the journal for read/write access. This is because in 
      ** exclusive-access mode the file descriptor will be kept open and
      ** possibly used for a transaction later on. On some systems, the
      ** OsTruncate() call used in exclusive-access mode also requires
      ** a read/write file handle.
      */</comment>
      <if>if<condition>( <expr>!<name>isErrorReset</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOpen</name>==0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsAccess</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>,<argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>,<argument><expr><name>SQLITE_ACCESS_EXISTS</name></expr></argument>,<argument><expr>&amp;<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <if>if<condition>( <expr><name>res</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>int</name></type> <name>fout</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>f</name> =<init> <expr><name>SQLITE_OPEN_READWRITE</name>|<name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPager</name>-&gt;<name>tempFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>&amp;<name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pPager</name>-&gt;<name>jfd</name>-&gt;<name>pMethods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>fout</name>&amp;<name>SQLITE_OPEN_READONLY</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>rc</name> = <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3OsClose</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></then><else>else<block>{
            <comment type="block">/* If the journal does not exist, that means some other process
            ** has already rolled it back */</comment>
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then></if>
      }</block></then></if>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <goto>goto <name>failed</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOpen</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>setMaster</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalHdr</name> = 0</expr>;</expr_stmt>
 
      <comment type="block">/* Playback and delete the journal.  Drop the database write
      ** lock and reacquire the read lock. Purge the cache before
      ** playing back the hot-journal so that we don't end up with
      ** an inconsistent cache.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3PcacheClear</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_SHARED</name> || 
          (<name>pPager</name>-&gt;<name>exclusiveMode</name> &amp;&amp; <name>pPager</name>-&gt;<name>state</name>&gt;<name>PAGER_SHARED</name>)</expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr><call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>&gt;0</expr> )</condition><then><block>{
      <comment type="block">/* The shared-lock has just been acquired on the database file
      ** and there are already pages in the cache (from a previous
      ** read or write transaction).  Check to see if the database
      ** has been modified.  If the database has changed, flush the
      ** cache.
      **
      ** Database changes is detected by looking at 15 bytes beginning
      ** at offset 24 into the file.  The first 4 of these 16 bytes are
      ** a 32-bit counter that is incremented with each change.  The
      ** other bytes change randomly with each file change when
      ** a codec is in use.
      ** 
      ** There is a vanishingly small chance that a change will not be 
      ** detected.  The chance of an undetected change is so small that
      ** it can be neglected.
      */</comment>
      <decl_stmt><decl><type><name>char</name></type> <name><name>dbFileVers</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>pPager</name>-&gt;<name>errCode</name></expr>;</expr_stmt>
        <goto>goto <name>failed</name>;</goto>
      }</block></then></if>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSizeValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("CKVERS %p %d\n", <name>pPager</name>, <call><name>sizeof</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsRead</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>dbFileVers</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <goto>goto <name>failed</name>;</goto>
        }</block></then></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>, <argument><expr><name>dbFileVers</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>dbFileVers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>pager_reset</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>exclusiveMode</name> || <name>pPager</name>-&gt;<name>state</name>==<name>PAGER_SHARED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

 <label><name>failed</name>:</label>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* pager_unlock() is a no-op for exclusive mode and in-memory databases. */</comment>
    <expr_stmt><expr><call><name>pager_unlock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Make sure we have the content for a page.  If the page was
** previously acquired with noContent==1, then the content was
** just initialized to zeros instead of being read from disk.
** But now we need the real data off of disk.  So make sure we
** have it.  Read it in if we do not have it already.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_get_content</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_READ</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>readDbPage</name><argument_list>(<argument><expr><name>pPg</name>-&gt;<name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_NEED_READ</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the reference count has reached zero, and the pager is not in the
** middle of a write transaction or opened in exclusive mode, unlock it.
*/</comment> 
<function><type><name>static</name> <name>void</name></type> <name>pagerUnlockIfUnused</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>(<call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>==0)
    &amp;&amp; (!<name>pPager</name>-&gt;<name>exclusiveMode</name> || <name>pPager</name>-&gt;<name>journalOff</name>&gt;0)</expr> 
  )</condition><then><block>{
    <expr_stmt><expr><call><name>pagerUnlockAndRollback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Drop a page from the cache using sqlite3PcacheDrop().
**
** If this means there are now no pages with references to them, a rollback
** occurs and the lock on the database is removed.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pagerDropPage</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheDrop</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pagerUnlockIfUnused</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Acquire a page.
**
** A read lock on the disk file is obtained when the first page is acquired. 
** This read lock is dropped when the last page is released.
**
** This routine works for any page number greater than 0.  If the database
** file is smaller than the requested page, then no actual disk
** read occurs and the memory image of the page is initialized to
** all zeros.  The extra data appended to a page is always initialized
** to zeros the first time a page is loaded into memory.
**
** The acquisition might fail for several reasons.  In all cases,
** an appropriate error code is returned and *ppPage is set to NULL.
**
** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt
** to find a page in the in-memory cache first.  If the page is not already
** in memory, this routine goes to disk to read it in whereas Lookup()
** just returns 0.  This routine acquires a read-lock the first time it
** has to go to disk, and could also playback an old journal if necessary.
** Since Lookup() never goes to disk, it never has to deal with locks
** or journal files.
**
** If noContent is false, the page contents are actually read from disk.
** If noContent is true, it means that we do not care about the contents
** of the page at this time, so do not do a disk read.  Just fill in the
** page content with zeros.  But mark the fact that we have not read the
** content by setting the PgHdr.needRead flag.  Later on, if 
** sqlite3PagerWrite() is called on this page or if this routine is
** called again with noContent==0, that means that the content is needed
** and the disk read should occur at that point.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerAcquire</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>,      <comment type="block">/* The pager open on the database file */</comment>
  <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>,          <comment type="block">/* Page number to fetch */</comment>
  <param><decl><type><name>DbPage</name> **</type><name>ppPage</name></decl></param>,    <comment type="block">/* Write a pointer to the page here */</comment>
  <param><decl><type><name>int</name></type> <name>noContent</name></decl></param>       <comment type="block">/* Do not bother reading content from disk if true */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_UNLOCK</name> 
       || <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>&gt;0 
       || <name>pgno</name>==1</expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The maximum page number is 2^31. Return SQLITE_CORRUPT if a page
  ** number greater than this, or zero, is requested.
  */</comment>
  <if>if<condition>( <expr><name>pgno</name>&gt;<name>PAGER_MAX_PGNO</name> || <name>pgno</name>==0 || <name>pgno</name>==<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CORRUPT_BKPT</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Make sure we have not hit any critical errors.
  */</comment> 
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>ppPage</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* If this is the first page accessed, then get a SHARED lock
  ** on the database file. pagerSharedLock() is a no-op if 
  ** a database lock is already held.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>pagerSharedLock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_UNLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PcacheFetch</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPg</name>-&gt;<name>pPager</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* The pager cache has created a new page. Its content needs to 
    ** be initialized.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>nMiss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPg</name>-&gt;<name>pPager</name> = <name>pPager</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPg</name>-&gt;<name>pExtra</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>&amp;<name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <if>if<condition>( <expr><name>nMax</name>&lt;(<name>int</name>)<name>pgno</name> || <name>MEMDB</name> || <name>noContent</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pgno</name>&gt;<name>pPager</name>-&gt;<name>mxPgno</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_FULL</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPg</name>-&gt;<name>pData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>noContent</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> |= <name>PGHDR_NEED_READ</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("ZERO %p %d\n", <name>pPager</name>, <name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>readDbPage</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><then><block>{
        <comment type="block">/* sqlite3PagerUnref(pPg); */</comment>
        <expr_stmt><expr><call><name>pagerDropPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></else></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
    <expr_stmt><expr><name>pPg</name>-&gt;<name>pageHash</name> = <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then><else>else<block>{
    <comment type="block">/* The requested page is in the page cache. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call>&gt;0 || <name>pgno</name>==1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>nHit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>noContent</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_get_content</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if>

  <expr_stmt><expr>*<name>ppPage</name> = <name>pPg</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Acquire a page if it is already in the in-memory cache.  Do
** not read the page from disk.  Return a pointer to the page,
** or 0 if the page is not in cache.
**
** See also sqlite3PagerGet().  The difference between this routine
** and sqlite3PagerGet() is that _get() will go to the disk and read
** in the page if the page is not already in cache.  This routine
** returns NULL if the page is not in cache or if a disk I/O error 
** has ever happened.
*/</comment>
<function><type><name>DbPage</name> *</type><name>sqlite3PagerLookup</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>(<name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_UNLOCK</name>)
   &amp;&amp; (<name>pPager</name>-&gt;<name>errCode</name>==<name>SQLITE_OK</name> || <name>pPager</name>-&gt;<name>errCode</name>==<name>SQLITE_FULL</name>)</expr>
  )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3PcacheFetch</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>pPg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Release a page.
**
** If the number of references to the page drop to zero, then the
** page is added to the LRU list.  When all references to all pages
** are released, a rollback occurs and the lock on the database is
** removed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerUnref</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pPg</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheRelease</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pagerUnlockIfUnused</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the main journal file has already been opened, ensure that the
** sub-journal file is open too. If the main journal is not open,
** this function is a no-op.
**
** SQLITE_OK is returned if everything goes according to plan. An 
** SQLITE_IOERR_XXX error code is returned if the call to 
** sqlite3OsOpen() fails.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>openSubJournal</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name> &amp;&amp; !<name>pPager</name>-&gt;<name>sjfd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3MemJournalOpen</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerOpentemp</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>, <argument><expr><name>SQLITE_OPEN_SUBJOURNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a journal file for pPager.  There should already be a RESERVED
** or EXCLUSIVE lock on the database file when this routine is called.
**
** Return SQLITE_OK if everything.  Return an error code and release the
** write lock if anything goes wrong.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_open_journal</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name> =<init> <expr><name>pPager</name>-&gt;<name>pVfs</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr>(<name>SQLITE_OPEN_READWRITE</name>|<name>SQLITE_OPEN_EXCLUSIVE</name>|<name>SQLITE_OPEN_CREATE</name>)</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_RESERVED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>useJournal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pInJournal</name> = <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>pInJournal</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>failed_to_open_journal</name>;</goto>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>tempFile</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>flags</name> |= (<name>SQLITE_OPEN_DELETEONCLOSE</name>|<name>SQLITE_OPEN_TEMP_JOURNAL</name>)</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>flags</name> |= (<name>SQLITE_OPEN_MAIN_JOURNAL</name>)</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3MemJournalOpen</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3JournalOpen</name><argument_list>(
          <argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>jrnlBufferSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_OK</name> || <name>pPager</name>-&gt;<name>jfd</name>-&gt;<name>pMethods</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>setMaster</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalHdr</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3OsDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>zJournal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <goto>goto <name>failed_to_open_journal</name>;</goto>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOpen</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>journalStarted</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>nRec</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>pPager</name>-&gt;<name>errCode</name></expr>;</expr_stmt>
    <goto>goto <name>failed_to_open_journal</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbOrigSize</name> = <name>pPager</name>-&gt;<name>dbSize</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>writeJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>nSavepoint</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>openSubJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_NOMEM</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_IOERR_NOMEM</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_FULL</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>

<label><name>failed_to_open_journal</name>:</label>
  <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pInJournal</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Acquire a write-lock on the database.  The lock is removed when
** the any of the following happen:
**
**   *  sqlite3PagerCommitPhaseTwo() is called.
**   *  sqlite3PagerRollback() is called.
**   *  sqlite3PagerClose() is called.
**   *  sqlite3PagerUnref() is called to on every outstanding page.
**
** The first parameter to this routine is a pointer to any open page of the
** database file.  Nothing changes about the page - it is used merely to
** acquire a pointer to the Pager structure and as proof that there is
** already a read-lock on the database.
**
** The second parameter indicates how much space in bytes to reserve for a
** master journal file-name at the start of the journal when it is created.
**
** A journal file is opened if this is not a temporary file.  For temporary
** files, the opening of the journal file is deferred until there is an
** actual need to write to the journal.
**
** If the database is already reserved for writing, this routine is a no-op.
**
** If exFlag is true, go ahead and get an EXCLUSIVE lock on the file
** immediately instead of waiting until we try to flush the cache.  The
** exFlag is ignored if a transaction is already active.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerBegin</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>, <param><decl><type><name>int</name></type> <name>exFlag</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_UNLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_SHARED</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsLock</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>RESERVED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_RESERVED</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>exFlag</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>pager_wait_on_lock</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dirtyCache</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("TRANSACTION %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>useJournal</name> &amp;&amp; !<name>pPager</name>-&gt;<name>tempFile</name>
           &amp;&amp; <name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_open_journal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOff</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* This happens when the pager was in exclusive-access mode the last
    ** time a (read or write) transaction was successfully concluded
    ** by this connection. Instead of deleting the journal file it was 
    ** kept open and either was truncated to 0 bytes or its header was
    ** overwritten with zeros.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>nRec</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbOrigSize</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>pInJournal</name> = <call><name>sqlite3BitvecCreate</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>pInJournal</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbOrigSize</name> = <name>pPager</name>-&gt;<name>dbSize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>writeJournalHdr</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPager</name>-&gt;<name>journalOpen</name> || <name>pPager</name>-&gt;<name>journalOff</name>&gt;0 || <name>rc</name>!=<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Mark a data page as writeable.  The page is written into the journal 
** if it is not there already.  This routine must be called before making
** changes to a page.
**
** The first time this routine is called, the pager creates a new
** journal and acquires a RESERVED lock on the database.  If the RESERVED
** lock could not be acquired, this routine returns SQLITE_BUSY.  The
** calling routine must check for that return value and be careful not to
** change any page data until this routine returns SQLITE_OK.
**
** If the journal file could not be written because the disk is full,
** then this routine returns SQLITE_FULL and does an immediate rollback.
** All subsequent write attempts also return SQLITE_FULL until there
** is a call to sqlite3PagerCommit() or sqlite3PagerRollback() to
** reset.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_write</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pData</name> =<init> <expr><name>pPg</name>-&gt;<name>pData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check for errors
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{ 
    <return>return <expr><name>pPager</name>-&gt;<name>errCode</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>readOnly</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPager</name>-&gt;<name>setMaster</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CHECK_PAGE</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this page was previously acquired with noContent==1, that means
  ** we didn't really read in the content of the page.  This can happen
  ** (for example) when the page is being moved to the freelist.  But
  ** now we are (perhaps) moving the page off of the freelist for
  ** reuse and we need to know its original content so that content
  ** can be stored in the rollback journal.  So do the read at this
  ** time.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>pager_get_content</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Mark the page as dirty.  If the page has already been written
  ** to the journal then we can return right away.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>subjRequiresPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dirtyCache</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dbModified</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{

    <comment type="block">/* If we get this far, it means that the page needs to be
    ** written to the transaction journal or the ckeckpoint journal
    ** or both.
    **
    ** First check to see that the transaction journal exists and
    ** create it if it does not.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_UNLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerBegin</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_RESERVED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>journalOpen</name> &amp;&amp; <name>pPager</name>-&gt;<name>useJournal</name>
          &amp;&amp; <name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_open_journal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dirtyCache</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dbModified</name> = 1</expr>;</expr_stmt>
  
    <comment type="block">/* The transaction journal now exists and we have a RESERVED or an
    ** EXCLUSIVE lock on the main database file.  Write the current page to
    ** the transaction journal if it is not there already.
    */</comment>
    <if>if<condition>( <expr>!<call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call> &amp;&amp; <name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pPg</name>-&gt;<name>pgno</name>&lt;=<name>pPager</name>-&gt;<name>dbOrigSize</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>u32</name></type> <name>cksum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>pData2</name></decl>;</decl_stmt>

        <comment type="block">/* We should never write to the journal file the page that
        ** contains the database locks.  The following assert verifies
        ** that we do not. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>pgno</name>!=<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pData2</name> = <call><name>CODEC2</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cksum</name> = <call><name>pager_cksum</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>(<name>u8</name>*)<name>pData2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>pData2</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>,
                              <argument><expr><name>pPager</name>-&gt;<name>journalOff</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> += <name>pPager</name>-&gt;<name>pageSize</name>+4</expr>;</expr_stmt>
        }</block></then></if>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>journalOff</name></expr></argument>, <argument><expr><name>cksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>journalOff</name> += 4</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>IOTRACE</name><argument_list>(<argument><expr>("JOUT %p %d %lld %d\n", <name>pPager</name>, <name>pPg</name>-&gt;<name>pgno</name>, 
                 <name>pPager</name>-&gt;<name>journalOff</name>, <name>pPager</name>-&gt;<name>pageSize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PAGER_INCR</name><argument_list>(<argument><expr><name>sqlite3_pager_writej_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("JOURNAL %d page %d needSync=%d hash(%08x)\n",
             <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>, 
             ((<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)?1:0), <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Even if an IO or diskfull error occurred while journalling the
        ** page in the block above, set the need-sync flag for the page.
        ** Otherwise, when the transaction is rolled back, the logic in
        ** playback_one_page() will think that the page needs to be restored
        ** in the database file. And if an IO error occurs while doing so,
        ** then corruption may follow.
        */</comment>
        <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>noSync</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> |= <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 1</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* An error has occured writing to the journal file. The 
        ** transaction will be rolled back by the layer above.
        */</comment>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>pPager</name>-&gt;<name>nRec</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name> || <name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> |= <call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
      }</block></then><else>else<block>{
        <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>journalStarted</name> &amp;&amp; !<name>pPager</name>-&gt;<name>noSync</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> |= <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("APPEND %d page %d needSync=%d\n",
                <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>,
               ((<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)?1:0))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  
    <comment type="block">/* If the statement journal is open and the page is not in it,
    ** then write the current page to the statement journal.  Note that
    ** the statement journal format differs from the standard journal format
    ** in that it omits the checksums and the header.
    */</comment>
    <if>if<condition>( <expr><call><name>subjRequiresPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>subjournalPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* Update the database size and return.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_SHARED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>&lt;<name>pPg</name>-&gt;<name>pgno</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>pPg</name>-&gt;<name>pgno</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>==(<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>-1)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name>++</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is used to mark a data-page as writable. It uses 
** pager_write() to open a journal file (if it is not already open)
** and write the page *pData to the journal.
**
** The difference between this function and pager_write() is that this
** function also deals with the special case where 2 or more pages
** fit on a single disk sector. In this case all co-resident pages
** must have been written to the journal file before returning.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerWrite</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name> =<init> <expr><name>pDbPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPagePerSector</name> =<init> <expr>(<name>pPager</name>-&gt;<name>sectorSize</name>/<name>pPager</name>-&gt;<name>pageSize</name>)</expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>nPagePerSector</name>&gt;1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Pgno</name></type> <name>nPageCount</name></decl>;</decl_stmt>          <comment type="block">/* Total number of pages in database file */</comment>
    <decl_stmt><decl><type><name>Pgno</name></type> <name>pg1</name></decl>;</decl_stmt>                 <comment type="block">/* First page of the sector pPg is located on. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nPage</name></decl>;</decl_stmt>                <comment type="block">/* Number of pages starting at pg1 to journal */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needSync</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Set the doNotSync flag to 1. This is because we cannot allow a journal
    ** header to be written between the pages journaled by this function.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>doNotSync</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>doNotSync</name> = 1</expr>;</expr_stmt>

    <comment type="block">/* This trick assumes that both the page-size and sector-size are
    ** an integer power of 2. It sets variable pg1 to the identifier
    ** of the first page of the sector pPg is located on.
    */</comment>
    <expr_stmt><expr><name>pg1</name> = ((<name>pPg</name>-&gt;<name>pgno</name>-1) &amp; ~(<name>nPagePerSector</name>-1)) + 1</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3PagerPagecount</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>(<name>int</name> *)&amp;<name>nPageCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPg</name>-&gt;<name>pgno</name>&gt;<name>nPageCount</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nPage</name> = (<name>pPg</name>-&gt;<name>pgno</name> - <name>pg1</name>)+1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>(<name>pg1</name>+<name>nPagePerSector</name>-1)&gt;<name>nPageCount</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nPage</name> = <name>nPageCount</name>+1-<name>pg1</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nPage</name> = <name>nPagePerSector</name></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nPage</name>&gt;0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pg1</name>&lt;=<name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>pg1</name>+<name>nPage</name>)&gt;<name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>nPage</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Pgno</name></type> <name>pg</name> =<init> <expr><name>pg1</name>+<name>ii</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPage</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pg</name>==<name>pPg</name>-&gt;<name>pgno</name> || !<call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>pg</name>!=<call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr>&amp;<name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>rc</name> = <call><name>pager_write</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>pPage</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>needSync</name> = 1</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>needSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr>(<name>pPage</name> = <call><name>pager_lookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>pPage</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>needSync</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></for>

    <comment type="block">/* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages 
    ** starting at pg1, then it needs to be set for all of them. Because
    ** writing to any of these nPage pages may damage the others, the
    ** journal file must contain sync()ed copies of all of them
    ** before any of them can be written out to the database file.
    */</comment>
    <if>if<condition>( <expr><name>needSync</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>MEMDB</name> &amp;&amp; <name>pPager</name>-&gt;<name>noSync</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>ii</name>=0</expr>;</init> <condition><expr><name>ii</name>&lt;<name>nPage</name> &amp;&amp; <name>needSync</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPage</name> =<init> <expr><call><name>pager_lookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pg1</name>+<name>ii</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pPage</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pPage</name>-&gt;<name>flags</name> |= <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>needSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>doNotSync</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>doNotSync</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>pager_write</name><argument_list>(<argument><expr><name>pDbPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the page given in the argument was previously passed
** to sqlite3PagerWrite().  In other words, return TRUE if it is ok
** to change the content of the page.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3PagerIswriteable</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** A call to this routine tells the pager that it is not necessary to
** write the information on page pPg back to the disk, even though
** that page might be marked as dirty.  This happens, for example, when
** the page has been added as a leaf of the freelist and so its
** content no longer matters.
**
** The overlying software layer calls this routine when all of the data
** on the given page is unused.  The pager marks the page as clean so
** that it does not get written to disk.
**
** Tests show that this optimization, together with the
** sqlite3PagerDontRollback() below, more than double the speed
** of large INSERT operations and quadruple the speed of large DELETEs.
**
** When this routine is called, set the bit corresponding to pDbPage in
** the Pager.pAlwaysRollback bitvec.  Subsequent calls to
** sqlite3PagerDontRollback() for the same page will thereafter be ignored.
** This is necessary to avoid a problem where a page with data is added to
** the freelist during one part of a transaction then removed from the
** freelist during a later part of the same transaction and reused for some
** other purpose.  When it is first added to the freelist, this routine is
** called.  When reused, the sqlite3PagerDontRollback() routine is called.
** But because the page contains critical data, we still need to be sure it
** gets rolled back in spite of the sqlite3PagerDontRollback() call.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerDontWrite</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name> =<init> <expr><name>pDbPage</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name> = <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbOrigSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; (<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name>) &amp;&amp; <name>pPager</name>-&gt;<name>nSavepoint</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_SHARED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>==<name>pPg</name>-&gt;<name>pgno</name> &amp;&amp; <name>pPager</name>-&gt;<name>dbOrigSize</name>&lt;<name>pPager</name>-&gt;<name>dbSize</name></expr> )</condition><then><block>{
      <comment type="block">/* If this pages is the last page in the file and the file has grown
      ** during the current transaction, then do NOT mark the page as clean.
      ** When the database file grows, we must make sure that the last page
      ** gets written at least once so that the disk file will be the correct
      ** size. If you do not write this page and the size of the file
      ** on the disk ends up being too small, that can lead to database
      ** corruption during the next transaction.
      */</comment>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("DONT_WRITE page %d of %d\n", <name>pPg</name>-&gt;<name>pgno</name>, <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <macro><name>IOTRACE</name><argument_list>(<argument>("CLEAN %p %d\n", pPager, pPg-&gt;pgno)</argument>)</argument_list></macro>
      <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> |= <name>PGHDR_DONT_WRITE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
      <expr_stmt><expr><name>pPg</name>-&gt;<name>pageHash</name> = <call><name>pager_pagehash</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** A call to this routine tells the pager that if a rollback occurs,
** it is not necessary to restore the data on the given page.  This
** means that the pager does not have to record the given page in the
** rollback journal.
**
** If we have not yet actually read the content of this page (if
** the PgHdr.needRead flag is set) then this routine acts as a promise
** that we will never need to read the page content in the future.
** so the needRead flag can be cleared at this point.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerDontRollback</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>int rc;</argument> )</argument_list></macro>  <comment type="block">/* Return value from sqlite3BitvecSet() */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_RESERVED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the journal file is not open, or DontWrite() has been called on
  ** this page (DontWrite() sets the Pager.pAlwaysRollback bit), then this
  ** function is a no-op.
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name>==0 
   || <call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pAlwaysRollback</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call>
   || <name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr>
  )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SECURE_DELETE</name></cpp:ifdef>
  <if>if<condition>( <expr><call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call>!=0
   || <name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If SECURE_DELETE is disabled, then there is no way that this
  ** routine can be called on a page for which sqlite3PagerDontWrite()
  ** has not been previously called during the same transaction.
  ** And if DontWrite() has previously been called, the following
  ** conditions must be met.
  **
  ** (Later:)  Not true.  If the database is corrupted by having duplicate
  ** pages on the freelist (ex: corrupt9.test) then the following is not
  ** necessarily true:
  */</comment>
  <comment type="block">/* assert( !pPg-&gt;inJournal &amp;&amp; (int)pPg-&gt;pgno &lt;= pPager-&gt;dbOrigSize ); */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>pInJournal</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_NEED_READ</name></expr>;</expr_stmt>

  <comment type="block">/* Failure to set the bits in the InJournal bit-vectors is benign.
  ** It merely means that we might do some extra work to journal a page
  ** that does not need to be journaled.  Nevertheless, be sure to test the
  ** case where a malloc error occurs while trying to set a bit in a 
  ** bit vector.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>rc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name>sqlite3BitvecSet</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>TESTONLY</name><argument_list>( <argument>rc =</argument> )</argument_list></macro> <expr_stmt><expr><call><name>addToSavepointBitvecs</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPg</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("DONT_ROLLBACK page %d of %d\n", <name>pPg</name>-&gt;<name>pgno</name>, <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>("GARBAGE %p %d\n", pPager, pPg-&gt;pgno)</argument>)</argument_list></macro>
}</block></function>


<comment type="block">/*
** This routine is called to increment the database file change-counter,
** stored at byte 24 of the pager file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pager_incr_changecounter</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>isDirect</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPgHdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>change_counter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isDirect</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* isDirect is only true for atomic writes */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>changeCountDone</name> &amp;&amp; <name>pPager</name>-&gt;<name>dbSize</name>&gt;0</expr> )</condition><then><block>{
    <comment type="block">/* Open page 1 of the file for writing. */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

    <if>if<condition>( <expr>!<name>isDirect</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Increment the value just read and write it back to byte 24. */</comment>
    <expr_stmt><expr><name>change_counter</name> = <call><name>sqlite3Get4byte</name><argument_list>(<argument><expr>(<name>u8</name>*)<name>pPager</name>-&gt;<name>dbFileVers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>change_counter</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>put32bits</name><argument_list>(<argument><expr>((<name>char</name>*)<name>pPgHdr</name>-&gt;<name>pData</name>)+24</expr></argument>, <argument><expr><name>change_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
    <if>if<condition>( <expr><name>isDirect</name> &amp;&amp; <name>pPager</name>-&gt;<name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>const</name> <name>void</name> *</type><name>zBuf</name> =<init> <expr><name>pPgHdr</name>-&gt;<name>pData</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbFileSize</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsWrite</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>pageSize</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Release the page reference. */</comment>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>changeCountDone</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sync the pager file to disk.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerSync</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>MEMDB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sync_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sync the database file for the pager pPager. zMaster points to the name
** of a master journal file that should be written into the individual
** journal file. zMaster may be NULL, which is interpreted as no master
** journal (a single database transaction).
**
** This routine ensures that the journal is synced, all dirty pages written
** to the database file and the database file synced. The only thing that
** remains to commit the transaction is to delete the journal file (or
** master journal file if specified).
**
** Note that if zMaster==NULL, this does not overwrite a previous value
** passed to an sqlite3PagerCommitPhaseOne() call.
**
** If the final parameter - noSync - is true, then the database file itself
** is not synced. The caller must call sqlite3PagerSync() directly to
** sync the database file before calling CommitPhaseTwo() to delete the
** journal file in this case.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCommitPhaseOne</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zMaster</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>noSync</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
    <return>return <expr><name>pPager</name>-&gt;<name>errCode</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* If no changes have been made, we can leave the transaction early.
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbModified</name>==0 &amp;&amp;
        (<name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_DELETE</name> ||
          <name>pPager</name>-&gt;<name>exclusiveMode</name>!=0)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dirtyCache</name>==0 || <name>pPager</name>-&gt;<name>journalOpen</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n", 
      <name>pPager</name>-&gt;<name>zFilename</name>, <name>zMaster</name>, <name>pPager</name>-&gt;<name>dbSize</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is an in-memory db, or no pages have been written to, or this
  ** function has already been called, it is a no-op.
  */</comment>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>!=<name>PAGER_SYNCED</name> &amp;&amp; !<name>MEMDB</name> &amp;&amp; <name>pPager</name>-&gt;<name>dirtyCache</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ATOMIC_WRITE</name></cpp:ifdef>
    <comment type="block">/* The atomic-write optimization can be used if all of the
    ** following are true:
    **
    **    + The file-system supports the atomic-write property for
    **      blocks of size page-size, and
    **    + This commit is not part of a multi-file transaction, and
    **    + Exactly one page has been modified and store in the journal file.
    **
    ** If the optimization can be used, then the journal file will never
    ** be created for this transaction.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>useAtomicWrite</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pPg</name> = <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>useAtomicWrite</name> = (
        !<name>zMaster</name> &amp;&amp; 
        <name>pPager</name>-&gt;<name>journalOpen</name> &amp;&amp;
        <name>pPager</name>-&gt;<name>journalOff</name>==<call><name>jrnlBufferSize</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call> &amp;&amp; 
        <name>pPager</name>-&gt;<name>dbSize</name>&gt;=<name>pPager</name>-&gt;<name>dbFileSize</name> &amp;&amp; 
        (<name>pPg</name>==0 || <name>pPg</name>-&gt;<name>pDirty</name>==0)
    )</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>journalOpen</name> || <name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_OFF</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>useAtomicWrite</name></expr> )</condition><then><block>{
      <comment type="block">/* Update the nRec field in the journal file. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>offset</name> =<init> <expr><name>pPager</name>-&gt;<name>journalHdr</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>aJournalMagic</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>nRec</name>==1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>write32bits</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>nRec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Update the db file change counter. The following call will modify
      ** the in-memory representation of page 1 to include the updated
      ** change counter and then write page 1 directly to the database
      ** file. Because of the atomic-write property of the host file-system, 
      ** this is safe.
      */</comment>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>pager_incr_changecounter</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3JournalCreate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>jfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if<condition>( <expr>!<name>useAtomicWrite</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If a master journal file name has already been written to the
    ** journal file, then no sync is required. This happens when it is
    ** written, then the process fails to upgrade from a RESERVED to an
    ** EXCLUSIVE lock. The next time the process tries to commit the
    ** transaction the m-j name will have already been written.
    */</comment>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>setMaster</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_incr_changecounter</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>
      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_OFF</name></expr> )</condition><then><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
        <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>&lt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr> )</condition><then><block>{
          <comment type="block">/* If this transaction has made the database smaller, then all pages
          ** being discarded by the truncation must be written to the journal
          ** file.
          */</comment>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>iSkip</name> =<init> <expr><call><name>PAGER_MJ_PGNO</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>Pgno</name></type> <name>dbSize</name> =<init> <expr><name>pPager</name>-&gt;<name>dbSize</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>pPager</name>-&gt;<name>dbOrigSize</name></expr>;</expr_stmt>
          <for>for( <init><expr><name>i</name>=<name>dbSize</name>+1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>pPager</name>-&gt;<name>dbOrigSize</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
            <if>if<condition>( <expr>!<call><name>sqlite3BitvecTest</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> &amp;&amp; <name>i</name>!=<name>iSkip</name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>
              <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerWrite</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>
            }</block></then></if>
          }</block></for> 
          <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSize</name> = <name>dbSize</name></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>rc</name> = <call><name>writeMasterJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>zMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>
        <expr_stmt><expr><name>rc</name> = <call><name>syncJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>

    <comment type="block">/* Write all dirty pages to the database file */</comment>
    <expr_stmt><expr><name>pPg</name> = <call><name>sqlite3PcacheDirtyList</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>pager_write_pagelist</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>!=<name>SQLITE_IOERR_BLOCKED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The error might have left the dirty list all fouled up here,
      ** but that does not matter because if the if the dirty list did
      ** get corrupted, then the transaction will roll back and
      ** discard the dirty list.  There is an assert in
      ** pager_get_all_dirty_pages() that verifies that no attempt
      ** is made to use an invalid dirty list.
      */</comment>
      <goto>goto <name>sync_exit</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3PcacheCleanAll</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbSize</name>&lt;<name>pPager</name>-&gt;<name>dbFileSize</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>pager_truncate</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>dbSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then> <goto>goto <name>sync_exit</name>;</goto></then></if>
    }</block></then></if>

    <comment type="block">/* Sync the database file. */</comment>
    <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>noSync</name> &amp;&amp; !<name>noSync</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsSync</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>sync_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <macro><name>IOTRACE</name><argument_list>(<argument>("DBSYNC %p\n", pPager)</argument>)</argument_list></macro>

    <expr_stmt><expr><name>pPager</name>-&gt;<name>state</name> = <name>PAGER_SYNCED</name></expr>;</expr_stmt>
  }</block></then></if>

<label><name>sync_exit</name>:</label>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IOERR_BLOCKED</name></expr> )</condition><then><block>{
    <comment type="block">/* pager_incr_changecounter() may attempt to obtain an exclusive
     * lock to spill the cache and return IOERR_BLOCKED. But since 
     * there is no chance the cache is inconsistent, it is
     * better to return SQLITE_BUSY.
     */</comment>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Commit all changes to the database and release the write lock.
**
** If the commit fails for any reason, a rollback attempt is made
** and an error code is returned.  If the commit worked, SQLITE_OK
** is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerCommitPhaseTwo</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name></expr> )</condition><then><block>{
    <return>return <expr><name>pPager</name>-&gt;<name>errCode</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&lt;<name>PAGER_RESERVED</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pPager</name>-&gt;<name>dbModified</name>==0 &amp;&amp;
        (<name>pPager</name>-&gt;<name>journalMode</name>!=<name>PAGER_JOURNALMODE_DELETE</name> ||
          <name>pPager</name>-&gt;<name>exclusiveMode</name>!=0)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dirtyCache</name>==0 || <name>pPager</name>-&gt;<name>journalOpen</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("COMMIT %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_SYNCED</name> || <name>MEMDB</name> || !<name>pPager</name>-&gt;<name>dirtyCache</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>setMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Rollback all changes.  The database falls back to PAGER_SHARED mode.
** All in-memory cache pages revert to their original data contents.
** The journal is deleted.
**
** This routine cannot fail unless some other process is not following
** the correct locking protocol or unless some other
** process is writing trash into the journal file (SQLITE_CORRUPT) or
** unless a prior malloc() failed (SQLITE_NOMEM).  Appropriate error
** codes are returned for all these occasions.  Otherwise,
** SQLITE_OK is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerRollback</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("ROLLBACK %d\n", <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pPager</name>-&gt;<name>dirtyCache</name> || !<name>pPager</name>-&gt;<name>journalOpen</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>setMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pPager</name>-&gt;<name>errCode</name> &amp;&amp; <name>pPager</name>-&gt;<name>errCode</name>!=<name>SQLITE_FULL</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>&gt;=<name>PAGER_EXCLUSIVE</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <name>pPager</name>-&gt;<name>errCode</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>pPager</name>-&gt;<name>state</name>==<name>PAGER_RESERVED</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc2</name> = <call><name>pager_end_transaction</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pPager</name>-&gt;<name>setMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>rc2</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <call><name>pager_playback</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if<condition>( <expr>!<name>MEMDB</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>dbSizeValid</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If an error occurs during a ROLLBACK, we can no longer trust the pager
    ** cache. So call pager_error() on the way out to make any error 
    ** persistent.
    */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>pager_error</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the database file is opened read-only.  Return FALSE
** if the database is (in theory) writable.
*/</comment>
<function><type><name>u8</name></type> <name>sqlite3PagerIsreadonly</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>readOnly</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the number of references to the pager.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerRefcount</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the number of references to the specified page.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerPageRefcount</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <return>return <expr><call><name>sqlite3PcachePageRefcount</name><argument_list>(<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** This routine is used for testing and analysis only.
*/</comment>
<function><type><name>int</name> *</type><name>sqlite3PagerStats</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name><name>a</name><index>[<expr>11</expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>0</expr>]</index></name> = <call><name>sqlite3PcacheRefCount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>1</expr>]</index></name> = <call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>2</expr>]</index></name> = <call><name>sqlite3PcacheGetCachesize</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pPCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>3</expr>]</index></name> = <name>pPager</name>-&gt;<name>dbSizeValid</name> ? (<name>int</name>) <name>pPager</name>-&gt;<name>dbSize</name> : -1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>4</expr>]</index></name> = <name>pPager</name>-&gt;<name>state</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>5</expr>]</index></name> = <name>pPager</name>-&gt;<name>errCode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>6</expr>]</index></name> = <name>pPager</name>-&gt;<name>nHit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>7</expr>]</index></name> = <name>pPager</name>-&gt;<name>nMiss</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>8</expr>]</index></name> = 0</expr>;</expr_stmt>  <comment type="block">/* Used to be pPager-&gt;nOvfl */</comment>
  <expr_stmt><expr><name><name>a</name><index>[<expr>9</expr>]</index></name> = <name>pPager</name>-&gt;<name>nRead</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>10</expr>]</index></name> = <name>pPager</name>-&gt;<name>nWrite</name></expr>;</expr_stmt>
  <return>return <expr><name>a</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3PagerIsMemdb</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>MEMDB</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Ensure that there are at least nSavepoint savepoints open.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerOpenSavepoint</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>nSavepoint</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>nSavepoint</name>&gt;<name>pPager</name>-&gt;<name>nSavepoint</name> &amp;&amp; <name>pPager</name>-&gt;<name>useJournal</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PagerSavepoint</name> *</type><name>aNew</name></decl>;</decl_stmt>

    <comment type="block">/* Either there is no active journal or the sub-journal is open or 
    ** the journal is always stored in memory */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>nSavepoint</name>==0 || <name>pPager</name>-&gt;<name>sjfd</name>-&gt;<name>pMethods</name> ||
            <name>pPager</name>-&gt;<name>journalMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM
    ** if the allocation fails. Otherwise, zero the new portion in case a 
    ** malloc failure occurs while populating it in the for(...) loop below.
    */</comment>
    <expr_stmt><expr><name>aNew</name> = (<name>PagerSavepoint</name> *)<call><name>sqlite3Realloc</name><argument_list>(
        <argument><expr><name>pPager</name>-&gt;<name>aSavepoint</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PagerSavepoint</name></expr></argument>)</argument_list></call>*<name>nSavepoint</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>aNew</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>aNew</name><index>[<expr><name>pPager</name>-&gt;<name>nSavepoint</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>,
        <argument><expr>(<name>nSavepoint</name> - <name>pPager</name>-&gt;<name>nSavepoint</name>) * <call><name>sizeof</name><argument_list>(<argument><expr><name>PagerSavepoint</name></expr></argument>)</argument_list></call></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>aSavepoint</name> = <name>aNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ii</name> = <name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>nSavepoint</name> = <name>nSavepoint</name></expr>;</expr_stmt>

    <comment type="block">/* Populate the PagerSavepoint structures just allocated. */</comment>
    <for>for(<comment type="block">/* no-op */</comment><init>;</init> <condition><expr><name>ii</name>&lt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>dbSizeValid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>nOrig</name> = <name>pPager</name>-&gt;<name>dbSize</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>journalOpen</name> &amp;&amp; <name>pPager</name>-&gt;<name>journalOff</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iOffset</name> = <name>pPager</name>-&gt;<name>journalOff</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iOffset</name> = <call><name>JOURNAL_HDR_SZ</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>iSubRec</name> = <name>pPager</name>-&gt;<name>stmtNRec</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>pInSavepoint</name> = <call><name>sqlite3BitvecCreate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>dbSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name><name>aNew</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>pInSavepoint</name></expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* Open the sub-journal, if it is not already opened. */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>openSubJournal</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.
** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with
** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes
** that have occured since savepoint iSavepoint was created.
**
** In either case, all savepoints with an index greater than iSavepoint 
** are destroyed.
**
** If there are less than (iSavepoint+1) active savepoints when this 
** function is called it is a no-op.
*/</comment> 
<function><type><name>int</name></type> <name>sqlite3PagerSavepoint</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>int</name></type> <name>iSavepoint</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>==<name>SAVEPOINT_RELEASE</name> || <name>op</name>==<name>SAVEPOINT_ROLLBACK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>iSavepoint</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nNew</name> =<init> <expr><name>iSavepoint</name> + (<name>op</name>==<name>SAVEPOINT_ROLLBACK</name>)</expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>ii</name>=<name>nNew</name></expr>;</init> <condition><expr><name>ii</name>&lt;<name>pPager</name>-&gt;<name>nSavepoint</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3BitvecDestroy</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>ii</name></expr>]</index></name>.<name>pInSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>nSavepoint</name> = <name>nNew</name></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>op</name>==<name>SAVEPOINT_ROLLBACK</name> &amp;&amp; <name>pPager</name>-&gt;<name>jfd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>PagerSavepoint</name> *</type><name>pSavepoint</name> =<init> <expr>(<name>nNew</name>==0)?0:&amp;<name>pPager</name>-&gt;<name><name>aSavepoint</name><index>[<expr><name>nNew</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>pagerPlaybackSavepoint</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name>!=<name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  
    <comment type="block">/* If this is a release of the outermost savepoint, truncate 
    ** the sub-journal. */</comment>
    <if>if<condition>( <expr><name>nNew</name>==0 &amp;&amp; <name>op</name>==<name>SAVEPOINT_RELEASE</name> &amp;&amp; <name>pPager</name>-&gt;<name>sjfd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsTruncate</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>sjfd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name>-&gt;<name>stmtNRec</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the full pathname of the database file.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3PagerFilename</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>zFilename</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the VFS structure for the pager.
*/</comment>
<function><type><name>const</name> <name>sqlite3_vfs</name> *</type><name>sqlite3PagerVfs</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>pVfs</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the file handle for the database file associated
** with the pager.  This might return NULL if the file has
** not yet been opened.
*/</comment>
<function><type><name>sqlite3_file</name> *</type><name>sqlite3PagerFile</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>fd</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the directory of the database file.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3PagerDirname</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>zDirectory</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the full pathname of the journal file.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3PagerJournalname</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>zJournal</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return true if fsync() calls are disabled for this pager.  Return FALSE
** if fsync()s are executed normally.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerNosync</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pPager</name>-&gt;<name>noSync</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
<comment type="block">/*
** Set the codec for this pager
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PagerSetCodec</name><parameter_list>(
  <param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>,
  <param><function_decl><type><name>void</name> *</type>(*<name>xCodec</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>Pgno</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pCodecArg</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><name>pPager</name>-&gt;<name>xCodec</name> = <name>xCodec</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>pCodecArg</name> = <name>pCodecArg</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<comment type="block">/*
** Move the page pPg to location pgno in the file.
**
** There must be no references to the page previously located at
** pgno (which we call pPgOld) though that page is allowed to be
** in cache.  If the page previously located at pgno is not already
** in the rollback journal, it is not put there by by this routine.
**
** References to the page pPg remain valid. Updating any
** meta-data associated with pPg (i.e. data stored in the nExtra bytes
** allocated along with the page) is the responsibility of the caller.
**
** A transaction must be active when this routine is called. It used to be
** required that a statement transaction was not active, but this restriction
** has been removed (CREATE INDEX needs to move a page when a statement
** transaction is active).
**
** If the fourth argument, isCommit, is non-zero, then this page is being
** moved as part of a database reorganization just before the transaction 
** is being committed. In this case, it is guaranteed that the database page 
** pPg refers to will not be written to again within this transaction.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerMovepage</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>int</name></type> <name>isCommit</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPgOld</name></decl>;</decl_stmt>  <comment type="block">/* The page being overwritten. */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>needSyncPgno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the page being moved is dirty and has not been saved by the latest
  ** savepoint, then save the current contents of the page into the 
  ** sub-journal now. This is required to handle the following scenario:
  **
  **   BEGIN;
  **     &lt;journal page X, then modify it in memory&gt;
  **     SAVEPOINT one;
  **       &lt;Move page X to location Y&gt;
  **     ROLLBACK TO one;
  **
  ** If page X were not written to the sub-journal here, it would not
  ** be possible to restore its contents when the "ROLLBACK TO one"
  ** statement were processed.
  */</comment>
  <if>if<condition>( <expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name> 
   &amp;&amp; <call><name>subjRequiresPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call>
   &amp;&amp; <name>SQLITE_OK</name>!=(<name>rc</name> = <call><name>subjournalPage</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call>)</expr>
  )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>PAGERTRACE</name><argument_list>(<argument><expr>("MOVE %d page %d (needSync=%d) moves to %d\n", 
      <call><name>PAGERID</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call>, <name>pPg</name>-&gt;<name>pgno</name>, (<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)?1:0, <name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>IOTRACE</name><argument_list>(<argument>("MOVE %p %d %d\n", pPager, pPg-&gt;pgno, pgno)</argument>)</argument_list></macro>

  <expr_stmt><expr><call><name>pager_get_content</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the journal needs to be sync()ed before page pPg-&gt;pgno can
  ** be written to, store pPg-&gt;pgno in local variable needSyncPgno.
  **
  ** If the isCommit flag is set, there is no need to remember that
  ** the journal needs to be sync()ed before database page pPg-&gt;pgno 
  ** can be written to. The caller has already promised not to write to it.
  */</comment>
  <if>if<condition>( <expr>(<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>) &amp;&amp; !<name>isCommit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>needSyncPgno</name> = <name>pPg</name>-&gt;<name>pgno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>pageInJournal</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call> || <name>pPg</name>-&gt;<name>pgno</name>&gt;<name>pPager</name>-&gt;<name>dbOrigSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>needSync</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the cache contains a page with page-number pgno, remove it
  ** from its hash chain. Also, if the PgHdr.needSync was set for 
  ** page pgno before the 'move' operation, it needs to be retained 
  ** for the page moved there.
  */</comment>
  <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPgOld</name> = <call><name>pager_lookup</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pPgOld</name> || <name>pPgOld</name>-&gt;<name>nRef</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPgOld</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPg</name>-&gt;<name>flags</name> |= (<name>pPgOld</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3PcacheMove</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPgOld</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3PcacheDrop</name><argument_list>(<argument><expr><name>pPgOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dirtyCache</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPager</name>-&gt;<name>dbModified</name> = 1</expr>;</expr_stmt>

  <if>if<condition>( <expr><name>needSyncPgno</name></expr> )</condition><then><block>{
    <comment type="block">/* If needSyncPgno is non-zero, then the journal file needs to be 
    ** sync()ed before any data is written to database file page needSyncPgno.
    ** Currently, no such page exists in the page-cache and the 
    ** "is journaled" bitvec flag has been set. This needs to be remedied by
    ** loading the page into the pager-cache and setting the PgHdr.needSync 
    ** flag.
    **
    ** If the attempt to load the page into the page-cache fails, (due
    ** to a malloc() or IO failure), clear the bit in the pInJournal[]
    ** array. Otherwise, if the page is loaded and written again in
    ** this transaction, it may be written to the database file before
    ** it is synced into the journal file. This way, it may end up in
    ** the journal file twice, but that is not a problem.
    **
    ** The sqlite3PagerGet() call may cause the journal to sync. So make
    ** sure the Pager.needSync flag is set too.
    */</comment>
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPgHdr</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>needSync</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PagerGet</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>, <argument><expr><name>needSyncPgno</name></expr></argument>, <argument><expr>&amp;<name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pPager</name>-&gt;<name>pInJournal</name> &amp;&amp; <name>needSyncPgno</name>&lt;=<name>pPager</name>-&gt;<name>dbOrigSize</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3BitvecClear</name><argument_list>(<argument><expr><name>pPager</name>-&gt;<name>pInJournal</name></expr></argument>, <argument><expr><name>needSyncPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pPager</name>-&gt;<name>needSync</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>-&gt;<name>noSync</name>==0 &amp;&amp; !<name>MEMDB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPgHdr</name>-&gt;<name>flags</name> |= <name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeDirty</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerUnref</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return a pointer to the data for the specified page.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3PagerGetData</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPg</name>-&gt;<name>nRef</name>&gt;0 || <name>pPg</name>-&gt;<name>pPager</name>-&gt;<name>memDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pPg</name>-&gt;<name>pData</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a pointer to the Pager.nExtra bytes of "extra" space 
** allocated along with the specified page.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3PagerGetExtra</name><parameter_list>(<param><decl><type><name>DbPage</name> *</type><name>pPg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name> =<init> <expr><name>pPg</name>-&gt;<name>pPager</name></expr></init></decl>;</decl_stmt>
  <return>return <expr>(<name>pPager</name>?<name>pPg</name>-&gt;<name>pExtra</name>:0)</expr>;</return>
}</block></function>

<comment type="block">/*
** Get/set the locking-mode for this pager. Parameter eMode must be one
** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or 
** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then
** the locking-mode is set to the value specified.
**
** The returned value is either PAGER_LOCKINGMODE_NORMAL or
** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)
** locking-mode.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerLockingMode</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>eMode</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name>==<name>PAGER_LOCKINGMODE_QUERY</name>
            || <name>eMode</name>==<name>PAGER_LOCKINGMODE_NORMAL</name>
            || <name>eMode</name>==<name>PAGER_LOCKINGMODE_EXCLUSIVE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_QUERY</name>&lt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_LOCKINGMODE_NORMAL</name>&gt;=0 &amp;&amp; <name>PAGER_LOCKINGMODE_EXCLUSIVE</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eMode</name>&gt;=0 &amp;&amp; !<name>pPager</name>-&gt;<name>tempFile</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>exclusiveMode</name> = (<name>u8</name>)<name>eMode</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>(<name>int</name>)<name>pPager</name>-&gt;<name>exclusiveMode</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Get/set the journal-mode for this pager. Parameter eMode must be one of:
**
**    PAGER_JOURNALMODE_QUERY
**    PAGER_JOURNALMODE_DELETE
**    PAGER_JOURNALMODE_TRUNCATE
**    PAGER_JOURNALMODE_PERSIST
**    PAGER_JOURNALMODE_OFF
**
** If the parameter is not _QUERY, then the journal-mode is set to the
** value specified.
**
** The returned indicate the current (possibly updated)
** journal-mode.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PagerJournalMode</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>int</name></type> <name>eMode</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>MEMDB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name>==<name>PAGER_JOURNALMODE_QUERY</name>
              || <name>eMode</name>==<name>PAGER_JOURNALMODE_DELETE</name>
              || <name>eMode</name>==<name>PAGER_JOURNALMODE_TRUNCATE</name>
              || <name>eMode</name>==<name>PAGER_JOURNALMODE_PERSIST</name>
              || <name>eMode</name>==<name>PAGER_JOURNALMODE_OFF</name> 
              || <name>eMode</name>==<name>PAGER_JOURNALMODE_MEMORY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PAGER_JOURNALMODE_QUERY</name>&lt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>eMode</name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pPager</name>-&gt;<name>journalMode</name> = (<name>u8</name>)<name>eMode</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eMode</name>==<name>PAGER_JOURNALMODE_QUERY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr>(<name>int</name>)<name>pPager</name>-&gt;<name>journalMode</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Get/set the size-limit used for persistent journal files.
*/</comment>
<function><type><name>i64</name></type> <name>sqlite3PagerJournalSizeLimit</name><parameter_list>(<param><decl><type><name>Pager</name> *</type><name>pPager</name></decl></param>, <param><decl><type><name>i64</name></type> <name>iLimit</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>iLimit</name>&gt;=-1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPager</name>-&gt;<name>journalSizeLimit</name> = <name>iLimit</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pPager</name>-&gt;<name>journalSizeLimit</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_DISKIO */</comment>
</unit>
