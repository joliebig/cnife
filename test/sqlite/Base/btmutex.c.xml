<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="btmutex.c" filename=""><comment type="block">/*
** 2007 August 27
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** $Id: btmutex.c,v 1.12 2008/11/17 19:18:55 danielk1977 Exp $
**
** This file contains code used to implement mutexes on Btree objects.
** This code really belongs in btree.c.  But btree.c is getting too
** big and we want to break it down some.  This packaged seemed like
** a good breakout.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btreeInt.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SHARED_CACHE</name></expr></argument>)</argument_list></call></expr></cpp:if>


<comment type="block">/*
** Enter a mutex on the given BTree object.
**
** If the object is not sharable, then no mutex is ever required
** and this routine is a no-op.  The underlying mutex is non-recursive.
** But we keep a reference count in Btree.wantToLock so the behavior
** of this interface is recursive.
**
** To avoid deadlocks, multiple Btrees are locked in the same order
** by all database connections.  The p-&gt;pNext is a list of other
** Btrees belonging to the same database connection as the p Btree
** which need to be locked after p.  If we cannot get a lock on
** p, then first unlock all of the others on p-&gt;pNext, then wait
** for the lock to become available on p, then relock all of the
** subsequent Btrees that desire a lock.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeEnter</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pLater</name></decl>;</decl_stmt>

  <comment type="block">/* Some basic sanity checking on the Btree.  The list of Btrees
  ** connected by pNext and pPrev should be in sorted order by
  ** Btree.pBt value. All elements of the list should belong to
  ** the same connection. Only shared Btrees are on the list. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pNext</name>==0 || <name>p</name>-&gt;<name>pNext</name>-&gt;<name>pBt</name>&gt;<name>p</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pPrev</name>==0 || <name>p</name>-&gt;<name>pPrev</name>-&gt;<name>pBt</name>&lt;<name>p</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pNext</name>==0 || <name>p</name>-&gt;<name>pNext</name>-&gt;<name>db</name>==<name>p</name>-&gt;<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pPrev</name>==0 || <name>p</name>-&gt;<name>pPrev</name>-&gt;<name>db</name>==<name>p</name>-&gt;<name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>sharable</name> || (<name>p</name>-&gt;<name>pNext</name>==0 &amp;&amp; <name>p</name>-&gt;<name>pPrev</name>==0)</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for locking consistency */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>p</name>-&gt;<name>locked</name> || <name>p</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>sharable</name> || <name>p</name>-&gt;<name>wantToLock</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We should already hold a lock on the database connection */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>sharable</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>++</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>locked</name></expr> )</condition><then> <return>return;</return></then></if>

  <comment type="block">/* In most cases, we should be able to acquire the lock we
  ** want without having to go throught the ascending lock
  ** procedure that follows.  Just be sure not to block.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3_mutex_try</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 1</expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="block">/* To avoid deadlock, first release all locks with a larger
  ** BtShared address.  Then acquire our lock.  Then reacquire
  ** the other BtShared locks that we used to hold in ascending
  ** order.
  */</comment>
  <for>for(<init><expr><name>pLater</name>=<name>p</name>-&gt;<name>pNext</name></expr>;</init> <condition><expr><name>pLater</name></expr>;</condition> <incr><expr><name>pLater</name>=<name>pLater</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLater</name>-&gt;<name>sharable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLater</name>-&gt;<name>pNext</name>==0 || <name>pLater</name>-&gt;<name>pNext</name>-&gt;<name>pBt</name>&gt;<name>pLater</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pLater</name>-&gt;<name>locked</name> || <name>pLater</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLater</name>-&gt;<name>locked</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pLater</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLater</name>-&gt;<name>locked</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 1</expr>;</expr_stmt>
  <for>for(<init><expr><name>pLater</name>=<name>p</name>-&gt;<name>pNext</name></expr>;</init> <condition><expr><name>pLater</name></expr>;</condition> <incr><expr><name>pLater</name>=<name>pLater</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>pLater</name>-&gt;<name>wantToLock</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pLater</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLater</name>-&gt;<name>locked</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Exit the recursive mutex on a Btree.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeLeave</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>wantToLock</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>locked</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return true if the BtShared mutex is held on the btree.  
**
** This routine makes no determination one why or another if the
** database connection mutex is held.
**
** This routine is used only from within assert() statements.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeHoldsMutex</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr>(<name>p</name>-&gt;<name>sharable</name>==0 ||
             (<name>p</name>-&gt;<name>locked</name> &amp;&amp; <name>p</name>-&gt;<name>wantToLock</name> &amp;&amp; <call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call>))</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** Enter and leave a mutex on a Btree given a cursor owned by that
** Btree.  These entry points are used by incremental I/O and can be
** omitted if that module is not used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeEnterCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3BtreeLeaveCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pCur</name>-&gt;<name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_INCRBLOB */</comment>


<comment type="block">/*
** Enter the mutex on every Btree associated with a database
** connection.  This is needed (for example) prior to parsing
** a statement since we will be comparing table and column names
** against all schemas and we do not want those schemas being
** reset out from under us.
**
** There is a corresponding leave-all procedures.
**
** Enter the mutexes in accending order by BtShared pointer address
** to avoid the possibility of deadlock when two threads with
** two or more btrees in common both try to lock all their btrees
** at the same instant.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeEnterAll</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name>, *<name>pLater</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>p</name>-&gt;<name>locked</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>( <expr><name>p</name>-&gt;<name>pPrev</name></expr> )</condition> <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pPrev</name></expr>;</expr_stmt></while>
        <while>while<condition>( <expr><name>p</name>-&gt;<name>locked</name> &amp;&amp; <name>p</name>-&gt;<name>pNext</name></expr> )</condition> <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt></while>
        <for>for(<init><expr><name>pLater</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</init> <condition><expr><name>pLater</name></expr>;</condition> <incr><expr><name>pLater</name>=<name>pLater</name>-&gt;<name>pNext</name></expr></incr>)<block>{
          <if>if<condition>( <expr><name>pLater</name>-&gt;<name>locked</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pLater</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pLater</name>-&gt;<name>locked</name> = 0</expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>
        <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{
          <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name>-&gt;<name>locked</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        }</block></while>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3BtreeLeaveAll</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>--</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>wantToLock</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>locked</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/*
** Return true if the current thread holds the database connection
** mutex and all required BtShared mutexes.
**
** This routine is used inside assert() statements only.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeHoldsAllMutexes</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>sharable</name> &amp;&amp;
         (<name>p</name>-&gt;<name>wantToLock</name>==0 || !<call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NDEBUG */</comment>

<comment type="block">/*
** Add a new Btree pointer to a BtreeMutexArray. 
** if the pointer can possibly be shared with
** another database connection.
**
** The pointers are kept in sorted order by pBtree-&gt;pBt.  That
** way when we go to enter all the mutexes, we can enter them
** in order without every having to backup and retry and without
** worrying about deadlock.
**
** The number of shared btrees will always be small (usually 0 or 1)
** so an insertion sort is an adequate algorithm here.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeMutexArrayInsert</name><parameter_list>(<param><decl><type><name>BtreeMutexArray</name> *</type><name>pArray</name></decl></param>, <param><decl><type><name>Btree</name> *</type><name>pBtree</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pBtree</name>==0 || <name>pBtree</name>-&gt;<name>sharable</name>==0</expr> )</condition><then> <return>return;</return></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pArray</name>-&gt;<name>nMutex</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name>!=<name>pBtree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArray</name>-&gt;<name>nMutex</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArray</name>-&gt;<name>nMutex</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>pArray</name>-&gt;<name>aBtree</name></expr></argument>)</argument_list></call>-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBt</name> = <name>pBtree</name>-&gt;<name>pBt</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pArray</name>-&gt;<name>nMutex</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name>!=<name>pBtree</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>pBt</name>&gt;<name>pBt</name></expr> )</condition><then><block>{
      <for>for(<init><expr><name>j</name>=<name>pArray</name>-&gt;<name>nMutex</name></expr>;</init> <condition><expr><name>j</name>&gt;<name>i</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>)<block>{
        <expr_stmt><expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>j</name></expr>]</index></name> = <name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pBtree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pArray</name>-&gt;<name>nMutex</name>++</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>pArray</name>-&gt;<name>nMutex</name>++</expr>]</index></name> = <name>pBtree</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Enter the mutex of every btree in the array.  This routine is
** called at the beginning of sqlite3VdbeExec().  The mutexes are
** exited at the end of the same function.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeMutexArrayEnter</name><parameter_list>(<param><decl><type><name>BtreeMutexArray</name> *</type><name>pArray</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pArray</name>-&gt;<name>nMutex</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Some basic sanity checking */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>==0 || <name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name>-1</expr>]</index></name>-&gt;<name>pBt</name>&lt;<name>p</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>p</name>-&gt;<name>locked</name> || <name>p</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We should already hold a lock on the database connection */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>locked</name> &amp;&amp; <name>p</name>-&gt;<name>sharable</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Leave the mutex of every btree in the group.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeMutexArrayLeave</name><parameter_list>(<param><decl><type><name>BtreeMutexArray</name> *</type><name>pArray</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pArray</name>-&gt;<name>nMutex</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Btree</name> *</type><name>p</name> =<init> <expr><name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Some basic sanity checking */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name>==0 || <name>pArray</name>-&gt;<name><name>aBtree</name><index>[<expr><name>i</name>-1</expr>]</index></name>-&gt;<name>pBt</name>&lt;<name>p</name>-&gt;<name>pBt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>locked</name> || !<name>p</name>-&gt;<name>sharable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>wantToLock</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We should already hold a lock on the database connection */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name>-&gt;<name>wantToLock</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>wantToLock</name>==0 &amp;&amp; <name>p</name>-&gt;<name>locked</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBt</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>locked</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_THREADSAFE &amp;&amp; !SQLITE_OMIT_SHARED_CACHE */</comment>
</unit>
