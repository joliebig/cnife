<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="main.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Main file for the SQLite library.  The routines in this file
** implement the programmer interface to the library.  Routines in
** other files are for internal use by SQLite and should not be
** accessed by users of the library.
**
** $Id: main.c,v 1.521 2009/01/10 16:15:22 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"fts3.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"rtree.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqliteicu.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The version of the library
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<decl_stmt><decl><type><name>const</name> <name>char</name></type> <name><name>sqlite3_version</name><index>[]</index></name> =<init> <expr><name>SQLITE_VERSION</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3_libversion</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ <return>return <expr><name>sqlite3_version</name></expr>;</return> }</block></function>
<function><type><name>int</name></type> <name>sqlite3_libversion_number</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ <return>return <expr><name>SQLITE_VERSION_NUMBER</name></expr>;</return> }</block></function>
<function><type><name>int</name></type> <name>sqlite3_threadsafe</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ <return>return <expr><name>SQLITE_THREADSAFE</name></expr>;</return> }</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRACE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_IOTRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** If the following function pointer is not NULL and if
** SQLITE_ENABLE_IOTRACE is enabled, then messages describing
** I/O active are written using this function.  These messages
** are intended for debugging activity only.
*/</comment>
<function_decl><type><name>void</name></type> (*<name>sqlite3IoTrace</name>)<parameter_list>(<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>, <param>...</param>)</parameter_list> <specifier>= 0</specifier>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the following global variable points to a string which is the
** name of a directory, then that directory will be used to store
** temporary files.
**
** See also the "PRAGMA temp_store_directory" SQL command.
*/</comment>
<decl_stmt><decl><type><name>char</name> *</type><name>sqlite3_temp_directory</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Initialize SQLite.  
**
** This routine must be called to initialize the memory allocation,
** VFS, and mutex subsystems prior to doing any serious work with
** SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT
** this routine will be called automatically by key routines such as
** sqlite3_open().  
**
** This routine is a no-op except on its very first call for the process,
** or for the first call after a call to sqlite3_shutdown.
**
** The first thread to call this routine runs the initialization to
** completion.  If subsequent threads call this routine before the first
** thread has finished the initialization process, then the subsequent
** threads must block until the first thread finishes with the initialization.
**
** The first thread might call this routine recursively.  Recursive
** calls to this routine should not block, of course.  Otherwise the
** initialization process would never complete.
**
** Let X be the first thread to enter this routine.  Let Y be some other
** thread.  Then while the initial invocation of this routine by X is
** incomplete, it is required that:
**
**    *  Calls to this routine from Y must block until the outer-most
**       call by X completes.
**
**    *  Recursive calls to this routine from thread X return immediately
**       without blocking.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_initialize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>pMaster</name></decl>;</decl_stmt>                      <comment type="block">/* The main static mutex */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                                      <comment type="block">/* Result code */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_WSD</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_wsd_init</name><argument_list>(<argument><expr>4096</expr></argument>, <argument><expr>24</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If SQLite is already completely initialized, then this call
  ** to sqlite3_initialize() should be a no-op.  But the initialization
  ** must be complete.  So isInit must not be set until the very end
  ** of this routine.
  */</comment>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>isInit</name></expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>

  <comment type="block">/* Make sure the mutex subsystem is initialized.  If unable to 
  ** initialize the mutex subsystem, return early with the error.
  ** If the system is so sick that we are unable to allocate a mutex,
  ** there is not much SQLite is going to be able to do.
  **
  ** The mutex subsystem must take care of serializing its own
  ** initialization.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3MutexInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>

  <comment type="block">/* Initialize the malloc() system and the recursive pInitMutex mutex.
  ** This operation is protected by the STATIC_MASTER mutex.  Note that
  ** MutexAlloc() is called for a static mutex prior to initializing the
  ** malloc subsystem - this implies that the allocation of a static
  ** mutex must not require support from the malloc subsystem.
  */</comment>
  <expr_stmt><expr><name>pMaster</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>sqlite3GlobalConfig</name>.<name>isMallocInit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3MallocInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>isMallocInit</name> = 1</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>sqlite3GlobalConfig</name>.<name>pInitMutex</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pInitMutex</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name> &amp;&amp; !<name>sqlite3GlobalConfig</name>.<name>pInitMutex</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nRefInitMutex</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If unable to initialize the malloc subsystem, then return early.
  ** There is little hope of getting SQLite to run if the malloc
  ** subsystem cannot be initialized.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Do the rest of the initialization under the recursive mutex so
  ** that we will be able to handle recursive calls into
  ** sqlite3_initialize().  The recursive calls normally come through
  ** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other
  ** recursive calls might also be possible.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>pInitMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>isInit</name>==0 &amp;&amp; <name>sqlite3GlobalConfig</name>.<name>inProgress</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>FuncDefHash</name> *</type><name>pHash</name> =<init> <expr>&amp;<call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDefHash</name></expr></argument>, <argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>inProgress</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RegisterGlobalFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_os_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3PcacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3PCacheBufferSetup</name><argument_list>( <argument><expr><name>sqlite3GlobalConfig</name>.<name>pPage</name></expr></argument>, 
          <argument><expr><name>sqlite3GlobalConfig</name>.<name>szPage</name></expr></argument>, <argument><expr><name>sqlite3GlobalConfig</name>.<name>nPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>inProgress</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>isInit</name> = (<name>rc</name>==<name>SQLITE_OK</name> ? 1 : 0)</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>pInitMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Go back under the static mutex and clean up the recursive
  ** mutex to prevent a resource leak.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nRefInitMutex</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>nRefInitMutex</name>&lt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>sqlite3GlobalConfig</name>.<name>nRefInitMutex</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>pInitMutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pInitMutex</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>pMaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The following is just a sanity check to make sure SQLite has
  ** been compiled correctly.  It is important to run this code, but
  ** we don't want to run it too often and soak up CPU cycles for no
  ** reason.  So we run it once during initialization.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* This section of code's only "output" is via assert() statements. */</comment>
  <if>if <condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u64</name></type> <name>x</name> =<init> <expr>(((<name>u64</name>)1)&lt;&lt;63)-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>==8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>y</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3IsNaN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Undo the effects of sqlite3_initialize().  Must not be called while
** there are outstanding database connections or memory allocations or
** while any part of SQLite is otherwise in use in any thread.  This
** routine is not threadsafe.  Not by a long shot.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_shutdown</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>isMallocInit</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PcacheShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>isInit</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_os_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3MallocEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MutexEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>isInit</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This API allows applications to modify the global configuration of
** the SQLite library at run-time.
**
** This routine should only be called when there are no outstanding
** database connections or memory allocations.  This routine is not
** threadsafe.  Failure to heed these warnings can lead to unpredictable
** behavior.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_config</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while
  ** the SQLite library is in use. */</comment>
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>isInit</name></expr> )</condition><then> <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{

    <comment type="block">/* Mutex configuration options are only available in a threadsafe
    ** compile. 
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
    <case>case <expr><name>SQLITE_CONFIG_SINGLETHREAD</name></expr>: <block>{
      <comment type="block">/* Disable all mutexing */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bFullMutex</name> = 0</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_MULTITHREAD</name></expr>: <block>{
      <comment type="block">/* Disable mutexing of database connections */</comment>
      <comment type="block">/* Enable mutexing of core data structures */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bFullMutex</name> = 0</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_SERIALIZED</name></expr>: <block>{
      <comment type="block">/* Enable all mutexing */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bFullMutex</name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_MUTEX</name></expr>: <block>{
      <comment type="block">/* Specify an alternative mutex implementation */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>mutex</name> = *<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_GETMUTEX</name></expr>: <block>{
      <comment type="block">/* Retrieve the current mutex implementation */</comment>
      <expr_stmt><expr>*<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mutex_methods</name>*</expr></argument>)</argument_list></call> = <name>sqlite3GlobalConfig</name>.<name>mutex</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    </case><case>case <expr><name>SQLITE_CONFIG_MALLOC</name></expr>: <block>{
      <comment type="block">/* Specify an alternative malloc implementation */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name> = *<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_GETMALLOC</name></expr>: <block>{
      <comment type="block">/* Retrieve the current malloc() implementation */</comment>
      <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>m</name>.<name>xMalloc</name>==0</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3MemSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr>*<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_mem_methods</name>*</expr></argument>)</argument_list></call> = <name>sqlite3GlobalConfig</name>.<name>m</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_MEMSTATUS</name></expr>: <block>{
      <comment type="block">/* Enable or disable the malloc status collection */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>bMemstat</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_SCRATCH</name></expr>: <block>{
      <comment type="block">/* Designate a buffer for scratch memory space */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pScratch</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szScratch</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nScratch</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_CONFIG_PAGECACHE</name></expr>: <block>{
      <comment type="block">/* Designate a buffer for scratch memory space */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pPage</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szPage</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nPage</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    </case><case>case <expr><name>SQLITE_CONFIG_PCACHE</name></expr>: <block>{
      <comment type="block">/* Specify an alternative malloc implementation */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name> = *<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    </case><case>case <expr><name>SQLITE_CONFIG_GETPCACHE</name></expr>: <block>{
      <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<name>xInit</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3PCacheSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr>*<call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>sqlite3_pcache_methods</name>*</expr></argument>)</argument_list></call> = <name>sqlite3GlobalConfig</name>.<name>pcache</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS3</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_MEMSYS5</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>SQLITE_CONFIG_HEAP</name></expr>: <block>{
      <comment type="block">/* Designate a buffer for heap memory space */</comment>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pHeap</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nHeap</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>mnReq</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pHeap</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* If the heap pointer is NULL, then restore the malloc implementation
        ** back to NULL pointers too.  This will cause the malloc to go
        ** back to its default implementation when sqlite3_initialize() is
        ** run.
        */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sqlite3GlobalConfig</name>.<name>m</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* The heap pointer is not NULL, then install one of the
        ** mem5.c/mem3.c methods. If neither ENABLE_MEMSYS3 nor
        ** ENABLE_MEMSYS5 is defined, return an error.
        ** the default case and return an error.
        */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS3</name></cpp:ifdef>
        <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name> = *<call><name>sqlite3MemGetMemsys3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS5</name></cpp:ifdef>
        <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>m</name> = *<call><name>sqlite3MemGetMemsys5</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></else></if>
      <break>break;</break>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </case><case>case <expr><name>SQLITE_CONFIG_LOOKASIDE</name></expr>: <block>{
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>szLookaside</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>nLookaside</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    </case><default>default: <block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Set up the lookaside buffers for a database connection.
** Return SQLITE_OK on success.  
** If lookaside is already active, return SQLITE_BUSY.
**
** The sz parameter is the number of bytes in each lookaside slot.
** The cnt parameter is the number of slots.  If pStart is NULL the
** space for the lookaside memory is obtained from sqlite3_malloc().
** If pStart is not NULL then it is sz*cnt bytes of memory to use for
** the lookaside memory.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>setupLookaside</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>sz</name></decl></param>, <param><decl><type><name>int</name></type> <name>cnt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pStart</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>sz</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>sz</name> = 0</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>cnt</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>cnt</name> = 0</expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pBuf</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>sz</name> = (<name>sz</name> + 7)&amp;~7</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>sz</name>*<name>cnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>sz</name> = <name>sz</name>&amp;~7</expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> = <name>pBuf</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>lookaside</name>.<name>bMalloced</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pStart</name> = <name>pStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>sz</name> = (<name>u16</name>)<name>sz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>bMalloced</name> = <name>pBuf</name>==0 ?1:0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pStart</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LookasideSlot</name> *</type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> = (<name>LookasideSlot</name>*)<name>pStart</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=<name>cnt</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pFree</name> = <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> = (<name>LookasideSlot</name>*)&amp;((<name>u8</name>*)<name>p</name>)[<name>sz</name>]</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pEnd</name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>bEnabled</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pEnd</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>lookaside</name>.<name>bEnabled</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the mutex associated with a database connection.
*/</comment>
<function><type><name>sqlite3_mutex</name> *</type><name>sqlite3_db_mutex</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name>-&gt;<name>mutex</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Configuration settings for an individual database connection
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_db_config</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_DBCONFIG_LOOKASIDE</name></expr>: <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>pBuf</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Return true if the buffer z[0..n-1] contains all spaces.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>allSpaces</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <while>while<condition>( <expr><name>n</name>&gt;0 &amp;&amp; <name><name>z</name><index>[<expr><name>n</name>-1</expr>]</index></name>==' '</expr> )</condition><block>{ <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt> }</block></while>
  <return>return <expr><name>n</name>==0</expr>;</return>
}</block></function>

<comment type="block">/*
** This is the default collating function named "BINARY" which is always
** available.
**
** If the padFlag argument is not NULL then space padding at the end
** of strings is ignored.  This implements the RTRIM collation.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>binCollFunc</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>padFlag</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nKey1</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey1</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nKey2</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name>, <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> = <name>nKey1</name>&lt;<name>nKey2</name> ? <name>nKey1</name> : <name>nKey2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>memcmp</name><argument_list>(<argument><expr><name>pKey1</name></expr></argument>, <argument><expr><name>pKey2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>padFlag</name>
     &amp;&amp; <call><name>allSpaces</name><argument_list>(<argument><expr>((<name>char</name>*)<name>pKey1</name>)+<name>n</name></expr></argument>, <argument><expr><name>nKey1</name>-<name>n</name></expr></argument>)</argument_list></call>
     &amp;&amp; <call><name>allSpaces</name><argument_list>(<argument><expr>((<name>char</name>*)<name>pKey2</name>)+<name>n</name></expr></argument>, <argument><expr><name>nKey2</name>-<name>n</name></expr></argument>)</argument_list></call></expr>
    )</condition><then><block>{
      <comment type="block">/* Leave rc unchanged at 0 */</comment>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>rc</name> = <name>nKey1</name> - <name>nKey2</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Another built-in collating sequence: NOCASE. 
**
** This collating sequence is intended to be used for "case independant
** comparison". SQLite's knowledge of upper and lower case equivalents
** extends only to the 26 characters used in the English language.
**
** At the moment there is only a UTF-8 implementation.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>nocaseCollatingFunc</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>NotUsed</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nKey1</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey1</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nKey2</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pKey2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> =<init> <macro><name>sqlite3StrNICmp</name><argument_list>(
      <argument>(const char *)pKey1</argument>, <argument>(const char *)pKey2</argument>, <argument>(nKey1&lt;nKey2)?nKey1:nKey2</argument>)</argument_list></macro></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>0==<name>r</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>r</name> = <name>nKey1</name>-<name>nKey2</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>r</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the ROWID of the most recent insert
*/</comment>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_last_insert_rowid</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name>-&gt;<name>lastRowid</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the number of changes in the most recent call to sqlite3_exec().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_changes</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name>-&gt;<name>nChange</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the number of changes since the database handle was opened.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_total_changes</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name>-&gt;<name>nTotalChange</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close all open savepoints. This function only manipulates fields of the
** database handle object, it does not close any savepoints that may be open
** at the b-tree/pager level.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CloseSavepoints</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <while>while<condition>( <expr><name>db</name>-&gt;<name>pSavepoint</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>Savepoint</name> *</type><name>pTmp</name> =<init> <expr><name>db</name>-&gt;<name>pSavepoint</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>pSavepoint</name> = <name>pTmp</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>db</name>-&gt;<name>nSavepoint</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>isTransactionSavepoint</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Close an existing SQLite database
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_close</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>HashElem</name> *</type><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>db</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SSE</name></cpp:ifdef>
  <block>{
    <function_decl><type><name>extern</name> <name>void</name></type> <name>sqlite3SseCleanup</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><call><name>sqlite3SseCleanup</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

  <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a transaction is open, the ResetInternalSchema() call above
  ** will not have called the xDisconnect() method on any virtual
  ** tables in the db-&gt;aVTrans[] array. The following sqlite3VtabRollback()
  ** call will do so. We need to do this before the check for active
  ** SQL statements below, as the v-table implementation may be storing
  ** some prepared statements internally.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there are any outstanding VMs, return SQLITE_BUSY. */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>pVdbe</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr>"Unable to close due to unfinalised statements"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free any outstanding Savepoint structures. */</comment>
  <expr_stmt><expr><call><name>sqlite3CloseSavepoints</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pBt</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3BtreeClose</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name>-&gt;<name>pBt</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>j</name>!=1</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>pSchema</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>nDb</name>&lt;=2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>aDb</name>==<name>db</name>-&gt;<name>aDbStatic</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>aFunc</name>.<name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pNext</name>, *<name>pHash</name>, *<name>p</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>p</name>=<name>db</name>-&gt;<name>aFunc</name>.<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>pHash</name></expr></incr>)<block>{
      <expr_stmt><expr><name>pHash</name> = <name>p</name>-&gt;<name>pHash</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><name>p</name></expr> )</condition><block>{
        <expr_stmt><expr><name>pNext</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> = <name>pNext</name></expr>;</expr_stmt>
      }</block></while>
    }</block></for>
  }</block></for>
  <for>for(<init><expr><name>i</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aCollSeq</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
    <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr>(<name>CollSeq</name> *)<call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Invoke any destructors registered for collation sequence user data. */</comment>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;3</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name>.<name>xDel</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name>.<call><name>xDel</name><argument_list>(<argument><expr><name><name>pColl</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aCollSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <for>for(<init><expr><name>i</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aModule</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
    <decl_stmt><decl><type><name>Module</name> *</type><name>pMod</name> =<init> <expr>(<name>Module</name> *)<call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pMod</name>-&gt;<name>xDestroy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pMod</name>-&gt;<call><name>xDestroy</name><argument_list>(<argument><expr><name>pMod</name>-&gt;<name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3HashClear</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Deallocates any cached error strings. */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>pErr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3CloseExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>db</name>-&gt;<name>magic</name> = <name>SQLITE_MAGIC_ERROR</name></expr>;</expr_stmt>

  <comment type="block">/* The temp-database schema is allocated differently from the other schema
  ** objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema()).
  ** So it needs to be freed here. Todo: Why not roll the temp schema into
  ** the same sqliteMalloc() as the one that allocates the database 
  ** structure?
  */</comment>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>magic</name> = <name>SQLITE_MAGIC_CLOSED</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>lookaside</name>.<name>nOut</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Fails on a lookaside memory leak */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>lookaside</name>.<name>bMalloced</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>lookaside</name>.<name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Rollback all database files.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RollbackAll</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>inTrans</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>sqlite3BtreeIsInTrans</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>inTrans</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3BtreeRollback</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name>.<name>inTrans</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3VtabRollback</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name>&amp;<name>SQLITE_InternChanges</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If one has been configured, invoke the rollback-hook callback */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>xRollbackCallback</name> &amp;&amp; (<name>inTrans</name> || !<name>db</name>-&gt;<name>autoCommit</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<call><name>xRollbackCallback</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pRollbackArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Return a static string that describes the kind of error specified in the
** argument.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3ErrStr</name><parameter_list>(<param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>rc</name> &amp; 0xff</expr> )</condition><block>{
    <case>case <expr><name>SQLITE_ROW</name></expr>:
    </case><case>case <expr><name>SQLITE_DONE</name></expr>:
    </case><case>case <expr><name>SQLITE_OK</name></expr>:         <expr_stmt><expr><name>z</name> = "not an error"</expr>;</expr_stmt>                          <break>break;</break>
    </case><case>case <expr><name>SQLITE_ERROR</name></expr>:      <expr_stmt><expr><name>z</name> = "SQL logic error or missing database"</expr>;</expr_stmt>   <break>break;</break>
    </case><case>case <expr><name>SQLITE_PERM</name></expr>:       <expr_stmt><expr><name>z</name> = "access permission denied"</expr>;</expr_stmt>              <break>break;</break>
    </case><case>case <expr><name>SQLITE_ABORT</name></expr>:      <expr_stmt><expr><name>z</name> = "callback requested query abort"</expr>;</expr_stmt>        <break>break;</break>
    </case><case>case <expr><name>SQLITE_BUSY</name></expr>:       <expr_stmt><expr><name>z</name> = "database is locked"</expr>;</expr_stmt>                    <break>break;</break>
    </case><case>case <expr><name>SQLITE_LOCKED</name></expr>:     <expr_stmt><expr><name>z</name> = "database table is locked"</expr>;</expr_stmt>              <break>break;</break>
    </case><case>case <expr><name>SQLITE_NOMEM</name></expr>:      <expr_stmt><expr><name>z</name> = "out of memory"</expr>;</expr_stmt>                         <break>break;</break>
    </case><case>case <expr><name>SQLITE_READONLY</name></expr>:   <expr_stmt><expr><name>z</name> = "attempt to write a readonly database"</expr>;</expr_stmt>  <break>break;</break>
    </case><case>case <expr><name>SQLITE_INTERRUPT</name></expr>:  <expr_stmt><expr><name>z</name> = "interrupted"</expr>;</expr_stmt>                           <break>break;</break>
    </case><case>case <expr><name>SQLITE_IOERR</name></expr>:      <expr_stmt><expr><name>z</name> = "disk I/O error"</expr>;</expr_stmt>                        <break>break;</break>
    </case><case>case <expr><name>SQLITE_CORRUPT</name></expr>:    <expr_stmt><expr><name>z</name> = "database disk image is malformed"</expr>;</expr_stmt>      <break>break;</break>
    </case><case>case <expr><name>SQLITE_FULL</name></expr>:       <expr_stmt><expr><name>z</name> = "database or disk is full"</expr>;</expr_stmt>              <break>break;</break>
    </case><case>case <expr><name>SQLITE_CANTOPEN</name></expr>:   <expr_stmt><expr><name>z</name> = "unable to open database file"</expr>;</expr_stmt>          <break>break;</break>
    </case><case>case <expr><name>SQLITE_EMPTY</name></expr>:      <expr_stmt><expr><name>z</name> = "table contains no data"</expr>;</expr_stmt>                <break>break;</break>
    </case><case>case <expr><name>SQLITE_SCHEMA</name></expr>:     <expr_stmt><expr><name>z</name> = "database schema has changed"</expr>;</expr_stmt>           <break>break;</break>
    </case><case>case <expr><name>SQLITE_TOOBIG</name></expr>:     <expr_stmt><expr><name>z</name> = "String or BLOB exceeded size limit"</expr>;</expr_stmt>    <break>break;</break>
    </case><case>case <expr><name>SQLITE_CONSTRAINT</name></expr>: <expr_stmt><expr><name>z</name> = "constraint failed"</expr>;</expr_stmt>                     <break>break;</break>
    </case><case>case <expr><name>SQLITE_MISMATCH</name></expr>:   <expr_stmt><expr><name>z</name> = "datatype mismatch"</expr>;</expr_stmt>                     <break>break;</break>
    </case><case>case <expr><name>SQLITE_MISUSE</name></expr>:     <expr_stmt><expr><name>z</name> = "library routine called out of sequence"</expr>;</expr_stmt><break>break;</break>
    </case><case>case <expr><name>SQLITE_NOLFS</name></expr>:      <expr_stmt><expr><name>z</name> = "large file support is disabled"</expr>;</expr_stmt>        <break>break;</break>
    </case><case>case <expr><name>SQLITE_AUTH</name></expr>:       <expr_stmt><expr><name>z</name> = "authorization denied"</expr>;</expr_stmt>                  <break>break;</break>
    </case><case>case <expr><name>SQLITE_FORMAT</name></expr>:     <expr_stmt><expr><name>z</name> = "auxiliary database format error"</expr>;</expr_stmt>       <break>break;</break>
    </case><case>case <expr><name>SQLITE_RANGE</name></expr>:      <expr_stmt><expr><name>z</name> = "bind or column index out of range"</expr>;</expr_stmt>     <break>break;</break>
    </case><case>case <expr><name>SQLITE_NOTADB</name></expr>:     <expr_stmt><expr><name>z</name> = "file is encrypted or is not a database"</expr>;</expr_stmt><break>break;</break>
    </case><default>default:                <expr_stmt><expr><name>z</name> = "unknown error"</expr>;</expr_stmt>                         <break>break;</break>
  </default>}</block></switch>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine implements a busy callback that sleeps and tries
** again until a timeout value is reached.  The timeout value is
** an integer number of milliseconds passed in as the first
** argument.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqliteDefaultBusyCallback</name><parameter_list>(
 <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>,               <comment type="block">/* Database connection */</comment>
 <param><decl><type><name>int</name></type> <name>count</name></decl></param>                <comment type="block">/* Number of times table has been busy */</comment>
)</parameter_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name> || (<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USLEEP</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_USLEEP</name>)</expr></cpp:if>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>delays</name><index>[]</index></name> =<init>
     <expr><block>{ <expr>1</expr>, <expr>2</expr>, <expr>5</expr>, <expr>10</expr>, <expr>15</expr>, <expr>20</expr>, <expr>25</expr>, <expr>25</expr>,  <expr>25</expr>,  <expr>50</expr>,  <expr>50</expr>, <expr>100</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>totals</name><index>[]</index></name> =<init>
     <expr><block>{ <expr>0</expr>, <expr>1</expr>, <expr>3</expr>,  <expr>8</expr>, <expr>18</expr>, <expr>33</expr>, <expr>53</expr>, <expr>78</expr>, <expr>103</expr>, <expr>128</expr>, <expr>178</expr>, <expr>228</expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <name>NDELAY</name> (sizeof(delays)/sizeof(delays[0]))</cpp:define>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr>(<name>sqlite3</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> =<init> <expr><name>db</name>-&gt;<name>busyTimeout</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>delay</name>, <name>prior</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>count</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>count</name> &lt; <name>NDELAY</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>delay</name> = <name><name>delays</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> = <name><name>totals</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>delay</name> = <name><name>delays</name><index>[<expr><name>NDELAY</name>-1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prior</name> = <name><name>totals</name><index>[<expr><name>NDELAY</name>-1</expr>]</index></name> + <name>delay</name>*(<name>count</name>-(<name>NDELAY</name>-1))</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>prior</name> + <name>delay</name> &gt; <name>timeout</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>delay</name> = <name>timeout</name> - <name>prior</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>delay</name>&lt;=0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr><name>delay</name>*1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr>(<name>sqlite3</name> *)<name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> =<init> <expr>((<name>sqlite3</name> *)<name>ptr</name>)-&gt;<name>busyTimeout</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>count</name>+1)*1000 &gt; <name>timeout</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pVfs</name></expr></argument>, <argument><expr>1000000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Invoke the given busy handler.
**
** This routine is called when an operation failed with a lock.
** If this routine returns non-zero, the lock is retried.  If it
** returns 0, the operation aborts with an SQLITE_BUSY error.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3InvokeBusyHandler</name><parameter_list>(<param><decl><type><name>BusyHandler</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>p</name>==0</expr></argument>)</argument_list></call> || <name>p</name>-&gt;<name>xFunc</name>==0 || <name>p</name>-&gt;<name>nBusy</name>&lt;0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>rc</name> = <name>p</name>-&gt;<call><name>xFunc</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pArg</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>nBusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>nBusy</name> = -1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>nBusy</name>++</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return> 
}</block></function>

<comment type="block">/*
** This routine sets the busy callback for an Sqlite database to the
** given callback function with the given argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_handler</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><function_decl><type><name>int</name></type> (*<name>xBusy</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>busyHandler</name>.<name>xFunc</name> = <name>xBusy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>busyHandler</name>.<name>pArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>busyHandler</name>.<name>nBusy</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
<comment type="block">/*
** This routine sets the progress callback for an Sqlite database to the
** given callback function with the given argument. The progress callback will
** be invoked every nOps opcodes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_progress_handler</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>nOps</name></decl></param>,
  <param><function_decl><type><name>int</name></type> (*<name>xProgress</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>, 
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>nOps</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>xProgress</name> = <name>xProgress</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>nProgressOps</name> = <name>nOps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>pProgressArg</name> = <name>pArg</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>xProgress</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>nProgressOps</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>pProgressArg</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This routine installs a default busy handler that waits for the
** specified number of milliseconds before returning 0.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_busy_timeout</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>ms</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>ms</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>busyTimeout</name> = <name>ms</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sqliteDefaultBusyCallback</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Cause any pending operation to stop at its earliest opportunity.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_interrupt</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>db</name>-&gt;<name>u1</name>.<name>isInterrupted</name> = 1</expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** This function is exactly the same as sqlite3_create_function(), except
** that it is designed to be called by internal code. The difference is
** that if a malloc() fails in sqlite3_create_function(), an error code
** is returned and the mallocFailed flag cleared. 
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CreateFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFunctionName</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>pUserData</name></decl></param>,
  <param><function_decl><type><name>void</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name> **</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xStep</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name> **</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xFinal</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>)</parameter_list></function_decl></param></function_decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zFunctionName</name>==0 ||
      (<name>xFunc</name> &amp;&amp; (<name>xFinal</name> || <name>xStep</name>)) || 
      (!<name>xFunc</name> &amp;&amp; (<name>xFinal</name> &amp;&amp; !<name>xStep</name>)) ||
      (!<name>xFunc</name> &amp;&amp; (!<name>xFinal</name> &amp;&amp; <name>xStep</name>)) ||
      (<name>nArg</name>&lt;-1 || <name>nArg</name>&gt;<name>SQLITE_MAX_FUNCTION_ARG</name>) ||
      (255&lt;(<name>nName</name> = <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>)</argument_list></call>))</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr>"bad parameters"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>
  
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  **
  ** If SQLITE_ANY is specified, add three versions of the function
  ** to the hash table.
  */</comment>
  <if>if<condition>( <expr><name>enc</name>==<name>SQLITE_UTF16</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>enc</name> = <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>enc</name>==<name>SQLITE_ANY</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
         <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>,
          <argument><expr><name>pUserData</name></expr></argument>, <argument><expr><name>xFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>enc</name> = <name>SQLITE_UTF16BE</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>enc</name> = <name>SQLITE_UTF8</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/* Check if an existing function is being overridden or deleted. If so,
  ** and there are active VMs, then return SQLITE_BUSY. If a function
  ** is being overridden/deleted but there are no active VMs, allow the
  ** operation to continue but invalidate all precompiled statements.
  */</comment>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>enc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>iPrefEnc</name>==<name>enc</name> &amp;&amp; <name>p</name>-&gt;<name>nArg</name>==<name>nArg</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>activeVdbeCnt</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr>"Unable to delete/modify user-function due to active statements"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>

  <expr_stmt><expr><name>p</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>enc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>p</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>xFunc</name> = <name>xFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>xStep</name> = <name>xStep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>xFinalize</name> = <name>xFinal</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pUserData</name> = <name>pUserData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nArg</name> = (<name>u16</name>)<name>nArg</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create new user functions.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_function</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFunctionName</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>p</name></decl></param>,
  <param><function_decl><type><name>void</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name> **</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xStep</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name> **</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xFinal</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>)</parameter_list></function_decl></param></function_decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>int</name></type> <name>sqlite3_create_function16</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>const</name> <name>void</name> *</type><name>zFunctionName</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>eTextRep</name></decl></param>,
  <param><decl><type><name>void</name> *</type><name>p</name></decl></param>,
  <param><function_decl><type><name>void</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name>**</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xStep</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name>**</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type> (*<name>xFinal</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>)</parameter_list></function_decl></param></function_decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zFunc8</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFunc8</name> = <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunctionName</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>eTextRep</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xFunc</name></expr></argument>, <argument><expr><name>xStep</name></expr></argument>, <argument><expr><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFunc8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Declare that a function has been overloaded by a virtual table.
**
** If the function already exists as a regular global function, then
** this routine is a no-op.  If the function does not exist, then create
** a new one that always throws a run-time error.  
**
** When virtual tables intend to provide an overloaded function, they
** should call this routine to make sure the global function exists.
** A global function must exist in order for name resolution to work
** properly.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_overload_function</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> =<init> <expr><call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
                      <argument><expr>0</expr></argument>, <argument><expr><name>sqlite3InvalidFunction</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** Register a trace function.  The pArg from the previously registered trace
** is returned.  
**
** A NULL trace function means that no tracing is executes.  A non-NULL
** trace is a pointer to a function that is invoked at the start of each
** SQL statement.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_trace</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>xTrace</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>)</parameter_list>, <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pOld</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> = <name>db</name>-&gt;<name>pTraceArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xTrace</name> = <name>xTrace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pTraceArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
}</block></function>
<comment type="block">/*
** Register a profile function.  The pArg from the previously registered 
** profile function is returned.  
**
** A NULL profile function means that no profiling is executes.  A non-NULL
** profile is a pointer to a function that is invoked at the conclusion of
** each SQL statement that is run.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_profile</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><function_decl><type><name>void</name></type> (*<name>xProfile</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>sqlite_uint64</name></type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pOld</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> = <name>db</name>-&gt;<name>pProfileArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xProfile</name> = <name>xProfile</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pProfileArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>

<comment type="block">/*** EXPERIMENTAL ***
**
** Register a function to be invoked when a transaction comments.
** If the invoked function returns non-zero, then the commit becomes a
** rollback.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_commit_hook</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,              <comment type="block">/* Attach the hook to this database */</comment>
  <param><function_decl><type><name>int</name></type> (*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>,  <comment type="block">/* Function to invoke on each commit */</comment>
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pOld</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOld</name> = <name>db</name>-&gt;<name>pCommitArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xCommitCallback</name> = <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pCommitArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pOld</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a row is updated,
** inserted or deleted using this database connection.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_update_hook</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,              <comment type="block">/* Attach the hook to this database */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>char</name> <name>const</name> *</type></decl></param>,<param><decl><type><name>char</name> <name>const</name> *</type></decl></param>,<param><decl><type><name>sqlite_int64</name></type></decl></param>)</parameter_list>,
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> = <name>db</name>-&gt;<name>pUpdateArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xUpdateCallback</name> = <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pUpdateArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Register a callback to be invoked each time a transaction is rolled
** back by this database connection.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3_rollback_hook</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,              <comment type="block">/* Attach the hook to this database */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xCallback</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>, <comment type="block">/* Callback function */</comment>
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param></function_decl></param>                <comment type="block">/* Argument to the function */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>pRet</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRet</name> = <name>db</name>-&gt;<name>pRollbackArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xRollbackCallback</name> = <name>xCallback</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pRollbackArg</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called to create a connection to a database BTree
** driver.  If zFilename is the name of a file, then that file is
** opened and used.  If zFilename is the magic name ":memory:" then
** the database is stored in memory (and is thus forgotten as soon as
** the connection is closed.)  If zFilename is NULL then the database
** is a "virtual" database for transient use only and is deleted as
** soon as the connection is closed.
**
** A virtual database can be either a disk file (that is automatically
** deleted when the file is closed) or it an be held entirely in memory,
** depending on the values of the SQLITE_TEMP_STORE compile-time macro and the
** db-&gt;temp_store variable, according to the following chart:
**
**   SQLITE_TEMP_STORE     db-&gt;temp_store     Location of temporary database
**   -----------------     --------------     ------------------------------
**   0                     any                file
**   1                     1                  file
**   1                     2                  memory
**   1                     0                  file
**   2                     1                  file
**   2                     2                  memory
**   2                     0                  memory
**   3                     any                memory
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeFactory</name><parameter_list>(
  <param><decl><type><name>const</name> <name>sqlite3</name> *</type><name>db</name></decl></param>,        <comment type="block">/* Main database when opening aux otherwise 0 */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,    <comment type="block">/* Name of the file containing the BTree database */</comment>
  <param><decl><type><name>int</name></type> <name>omitJournal</name></decl></param>,          <comment type="block">/* if TRUE then do not journal this file */</comment>
  <param><decl><type><name>int</name></type> <name>nCache</name></decl></param>,               <comment type="block">/* How many pages in the page cache */</comment>
  <param><decl><type><name>int</name></type> <name>vfsFlags</name></decl></param>,             <comment type="block">/* Flags passed through to vfsOpen */</comment>
  <param><decl><type><name>Btree</name> **</type><name>ppBtree</name></decl></param>           <comment type="block">/* Pointer to new Btree object written here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>btFlags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ppBtree</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>omitJournal</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>btFlags</name> |= <name>BTREE_OMIT_JOURNAL</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_NoReadlock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>btFlags</name> |= <name>BTREE_NO_READLOCK</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>zFilename</name>==0</expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name>==0</expr></cpp:if>
    <comment type="block">/* Do nothing */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_MEMORYDB</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name>==1</expr></cpp:if>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>temp_store</name>==2</expr> )</condition><then> <expr_stmt><expr><name>zFilename</name> = ":memory:"</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name>==2</expr></cpp:if>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>temp_store</name>!=1</expr> )</condition><then> <expr_stmt><expr><name>zFilename</name> = ":memory:"</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_TEMP_STORE</name>==3</expr></cpp:if>
    <expr_stmt><expr><name>zFilename</name> = ":memory:"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_MEMORYDB */</comment>
  }</block></then></if>

  <if>if<condition>( <expr>(<name>vfsFlags</name> &amp; <name>SQLITE_OPEN_MAIN_DB</name>)!=0 &amp;&amp; (<name>zFilename</name>==0 || *<name>zFilename</name>==0)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>vfsFlags</name> = (<name>vfsFlags</name> &amp; ~<name>SQLITE_OPEN_MAIN_DB</name>) | <name>SQLITE_OPEN_TEMP_DB</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeOpen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr>(<name>sqlite3</name> *)<name>db</name></expr></argument>, <argument><expr><name>ppBtree</name></expr></argument>, <argument><expr><name>btFlags</name></expr></argument>, <argument><expr><name>vfsFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the B-Tree was successfully opened, set the pager-cache size to the
  ** default value. Except, if the call to BtreeOpen() returned a handle
  ** open on an existing shared pager-cache, do not change the pager-cache 
  ** size.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; 0==<call><name>sqlite3BtreeSchema</name><argument_list>(<argument><expr>*<name>ppBtree</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeSetCacheSize</name><argument_list>(<argument><expr>*<name>ppBtree</name></expr></argument>, <argument><expr><name>nCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return UTF-8 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><name>const</name> <name>char</name> *</type><name>sqlite3_errmsg</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>db</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return <expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>errCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Return UTF-16 encoded English language explanation of the most recent
** error.
*/</comment>
<function><type><name>const</name> <name>void</name> *</type><name>sqlite3_errmsg16</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* Because all the characters in the string are in the unicode
  ** range 0x00-0xFF, if we pad the big-endian string with a 
  ** zero byte, we can obtain the little-endian string with
  ** &amp;big_endian[1].
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>outOfMemBe</name><index>[]</index></name> =<init> <expr><block>{
    <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'u'</expr>, <expr>0</expr>, <expr>'t'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'f'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'m'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>'m'</expr>, <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'r'</expr>, <expr>0</expr>, <expr>'y'</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>misuseBe</name> <index>[]</index></name> =<init> <expr><block>{
    <expr>0</expr>, <expr>'l'</expr>, <expr>0</expr>, <expr>'i'</expr>, <expr>0</expr>, <expr>'b'</expr>, <expr>0</expr>, <expr>'r'</expr>, <expr>0</expr>, <expr>'a'</expr>, <expr>0</expr>, <expr>'r'</expr>, <expr>0</expr>, <expr>'y'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'r'</expr>, <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'u'</expr>, <expr>0</expr>, <expr>'t'</expr>, <expr>0</expr>, <expr>'i'</expr>, <expr>0</expr>, <expr>'n'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'c'</expr>, <expr>0</expr>, <expr>'a'</expr>, <expr>0</expr>, <expr>'l'</expr>, <expr>0</expr>, <expr>'l'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>'d'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'u'</expr>, <expr>0</expr>, <expr>'t'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'o'</expr>, <expr>0</expr>, <expr>'f'</expr>, <expr>0</expr>, <expr>' '</expr>, 
    <expr>0</expr>, <expr>'s'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>'q'</expr>, <expr>0</expr>, <expr>'u'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>'n'</expr>, <expr>0</expr>, <expr>'c'</expr>, <expr>0</expr>, <expr>'e'</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>const</name> <name>void</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>db</name></expr> )</condition><then><block>{
    <return>return <expr>(<name>void</name> *)(&amp;<name><name>outOfMemBe</name><index>[<expr><name>SQLITE_UTF16NATIVE</name>==<name>SQLITE_UTF16LE</name>?1:0</expr>]</index></name>)</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>(<name>void</name> *)(&amp;<name><name>misuseBe</name><index>[<expr><name>SQLITE_UTF16NATIVE</name>==<name>SQLITE_UTF16LE</name>?1:0</expr>]</index></name>)</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>errCode</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3_value_text16</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>pErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="block">/* A malloc() may have failed within the call to sqlite3_value_text16()
  ** above. If this is the case, then the db-&gt;mallocFailed flag needs to
  ** be cleared before returning. Do this directly, instead of via
  ** sqlite3ApiExit(), to avoid setting the database handle error message.
  */</comment>
  <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Return the most recent error code generated by an SQLite routine. If NULL is
** passed to this function, we assume a malloc() failed during sqlite3_open().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_errcode</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>db</name> &amp;&amp; !<call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>db</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>db</name>-&gt;<name>errCode</name> &amp; <name>db</name>-&gt;<name>errMask</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3_extended_errcode</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>db</name> &amp;&amp; !<call><name>sqlite3SafetyCheckSickOrOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>db</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>db</name>-&gt;<name>errCode</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new collating function for database "db".  The name is zName
** and the encoding is enc.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>createCollation</name><parameter_list>(
  <param><decl><type><name>sqlite3</name>*</type> <name>db</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>, 
  <param><decl><type><name>void</name>*</type> <name>pCtx</name></decl></param>,
  <param><function_decl><type><name>int</name></type>(*<name>xCompare</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type>(*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>enc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If SQLITE_UTF16 is specified as the encoding type, transform this
  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
  */</comment>
  <expr_stmt><expr><name>enc2</name> = <name>enc</name> &amp; ~<name>SQLITE_UTF16_ALIGNED</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>enc2</name>==<name>SQLITE_UTF16</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>enc2</name> = <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr>(<name>enc2</name>&amp;~3)!=0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Check if this call is removing or replacing an existing collation 
  ** sequence. If so, and there are active VMs, return busy. If there
  ** are no active VMs, invalidate any pre-compiled statements.
  */</comment>
  <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pColl</name> &amp;&amp; <name>pColl</name>-&gt;<name>xCmp</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>activeVdbeCnt</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>, 
        <argument><expr>"Unable to delete/modify collation sequence due to active statements"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If collation sequence pColl was created directly by a call to
    ** sqlite3_create_collation, and not generated by synthCollSeq(),
    ** then any copies made by synthCollSeq() need to be invalidated.
    ** Also, collation destructor - CollSeq.xDel() - function may need
    ** to be called.
    */</comment> 
    <if>if<condition>( <expr>(<name>pColl</name>-&gt;<name>enc</name> &amp; ~<name>SQLITE_UTF16_ALIGNED</name>)==<name>enc2</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>CollSeq</name> *</type><name>aColl</name> =<init> <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aCollSeq</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;3</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>CollSeq</name> *</type><name>p</name> =<init> <expr>&amp;<name><name>aColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>p</name>-&gt;<name>enc</name>==<name>pColl</name>-&gt;<name>enc</name></expr> )</condition><then><block>{
          <if>if<condition>( <expr><name>p</name>-&gt;<name>xDel</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>p</name>-&gt;<call><name>xDel</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>p</name>-&gt;<name>xCmp</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>u8</name>)<name>enc2</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pColl</name>-&gt;<name>xCmp</name> = <name>xCompare</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name>-&gt;<name>pUser</name> = <name>pCtx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name>-&gt;<name>xDel</name> = <name>xDel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pColl</name>-&gt;<name>enc</name> = (<name>u8</name>)(<name>enc2</name> | (<name>enc</name> &amp; <name>SQLITE_UTF16_ALIGNED</name>))</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** This array defines hard upper bounds on limit values.  The
** initializer must be kept in sync with the SQLITE_LIMIT_*
** #defines in sqlite3.h.
*/</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>int</name></type> <name><name>aHardLimit</name><index>[]</index></name> =<init> <expr><block>{
  <expr><name>SQLITE_MAX_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_SQL_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_COLUMN</name></expr>,
  <expr><name>SQLITE_MAX_EXPR_DEPTH</name></expr>,
  <expr><name>SQLITE_MAX_COMPOUND_SELECT</name></expr>,
  <expr><name>SQLITE_MAX_VDBE_OP</name></expr>,
  <expr><name>SQLITE_MAX_FUNCTION_ARG</name></expr>,
  <expr><name>SQLITE_MAX_ATTACHED</name></expr>,
  <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name></expr>,
  <expr><name>SQLITE_MAX_VARIABLE_NUMBER</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Make sure the hard limits are set to reasonable values
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LENGTH</name>&lt;100</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name>&lt;100</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must be at least 100</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_SQL_LENGTH</name>&gt;<name>SQLITE_MAX_LENGTH</name></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COMPOUND_SELECT</name>&lt;2</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COMPOUND_SELECT must be at least 2</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_VDBE_OP</name>&lt;40</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_VDBE_OP must be at least 40</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_FUNCTION_ARG</name>&lt;0 || <name>SQLITE_MAX_FUNCTION_ARG</name>&gt;1000</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_ATTACHED</name>&lt;0 || <name>SQLITE_MAX_ATTACHED</name>&gt;30</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_ATTACHED must be between 0 and 30</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_LIKE_PATTERN_LENGTH</name>&lt;1</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_VARIABLE_NUMBER</name>&lt;1</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_VARIABLE_NUMBER must be at least 1</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name>&gt;32767</expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> SQLITE_MAX_COLUMN must not exceed 32767</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Change the value of a limit.  Report the old value.
** If an invalid limit index is supplied, report -1.
** Make no changes but still report the old value if the
** new limit is negative.
**
** A new lower limit does not shrink existing constructs.
** It merely prevents new constructs that exceed the limit
** from forming.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_limit</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>limitId</name></decl></param>, <param><decl><type><name>int</name></type> <name>newLimit</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>oldLimit</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>limitId</name>&lt;0 || <name>limitId</name>&gt;=<name>SQLITE_N_LIMIT</name></expr> )</condition><then><block>{
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>oldLimit</name> = <name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>newLimit</name>&gt;=0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>newLimit</name>&gt;<name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>newLimit</name> = <name><name>aHardLimit</name><index>[<expr><name>limitId</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>limitId</name></expr>]</index></name> = <name>newLimit</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>oldLimit</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine does the work of opening a database on behalf of
** sqlite3_open() and sqlite3_open16(). The database filename "zFilename"  
** is UTF-8 encoded.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>openDatabase</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>, <comment type="block">/* Database filename UTF-8 encoded */</comment>
  <param><decl><type><name>sqlite3</name> **</type><name>ppDb</name></decl></param>,        <comment type="block">/* OUT: Returned database handle */</comment>
  <param><decl><type><name>unsigned</name></type> <name>flags</name></decl></param>,        <comment type="block">/* Operational flags */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zVfs</name></decl></param>       <comment type="block">/* Name of the VFS to use */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isThreadsafe</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>bCoreMutex</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>isThreadsafe</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_NOMUTEX</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>isThreadsafe</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>flags</name> &amp; <name>SQLITE_OPEN_FULLMUTEX</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>isThreadsafe</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>isThreadsafe</name> = <name>sqlite3GlobalConfig</name>.<name>bFullMutex</name></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>

  <comment type="block">/* Remove harmful bits from the flags parameter */</comment>
  <expr_stmt><expr><name>flags</name> &amp;=  ~( <name>SQLITE_OPEN_DELETEONCLOSE</name> |
               <name>SQLITE_OPEN_MAIN_DB</name> |
               <name>SQLITE_OPEN_TEMP_DB</name> | 
               <name>SQLITE_OPEN_TRANSIENT_DB</name> | 
               <name>SQLITE_OPEN_MAIN_JOURNAL</name> | 
               <name>SQLITE_OPEN_TEMP_JOURNAL</name> | 
               <name>SQLITE_OPEN_SUBJOURNAL</name> | 
               <name>SQLITE_OPEN_MASTER_JOURNAL</name> |
               <name>SQLITE_OPEN_NOMUTEX</name> |
               <name>SQLITE_OPEN_FULLMUTEX</name>
             )</expr>;</expr_stmt>

  <comment type="block">/* Allocate the sqlite data structure */</comment>
  <expr_stmt><expr><name>db</name> = <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>==0</expr> )</condition><then> <goto>goto <name>opendb_out</name>;</goto></then></if>
  <if>if<condition>( <expr><name>isThreadsafe</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mutex</name> = <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_RECURSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>mutex</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>db</name> = 0</expr>;</expr_stmt>
      <goto>goto <name>opendb_out</name>;</goto>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>errMask</name> = 0xff</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>priorNewRowid</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nDb</name> = 2</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>magic</name> = <name>SQLITE_MAGIC_BUSY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>aDb</name> = <name>db</name>-&gt;<name>aDbStatic</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>aLimit</name></expr></argument>)</argument_list></call>==<call><name>sizeof</name><argument_list>(<argument><expr><name>aHardLimit</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>aLimit</name></expr></argument>, <argument><expr><name>aHardLimit</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>aLimit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>autoCommit</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nextAutovac</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nextPagesize</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_ShortColNames</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEFAULT_FILE_FORMAT</name>&lt;4</expr></cpp:if>
                 | <name>SQLITE_LegacyFileFmt</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_LOAD_EXTENSION</name></cpp:ifdef>
                 | <name>SQLITE_LoadExtension</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      ;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aCollSeq</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3HashInit</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aModule</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>db</name>-&gt;<name>pVfs</name> = <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>pVfs</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr>"no such vfs: %s"</expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Add the default collation sequence BINARY. BINARY works for both UTF-8
  ** and UTF-16, so add a version for each to avoid any unnecessary
  ** conversions. The only error that can occur here is a malloc() failure.
  */</comment>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"BINARY"</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"BINARY"</expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"BINARY"</expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"RTRIM"</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>(<name>void</name>*)1</expr></argument>, <argument><expr><name>binCollFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>opendb_out</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name>pDfltColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>"BINARY"</expr></argument>, <argument><expr>6</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>pDfltColl</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Also add a UTF-8 case-insensitive collation sequence. */</comment>
  <expr_stmt><expr><call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"NOCASE"</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nocaseCollatingFunc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set flags on the built-in collating sequences */</comment>
  <expr_stmt><expr><name>db</name>-&gt;<name>pDfltColl</name>-&gt;<name>type</name> = <name>SQLITE_COLL_BINARY</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>"NOCASE"</expr></argument>, <argument><expr>6</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pColl</name>-&gt;<name>type</name> = <name>SQLITE_COLL_NOCASE</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Open the backend database driver */</comment>
  <expr_stmt><expr><name>db</name>-&gt;<name>openFlags</name> = <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeFactory</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SQLITE_DEFAULT_CACHE_SIZE</name></expr></argument>, 
                           <argument><expr><name>flags</name> | <name>SQLITE_OPEN_MAIN_DB</name></expr></argument>,
                           <argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_IOERR_NOMEM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>opendb_out</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pSchema</name> = <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name> = <call><name>sqlite3SchemaGet</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* The default safety_level for the main database is 'full'; for the temp
  ** database it is 'NONE'. This matches the pager layer defaults.  
  */</comment>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>zName</name> = "main"</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>safety_level</name> = 3</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TEMPDB</name></cpp:ifndef>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>zName</name> = "temp"</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>safety_level</name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>db</name>-&gt;<name>magic</name> = <name>SQLITE_MAGIC_OPEN</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>opendb_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Register all built-in functions, but do not attempt to read the
  ** database schema yet. This is delayed until the first time the database
  ** is accessed.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RegisterBuiltinFunctions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Load automatic extensions - extensions that have been registered
  ** using the sqlite3_automatic_extension() API.
  */</comment>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3AutoLoadExtensions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <goto>goto <name>opendb_out</name>;</goto>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS1</name></cpp:ifdef>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <function_decl><type><name>extern</name> <name>int</name></type> <name>sqlite3Fts1Init</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Fts1Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS2</name></cpp:ifdef>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <function_decl><type><name>extern</name> <name>int</name></type> <name>sqlite3Fts2Init</name><parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Fts2Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_FTS3</name></cpp:ifdef>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Fts3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3IcuInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_RTREE</name></cpp:ifdef>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name> &amp;&amp; <name>rc</name>==<name>SQLITE_OK</name></expr>)</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3RtreeInit</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
  ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
  ** mode.  Doing nothing at all also makes NORMAL the default.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEFAULT_LOCKING_MODE</name></cpp:ifdef>
  <expr_stmt><expr><name>db</name>-&gt;<name>dfltLockMode</name> = <name>SQLITE_DEFAULT_LOCKING_MODE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3PagerLockingMode</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>SQLITE_DEFAULT_LOCKING_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Enable the lookaside-malloc subsystem */</comment>
  <expr_stmt><expr><call><name>setupLookaside</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>sqlite3GlobalConfig</name>.<name>szLookaside</name></expr></argument>,
                        <argument><expr><name>sqlite3GlobalConfig</name>.<name>nLookaside</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>opendb_out</name>:</label>
  <if>if<condition>( <expr><name>db</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mutex</name>!=0 || <name>isThreadsafe</name>==0 || <name>sqlite3GlobalConfig</name>.<name>bFullMutex</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>magic</name> = <name>SQLITE_MAGIC_SICK</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr>*<name>ppDb</name> = <name>db</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3ApiExit</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>, 
  <param><decl><type><name>sqlite3</name> **</type><name>ppDb</name></decl></param> 
)</parameter_list><block>{
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> | <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>sqlite3_open_v2</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>filename</name></decl></param>,   <comment type="block">/* Database filename (UTF-8) */</comment>
  <param><decl><type><name>sqlite3</name> **</type><name>ppDb</name></decl></param>,         <comment type="block">/* OUT: SQLite db handle */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,              <comment type="block">/* Flags */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zVfs</name></decl></param>        <comment type="block">/* Name of VFS module to use */</comment>
)</parameter_list><block>{
  <return>return <expr><call><name>openDatabase</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Open a new database handle.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_open16</name><parameter_list>(
  <param><decl><type><name>const</name> <name>void</name> *</type><name>zFilename</name></decl></param>, 
  <param><decl><type><name>sqlite3</name> **</type><name>ppDb</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zFilename8</name></decl>;</decl_stmt>   <comment type="block">/* zFilename encoded in UTF-8 instead of UTF-16 */</comment>
  <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zFilename</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ppDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>ppDb</name> = 0</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINIT</name></cpp:ifndef>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pVal</name> = <call><name>sqlite3ValueNew</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ValueSetStr</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFilename8</name> = <call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zFilename8</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>openDatabase</name><argument_list>(<argument><expr><name>zFilename8</name></expr></argument>, <argument><expr><name>ppDb</name></expr></argument>,
                      <argument><expr><name>SQLITE_OPEN_READWRITE</name> | <name>SQLITE_OPEN_CREATE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>ppDb</name> || <name>rc</name>==<name>SQLITE_NOMEM</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !<call><name>DbHasProperty</name><argument_list>(<argument><expr>*<name>ppDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DB_SchemaLoaded</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>ENC</name><argument_list>(<argument><expr>*<name>ppDb</name></expr></argument>)</argument_list></call> = <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>sqlite3ApiExit</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation</name><parameter_list>(
  <param><decl><type><name>sqlite3</name>*</type> <name>db</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>, 
  <param><decl><type><name>void</name>*</type> <name>pCtx</name></decl></param>,
  <param><function_decl><type><name>int</name></type>(*<name>xCompare</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation_v2</name><parameter_list>(
  <param><decl><type><name>sqlite3</name>*</type> <name>db</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>, 
  <param><decl><type><name>void</name>*</type> <name>pCtx</name></decl></param>,
  <param><function_decl><type><name>int</name></type>(*<name>xCompare</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>)</parameter_list>,
  <param><function_decl><type><name>void</name></type>(*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a new collation sequence with the database handle db.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_collation16</name><parameter_list>(
  <param><decl><type><name>sqlite3</name>*</type> <name>db</name></decl></param>, 
  <param><decl><type><name>const</name> <name>void</name> *</type><name>zName</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>, 
  <param><decl><type><name>void</name>*</type> <name>pCtx</name></decl></param>,
  <param><function_decl><type><name>int</name></type>(*<name>xCompare</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName8</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName8</name> = <call><name>sqlite3Utf16to8</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zName8</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>createCollation</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>xCompare</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, 
  <param><decl><type><name>void</name> *</type><name>pCollNeededArg</name></decl></param>, 
  <param><function_decl><type><name>void</name></type>(*<name>xCollNeeded</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>sqlite3</name>*</type></decl></param>,<param><decl><type><name>int</name></type> <name>eTextRep</name></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>)</parameter_list></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xCollNeeded</name> = <name>xCollNeeded</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xCollNeeded16</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pCollNeededArg</name> = <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<comment type="block">/*
** Register a collation sequence factory callback with the database handle
** db. Replace any previously installed collation sequence factory.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_collation_needed16</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, 
  <param><decl><type><name>void</name> *</type><name>pCollNeededArg</name></decl></param>, 
  <param><function_decl><type><name>void</name></type>(*<name>xCollNeeded16</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>sqlite3</name>*</type></decl></param>,<param><decl><type><name>int</name></type> <name>eTextRep</name></decl></param>,<param><decl><type><name>const</name> <name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xCollNeeded</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>xCollNeeded16</name> = <name>xCollNeeded16</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>pCollNeededArg</name> = <name>pCollNeededArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_GLOBALRECOVER</name></cpp:ifndef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This function is now an anachronism. It used to be used to recover from a
** malloc() failure, but SQLite now does this automatically.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_global_recover</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Test to see whether or not the database connection is in autocommit
** mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on
** by default.  Autocommit is disabled by a BEGIN statement and reenabled
** by the next COMMIT or ROLLBACK.
**
******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_get_autocommit</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>db</name>-&gt;<name>autoCommit</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** The following routine is subtituted for constant SQLITE_CORRUPT in
** debugging builds.  This provides a way to set a breakpoint for when
** corruption is first detected.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Corrupt</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** This is a convenience routine that makes sure that all thread-specific
** data for this thread has been deallocated.
**
** SQLite no longer uses thread-specific data so this routine is now a
** no-op.  It is retained for historical compatibility.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_thread_cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return meta information about a specific column of a database table.
** See comment in sqlite3.h (sqlite.h.in) for details.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_COLUMN_METADATA</name></cpp:ifdef>
<function><type><name>int</name></type> <name>sqlite3_table_column_metadata</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,                <comment type="block">/* Connection handle */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zDbName</name></decl></param>,        <comment type="block">/* Database name or NULL */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zTableName</name></decl></param>,     <comment type="block">/* Table name */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zColumnName</name></decl></param>,    <comment type="block">/* Column name */</comment>
  <param><decl><type><name>char</name> <name>const</name> **</type><name>pzDataType</name></decl></param>,    <comment type="block">/* OUTPUT: Declared data type */</comment>
  <param><decl><type><name>char</name> <name>const</name> **</type><name>pzCollSeq</name></decl></param>,     <comment type="block">/* OUTPUT: Collation sequence name */</comment>
  <param><decl><type><name>int</name> *</type><name>pNotNull</name></decl></param>,              <comment type="block">/* OUTPUT: True if NOT NULL constraint exists */</comment>
  <param><decl><type><name>int</name> *</type><name>pPrimaryKey</name></decl></param>,           <comment type="block">/* OUTPUT: True if column part of PK */</comment>
  <param><decl><type><name>int</name> *</type><name>pAutoinc</name></decl></param>               <comment type="block">/* OUTPUT: True if column is auto-increment */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zDataType</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zCollSeq</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>notnull</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>primarykey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>autoinc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Ensure the database schema has been loaded */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<name>rc</name></expr> )</condition><then><block>{
    <goto>goto <name>error_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Locate the table in question */</comment>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pTab</name> || <name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name> = 0</expr>;</expr_stmt>
    <goto>goto <name>error_out</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Find the column for which info is requested */</comment>
  <if>if<condition>( <expr><call><name>sqlite3IsRowid</name><argument_list>(<argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iCol</name> = <name>pTab</name>-&gt;<name>iPKey</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iCol</name>&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCol</name> = &amp;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <for>for(<init><expr><name>iCol</name>=0</expr>;</init> <condition><expr><name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>pCol</name> = &amp;<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr>0==<call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>iCol</name>==<name>pTab</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTab</name> = 0</expr>;</expr_stmt>
      <goto>goto <name>error_out</name>;</goto>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* The following block stores the meta information that will be returned
  ** to the caller in local variables zDataType, zCollSeq, notnull, primarykey
  ** and autoinc. At this point there are two possibilities:
  ** 
  **     1. The specified column name was rowid", "oid" or "_rowid_" 
  **        and there is no explicitly declared IPK column. 
  **
  **     2. The table is not a view and the column name identified an 
  **        explicitly declared column. Copy meta information from *pCol.
  */</comment> 
  <if>if<condition>( <expr><name>pCol</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zDataType</name> = <name>pCol</name>-&gt;<name>zType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCollSeq</name> = <name>pCol</name>-&gt;<name>zColl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>notnull</name> = <name>pCol</name>-&gt;<name>notNull</name>!=0</expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name>  = <name>pCol</name>-&gt;<name>isPrimKey</name>!=0</expr>;</expr_stmt>
    <expr_stmt><expr><name>autoinc</name> = <name>pTab</name>-&gt;<name>iPKey</name>==<name>iCol</name> &amp;&amp; (<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Autoincrement</name>)!=0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zDataType</name> = "INTEGER"</expr>;</expr_stmt>
    <expr_stmt><expr><name>primarykey</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr>!<name>zCollSeq</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zCollSeq</name> = "BINARY"</expr>;</expr_stmt>
  }</block></then></if>

<label><name>error_out</name>:</label>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Whether the function call succeeded or failed, set the output parameters
  ** to whatever their local counterparts contain. If an error did occur,
  ** this has the effect of zeroing all output parameters.
  */</comment>
  <if>if<condition>( <expr><name>pzDataType</name></expr> )</condition><then> <expr_stmt><expr>*<name>pzDataType</name> = <name>zDataType</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pzCollSeq</name></expr> )</condition><then> <expr_stmt><expr>*<name>pzCollSeq</name> = <name>zCollSeq</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pNotNull</name></expr> )</condition><then> <expr_stmt><expr>*<name>pNotNull</name> = <name>notnull</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pPrimaryKey</name></expr> )</condition><then> <expr_stmt><expr>*<name>pPrimaryKey</name> = <name>primarykey</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>pAutoinc</name></expr> )</condition><then> <expr_stmt><expr>*<name>pAutoinc</name> = <name>autoinc</name></expr>;</expr_stmt></then></if>

  <if>if<condition>( <expr><name>SQLITE_OK</name>==<name>rc</name> &amp;&amp; !<name>pTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErrMsg</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"no such table column: %s.%s"</expr></argument>, <argument><expr><name>zTableName</name></expr></argument>,
        <argument><expr><name>zColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr>(<name>zErrMsg</name>?"%s":0)</expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_sleep</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ms</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pVfs</name> = <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pVfs</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* This function works in milliseconds, but the underlying OsSleep() 
  ** API uses microseconds. Hence the 1000's.
  */</comment>
  <expr_stmt><expr><name>rc</name> = (<call><name>sqlite3OsSleep</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr>1000*<name>ms</name></expr></argument>)</argument_list></call>/1000)</expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Enable or disable the extended result codes.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_extended_result_codes</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>onoff</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>errMask</name> = <name>onoff</name> ? 0xffffffff : 0xff</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Invoke the xFileControl method on a particular database.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_file_control</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zDbName</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zDbName</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>iDb</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <for>for(<init><expr><name>iDb</name>=0</expr>;</init> <condition><expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>iDb</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zDbName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <break>break;</break></then></if>
    }</block></for>
  }</block></else></if>
  <if>if<condition>( <expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Btree</name> *</type><name>pBtree</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pBt</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pBtree</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_file</name> *</type><name>fd</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pPager</name> = <call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPager</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>fd</name> = <call><name>sqlite3PagerFile</name><argument_list>(<argument><expr><name>pPager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>fd</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>fd</name>-&gt;<name>pMethods</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqlite3OsFileControl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>   
}</block></function>

<comment type="block">/*
** Interface to the testing logic.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_test_control</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BUILTIN_TEST</name></cpp:ifndef>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{

    <comment type="block">/*
    ** Save the current state of the PRNG.
    */</comment>
    <case>case <expr><name>SQLITE_TESTCTRL_PRNG_SAVE</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3PrngSaveState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/*
    ** Restore the state of the PRNG to the last state saved using
    ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then
    ** this verb acts like PRNG_RESET.
    */</comment>
    </case><case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESTORE</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3PrngRestoreState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/*
    ** Reset the PRNG back to its uninitialized state.  The next call
    ** to sqlite3_randomness() will reseed the PRNG using a single call
    ** to the xRandomness method of the default VFS.
    */</comment>
    </case><case>case <expr><name>SQLITE_TESTCTRL_PRNG_RESET</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3PrngResetState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/*
    **  sqlite3_test_control(BITVEC_TEST, size, program)
    **
    ** Run a test against a Bitvec object of size.  The program argument
    ** is an array of integers that defines the test.  Return -1 on a
    ** memory allocation error, 0 on success, or non-zero for an error.
    ** See the sqlite3BitvecBuiltinTest() for additional information.
    */</comment>
    </case><case>case <expr><name>SQLITE_TESTCTRL_BITVEC_TEST</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>sz</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name> *</type><name>aProg</name> =<init> <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BitvecBuiltinTest</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><name>aProg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>

    <comment type="block">/*
    **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)
    **
    ** Register hooks to call to indicate which malloc() failures 
    ** are benign.
    */</comment>
    </case><case>case <expr><name>SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS</name></expr>: <block>{
      <typedef>typedef <function_decl><type><name>void</name></type> (*<name>void_function</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl></typedef>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignBegin</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void_function</name></type> <name>xBenignEnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>xBenignBegin</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>xBenignEnd</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>void_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BenignMallocHooks</name><argument_list>(<argument><expr><name>xBenignBegin</name></expr></argument>, <argument><expr><name>xBenignEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </case>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_BUILTIN_TEST */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
</unit>
