<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="where.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.  This module is responsible for
** generating the code that loops through a table looking for applicable
** rows.  Indices are selected and used to speed the search when doing
** so is applicable.  Because this module is responsible for selecting
** indices, you might also think of this module as the "query optimizer".
**
** $Id: where.c,v 1.364 2009/01/14 00:55:10 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Trace output macros
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3WhereTrace</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>WHERETRACE</name>(X)  if(sqlite3WhereTrace) sqlite3DebugPrintf X</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>WHERETRACE</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Forward reference
*/</comment>
<typedef>typedef <type><struct>struct <name>WhereClause</name> WhereClause;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>WhereMaskSet</name> WhereMaskSet;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>WhereOrInfo</name> WhereOrInfo;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>WhereAndInfo</name> WhereAndInfo;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>WhereCost</name> WhereCost;</struct></type></typedef>

<comment type="block">/*
** The query generator uses an array of instances of this structure to
** help it analyze the subexpressions of the WHERE clause.  Each WHERE
** clause subexpression is separated from the others by AND operators.
** (Note: the same data structure is also reused to hold a group of terms
** separated by OR operators.  But at the top-level, everything is AND
** separated.)
**
** All WhereTerms are collected into a single WhereClause structure.  
** The following identity holds:
**
**        WhereTerm.pWC-&gt;a[WhereTerm.idx] == WhereTerm
**
** When a term is of the form:
**
**              X &lt;op&gt; &lt;expr&gt;
**
** where X is a column name and &lt;op&gt; is one of certain operators,
** then WhereTerm.leftCursor and WhereTerm.u.leftColumn record the
** cursor number and column number for X.  WhereTerm.eOperator records
** the &lt;op&gt; using a bitmask encoding defined by WO_xxx below.  The
** use of a bitmask encoding for the operator allows us to search
** quickly for terms that match any of several different operators.
**
** A WhereTerm might also be two or more subterms connected by OR:
**
**         (t1.X &lt;op&gt; &lt;expr&gt;) OR (t1.Y &lt;op&gt; &lt;expr&gt;) OR ....
**
** In this second case, wtFlag as the TERM_ORINFO set and eOperator==WO_OR
** and the WhereTerm.u.pOrInfo field points to auxiliary information that
** is collected about the
**
** If a term in the WHERE clause does not match either of the two previous
** categories, then eOperator==0.  The WhereTerm.pExpr field is still set
** to the original subexpression content and wtFlags is set up appropriately
** but no other fields in the WhereTerm object are meaningful.
**
** When eOperator!=0, prereqRight and prereqAll record sets of cursor numbers,
** but they do so indirectly.  A single WhereMaskSet structure translates
** cursor number into bits and the translated bit is stored in the prereq
** fields.  The translation is used in order to maximize the number of
** bits that will fit in a Bitmask.  The VDBE cursor numbers might be
** spread out over the non-negative integers.  For example, the cursor
** numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The WhereMaskSet
** translates these sparse cursor numbers into consecutive integers
** beginning with 0 in order to make the best possible use of the available
** bits in the Bitmask.  So, in the example above, the cursor numbers
** would be mapped into integers 0 through 7.
**
** The number of terms in a join is limited by the number of bits
** in prereqRight and prereqAll.  The default is 64 bits, hence SQLite
** is only able to process joins with 64 or fewer tables.
*/</comment>
<typedef>typedef <type><struct>struct <name>WhereTerm</name> WhereTerm;</struct></type></typedef>
<struct>struct <name>WhereTerm</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to the subexpression that is this term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iParent</name></decl>;</decl_stmt>            <comment type="block">/* Disable pWC-&gt;a[iParent] when this term disabled */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>leftCursor</name></decl>;</decl_stmt>         <comment type="block">/* Cursor number of X in "X &lt;op&gt; &lt;expr&gt;" */</comment>
  <decl_stmt><decl><type><struct>union <block>{<public type="default"/>
    <decl_stmt><decl><type><name>int</name></type> <name>leftColumn</name></decl>;</decl_stmt>         <comment type="block">/* Column number of X in "X &lt;op&gt; &lt;expr&gt;" */</comment>
    <decl_stmt><decl><type><name>WhereOrInfo</name> *</type><name>pOrInfo</name></decl>;</decl_stmt>   <comment type="block">/* Extra information if eOperator==WO_OR */</comment>
    <decl_stmt><decl><type><name>WhereAndInfo</name> *</type><name>pAndInfo</name></decl>;</decl_stmt> <comment type="block">/* Extra information if eOperator==WO_AND */</comment>
  }</block> <decl><name>u</name></decl>;</struct></type></decl></decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>eOperator</name></decl>;</decl_stmt>          <comment type="block">/* A WO_xx value describing &lt;op&gt; */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>wtFlags</name></decl>;</decl_stmt>             <comment type="block">/* TERM_xxx bit flags.  See below */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nChild</name></decl>;</decl_stmt>              <comment type="block">/* Number of children that must disable us */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl>;</decl_stmt>       <comment type="block">/* The clause this term is part of */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqRight</name></decl>;</decl_stmt>    <comment type="block">/* Bitmask of tables used by pExpr-&gt;pRight */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqAll</name></decl>;</decl_stmt>      <comment type="block">/* Bitmask of tables referenced by pExpr */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Allowed values of WhereTerm.wtFlags
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_DYNAMIC</name>    0x01</cpp:define>   <comment type="block">/* Need to call sqlite3ExprDelete(db, pExpr) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_VIRTUAL</name>    0x02</cpp:define>   <comment type="block">/* Added by the optimizer.  Do not code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_CODED</name>      0x04</cpp:define>   <comment type="block">/* This term is already coded */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_COPIED</name>     0x08</cpp:define>   <comment type="block">/* Has a child */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_ORINFO</name>     0x10</cpp:define>   <comment type="block">/* Need to free the WhereTerm.u.pOrInfo object */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_ANDINFO</name>    0x20</cpp:define>   <comment type="block">/* Need to free the WhereTerm.u.pAndInfo obj */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TERM_OR_OK</name>      0x40</cpp:define>   <comment type="block">/* Used during OR-clause processing */</comment>

<comment type="block">/*
** An instance of the following structure holds all information about a
** WHERE clause.  Mostly this is a container for one or more WhereTerms.
*/</comment>
<struct>struct <name>WhereClause</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name></decl>;</decl_stmt>           <comment type="block">/* The parser context */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl>;</decl_stmt>  <comment type="block">/* Mapping of table cursor numbers to bitmasks */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>op</name></decl>;</decl_stmt>                   <comment type="block">/* Split operator.  TK_AND or TK_OR */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>               <comment type="block">/* Number of terms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSlot</name></decl>;</decl_stmt>               <comment type="block">/* Number of entries in a[] */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>a</name></decl>;</decl_stmt>            <comment type="block">/* Each a[] describes a term of the WHERE cluase */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name></type> <name><name>aStatic</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Initial static space for a[] */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A WhereTerm with eOperator==WO_OR has its u.pOrInfo pointer set to
** a dynamically allocated instance of the following structure.
*/</comment>
<struct>struct <name>WhereOrInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>WhereClause</name></type> <name>wc</name></decl>;</decl_stmt>          <comment type="block">/* Decomposition into subterms */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>indexable</name></decl>;</decl_stmt>       <comment type="block">/* Bitmask of all indexable tables in the clause */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A WhereTerm with eOperator==WO_AND has its u.pAndInfo pointer set to
** a dynamically allocated instance of the following structure.
*/</comment>
<struct>struct <name>WhereAndInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>WhereClause</name></type> <name>wc</name></decl>;</decl_stmt>          <comment type="block">/* The subexpression broken out */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** An instance of the following structure keeps track of a mapping
** between VDBE cursor numbers and bits of the bitmasks in WhereTerm.
**
** The VDBE cursor numbers are small integers contained in 
** SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE 
** clause, the cursor numbers might not begin with 0 and they might
** contain gaps in the numbering sequence.  But we want to make maximum
** use of the bits in our bitmasks.  This structure provides a mapping
** from the sparse cursor numbers into consecutive integers beginning
** with 0.
**
** If WhereMaskSet.ix[A]==B it means that The A-th bit of a Bitmask
** corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1&lt;&lt;A.
**
** For example, if the WHERE clause expression used these VDBE
** cursors:  4, 5, 8, 29, 57, 73.  Then the  WhereMaskSet structure
** would map those cursor numbers into bits 0 through 5.
**
** Note that the mapping is not necessarily ordered.  In the example
** above, the mapping might go like this:  4-&gt;3, 5-&gt;1, 8-&gt;2, 29-&gt;0,
** 57-&gt;5, 73-&gt;4.  Or one of 719 other combinations might be used. It
** does not really matter.  What is important is that sparse cursor
** numbers all get mapped into bit numbers that begin with 0 and contain
** no gaps.
*/</comment>
<struct>struct <name>WhereMaskSet</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                        <comment type="block">/* Number of assigned cursor values */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>ix</name><index>[<expr><name>BMS</name></expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Cursor assigned to each bit */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** A WhereCost object records a lookup strategy and the estimated
** cost of pursuing that strategy.
*/</comment>
<struct>struct <name>WhereCost</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>WherePlan</name></type> <name>plan</name></decl>;</decl_stmt>    <comment type="block">/* The lookup strategy */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>rCost</name></decl>;</decl_stmt>      <comment type="block">/* Overall cost of pursuing this search strategy */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRow</name></decl>;</decl_stmt>       <comment type="block">/* Estimated number of output rows */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Bitmasks for the operators that indices are able to exploit.  An
** OR-ed combination of these values can be used when searching for
** terms in the where clause.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_IN</name>     0x001</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_EQ</name>     0x002</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_LT</name>     (WO_EQ&lt;&lt;(TK_LT-TK_EQ))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_LE</name>     (WO_EQ&lt;&lt;(TK_LE-TK_EQ))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_GT</name>     (WO_EQ&lt;&lt;(TK_GT-TK_EQ))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_GE</name>     (WO_EQ&lt;&lt;(TK_GE-TK_EQ))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_MATCH</name>  0x040</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_ISNULL</name> 0x080</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_OR</name>     0x100</cpp:define>       <comment type="block">/* Two or more OR-connected terms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_AND</name>    0x200</cpp:define>       <comment type="block">/* Two or more AND-connected terms */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_ALL</name>    0xfff</cpp:define>       <comment type="block">/* Mask of all possible WO_* values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WO_SINGLE</name> 0x0ff</cpp:define>       <comment type="block">/* Mask of all non-compound WO_* values */</comment>

<comment type="block">/*
** Value for wsFlags returned by bestIndex() and stored in
** WhereLevel.wsFlags.  These flags determine which search
** strategies are appropriate.
**
** The least significant 12 bits is reserved as a mask for WO_ values above.
** The WhereLevel.wsFlags field is usually set to WO_IN|WO_EQ|WO_ISNULL.
** But if the table is the right table of a left join, WhereLevel.wsFlags
** is set to WO_IN|WO_EQ.  The WhereLevel.wsFlags field can then be used as
** the "op" parameter to findTerm when we are resolving equality constraints.
** ISNULL constraints will then not be used on the right table of a left
** join.  Tickets #2177 and #2189.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_ROWID_EQ</name>     0x00001000</cpp:define>  <comment type="block">/* rowid=EXPR or rowid IN (...) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_ROWID_RANGE</name>  0x00002000</cpp:define>  <comment type="block">/* rowid&lt;EXPR and/or rowid&gt;EXPR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_COLUMN_EQ</name>    0x00010000</cpp:define>  <comment type="block">/* x=EXPR or x IN (...) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_COLUMN_RANGE</name> 0x00020000</cpp:define>  <comment type="block">/* x&lt;EXPR and/or x&gt;EXPR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_COLUMN_IN</name>    0x00040000</cpp:define>  <comment type="block">/* x IN (...) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_INDEXED</name>      0x00070000</cpp:define>  <comment type="block">/* Anything that uses an index */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_IN_ABLE</name>      0x00071000</cpp:define>  <comment type="block">/* Able to support an IN operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_TOP_LIMIT</name>    0x00100000</cpp:define>  <comment type="block">/* x&lt;EXPR or x&lt;=EXPR constraint */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_BTM_LIMIT</name>    0x00200000</cpp:define>  <comment type="block">/* x&gt;EXPR or x&gt;=EXPR constraint */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_IDX_ONLY</name>     0x00800000</cpp:define>  <comment type="block">/* Use index only - omit table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_ORDERBY</name>      0x01000000</cpp:define>  <comment type="block">/* Output will appear in correct order */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_REVERSE</name>      0x02000000</cpp:define>  <comment type="block">/* Scan in reverse order */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_UNIQUE</name>       0x04000000</cpp:define>  <comment type="block">/* Selects no more than one row */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_VIRTUALTABLE</name> 0x08000000</cpp:define>  <comment type="block">/* Use virtual-table processing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WHERE_MULTI_OR</name>     0x10000000</cpp:define>  <comment type="block">/* OR using multiple indices */</comment>

<comment type="block">/*
** Initialize a preallocated WhereClause structure.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereClauseInit</name><parameter_list>(
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,        <comment type="block">/* The WhereClause to be initialized */</comment>
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,           <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>   <comment type="block">/* Mapping from table cursor numbers to bitmasks */</comment>
)</parameter_list><block>{
  <expr_stmt><expr><name>pWC</name>-&gt;<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name>-&gt;<name>pMaskSet</name> = <name>pMaskSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name>-&gt;<name>nTerm</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name>-&gt;<name>nSlot</name> = <call><name>ArraySize</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name>aStatic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name>-&gt;<name>a</name> = <name>pWC</name>-&gt;<name>aStatic</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><name>static</name> <name>void</name></type> <name>whereClauseClear</name><parameter_list>(<param><decl><type><name>WhereClause</name>*</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Deallocate all memory associated with a WhereOrInfo object.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereOrInfoDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>WhereOrInfo</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>whereClauseClear</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Deallocate all memory associated with a WhereAndInfo object.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereAndInfoDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>WhereAndInfo</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>whereClauseClear</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Deallocate a WhereClause structure.  The WhereClause structure
** itself is not freed.  This routine is the inverse of whereClauseInit().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereClauseClear</name><parameter_list>(<param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pWC</name>-&gt;<name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=<name>pWC</name>-&gt;<name>nTerm</name>-1</expr>, <expr><name>a</name>=<name>pWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>a</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>a</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_DYNAMIC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>a</name>-&gt;<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>a</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_ORINFO</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>whereOrInfoDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>a</name>-&gt;<name>u</name>.<name>pOrInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>a</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_ANDINFO</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>whereAndInfoDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>a</name>-&gt;<name>u</name>.<name>pAndInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></for>
  <if>if<condition>( <expr><name>pWC</name>-&gt;<name>a</name>!=<name>pWC</name>-&gt;<name>aStatic</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Add a single new WhereTerm entry to the WhereClause object pWC.
** The new WhereTerm object is constructed from Expr p and with wtFlags.
** The index in pWC-&gt;a[] of the new WhereTerm is returned on success.
** 0 is returned if the new WhereTerm could not be added due to a memory
** allocation error.  The memory allocation failure will be recorded in
** the db-&gt;mallocFailed flag so that higher-level functions can detect it.
**
** This routine will increase the size of the pWC-&gt;a[] array as necessary.
**
** If the wtFlags argument includes TERM_DYNAMIC, then responsibility
** for freeing the expression p is assumed by the WhereClause object pWC.
** This is true even if this routine fails to allocate a new WhereTerm.
**
** WARNING:  This routine might reallocate the space used to store
** WhereTerms.  All pointers to WhereTerms should be invalidated after
** calling this routine.  Such pointers may be reinitialized by referencing
** the pWC-&gt;a[] array.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>whereClauseInsert</name><parameter_list>(<param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>u8</name></type> <name>wtFlags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pWC</name>-&gt;<name>nTerm</name>&gt;=<name>pWC</name>-&gt;<name>nSlot</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOld</name> =<init> <expr><name>pWC</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pWC</name>-&gt;<name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pWC</name>-&gt;<name>a</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>pWC</name>-&gt;<name>nSlot</name>*2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pWC</name>-&gt;<name>a</name>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>wtFlags</name> &amp; <name>TERM_DYNAMIC</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>pWC</name>-&gt;<name>a</name> = <name>pOld</name></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name>a</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>pWC</name>-&gt;<name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOld</name>!=<name>pWC</name>-&gt;<name>aStatic</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pWC</name>-&gt;<name>nSlot</name> = <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>a</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idx</name> = <name>pWC</name>-&gt;<name>nTerm</name>++</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>pExpr</name> = <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> = <name>wtFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>pWC</name> = <name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>iParent</name> = -1</expr>;</expr_stmt>
  <return>return <expr><name>idx</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine identifies subexpressions in the WHERE clause where
** each subexpression is separated by the AND operator or some other
** operator specified in the op parameter.  The WhereClause structure
** is filled with pointers to subexpressions.  For example:
**
**    WHERE  a=='hello' AND coalesce(b,11)&lt;10 AND (c+12!=d OR c==22)
**           \________/     \_______________/     \________________/
**            slot[0]            slot[1]               slot[2]
**
** The original WHERE clause in pExpr is unaltered.  All this routine
** does is make slot[] entries point to substructure within pExpr.
**
** In the previous sentence and in the diagram, "slot[]" refers to
** the WhereClause.a[] array.  The slot[] array grows as needed to contain
** all terms of the WHERE clause.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereSplit</name><parameter_list>(<param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pWC</name>-&gt;<name>op</name> = (<name>u8</name>)<name>op</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>op</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>whereSplit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>whereSplit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Initialize an expression mask set
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>initMaskSet</name>(P)  memset(P, 0, sizeof(*P))</cpp:define>

<comment type="block">/*
** Return the bitmask for the given cursor number.  Return 0 if
** iCursor is not in the set.
*/</comment>
<function><type><name>static</name> <name>Bitmask</name></type> <name>getMask</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCursor</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pMaskSet</name>-&gt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pMaskSet</name>-&gt;<name><name>ix</name><index>[<expr><name>i</name></expr>]</index></name>==<name>iCursor</name></expr> )</condition><then><block>{
      <return>return <expr>((<name>Bitmask</name>)1)&lt;&lt;<name>i</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new mask for cursor iCursor.
**
** There is one cursor per table in the FROM clause.  The number of
** tables in the FROM clause is limited by a test early in the
** sqlite3WhereBegin() routine.  So we know that the pMaskSet-&gt;ix[]
** array will never overflow.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>createMask</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <param><decl><type><name>int</name></type> <name>iCursor</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pMaskSet</name>-&gt;<name>n</name> &lt; <call><name>ArraySize</name><argument_list>(<argument><expr><name>pMaskSet</name>-&gt;<name>ix</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMaskSet</name>-&gt;<name><name>ix</name><index>[<expr><name>pMaskSet</name>-&gt;<name>n</name>++</expr>]</index></name> = <name>iCursor</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine walks (recursively) an expression tree and generates
** a bitmask indicating which tables are used in that expression
** tree.
**
** In order for this routine to work, the calling function must have
** previously invoked sqlite3ResolveExprNames() on the expression.  See
** the header comment on that routine for additional information.
** The sqlite3ResolveExprNames() routines looks for column names and
** sets their opcodes to TK_COLUMN and their Expr.iTable fields to
** the VDBE cursor number of the table.  This routine just has to
** translate the cursor numbers into bitmask values and OR all
** the bitmasks together.
*/</comment>
<function_decl><type><name>static</name> <name>Bitmask</name></type> <name>exprListTableUsage</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name>*</type></decl></param>, <param><decl><type><name>ExprList</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>Bitmask</name></type> <name>exprSelectTableUsage</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name>*</type></decl></param>, <param><decl><type><name>Select</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function><type><name>static</name> <name>Bitmask</name></type> <name>exprTableUsage</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>mask</name> = <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>mask</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>mask</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> |= <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> |= <call><name>exprListTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> |= <call><name>exprSelectTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>mask</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>Bitmask</name></type> <name>exprListTableUsage</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>mask</name> |= <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>mask</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>Bitmask</name></type> <name>exprSelectTableUsage</name><parameter_list>(<param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <param><decl><type><name>Select</name> *</type><name>pS</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>pS</name></expr> )</condition><block>{
    <expr_stmt><expr><name>mask</name> |= <call><name>exprListTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pS</name>-&gt;<name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> |= <call><name>exprListTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pS</name>-&gt;<name>pGroupBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> |= <call><name>exprListTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pS</name>-&gt;<name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> |= <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pS</name>-&gt;<name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> |= <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pS</name>-&gt;<name>pHaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pS</name> = <name>pS</name>-&gt;<name>pPrior</name></expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>mask</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the given operator is one of the operators that is
** allowed for an indexable WHERE clause term.  The allowed operators are
** "=", "&lt;", "&gt;", "&lt;=", "&gt;=", and "IN".
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>allowedOp</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name>&gt;<name>TK_EQ</name> &amp;&amp; <name>TK_GT</name>&lt;<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name>&gt;<name>TK_EQ</name> &amp;&amp; <name>TK_LT</name>&lt;<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name>&gt;<name>TK_EQ</name> &amp;&amp; <name>TK_LE</name>&lt;<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name>==<name>TK_EQ</name>+4</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>op</name>==<name>TK_IN</name> || (<name>op</name>&gt;=<name>TK_EQ</name> &amp;&amp; <name>op</name>&lt;=<name>TK_GE</name>) || <name>op</name>==<name>TK_ISNULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Swap two objects of type TYPE.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>SWAP</name>(TYPE,A,B) {TYPE t=A; A=B; B=t;}</cpp:define>

<comment type="block">/*
** Commute a comparison operator.  Expressions of the form "X op Y"
** are converted into "Y op X".
**
** If a collation sequence is associated with either the left or right
** side of the comparison, it remains associated with the same side after
** the commutation. So "Y collate NOCASE op X" becomes 
** "X collate NOCASE op Y". This is because any collation sequence on
** the left hand side of a comparison overrides any collation sequence 
** attached to the right. For the same reason the EP_ExpCollate flag
** is not commuted.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>exprCommute</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>expRight</name> =<init> <expr>(<name>pExpr</name>-&gt;<name>pRight</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name></type> <name>expLeft</name> =<init> <expr>(<name>pExpr</name>-&gt;<name>pLeft</name>-&gt;<name>flags</name> &amp; <name>EP_ExpCollate</name>)</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>op</name></expr></argument>)</argument_list></call> &amp;&amp; <name>pExpr</name>-&gt;<name>op</name>!=<name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name>-&gt;<name>pRight</name>-&gt;<name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name>-&gt;<name>pLeft</name>-&gt;<name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>,<argument><expr><name>pExpr</name>-&gt;<name>pRight</name>-&gt;<name>pColl</name></expr></argument>,<argument><expr><name>pExpr</name>-&gt;<name>pLeft</name>-&gt;<name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name>-&gt;<name>pRight</name>-&gt;<name>flags</name> = (<name>pExpr</name>-&gt;<name>pRight</name>-&gt;<name>flags</name> &amp; ~<name>EP_ExpCollate</name>) | <name>expLeft</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name>-&gt;<name>pLeft</name>-&gt;<name>flags</name> = (<name>pExpr</name>-&gt;<name>pLeft</name>-&gt;<name>flags</name> &amp; ~<name>EP_ExpCollate</name>) | <name>expRight</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>Expr</name>*</expr></argument>,<argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>,<argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>&gt;=<name>TK_GT</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name>==<name>TK_GT</name>+2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name>==<name>TK_LE</name>+2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name>&gt;<name>TK_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GT</name>&lt;<name>TK_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>&gt;=<name>TK_GT</name> &amp;&amp; <name>pExpr</name>-&gt;<name>op</name>&lt;=<name>TK_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pExpr</name>-&gt;<name>op</name> = ((<name>pExpr</name>-&gt;<name>op</name>-<name>TK_GT</name>)^2)+<name>TK_GT</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Translate from TK_xx operator to WO_xx bitmask.
*/</comment>
<function><type><name>static</name> <name>u16</name></type> <name>operatorMask</name><parameter_list>(<param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u16</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>TK_IN</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>c</name> = <name>WO_IN</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>op</name>==<name>TK_ISNULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>c</name> = <name>WO_ISNULL</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>WO_EQ</name>&lt;&lt;(<name>op</name>-<name>TK_EQ</name>)) &lt; 0x7fff</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> = (<name>u16</name>)(<name>WO_EQ</name>&lt;&lt;(<name>op</name>-<name>TK_EQ</name>))</expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_ISNULL</name> || <name>c</name>==<name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_IN</name> || <name>c</name>==<name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_EQ</name> || <name>c</name>==<name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_LT</name> || <name>c</name>==<name>WO_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_LE</name> || <name>c</name>==<name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_GT</name> || <name>c</name>==<name>WO_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=<name>TK_GE</name> || <name>c</name>==<name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>c</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Search for a term in the WHERE clause that is of the form "X &lt;op&gt; &lt;expr&gt;"
** where X is a reference to the iColumn of table iCur and &lt;op&gt; is one of
** the WO_xx operator codes specified by the op parameter.
** Return a pointer to the term.  Return 0 if not found.
*/</comment>
<function><type><name>static</name> <name>WhereTerm</name> *</type><name>findTerm</name><parameter_list>(
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,     <comment type="block">/* The WHERE clause to be searched */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,             <comment type="block">/* Cursor number of LHS */</comment>
  <param><decl><type><name>int</name></type> <name>iColumn</name></decl></param>,          <comment type="block">/* Column number of LHS */</comment>
  <param><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></param>,     <comment type="block">/* RHS must not overlap with this mask */</comment>
  <param><decl><type><name>u32</name></type> <name>op</name></decl></param>,               <comment type="block">/* Mask of WO_xx values describing operator */</comment>
  <param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>           <comment type="block">/* Must be compatible with this index, if not NULL */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iCur</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> &amp;= <name>WO_ALL</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>, <expr><name>k</name>=<name>pWC</name>-&gt;<name>nTerm</name></expr>;</init> <condition><expr><name>k</name></expr>;</condition> <incr><expr><name>k</name>--</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>leftCursor</name>==<name>iCur</name>
       &amp;&amp; (<name>pTerm</name>-&gt;<name>prereqRight</name> &amp; <name>notReady</name>)==0
       &amp;&amp; <name>pTerm</name>-&gt;<name>u</name>.<name>leftColumn</name>==<name>iColumn</name>
       &amp;&amp; (<name>pTerm</name>-&gt;<name>eOperator</name> &amp; <name>op</name>)!=0</expr>
    )</condition><then><block>{
      <if>if<condition>( <expr><name>pIdx</name> &amp;&amp; <name>pTerm</name>-&gt;<name>eOperator</name>!=<name>WO_ISNULL</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Expr</name> *</type><name>pX</name> =<init> <expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>idxaff</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWC</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>idxaff</name> = <name>pIdx</name>-&gt;<name>pTable</name>-&gt;<name><name>aCol</name><index>[<expr><name>iColumn</name></expr>]</index></name>.<name>affinity</name></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<call><name>sqlite3IndexAffinityOk</name><argument_list>(<argument><expr><name>pX</name></expr></argument>, <argument><expr><name>idxaff</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>

        <comment type="block">/* Figure out the collation sequence required from an index for
        ** it to be useful for optimising expression pX. Store this
        ** value in variable pColl.
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pX</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3BinaryCompareCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pLeft</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pColl</name> || <name>pParse</name>-&gt;<name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name>!=<name>iColumn</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>j</name>&gt;=<name>pIdx</name>-&gt;<name>nColumn</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>pColl</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
      }</block></then></if>
      <return>return <expr><name>pTerm</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><name>static</name> <name>void</name></type> <name>exprAnalyze</name><parameter_list>(<param><decl><type><name>SrcList</name>*</type></decl></param>, <param><decl><type><name>WhereClause</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
** Call exprAnalyze on all terms in a WHERE clause.  
**
**
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>exprAnalyzeAll</name><parameter_list>(
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,       <comment type="block">/* the FROM clause */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>         <comment type="block">/* the WHERE clause to be analyzed */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=<name>pWC</name>-&gt;<name>nTerm</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LIKE_OPTIMIZATION</name></cpp:ifndef>
<comment type="block">/*
** Check to see if the given expression is a LIKE or GLOB operator that
** can be optimized using inequality constraints.  Return TRUE if it is
** so and false if not.
**
** In order for the operator to be optimizible, the RHS must be a string
** literal that does not begin with a wildcard.  
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>isLikeOrGlob</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>,      <comment type="block">/* Test this expression */</comment>
  <param><decl><type><name>int</name> *</type><name>pnPattern</name></decl></param>,   <comment type="block">/* Number of non-wildcard prefix characters */</comment>
  <param><decl><type><name>int</name> *</type><name>pisComplete</name></decl></param>, <comment type="block">/* True if the only wildcard is % in the last character */</comment>
  <param><decl><type><name>int</name> *</type><name>pnoCase</name></decl></param>      <comment type="block">/* True if uppercase is equivalent to lowercase */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>             <comment type="block">/* String on RHS of LIKE operator */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pRight</name>, *<name>pLeft</name></decl>;</decl_stmt>      <comment type="block">/* Right and left size of LIKE operator */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name></decl>;</decl_stmt>           <comment type="block">/* List of operands to the LIKE operator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>                     <comment type="block">/* One character in z[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>                   <comment type="block">/* Number of non-wildcard prefix characters */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>wc</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>                <comment type="block">/* Wildcard characters */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>            <comment type="block">/* Collating sequence for LHS */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection */</comment>

  <if>if<condition>( <expr>!<call><name>sqlite3IsLikeFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>pnoCase</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_EBCDIC</name></cpp:ifdef>
  <if>if<condition>( <expr>*<name>pnoCase</name></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>pList</name> = <name>pExpr</name>-&gt;<name>pList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRight</name> = <name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pRight</name>-&gt;<name>op</name>!=<name>TK_STRING</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pLeft</name> = <name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColl</name>!=0 || <name>pLeft</name>-&gt;<name>iColumn</name>==-1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pColl</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* No collation is defined for the ROWID.  Use the default. */</comment>
    <expr_stmt><expr><name>pColl</name> = <name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr>(<name>pColl</name>-&gt;<name>type</name>!=<name>SQLITE_COLL_BINARY</name> || *<name>pnoCase</name>) &amp;&amp;
      (<name>pColl</name>-&gt;<name>type</name>!=<name>SQLITE_COLL_NOCASE</name> || !*<name>pnoCase</name>)</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3DequoteExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = (<name>char</name> *)<name>pRight</name>-&gt;<name>token</name>.<name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cnt</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name></expr> )</condition><then><block>{
    <while>while<condition>( <expr>(<name>c</name>=<name><name>z</name><index>[<expr><name>cnt</name></expr>]</index></name>)!=0 &amp;&amp; <name>c</name>!=<name><name>wc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name>c</name>!=<name><name>wc</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name>c</name>!=<name><name>wc</name><index>[<expr>2</expr>]</index></name></expr> )</condition><block>{ <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt> }</block></while>
  }</block></then></if>
  <if>if<condition>( <expr><name>cnt</name>==0 || 255==(<name>u8</name>)<name><name>z</name><index>[<expr><name>cnt</name>-1</expr>]</index></name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pisComplete</name> = <name><name>z</name><index>[<expr><name>cnt</name></expr>]</index></name>==<name><name>wc</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <name><name>z</name><index>[<expr><name>cnt</name>+1</expr>]</index></name>==0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pnPattern</name> = <name>cnt</name></expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Check to see if the given expression is of the form
**
**         column MATCH expr
**
** If it is then return TRUE.  If not, return FALSE.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>isMatchOfColumn</name><parameter_list>(
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>      <comment type="block">/* Test this expression */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_FUNCTION</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name>!=5 ||
       <call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>(<name>const</name> <name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>,<argument><expr>"match"</expr></argument>,<argument><expr>5</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pList</name> = <name>pExpr</name>-&gt;<name>pList</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pList</name>-&gt;<name>nExpr</name>!=2</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name>-&gt;<name>op</name> != <name>TK_COLUMN</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** If the pBase expression originated in the ON or USING clause of
** a join, then transfer the appropriate markings over to derived.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>transferJoinMarkings</name><parameter_list>(<param><decl><type><name>Expr</name> *</type><name>pDerived</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pBase</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pDerived</name>-&gt;<name>flags</name> |= <name>pBase</name>-&gt;<name>flags</name> &amp; <name>EP_FromJoin</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDerived</name>-&gt;<name>iRightJoinTable</name> = <name>pBase</name>-&gt;<name>iRightJoinTable</name></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_OR_OPTIMIZATION</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Analyze a term that consists of two or more OR-connected
** subterms.  So in:
**
**     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)
**                          ^^^^^^^^^^^^^^^^^^^^
**
** This routine analyzes terms such as the middle term in the above example.
** A WhereOrTerm object is computed and attached to the term under
** analysis, regardless of the outcome of the analysis.  Hence:
**
**     WhereTerm.wtFlags   |=  TERM_ORINFO
**     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object
**
** The term being analyzed must have two or more of OR-connected subterms.
** A single subterm might be a set of AND-connected sub-subterms.
** Examples of terms under analysis:
**
**     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a+5
**     (B)     x=expr1 OR expr2=x OR x=expr3
**     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)
**     (D)     x=expr1 OR (y&gt;11 AND y&lt;22 AND z LIKE '*hello*')
**     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)
**
** CASE 1:
**
** If all subterms are of the form T.C=expr for some single column of C
** a single table T (as shown in example B above) then create a new virtual
** term that is an equivalent IN expression.  In other words, if the term
** being analyzed is:
**
**      x = expr1  OR  expr2 = x  OR  x = expr3
**
** then create a new virtual term like this:
**
**      x IN (expr1,expr2,expr3)
**
** CASE 2:
**
** If all subterms are indexable by a single table T, then set
**
**     WhereTerm.eOperator              =  WO_OR
**     WhereTerm.u.pOrInfo-&gt;indexable  |=  the cursor number for table T
**
** A subterm is "indexable" if it is of the form
** "T.C &lt;op&gt; &lt;expr&gt;" where C is any column of table T and 
** &lt;op&gt; is one of "=", "&lt;", "&lt;=", "&gt;", "&gt;=", "IS NULL", or "IN".
** A subterm is also indexable if it is an AND of two or more
** subsubterms at least one of which is indexable.  Indexable AND 
** subterms have their eOperator set to WO_AND and they have
** u.pAndInfo set to a dynamically allocated WhereAndTerm object.
**
** From another point of view, "indexable" means that the subterm could
** potentially be used with an index if an appropriate index exists.
** This analysis does not consider whether or not the index exists; that
** is something the bestIndex() routine will determine.  This analysis
** only looks at whether subterms appropriate for indexing exist.
**
** All examples A through E above all satisfy case 2.  But if a term
** also statisfies case 1 (such as B) we know that the optimizer will
** always prefer case 1, so in that case we pretend that case 2 is not
** satisfied.
**
** It might be the case that multiple tables are indexable.  For example,
** (E) above is indexable on tables P, Q, and R.
**
** Terms that satisfy case 2 are candidates for lookup by using
** separate indices to find rowids for each subterm and composing
** the union of all rowids using a RowSet object.  This is similar
** to "bitmap indices" in other database engines.
**
** OTHERWISE:
**
** If neither case 1 nor case 2 apply, then leave the eOperator set to
** zero.  This term is not useful for search.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>exprAnalyzeOrTerm</name><parameter_list>(
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,            <comment type="block">/* the FROM clause */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,         <comment type="block">/* the complete WHERE clause */</comment>
  <param><decl><type><name>int</name></type> <name>idxTerm</name></decl></param>               <comment type="block">/* Index of the OR-term to be analyzed */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWC</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Parser context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name> =<init> <expr>&amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* The term to be analyzed */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name> =<init> <expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* The expression of the term */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name> =<init> <expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Table use masks */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                                  <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pOrWc</name></decl>;</decl_stmt>       <comment type="block">/* Breakup of pTerm into subterms */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOrTerm</name></decl>;</decl_stmt>       <comment type="block">/* A Sub-term within the pOrWc */</comment>
  <decl_stmt><decl><type><name>WhereOrInfo</name> *</type><name>pOrInfo</name></decl>;</decl_stmt>     <comment type="block">/* Additional information associated with pTerm */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>chngToIN</name></decl>;</decl_stmt>         <comment type="block">/* Tables that might satisfy case 1 */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>indexable</name></decl>;</decl_stmt>        <comment type="block">/* Tables that are indexable, satisfying case 2 */</comment>

  <comment type="block">/*
  ** Break the OR clause into its separate subterms.  The subterms are
  ** stored in a WhereClause structure containing within the WhereOrInfo
  ** object that is attached to the original OR clause term.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pTerm</name>-&gt;<name>wtFlags</name> &amp; (<name>TERM_DYNAMIC</name>|<name>TERM_ORINFO</name>|<name>TERM_ANDINFO</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>u</name>.<name>pOrInfo</name> = <name>pOrInfo</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pOrInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pOrInfo</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_ORINFO</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOrWc</name> = &amp;<name>pOrInfo</name>-&gt;<name>wc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereClauseInit</name><argument_list>(<argument><expr><name>pOrWc</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>pParse</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereSplit</name><argument_list>(<argument><expr><name>pOrWc</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>TK_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exprAnalyzeAll</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pOrWc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrWc</name>-&gt;<name>nTerm</name>&gt;=2</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
  ** Compute the set of tables that might satisfy cases 1 or 2.
  */</comment>
  <expr_stmt><expr><name>indexable</name> = <name>chngToIN</name> = ~(<name>Bitmask</name>)0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>pOrWc</name>-&gt;<name>nTerm</name>-1</expr>, <expr><name>pOrTerm</name>=<name>pOrWc</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&gt;=0 &amp;&amp; <name>indexable</name></expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>(<name>pOrTerm</name>-&gt;<name>eOperator</name> &amp; <name>WO_SINGLE</name>)==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>WhereAndInfo</name> *</type><name>pAndInfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>eOperator</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp; (<name>TERM_ANDINFO</name>|<name>TERM_ORINFO</name>))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>chngToIN</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pAndInfo</name> = <call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pAndInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pAndInfo</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pAndWC</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pAndTerm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>u</name>.<name>pAndInfo</name> = <name>pAndInfo</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_ANDINFO</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>eOperator</name> = <name>WO_AND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pAndWC</name> = &amp;<name>pAndInfo</name>-&gt;<name>wc</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereClauseInit</name><argument_list>(<argument><expr><name>pAndWC</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>pParse</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>whereSplit</name><argument_list>(<argument><expr><name>pAndWC</name></expr></argument>, <argument><expr><name>pOrTerm</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exprAnalyzeAll</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pAndWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
          <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pAndTerm</name>=<name>pAndWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>pAndWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pAndTerm</name>++</expr></incr>)<block>{
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAndTerm</name>-&gt;<name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>pAndTerm</name>-&gt;<name>pExpr</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
              <expr_stmt><expr><name>b</name> |= <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pAndTerm</name>-&gt;<name>leftCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          }</block></for>
        }</block></then></if>
        <expr_stmt><expr><name>indexable</name> &amp;= <name>b</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_COPIED</name></expr> )</condition><then><block>{
      <comment type="block">/* Skip this term for now.  We revisit it when we process the
      ** corresponding TERM_VIRTUAL term */</comment>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>b</name> = <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pOrTerm</name>-&gt;<name>leftCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_VIRTUAL</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOther</name> =<init> <expr>&amp;<name>pOrWc</name>-&gt;<name><name>a</name><index>[<expr><name>pOrTerm</name>-&gt;<name>iParent</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>b</name> |= <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pOther</name>-&gt;<name>leftCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>indexable</name> &amp;= <name>b</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>eOperator</name>!=<name>WO_EQ</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>chngToIN</name> = 0</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>chngToIN</name> &amp;= <name>b</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
  }</block></for>

  <comment type="block">/*
  ** Record the set of tables that satisfy case 2.  The set might be
  ** empty.
  */</comment>
  <expr_stmt><expr><name>pOrInfo</name>-&gt;<name>indexable</name> = <name>indexable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>eOperator</name> = <name>indexable</name>==0 ? 0 : <name>WO_OR</name></expr>;</expr_stmt>

  <comment type="block">/*
  ** chngToIN holds a set of tables that *might* satisfy case 1.  But
  ** we have to do some additional checking to see if case 1 really
  ** is satisfied.
  */</comment>
  <if>if<condition>( <expr><name>chngToIN</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>okToChngToIN</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* True if the conversion to IN is valid */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>         <comment type="block">/* Column index on lhs of IN operator */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iCursor</name></decl>;</decl_stmt>              <comment type="block">/* Table cursor common to all terms */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                <comment type="block">/* Loop counter */</comment>

    <comment type="block">/* Search for a table and column that appears on one side or the
    ** other of the == operator in every subterm.  That table and column
    ** will be recorded in iCursor and iColumn.  There might not be any
    ** such table and column.  Set okToChngToIN if an appropriate table
    ** and column is found but leave okToChngToIN false if not found.
    */</comment>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;2 &amp;&amp; !<name>okToChngToIN</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>pOrTerm</name> = <name>pOrWc</name>-&gt;<name>a</name></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=<name>pOrWc</name>-&gt;<name>nTerm</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>eOperator</name>==<name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp;= ~<name>TERM_OR_OK</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>leftCursor</name>==<name>iColumn</name></expr> )</condition><then> <continue>continue;</continue></then></if>
        <if>if<condition>( <expr>(<name>chngToIN</name> &amp; <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pOrTerm</name>-&gt;<name>leftCursor</name></expr></argument>)</argument_list></call>)==0</expr> )</condition><then> <continue>continue;</continue></then></if>
        <expr_stmt><expr><name>iColumn</name> = <name>pOrTerm</name>-&gt;<name>u</name>.<name>leftColumn</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iCursor</name> = <name>pOrTerm</name>-&gt;<name>leftCursor</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></for>
      <if>if<condition>( <expr><name>i</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>chngToIN</name>&amp;(<name>chngToIN</name>-1))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>chngToIN</name>==<call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><name>okToChngToIN</name> = 1</expr>;</expr_stmt>
      <for>for(<init>;</init> <condition><expr><name>i</name>&gt;=0 &amp;&amp; <name>okToChngToIN</name></expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>eOperator</name>==<name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>leftCursor</name>!=<name>iCursor</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp;= ~<name>TERM_OR_OK</name></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>u</name>.<name>leftColumn</name>!=<name>iColumn</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>okToChngToIN</name> = 0</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <decl_stmt><decl><type><name>int</name></type> <name>affLeft</name>, <name>affRight</name></decl>;</decl_stmt>
          <comment type="block">/* If the right-hand side is also a column, then the affinities
          ** of both right and left sides must be such that no type
          ** conversions are required on the right.  (Ticket #2249)
          */</comment>
          <expr_stmt><expr><name>affRight</name> = <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pOrTerm</name>-&gt;<name>pExpr</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>affLeft</name> = <call><name>sqlite3ExprAffinity</name><argument_list>(<argument><expr><name>pOrTerm</name>-&gt;<name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>affRight</name>!=0 &amp;&amp; <name>affRight</name>!=<name>affLeft</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>okToChngToIN</name> = 0</expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pOrTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_OR_OK</name></expr>;</expr_stmt>
          }</block></else></if>
        }</block></else></if></else></if>
      }</block></for>
    }</block></for>

    <comment type="block">/* At this point, okToChngToIN is true if original pTerm satisfies
    ** case 1.  In that case, construct a new virtual term that is 
    ** pTerm converted into an IN operator.
    */</comment>
    <if>if<condition>( <expr><name>okToChngToIN</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pDup</name></decl>;</decl_stmt>            <comment type="block">/* A transient duplicate expression */</comment>
      <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* The RHS of the IN operator */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* The LHS of the IN operator */</comment>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pNew</name></decl>;</decl_stmt>            <comment type="block">/* The complete IN operator */</comment>

      <for>for(<init><expr><name>i</name>=<name>pOrWc</name>-&gt;<name>nTerm</name>-1</expr>, <expr><name>pOrTerm</name>=<name>pOrWc</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr>(<name>pOrTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_OR_OK</name>)==0</expr> )</condition><then> <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>eOperator</name>==<name>WO_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>leftCursor</name>==<name>iCursor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrTerm</name>-&gt;<name>u</name>.<name>leftColumn</name>==<name>iColumn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDup</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOrTerm</name>-&gt;<name>pExpr</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name>pParse</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLeft</name> = <name>pOrTerm</name>-&gt;<name>pExpr</name>-&gt;<name>pLeft</name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLeft</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDup</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pNew</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>transferJoinMarkings</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>pList</name> = <name>pList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>idxNew</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name>.<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name>-&gt;<name>nChild</name> = 1</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>eOperator</name> = 0</expr>;</expr_stmt>  <comment type="block">/* case 1 trumps case 2 */</comment>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OMIT_OR_OPTIMIZATION &amp;&amp; !SQLITE_OMIT_SUBQUERY */</comment>


<comment type="block">/*
** The input to this routine is an WhereTerm structure with only the
** "pExpr" field filled in.  The job of this routine is to analyze the
** subexpression and populate all the other fields of the WhereTerm
** structure.
**
** If the expression is of the form "&lt;expr&gt; &lt;op&gt; X" it gets commuted
** to the standard form of "X &lt;op&gt; &lt;expr&gt;".
**
** If the expression is of the form "X &lt;op&gt; Y" where both X and Y are
** columns, then the original expression is unchanged and a new virtual
** term of the form "Y &lt;op&gt; X" is added to the WHERE clause and
** analyzed separately.  The original term is marked with TERM_COPIED
** and the new term is marked with TERM_DYNAMIC (because it's pExpr
** needs to be freed with the WhereClause) and TERM_VIRTUAL (because it
** is a commuted copy of a prior term.)  The original term has nChild=1
** and the copy has idxParent set to the index of the original term.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>exprAnalyze</name><parameter_list>(
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,            <comment type="block">/* the FROM clause */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,         <comment type="block">/* the WHERE clause */</comment>
  <param><decl><type><name>int</name></type> <name>idxTerm</name></decl></param>               <comment type="block">/* Index of the term to be analyzed */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>                <comment type="block">/* The term to be analyzed */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl>;</decl_stmt>          <comment type="block">/* Set of table index masks */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>                     <comment type="block">/* The expression to be analyzed */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqLeft</name></decl>;</decl_stmt>              <comment type="block">/* Prerequesites of the pExpr-&gt;pLeft */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqAll</name></decl>;</decl_stmt>               <comment type="block">/* Prerequesites of pExpr */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>extraRight</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isComplete</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>noCase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>                          <comment type="block">/* Top-level operator.  pExpr-&gt;op */</comment>
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWC</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Database connection */</comment>

  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMaskSet</name> = <name>pWC</name>-&gt;<name>pMaskSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pExpr</name> = <name>pTerm</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prereqLeft</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> = <name>pExpr</name>-&gt;<name>op</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>TK_IN</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pExpr</name>-&gt;<name>pRight</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>prereqRight</name> = <call><name>exprListTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call>
                          | <call><name>exprSelectTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>op</name>==<name>TK_ISNULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>prereqRight</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>prereqRight</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><name>prereqAll</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>x</name> =<init> <expr><call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>iRightJoinTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>prereqAll</name> |= <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extraRight</name> = <name>x</name>-1</expr>;</expr_stmt>  <comment type="block">/* ON clause terms may not be used with an index
                       ** on left table of a LEFT JOIN.  Ticket #3015 */</comment>
  }</block></then></if>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>prereqAll</name> = <name>prereqAll</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>leftCursor</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>iParent</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>eOperator</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>allowedOp</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>pTerm</name>-&gt;<name>prereqRight</name> &amp; <name>prereqLeft</name>)==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name> =<init> <expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pRight</name> =<init> <expr><name>pExpr</name>-&gt;<name>pRight</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pLeft</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>leftCursor</name> = <name>pLeft</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>u</name>.<name>leftColumn</name> = <name>pLeft</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>eOperator</name> = <call><name>operatorMask</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pRight</name> &amp;&amp; <name>pRight</name>-&gt;<name>op</name>==<name>TK_COLUMN</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pDup</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>leftCursor</name>&gt;=0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pDup</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>idxNew</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>idxNew</name>==0</expr> )</condition><then> <return>return;</return></then></if>
        <expr_stmt><expr><name>pNew</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name>-&gt;<name>nChild</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_COPIED</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDup</name> = <name>pExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name> = <name>pTerm</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>exprCommute</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> = <name>pDup</name>-&gt;<name>pLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>leftCursor</name> = <name>pLeft</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>u</name>.<name>leftColumn</name> = <name>pLeft</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>prereqRight</name> = <name>prereqLeft</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>prereqAll</name> = <name>prereqAll</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>eOperator</name> = <call><name>operatorMask</name><argument_list>(<argument><expr><name>pDup</name>-&gt;<name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_BETWEEN_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* If a term is the BETWEEN operator, create two new virtual terms
  ** that define the range that the BETWEEN implements.  For example:
  **
  **      a BETWEEN b AND c
  **
  ** is converted into:
  **
  **      (a BETWEEN b AND c) AND (a&gt;=b) AND (a&lt;=c)
  **
  ** The two new terms are added onto the end of the WhereClause object.
  ** The new terms are "dynamic" and are children of the original BETWEEN
  ** term.  That means that if the BETWEEN term is coded, the children are
  ** skipped.  Or, if the children are satisfied by an index, the original
  ** BETWEEN term is skipped.
  */</comment>
  <else>else <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_BETWEEN</name> &amp;&amp; <name>pWC</name>-&gt;<name>op</name>==<name>TK_AND</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>ExprList</name> *</type><name>pList</name> =<init> <expr><name>pExpr</name>-&gt;<name>pList</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>u8</name></type> <name><name>ops</name><index>[]</index></name> =<init> <expr><block>{<expr><name>TK_GE</name></expr>, <expr><name>TK_LE</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pList</name>-&gt;<name>nExpr</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pNewExpr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNewExpr</name> = <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>ops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNew</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name>.<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>nChild</name> = 2</expr>;</expr_stmt>
  }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_BETWEEN_OPTIMIZATION */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_OR_OPTIMIZATION</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Analyze a term that is composed of two or more subterms connected by
  ** an OR operator.
  */</comment>
  <else>else <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>==<name>TK_OR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pWC</name>-&gt;<name>op</name>==<name>TK_AND</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyzeOrTerm</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LIKE_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* Add constraints to reduce the search space on a LIKE or GLOB
  ** operator.
  **
  ** A like pattern of the form "x LIKE 'abc%'" is changed into constraints
  **
  **          x&gt;='abc' AND x&lt;'abd' AND x LIKE 'abc%'
  **
  ** The last character of the prefix "abc" is incremented to form the
  ** termination condition "abd".
  */</comment>
  <if>if<condition>( <expr><call><name>isLikeOrGlob</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>, <argument><expr>&amp;<name>nPattern</name></expr></argument>, <argument><expr>&amp;<name>isComplete</name></expr></argument>, <argument><expr>&amp;<name>noCase</name></expr></argument>)</argument_list></call>
         &amp;&amp; <name>pWC</name>-&gt;<name>op</name>==<name>TK_AND</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pLeft</name>, *<name>pRight</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pStr1</name>, *<name>pStr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pNewExpr1</name>, *<name>pNewExpr2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idxNew1</name>, <name>idxNew2</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pLeft</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStr1</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_STRING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pStr1</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pStr1</name>-&gt;<name>token</name></expr></argument>, <argument><expr>&amp;<name>pRight</name>-&gt;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStr1</name>-&gt;<name>token</name>.<name>n</name> = <name>nPattern</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStr1</name>-&gt;<name>flags</name> = <name>EP_Dequoted</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pStr2</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pStr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u8</name></type> <name>c</name>, *<name>pC</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStr2</name>-&gt;<name>token</name>.<name>dyn</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pC</name> = (<name>u8</name>*)&amp;<name>pStr2</name>-&gt;<name>token</name>.<name><name>z</name><index>[<expr><name>nPattern</name>-1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> = *<name>pC</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>noCase</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>c</name>=='@'</expr> )</condition><then> <expr_stmt><expr><name>isComplete</name> = 0</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>c</name> = <name><name>sqlite3UpperToLower</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr>*<name>pC</name> = <name>c</name> + 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pNewExpr1</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_GE</name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pStr1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxNew1</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr1</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew1</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNewExpr2</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_LT</name></expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pStr2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>idxNew2</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr2</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew2</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exprAnalyze</name><argument_list>(<argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>idxNew2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>isComplete</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew1</name></expr>]</index></name>.<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew2</name></expr>]</index></name>.<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>nChild</name> = 2</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_LIKE_OPTIMIZATION */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <comment type="block">/* Add a WO_MATCH auxiliary term to the constraint set if the
  ** current expression is of the form:  column MATCH expr.
  ** This information is used by the xBestIndex methods of
  ** virtual tables.  The native query optimizer does not attempt
  ** to do anything with MATCH functions.
  */</comment>
  <if>if<condition>( <expr><call><name>isMatchOfColumn</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>idxNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pRight</name>, *<name>pLeft</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pNewTerm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>prereqColumn</name>, <name>prereqExpr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pRight</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name><name>a</name><index>[<expr>1</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prereqExpr</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>prereqColumn</name> = <call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>prereqExpr</name> &amp; <name>prereqColumn</name>)==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pNewExpr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pNewExpr</name> = <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>TK_MATCH</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>idxNew</name> = <call><name>whereClauseInsert</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pNewExpr</name></expr></argument>, <argument><expr><name>TERM_VIRTUAL</name>|<name>TERM_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>idxNew</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxNew</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>prereqRight</name> = <name>prereqExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>leftCursor</name> = <name>pLeft</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>u</name>.<name>leftColumn</name> = <name>pLeft</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>eOperator</name> = <name>WO_MATCH</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>iParent</name> = <name>idxTerm</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>idxTerm</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>nChild</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_COPIED</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNewTerm</name>-&gt;<name>prereqAll</name> = <name>pTerm</name>-&gt;<name>prereqAll</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

  <comment type="block">/* Prevent ON clause terms of a LEFT JOIN from being used to drive
  ** an index for tables to the left of the join.
  */</comment>
  <expr_stmt><expr><name>pTerm</name>-&gt;<name>prereqRight</name> |= <name>extraRight</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return TRUE if any of the expressions in pList-&gt;a[iFirst...] contain
** a reference to any table other than the iBase table.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>referencesOtherTables</name><parameter_list>(
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,          <comment type="block">/* Search expressions in ths list */</comment>
  <param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>,   <comment type="block">/* Mapping from tables to bitmaps */</comment>
  <param><decl><type><name>int</name></type> <name>iFirst</name></decl></param>,               <comment type="block">/* Be searching with the iFirst-th expression */</comment>
  <param><decl><type><name>int</name></type> <name>iBase</name></decl></param>                 <comment type="block">/* Ignore references to this table */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>allowed</name> =<init> <expr>~<call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>iBase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>iFirst</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr> )</condition><block>{
    <if>if<condition>( <expr>(<call><name>exprTableUsage</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>iFirst</name>++</expr>]</index></name>.<name>pExpr</name></expr></argument>)</argument_list></call>&amp;<name>allowed</name>)!=0</expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
  }</block></while>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** This routine decides if pIdx can be used to satisfy the ORDER BY
** clause.  If it can, it returns 1.  If pIdx cannot satisfy the
** ORDER BY clause, this routine returns 0.
**
** pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the
** left-most table in the FROM clause of that same SELECT statement and
** the table has a cursor number of "base".  pIdx is an index on pTab.
**
** nEqCol is the number of columns of pIdx that are used as equality
** constraints.  Any of these columns may be missing from the ORDER BY
** clause and the match can still be a success.
**
** All terms of the ORDER BY that match against the index must be either
** ASC or DESC.  (Terms of the ORDER BY clause past the end of a UNIQUE
** index do not need to satisfy this constraint.)  The *pbRev value is
** set to 1 if the ORDER BY clause is all DESC and it is set to 0 if
** the ORDER BY clause is all ASC.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>isSortingIndex</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <comment type="block">/* Mapping from table cursor numbers to bitmaps */</comment>
  <param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>,            <comment type="block">/* The index we are testing */</comment>
  <param><decl><type><name>int</name></type> <name>base</name></decl></param>,               <comment type="block">/* Cursor number for the table to be sorted */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,     <comment type="block">/* The ORDER BY clause */</comment>
  <param><decl><type><name>int</name></type> <name>nEqCol</name></decl></param>,             <comment type="block">/* Number of index columns with == constraints */</comment>
  <param><decl><type><name>int</name> *</type><name>pbRev</name></decl></param>              <comment type="block">/* Set to 1 if ORDER BY is DESC */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                       <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sortOrder</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>              <comment type="block">/* XOR of index and ORDER BY sort direction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                      <comment type="block">/* Number of ORDER BY terms */</comment>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pTerm</name></decl>;</decl_stmt>    <comment type="block">/* A term of the ORDER BY clause */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTerm</name> = <name>pOrderBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Match terms of the ORDER BY clause against columns of
  ** the index.
  **
  ** Note that indices have pIdx-&gt;nColumn regular columns plus
  ** one additional column containing the rowid.  The rowid column
  ** of the index is also allowed to match against the ORDER BY
  ** clause.
  */</comment>
  <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>, <expr><name>pTerm</name>=<name>pOrderBy</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>nTerm</name> &amp;&amp; <name>i</name>&lt;=<name>pIdx</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>       <comment type="block">/* The expression of the ORDER BY pTerm */</comment>
    <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>    <comment type="block">/* The collating sequence of pExpr */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>termSortOrder</name></decl>;</decl_stmt> <comment type="block">/* Sort order for this term */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>       <comment type="block">/* The i-th column of the index.  -1 for rowid */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iSortOrder</name></decl>;</decl_stmt>    <comment type="block">/* 1 for DESC, 0 for ASC on the i-th index term */</comment>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zColl</name></decl>;</decl_stmt> <comment type="block">/* Name of the collating sequence for i-th index term */</comment>

    <expr_stmt><expr><name>pExpr</name> = <name>pTerm</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name> || <name>pExpr</name>-&gt;<name>iTable</name>!=<name>base</name></expr> )</condition><then><block>{
      <comment type="block">/* Can not use an index sort on anything that is not a column in the
      ** left-most table of the FROM clause */</comment>
      <break>break;</break>
    }</block></then></if>
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3ExprCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pColl</name> = <name>db</name>-&gt;<name>pDfltColl</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>i</name>&lt;<name>pIdx</name>-&gt;<name>nColumn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>iColumn</name> = <name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>iColumn</name>==<name>pIdx</name>-&gt;<name>pTable</name>-&gt;<name>iPKey</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>iColumn</name> = -1</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>iSortOrder</name> = <name>pIdx</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> = <name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>iColumn</name> = -1</expr>;</expr_stmt>
      <expr_stmt><expr><name>iSortOrder</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> = <name>pColl</name>-&gt;<name>zName</name></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>iColumn</name>!=<name>iColumn</name> || <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* Term j of the ORDER BY clause does not match column i of the index */</comment>
      <if>if<condition>( <expr><name>i</name>&lt;<name>nEqCol</name></expr> )</condition><then><block>{
        <comment type="block">/* If an index column that is constrained by == fails to match an
        ** ORDER BY term, that is OK.  Just ignore that column of the index
        */</comment>
        <continue>continue;</continue>
      }</block></then><else>else <if>if<condition>( <expr><name>i</name>==<name>pIdx</name>-&gt;<name>nColumn</name></expr> )</condition><then><block>{
        <comment type="block">/* Index column i is the rowid.  All other terms match. */</comment>
        <break>break;</break>
      }</block></then><else>else<block>{
        <comment type="block">/* If an index column fails to match and is not constrained by ==
        ** then the index cannot satisfy the ORDER BY constraint.
        */</comment>
        <return>return <expr>0</expr>;</return>
      }</block></else></if></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>aSortOrder</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>sortOrder</name>==0 || <name>pTerm</name>-&gt;<name>sortOrder</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSortOrder</name>==0 || <name>iSortOrder</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>termSortOrder</name> = <name>iSortOrder</name> ^ <name>pTerm</name>-&gt;<name>sortOrder</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>i</name>&gt;<name>nEqCol</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>termSortOrder</name>!=<name>sortOrder</name></expr> )</condition><then><block>{
        <comment type="block">/* Indices can only be used if all ORDER BY terms past the
        ** equality constraints are all either DESC or ASC. */</comment>
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>sortOrder</name> = <name>termSortOrder</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iColumn</name>&lt;0 &amp;&amp; !<call><name>referencesOtherTables</name><argument_list>(<argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* If the indexed column is the primary key and everything matches
      ** so far and none of the ORDER BY terms to the right reference other
      ** tables in the join, then we are assured that the index can be used 
      ** to sort because the primary key is unique and so none of the other
      ** columns will make any difference
      */</comment>
      <expr_stmt><expr><name>j</name> = <name>nTerm</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr>*<name>pbRev</name> = <name>sortOrder</name>!=0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>j</name>&gt;=<name>nTerm</name></expr> )</condition><then><block>{
    <comment type="block">/* All terms of the ORDER BY clause are covered by this index so
    ** this index can be used for sorting. */</comment>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>onError</name>!=<name>OE_None</name> &amp;&amp; <name>i</name>==<name>pIdx</name>-&gt;<name>nColumn</name>
      &amp;&amp; !<call><name>referencesOtherTables</name><argument_list>(<argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* All terms of this index match some prefix of the ORDER BY clause
    ** and the index is UNIQUE and no terms on the tail of the ORDER BY
    ** clause reference other tables in a join.  If this is all true then
    ** the order by clause is superfluous. */</comment>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Check table to see if the ORDER BY clause in pOrderBy can be satisfied
** by sorting in order of ROWID.  Return true if so and set *pbRev to be
** true for reverse ROWID and false for forward ROWID order.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sortableByRowid</name><parameter_list>(
  <param><decl><type><name>int</name></type> <name>base</name></decl></param>,               <comment type="block">/* Cursor number for table to be sorted */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,     <comment type="block">/* The ORDER BY clause */</comment>
  <param><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl></param>, <comment type="block">/* Mapping from table cursors to bitmaps */</comment>
  <param><decl><type><name>int</name> *</type><name>pbRev</name></decl></param>              <comment type="block">/* Set to 1 if ORDER BY is DESC */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOrderBy</name>-&gt;<name>nExpr</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pExpr</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>op</name>==<name>TK_COLUMN</name> &amp;&amp; <name>p</name>-&gt;<name>iTable</name>==<name>base</name> &amp;&amp; <name>p</name>-&gt;<name>iColumn</name>==-1
    &amp;&amp; !<call><name>referencesOtherTables</name><argument_list>(<argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pbRev</name> = <name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>sortOrder</name></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Prepare a crude estimate of the logarithm of the input value.
** The results need not be exact.  This is only used for estimating
** the total cost of performing operations with O(logN) or O(NlogN)
** complexity.  Because N is just a guess, it is no great tragedy if
** logN is a little off.
*/</comment>
<function><type><name>static</name> <name>double</name></type> <name>estLog</name><parameter_list>(<param><decl><type><name>double</name></type> <name>N</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>double</name></type> <name>logN</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>x</name> =<init> <expr>10</expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>N</name>&gt;<name>x</name></expr> )</condition><block>{
    <expr_stmt><expr><name>logN</name> += 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name> *= 10</expr>;</expr_stmt>
  }</block></while>
  <return>return <expr><name>logN</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Two routines for printing the content of an sqlite3_index_info
** structure.  Used for testing and debugging only.  If neither
** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines
** are no-ops.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>static</name> <name>void</name></type> <name>TRACE_IDX_INPUTS</name><parameter_list>(<param><decl><type><name>sqlite3_index_info</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>sqlite3WhereTrace</name></expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n"</expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iColumn</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iTermOffset</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name>.<name>op</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name>.<name>usable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  orderby[%d]: col=%d desc=%d\n"</expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iColumn</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aOrderBy</name><index>[<expr><name>i</name></expr>]</index></name>.<name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>TRACE_IDX_OUTPUTS</name><parameter_list>(<param><decl><type><name>sqlite3_index_info</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<name>sqlite3WhereTrace</name></expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  usage[%d]: argvIdx=%d omit=%d\n"</expr></argument>,
       <argument><expr><name>i</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name>.<name>argvIndex</name></expr></argument>,
       <argument><expr><name>p</name>-&gt;<name><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name>.<name>omit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  idxNum=%d\n"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>idxNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  idxStr=%s\n"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  orderByConsumed=%d\n"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>orderByConsumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"  estimatedCost=%g\n"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>estimatedCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRACE_IDX_INPUTS</name>(A)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRACE_IDX_OUTPUTS</name>(A)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block">/*
** Compute the best index for a virtual table.
**
** The best index is computed by the xBestIndex method of the virtual
** table module.  This routine is really just a wrapper that sets up
** the sqlite3_index_info structure that is used to communicate with
** xBestIndex.
**
** In a join, this routine might be called multiple times for the
** same virtual table.  The sqlite3_index_info structure is created
** and initialized on the first invocation and reused on all subsequent
** invocations.  The sqlite3_index_info structure is also used when
** code is generated to access the virtual table.  The whereInfoDelete() 
** routine takes care of freeing the sqlite3_index_info structure after
** everybody has finished with it.
*/</comment>
<function><type><name>static</name> <name>double</name></type> <name>bestVirtualIndex</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,                 <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,              <comment type="block">/* The WHERE clause */</comment>
  <param><decl><type>struct <name>SrcList_item</name> *</type><name>pSrc</name></decl></param>,     <comment type="block">/* The FROM clause term to search */</comment>
  <param><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></param>,              <comment type="block">/* Mask of cursors that are not available */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,            <comment type="block">/* The order by clause */</comment>
  <param><decl><type><name>int</name></type> <name>orderByUsable</name></decl></param>,             <comment type="block">/* True if we can potential sort */</comment>
  <param><decl><type><name>sqlite3_index_info</name> **</type><name>ppIdxInfo</name></decl></param> <comment type="block">/* Index information passed to xBestIndex */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pSrc</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>pTab</name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_index_info</name> *</type><name>pIdxInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>sqlite3_index_constraint</name> *</type><name>pIdxCons</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>sqlite3_index_orderby</name> *</type><name>pIdxOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>sqlite3_index_constraint_usage</name> *</type><name>pUsage</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nOrderBy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* If the sqlite3_index_info structure has not been previously
  ** allocated and initialized for this virtual table, then allocate
  ** and initialize it now
  */</comment>
  <expr_stmt><expr><name>pIdxInfo</name> = *<name>ppIdxInfo</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIdxInfo</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("Recomputing index info for %s...\n", <name>pTab</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Count the number of possible WHERE clause constraints referring
    ** to this virtual table */</comment>
    <for>for(<init><expr><name>i</name>=<name>nTerm</name>=0</expr>, <expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>leftCursor</name> != <name>pSrc</name>-&gt;<name>iCursor</name></expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pTerm</name>-&gt;<name>eOperator</name>&amp;(<name>pTerm</name>-&gt;<name>eOperator</name>-1))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; (<name>WO_IN</name>|<name>WO_ISNULL</name>)</expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><name>nTerm</name>++</expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* If the ORDER BY clause contains only columns in the current 
    ** virtual table then allocate space for the aOrderBy part of
    ** the sqlite3_index_info structure.
    */</comment>
    <expr_stmt><expr><name>nOrderBy</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pOrderBy</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name> =<init> <expr><name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name> || <name>pExpr</name>-&gt;<name>iTable</name>!=<name>pSrc</name>-&gt;<name>iCursor</name></expr> )</condition><then> <break>break;</break></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>i</name>==<name>pOrderBy</name>-&gt;<name>nExpr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>nOrderBy</name> = <name>pOrderBy</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Allocate the sqlite3_index_info structure
    */</comment>
    <expr_stmt><expr><name>pIdxInfo</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pIdxInfo</name></expr></argument>)</argument_list></call>
                             + (<call><name>sizeof</name><argument_list>(<argument><expr>*<name>pIdxCons</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pUsage</name></expr></argument>)</argument_list></call>)*<name>nTerm</name>
                             + <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pIdxOrderBy</name></expr></argument>)</argument_list></call>*<name>nOrderBy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIdxInfo</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0.0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>ppIdxInfo</name> = <name>pIdxInfo</name></expr>;</expr_stmt>

    <comment type="block">/* Initialize the structure.  The sqlite3_index_info structure contains
    ** many fields that are declared "const" to prevent xBestIndex from
    ** changing them.  We have to do some funky casting in order to
    ** initialize those fields.
    */</comment>
    <expr_stmt><expr><name>pIdxCons</name> = (struct <name>sqlite3_index_constraint</name>*)&amp;<name><name>pIdxInfo</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxOrderBy</name> = (struct <name>sqlite3_index_orderby</name>*)&amp;<name><name>pIdxCons</name><index>[<expr><name>nTerm</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pUsage</name> = (struct <name>sqlite3_index_constraint_usage</name>*)&amp;<name><name>pIdxOrderBy</name><index>[<expr><name>nOrderBy</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*(<name>int</name>*)&amp;<name>pIdxInfo</name>-&gt;<name>nConstraint</name> = <name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr>*(<name>int</name>*)&amp;<name>pIdxInfo</name>-&gt;<name>nOrderBy</name> = <name>nOrderBy</name></expr>;</expr_stmt>
    <expr_stmt><expr>*(struct <name>sqlite3_index_constraint</name>**)&amp;<name>pIdxInfo</name>-&gt;<name>aConstraint</name> = <name>pIdxCons</name></expr>;</expr_stmt>
    <expr_stmt><expr>*(struct <name>sqlite3_index_orderby</name>**)&amp;<name>pIdxInfo</name>-&gt;<name>aOrderBy</name> = <name>pIdxOrderBy</name></expr>;</expr_stmt>
    <expr_stmt><expr>*(struct <name>sqlite3_index_constraint_usage</name>**)&amp;<name>pIdxInfo</name>-&gt;<name>aConstraintUsage</name> =
                                                                     <name>pUsage</name></expr>;</expr_stmt>

    <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>, <expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>leftCursor</name> != <name>pSrc</name>-&gt;<name>iCursor</name></expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pTerm</name>-&gt;<name>eOperator</name>&amp;(<name>pTerm</name>-&gt;<name>eOperator</name>-1))==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; (<name>WO_IN</name>|<name>WO_ISNULL</name>)</expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name>.<name>iColumn</name> = <name>pTerm</name>-&gt;<name>u</name>.<name>leftColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name>.<name>iTermOffset</name> = <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxCons</name><index>[<expr><name>j</name></expr>]</index></name>.<name>op</name> = (<name>u8</name>)<name>pTerm</name>-&gt;<name>eOperator</name></expr>;</expr_stmt>
      <comment type="block">/* The direct assignment in the previous line is possible only because
      ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The
      ** following asserts verify this fact. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_EQ</name>==<name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LT</name>==<name>SQLITE_INDEX_CONSTRAINT_LT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_LE</name>==<name>SQLITE_INDEX_CONSTRAINT_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GT</name>==<name>SQLITE_INDEX_CONSTRAINT_GT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_GE</name>==<name>SQLITE_INDEX_CONSTRAINT_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>WO_MATCH</name>==<name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; (<name>WO_EQ</name>|<name>WO_LT</name>|<name>WO_LE</name>|<name>WO_GT</name>|<name>WO_GE</name>|<name>WO_MATCH</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
    }</block></for>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nOrderBy</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name> =<init> <expr><name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iColumn</name> = <name>pExpr</name>-&gt;<name>iColumn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxOrderBy</name><index>[<expr><name>i</name></expr>]</index></name>.<name>desc</name> = <name>pOrderBy</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sortOrder</name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <comment type="block">/* At this point, the sqlite3_index_info structure that pIdxInfo points
  ** to will have been initialized, either during the current invocation or
  ** during some prior invocation.  Now we just have to customize the
  ** details of pIdxInfo for the current invocation and pass it to
  ** xBestIndex.
  */</comment>

  <comment type="block">/* The module name must be defined. Also, by this point there must
  ** be a pointer to an sqlite3_vtab structure. Otherwise
  ** sqlite3ViewGetColumnNames() would have picked up the error. 
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>-&gt;<name>azModuleArg</name> &amp;&amp; <name>pTab</name>-&gt;<name><name>azModuleArg</name><index>[<expr>0</expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  if( pTab-&gt;pVtab==0 ){
    sqlite3ErrorMsg(pParse, "undefined module %s for table %s",
        pTab-&gt;azModuleArg[0], pTab-&gt;zName);
    return 0.0;
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Set the aConstraint[].usable fields and initialize all 
  ** output variables to zero.
  **
  ** aConstraint[].usable is true for constraints where the right-hand
  ** side contains only references to tables to the left of the current
  ** table.  In other words, if the constraint is of the form:
  **
  **           column = expr
  **
  ** and we are evaluating a join, then the constraint on column is 
  ** only valid if all tables referenced in expr occur to the left
  ** of the table containing column.
  **
  ** The aConstraints[] array contains entries for all constraints
  ** on the current table.  That way we only have to compute it once
  ** even though we might try to pick the best index multiple times.
  ** For each attempt at picking an index, the order of tables in the
  ** join might be different so we have to recompute the usable flag
  ** each time.
  */</comment>
  <expr_stmt><expr><name>pIdxCons</name> = *(struct <name>sqlite3_index_constraint</name>**)&amp;<name>pIdxInfo</name>-&gt;<name>aConstraint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUsage</name> = <name>pIdxInfo</name>-&gt;<name>aConstraintUsage</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pIdxInfo</name>-&gt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pIdxCons</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>j</name> = <name>pIdxCons</name>-&gt;<name>iTermOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name> = &amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIdxCons</name>-&gt;<name>usable</name> =  (<name>pTerm</name>-&gt;<name>prereqRight</name> &amp; <name>notReady</name>)==0 ?1:0</expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pUsage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>pUsage</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>pIdxInfo</name>-&gt;<name>nConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIdxInfo</name>-&gt;<name>needToFreeIdxStr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pIdxInfo</name>-&gt;<name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>idxStr</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>idxNum</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>needToFreeIdxStr</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>orderByConsumed</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdxInfo</name>-&gt;<name>estimatedCost</name> = <name>SQLITE_BIG_DBL</name> / 2.0</expr>;</expr_stmt>
  <expr_stmt><expr><name>nOrderBy</name> = <name>pIdxInfo</name>-&gt;<name>nOrderBy</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIdxInfo</name>-&gt;<name>nOrderBy</name> &amp;&amp; !<name>orderByUsable</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*(<name>int</name>*)&amp;<name>pIdxInfo</name>-&gt;<name>nOrderBy</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("xBestIndex for %s\n", <name>pTab</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE_IDX_INPUTS</name><argument_list>(<argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>pVtab</name>-&gt;<name>pModule</name>-&gt;<call><name>xBestIndex</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE_IDX_OUTPUTS</name><argument_list>(<argument><expr><name>pIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>!<name>pVtab</name>-&gt;<name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pIdxInfo</name>-&gt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>!<name>pIdxInfo</name>-&gt;<name><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name>.<name>usable</name> &amp;&amp; <name><name>pUsage</name><index>[<expr><name>i</name></expr>]</index></name>.<name>argvIndex</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr>"table %s: xBestIndex returned an invalid plan"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>0.0</expr>;</return>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr>*(<name>int</name>*)&amp;<name>pIdxInfo</name>-&gt;<name>nOrderBy</name> = <name>nOrderBy</name></expr>;</expr_stmt>
  <return>return <expr><name>pIdxInfo</name>-&gt;<name>estimatedCost</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block">/*
** Find the query plan for accessing a particular table.  Write the
** best query plan and its cost into the WhereCost object supplied as the
** last parameter.
**
** The lowest cost plan wins.  The cost is an estimate of the amount of
** CPU and disk I/O need to process the request using the selected plan.
** Factors that influence cost include:
**
**    *  The estimated number of rows that will be retrieved.  (The
**       fewer the better.)
**
**    *  Whether or not sorting must occur.
**
**    *  Whether or not there must be separate lookups in the
**       index and in the main table.
**
** If there was an INDEXED BY clause attached to the table in the SELECT
** statement, then this function only considers plans using the 
** named index. If one cannot be found, then the returned cost is
** SQLITE_BIG_DBL. If a plan can be found that uses the named index, 
** then the cost is calculated in the usual way.
**
** If a NOT INDEXED clause was attached to the table in the SELECT 
** statement, then no indexes are considered. However, the selected 
** plan may still take advantage of the tables built-in rowid
** index.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>bestIndex</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,              <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,           <comment type="block">/* The WHERE clause */</comment>
  <param><decl><type>struct <name>SrcList_item</name> *</type><name>pSrc</name></decl></param>,  <comment type="block">/* The FROM clause term to search */</comment>
  <param><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></param>,           <comment type="block">/* Mask of cursors that are not available */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,         <comment type="block">/* The ORDER BY clause */</comment>
  <param><decl><type><name>WhereCost</name> *</type><name>pCost</name></decl></param>            <comment type="block">/* Lowest cost query plan */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>           <comment type="block">/* A single term of the WHERE clause */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> =<init> <expr><name>pSrc</name>-&gt;<name>iCursor</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The cursor of the table to be accessed */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pProbe</name></decl>;</decl_stmt>              <comment type="block">/* An index we are evaluating */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rev</name></decl>;</decl_stmt>                    <comment type="block">/* True to scan in reverse order */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>wsFlags</name></decl>;</decl_stmt>                <comment type="block">/* Flags associated with pProbe */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name></decl>;</decl_stmt>                    <comment type="block">/* Number of == or IN constraints */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eqTermMask</name></decl>;</decl_stmt>             <comment type="block">/* Mask of valid equality operators */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>cost</name></decl>;</decl_stmt>                <comment type="block">/* Cost of using pProbe */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>nRow</name></decl>;</decl_stmt>                <comment type="block">/* Estimated number of rows in result set */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                      <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>maskSrc</name></decl>;</decl_stmt>            <comment type="block">/* Bitmask for the pSrc table */</comment>

  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("bestIndex: tbl=%s notReady=%llx\n", <name>pSrc</name>-&gt;<name>pTab</name>-&gt;<name>zName</name>,<name>notReady</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pProbe</name> = <name>pSrc</name>-&gt;<name>pTab</name>-&gt;<name>pIndex</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSrc</name>-&gt;<name>notIndexed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pProbe</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the table has no indices and there are no terms in the where
  ** clause that refer to the ROWID, then we will never be able to do
  ** anything other than a full table scan on this table.  We might as
  ** well put it first in the join order.  That way, perhaps it can be
  ** referenced by other tables in the join.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCost</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pProbe</name>==0 &amp;&amp;
     <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>WO_EQ</name>|<name>WO_IN</name>|<name>WO_LT</name>|<name>WO_LE</name>|<name>WO_GT</name>|<name>WO_GE</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>==0 &amp;&amp;
     (<name>pOrderBy</name>==0 || !<call><name>sortableByRowid</name><argument_list>(<argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = <name>SQLITE_BIG_DBL</name></expr>;</expr_stmt>

  <comment type="block">/* Check for a rowid=EXPR or rowid IN (...) constraints. If there was
  ** an INDEXED BY clause attached to this table, skip this step.
  */</comment>
  <if>if<condition>( <expr>!<name>pSrc</name>-&gt;<name>pIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_EQ</name>|<name>WO_IN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTerm</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>WHERE_ROWID_EQ</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; <name>WO_EQ</name></expr> )</condition><then><block>{
        <comment type="block">/* Rowid== is always the best pick.  Look no further.  Because only
        ** a single row is generated, output is always in sorted order */</comment>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>WHERE_ROWID_EQ</name> | <name>WHERE_UNIQUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>nEq</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... best is rowid\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>nRow</name> = 1</expr>;</expr_stmt>
        <return>return;</return>
      }</block></then><else>else <if>if<condition>( <expr>(<name>pExpr</name> = <name>pTerm</name>-&gt;<name>pExpr</name>)-&gt;<name>pList</name>!=0</expr> )</condition><then><block>{
        <comment type="block">/* Rowid IN (LIST): cost is NlogN where N is the number of list
        ** elements.  */</comment>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = <name>pCost</name>-&gt;<name>nRow</name> = <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> *= <call><name>estLog</name><argument_list>(<argument><expr><name>pCost</name>-&gt;<name>rCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* Rowid IN (SELECT): cost is NlogN where N is the number of rows
        ** in the result of the inner select.  We have no way to estimate
        ** that value so make a wild guess. */</comment>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>nRow</name> = 100</expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = 200</expr>;</expr_stmt>
      }</block></else></if></else></if>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... rowid IN cost: %.9g\n", <name>pCost</name>-&gt;<name>rCost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  
    <comment type="block">/* Estimate the cost of a table scan.  If we do not know how many
    ** entries are in the table, use 1 million as a guess.
    */</comment>
    <expr_stmt><expr><name>cost</name> = <name>pProbe</name> ? <name>pProbe</name>-&gt;<name><name>aiRowEst</name><index>[<expr>0</expr>]</index></name> : 1000000</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... table scan base cost: %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>wsFlags</name> = <name>WHERE_ROWID_RANGE</name></expr>;</expr_stmt>
  
    <comment type="block">/* Check for constraints on a range of rowids in a table scan.
    */</comment>
    <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_LT</name>|<name>WO_LE</name>|<name>WO_GT</name>|<name>WO_GE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTerm</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_LT</name>|<name>WO_LE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cost</name> /= 3</expr>;</expr_stmt>  <comment type="block">/* Guess that rowid&lt;EXPR eliminates two-thirds of rows */</comment>
      }</block></then></if>
      <if>if<condition>( <expr><call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_GT</name>|<name>WO_GE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_BTM_LIMIT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cost</name> /= 3</expr>;</expr_stmt>  <comment type="block">/* Guess that rowid&gt;EXPR eliminates two-thirds of rows */</comment>
      }</block></then></if>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... rowid range reduces cost to %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>wsFlags</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>nRow</name> = <name>cost</name></expr>;</expr_stmt>
  
    <comment type="block">/* If the table scan does not satisfy the ORDER BY clause, increase
    ** the cost by NlogN to cover the expense of sorting. */</comment>
    <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>sortableByRowid</name><argument_list>(<argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_ORDERBY</name>|<name>WHERE_ROWID_RANGE</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rev</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_REVERSE</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>cost</name> += <name>cost</name>*<call><name>estLog</name><argument_list>(<argument><expr><name>cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... sorting increases cost to %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>cost</name>&lt;<name>pCost</name>-&gt;<name>rCost</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = <name>cost</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>nRow</name> = <name>nRow</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>wsFlags</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_OR_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* Search for an OR-clause that can be used to look up the table.
  */</comment>
  <expr_stmt><expr><name>maskSrc</name> = <call><name>getMask</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>WhereClause</name></type> <name>tempWC</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>tempWC</name> = *<name>pWC</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_OR</name> 
        &amp;&amp; ((<name>pTerm</name>-&gt;<name>prereqAll</name> &amp; ~<name>maskSrc</name>) &amp; <name>notReady</name>)==0
        &amp;&amp; (<name>pTerm</name>-&gt;<name>u</name>.<name>pOrInfo</name>-&gt;<name>indexable</name> &amp; <name>maskSrc</name>)!=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pOrWC</name> =<init> <expr>&amp;<name>pTerm</name>-&gt;<name>u</name>.<name>pOrInfo</name>-&gt;<name>wc</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOrTerm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sortable</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>rTotal</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nRow</name> = 0</expr>;</expr_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pOrTerm</name>=<name>pOrWC</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>pOrWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>WhereCost</name></type> <name>sTermCost</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... Multi-index OR testing for term %d of %d....\n", <name>j</name>,<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>eOperator</name>==<name>WO_AND</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pAndWC</name> =<init> <expr>&amp;<name>pOrTerm</name>-&gt;<name>u</name>.<name>pAndInfo</name>-&gt;<name>wc</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>bestIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pAndWC</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>sTermCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>leftCursor</name>==<name>iCur</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>tempWC</name>.<name>a</name> = <name>pOrTerm</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>tempWC</name>.<name>nTerm</name> = 1</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>bestIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>tempWC</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>sTermCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <continue>continue;</continue>
        }</block></else></if></else></if>
        <expr_stmt><expr><name>rTotal</name> += <name>sTermCost</name>.<name>rCost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nRow</name> += <name>sTermCost</name>.<name>nRow</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rTotal</name>&gt;=<name>pCost</name>-&gt;<name>rCost</name></expr> )</condition><then> <break>break;</break></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>pOrderBy</name>!=0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><call><name>sortableByRowid</name><argument_list>(<argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>rev</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>sortable</name> = 1</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>rTotal</name> += <name>nRow</name>*<call><name>estLog</name><argument_list>(<argument><expr><name>nRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... sorting increases OR cost to %.9g\n", <name>rTotal</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then></if>
      <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... multi-index OR cost=%.9g nrow=%.9g\n",
                  <name>rTotal</name>, <name>nRow</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rTotal</name>&lt;<name>pCost</name>-&gt;<name>rCost</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = <name>rTotal</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>nRow</name> = <name>nRow</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>WHERE_MULTI_OR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>u</name>.<name>pTerm</name> = <name>pTerm</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>sortable</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>WHERE_ORDERBY</name>|<name>WHERE_MULTI_OR</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>

  <comment type="block">/* If the pSrc table is the right table of a LEFT JOIN then we may not
  ** use an index to satisfy IS NULL constraints on that table.  This is
  ** because columns might end up being NULL if the table does not match -
  ** a circumstance which the index cannot help us discover.  Ticket #2177.
  */</comment>
  <if>if<condition>( <expr>(<name>pSrc</name>-&gt;<name>jointype</name> &amp; <name>JT_LEFT</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>eqTermMask</name> = <name>WO_EQ</name>|<name>WO_IN</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>eqTermMask</name> = <name>WO_EQ</name>|<name>WO_IN</name>|<name>WO_ISNULL</name></expr>;</expr_stmt>
  }</block></else></if>

  <comment type="block">/* Look at each index.
  */</comment>
  <if>if<condition>( <expr><name>pSrc</name>-&gt;<name>pIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pProbe</name> = <name>pSrc</name>-&gt;<name>pIndex</name></expr>;</expr_stmt>
  }</block></then></if>
  <for>for(<init>;</init> <condition><expr><name>pProbe</name></expr>;</condition> <incr><expr><name>pProbe</name>=(<name>pSrc</name>-&gt;<name>pIndex</name> ? 0 : <name>pProbe</name>-&gt;<name>pNext</name>)</expr></incr>)<block>{
    <decl_stmt><decl><type><name>double</name></type> <name>inMultiplier</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("... index %s:\n", <name>pProbe</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Count the number of columns in the index that are satisfied
    ** by x=EXPR constraints or x IN (...) constraints.
    */</comment>
    <expr_stmt><expr><name>wsFlags</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pProbe</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>pProbe</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>eqTermMask</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>==0</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_COLUMN_EQ</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; <name>WO_IN</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name> =<init> <expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_COLUMN_IN</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pSelect</name>!=0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>inMultiplier</name> *= 25</expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pExpr</name>-&gt;<name>pList</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>inMultiplier</name> *= <name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name> + 1</expr>;</expr_stmt>
        }</block></then></if></else></if>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>nRow</name> = <name>pProbe</name>-&gt;<name><name>aiRowEst</name><index>[<expr><name>i</name></expr>]</index></name> * <name>inMultiplier</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cost</name> = <name>nRow</name> * <call><name>estLog</name><argument_list>(<argument><expr><name>inMultiplier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nEq</name> = <name>i</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pProbe</name>-&gt;<name>onError</name>!=<name>OE_None</name> &amp;&amp; (<name>wsFlags</name> &amp; <name>WHERE_COLUMN_IN</name>)==0
         &amp;&amp; <name>nEq</name>==<name>pProbe</name>-&gt;<name>nColumn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_UNIQUE</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("...... nEq=%d inMult=%.9g cost=%.9g\n",<name>nEq</name>,<name>inMultiplier</name>,<name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Look for range constraints
    */</comment>
    <if>if<condition>( <expr><name>nEq</name>&lt;<name>pProbe</name>-&gt;<name>nColumn</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>pProbe</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>nEq</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_LT</name>|<name>WO_LE</name>|<name>WO_GT</name>|<name>WO_GE</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_COLUMN_RANGE</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_LT</name>|<name>WO_LE</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_TOP_LIMIT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cost</name> /= 3</expr>;</expr_stmt>
          <expr_stmt><expr><name>nRow</name> /= 3</expr>;</expr_stmt>
        }</block></then></if>
        <if>if<condition>( <expr><call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_GT</name>|<name>WO_GE</name></expr></argument>, <argument><expr><name>pProbe</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_BTM_LIMIT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cost</name> /= 3</expr>;</expr_stmt>
          <expr_stmt><expr><name>nRow</name> /= 3</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("...... range reduces cost to %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Add the additional cost of sorting if that is a factor.
    */</comment>
    <if>if<condition>( <expr><name>pOrderBy</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>(<name>wsFlags</name> &amp; <name>WHERE_COLUMN_IN</name>)==0 &amp;&amp;
           <call><name>isSortingIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>,<argument><expr><name>pProbe</name></expr></argument>,<argument><expr><name>iCur</name></expr></argument>,<argument><expr><name>pOrderBy</name></expr></argument>,<argument><expr><name>nEq</name></expr></argument>,<argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>wsFlags</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>wsFlags</name> = <name>WHERE_COLUMN_RANGE</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_ORDERBY</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rev</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_REVERSE</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>cost</name> += <name>cost</name>*<call><name>estLog</name><argument_list>(<argument><expr><name>cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("...... orderby increases cost to %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>

    <comment type="block">/* Check to see if we can get away with using just the index without
    ** ever reading the table.  If that is the case, then halve the
    ** cost of this index.
    */</comment>
    <if>if<condition>( <expr><name>wsFlags</name> &amp;&amp; <name>pSrc</name>-&gt;<name>colUsed</name> &lt; (((<name>Bitmask</name>)1)&lt;&lt;(<name>BMS</name>-1))</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> =<init> <expr><name>pSrc</name>-&gt;<name>colUsed</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pProbe</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>x</name> =<init> <expr><name>pProbe</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>x</name>&lt;<name>BMS</name>-1</expr> )</condition><then><block>{
          <expr_stmt><expr><name>m</name> &amp;= ~(((<name>Bitmask</name>)1)&lt;&lt;<name>x</name>)</expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>m</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>wsFlags</name> |= <name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cost</name> /= 2</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("...... idx-only reduces cost to %.9g\n", <name>cost</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If this index has achieved the lowest cost so far, then use it.
    */</comment>
    <if>if<condition>( <expr><name>wsFlags</name>!=0 &amp;&amp; <name>cost</name> &lt; <name>pCost</name>-&gt;<name>rCost</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCost</name>-&gt;<name>rCost</name> = <name>cost</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>nRow</name> = <name>nRow</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> = <name>wsFlags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>nEq</name> = <name>nEq</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name> = <name>pProbe</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Report the best result
  */</comment>
  <expr_stmt><expr><name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> |= <name>eqTermMask</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("best index is %s, cost=%.9g, nrow=%.9g, wsFlags=%x, nEq=%d\n",
        (<name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0 ?
             <name>pCost</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name>-&gt;<name>zName</name> : "(none)", <name>pCost</name>-&gt;<name>nRow</name>,
        <name>pCost</name>-&gt;<name>rCost</name>, <name>pCost</name>-&gt;<name>plan</name>.<name>wsFlags</name>, <name>pCost</name>-&gt;<name>plan</name>.<name>nEq</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Disable a term in the WHERE clause.  Except, do not disable the term
** if it controls a LEFT OUTER JOIN and it did not originate in the ON
** or USING clause of that join.
**
** Consider the term t2.z='ok' in the following queries:
**
**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'
**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'
**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'
**
** The t2.z='ok' is disabled in the in (2) because it originates
** in the ON clause.  The term is disabled in (3) because it is not part
** of a LEFT OUTER JOIN.  In (1), the term is not disabled.
**
** Disabling a term causes that term to not be tested in the inner loop
** of the join.  Disabling is an optimization.  When terms are satisfied
** by indices, we disable them to prevent redundant tests in the inner
** loop.  We would get the correct results if nothing were ever disabled,
** but joins might run a little slower.  The trick is to disable as much
** as we can without disabling too much.  If we disabled in (1), we'd get
** the wrong answer.  See ticket #813.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>disableTerm</name><parameter_list>(<param><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl></param>, <param><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pTerm</name>
      &amp;&amp; <call><name>ALWAYS</name><argument_list>(<argument><expr>(<name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_CODED</name>)==0</expr></argument>)</argument_list></call>
      &amp;&amp; (<name>pLevel</name>-&gt;<name>iLeftJoin</name>==0 || <call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call>)</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_CODED</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>iParent</name>&gt;=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOther</name> =<init> <expr>&amp;<name>pTerm</name>-&gt;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>pTerm</name>-&gt;<name>iParent</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>(--<name>pOther</name>-&gt;<name>nChild</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pOther</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Apply the affinities associated with the first n columns of index
** pIdx to the values in the n registers starting at base.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeApplyAffinity</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>n</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>v</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Affinity</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<comment type="block">/*
** Generate code for a single equality term of the WHERE clause.  An equality
** term can be either X=expr or X IN (...).   pTerm is the term to be 
** coded.
**
** The current value for the constraint is left in register iReg.
**
** For a constraint of the form X=expr, the expression is evaluated and its
** result is left on the stack.  For constraints of the form X IN (...)
** this routine sets up a loop that will iterate over all values of X.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>codeEqualityTerm</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,      <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl></param>,   <comment type="block">/* The term of the WHERE clause to be coded */</comment>
  <param><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl></param>, <comment type="block">/* When level of the FROM clause we are working on */</comment>
  <param><decl><type><name>int</name></type> <name>iTarget</name></decl></param>         <comment type="block">/* Attempt to leave results in this register */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pX</name> =<init> <expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>                  <comment type="block">/* Register holding results */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTarget</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pX</name>-&gt;<name>op</name>==<name>TK_EQ</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iReg</name> = <call><name>sqlite3ExprCodeTarget</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>iTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pX</name>-&gt;<name>op</name>==<name>TK_ISNULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>iReg</name> = <name>iTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SUBQUERY</name></cpp:ifndef>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>eType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>InLoop</name> *</type><name>pIn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name>-&gt;<name>op</name>==<name>TK_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iReg</name> = <name>iTarget</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>eType</name> = <call><name>sqlite3FindInIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iTab</name> = <name>pX</name>-&gt;<name>iTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%.*s", <name>pX</name>-&gt;<name>span</name>.<name>n</name>, <name>pX</name>-&gt;<name>span</name>.<name>z</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IN_ABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>addrNxt</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>aInLoop</name> =
       <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>aInLoop</name></expr></argument>,
                              <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name><name>aInLoop</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> = <name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>aInLoop</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIn</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pIn</name> += <name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name> - 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pIn</name>-&gt;<name>iCur</name> = <name>iTab</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>eType</name>==<name>IN_INDEX_ROWID</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pIn</name>-&gt;<name>addrInTop</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pIn</name>-&gt;<name>addrInTop</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if></else></if>
  <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iReg</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code that will evaluate all == and IN constraints for an
** index.  The values for all constraints are left on the stack.
**
** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).
** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c&gt;5 AND c&lt;10
** The index has as many as three equality constraints, but in this
** example, the third "c" value is an inequality.  So only two 
** constraints are coded.  This routine will generate code to evaluate
** a==5 and b IN (1,2,3).  The current values for a and b will be stored
** in consecutive registers and the index of the first register is returned.
**
** In the example above nEq==2.  But this subroutine works for any value
** of nEq including 0.  If nEq==0, this routine is nearly a no-op.
** The only thing it does is allocate the pLevel-&gt;iMem memory cell.
**
** This routine always allocates at least one memory cell and returns
** the index of that memory cell. The code that
** calls this routine will use that memory cell to store the termination
** key value of the loop.  If one or more IN operators appear, then
** this routine allocates an additional nEq memory cells for internal
** use.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>codeAllEqualityTerms</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl></param>,   <comment type="block">/* Which nested loop of the FROM we are coding */</comment>
  <param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>,     <comment type="block">/* The WHERE clause */</comment>
  <param><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></param>,     <comment type="block">/* Which parts of FROM have not yet been coded */</comment>
  <param><decl><type><name>int</name></type> <name>nExtraReg</name></decl></param>         <comment type="block">/* Number of extra registers to allocate */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>nEq</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The number of == or IN constraints to code */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The vm under construction */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>                  <comment type="block">/* The index being used for this loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> =<init> <expr><name>pLevel</name>-&gt;<name>iTabCur</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The cursor of the table */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>             <comment type="block">/* A single constraint term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                  <comment type="block">/* Base register */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nReg</name></decl>;</decl_stmt>                     <comment type="block">/* Number of registers to allocate */</comment>

  <comment type="block">/* This module is only called on query plans that use an index. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIdx</name> = <name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name></expr>;</expr_stmt>

  <comment type="block">/* Figure out how many memory cells we will need then allocate them.
  */</comment>
  <expr_stmt><expr><name>regBase</name> = <name>pParse</name>-&gt;<name>nMem</name> + 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>nReg</name> = <name>pLevel</name>-&gt;<name>plan</name>.<name>nEq</name> + <name>nExtraReg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> += <name>nReg</name></expr>;</expr_stmt>

  <comment type="block">/* Evaluate the equality constraints
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>nColumn</name>&gt;=<name>nEq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>nEq</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name> =<init> <expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pTerm</name>==0</expr></argument>)</argument_list></call></expr> )</condition><then> <break>break;</break></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_CODED</name>)==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r1</name> = <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>regBase</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>r1</name>!=<name>regBase</name>+<name>j</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>nReg</name>==1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>regBase</name> = <name>r1</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>regBase</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; <name>WO_ISNULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name> &amp; <name>WO_IN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pTerm</name>-&gt;<name>eOperator</name> &amp; (<name>WO_ISNULL</name>|<name>WO_IN</name>))==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name>+<name>j</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <return>return <expr><name>regBase</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return TRUE if the WhereClause pWC contains no terms that
** are not virtual and which have not been coded.
**
** To put it another way, return TRUE if no additional WHERE clauses
** tests are required in order to establish that the current row
** should go to output and return FALSE if there are some terms of
** the WHERE clause that need to be validated before outputing the row.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>whereRowReadyForOutput</name><parameter_list>(<param><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
 
  <for>for(<init><expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>, <expr><name>j</name>=<name>pWC</name>-&gt;<name>nTerm</name></expr>;</init> <condition><expr><name>j</name>&gt;0</expr>;</condition> <incr><expr><name>j</name>--</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>(<name>pTerm</name>-&gt;<name>wtFlags</name> &amp; (<name>TERM_VIRTUAL</name>|<name>TERM_CODED</name>))==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  }</block></for>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code for the start of the iLevel-th loop in the WHERE clause
** implementation described by pWInfo.
*/</comment>
<function><type><name>static</name> <name>Bitmask</name></type> <name>codeOneLoopStart</name><parameter_list>(
  <param><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl></param>,   <comment type="block">/* Complete information about the WHERE clause */</comment>
  <param><decl><type><name>int</name></type> <name>iLevel</name></decl></param>,          <comment type="block">/* Which level of pWInfo-&gt;a[] should be coded */</comment>
  <param><decl><type><name>u8</name></type> <name>wctrlFlags</name></decl></param>,       <comment type="block">/* One of the WHERE_* flags defined in sqliteInt.h */</comment>
  <param><decl><type><name>Bitmask</name></type> <name>notReady</name></decl></param>     <comment type="block">/* Which tables are currently available */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>j</name>, <name>k</name></decl>;</decl_stmt>            <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>            <comment type="block">/* The VDBE cursor for the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrNxt</name></decl>;</decl_stmt>         <comment type="block">/* Where to jump to continue with the next IN case */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>omitTable</name></decl>;</decl_stmt>       <comment type="block">/* True if we use the index only */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bRev</name></decl>;</decl_stmt>            <comment type="block">/* True if we need to scan in reverse order */</comment>
  <decl_stmt><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl>;</decl_stmt>  <comment type="block">/* The where level to be coded */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl>;</decl_stmt>    <comment type="block">/* Decomposition of the entire WHERE clause */</comment>
  <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pTerm</name></decl>;</decl_stmt>               <comment type="block">/* A WHERE clause term */</comment>
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name></decl>;</decl_stmt>                  <comment type="block">/* Parsing context */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>                        <comment type="block">/* The prepared stmt under constructions */</comment>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pTabItem</name></decl>;</decl_stmt>  <comment type="block">/* FROM clause term being coded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrBrk</name></decl>;</decl_stmt>                    <comment type="block">/* Jump here to break out of the loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addrCont</name></decl>;</decl_stmt>                   <comment type="block">/* Jump here to continue with next cycle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRowSet</name></decl>;</decl_stmt>       <comment type="block">/* Write rowids to this RowSet if non-negative */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>codeRowSetEarly</name></decl>;</decl_stmt> <comment type="block">/* True if index fully constrains the search */</comment>
  

  <expr_stmt><expr><name>pParse</name> = <name>pWInfo</name>-&gt;<name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWC</name> = <name>pWInfo</name>-&gt;<name>pWC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLevel</name> = &amp;<name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>iLevel</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabItem</name> = &amp;<name>pWInfo</name>-&gt;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>pLevel</name>-&gt;<name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> = <name>pTabItem</name>-&gt;<name>iCursor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>bRev</name> = (<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_REVERSE</name>)!=0</expr>;</expr_stmt>
  <expr_stmt><expr><name>omitTable</name> = (<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IDX_ONLY</name>)!=0</expr>;</expr_stmt>
  <expr_stmt><expr><name>regRowSet</name> = <name>pWInfo</name>-&gt;<name>regRowSet</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>codeRowSetEarly</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Create labels for the "break" and "continue" instructions
  ** for the current loop.  Jump to addrBrk to break out of a loop.
  ** Jump to cont to go immediately to the next iteration of the
  ** loop.
  **
  ** When there is an IN operator, we also have a "addrNxt" label that
  ** means to continue with the next IN value combination.  When
  ** there are no IN operators in the constraints, the "addrNxt" label
  ** is the same as "addrBrk".
  */</comment>
  <expr_stmt><expr><name>addrBrk</name> = <name>pLevel</name>-&gt;<name>addrBrk</name> = <name>pLevel</name>-&gt;<name>addrNxt</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addrCont</name> = <name>pLevel</name>-&gt;<name>addrCont</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is the right table of a LEFT OUTER JOIN, allocate and
  ** initialize a memory cell that records if this table matches any
  ** row of the left table of the join.
  */</comment>
  <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>iFrom</name>&gt;0 &amp;&amp; (<name><name>pTabItem</name><index>[<expr>0</expr>]</index></name>.<name>jointype</name> &amp; <name>JT_LEFT</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>iLeftJoin</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iLeftJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "init LEFT JOIN no-match flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>(  <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_VIRTUALTABLE</name>)!=0</expr> )</condition><then><block>{
    <comment type="block">/* Case 0:  The table is a virtual-table.  Use the VFilter and VNext
    **          to access the data.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>   <comment type="block">/* P3 Value for OP_VFilter */</comment>
    <decl_stmt><decl><type><name>sqlite3_index_info</name> *</type><name>pVtabIdx</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pVtabIdx</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name> =<init> <expr><name>pVtabIdx</name>-&gt;<name>nConstraint</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>sqlite3_index_constraint_usage</name> *</type><name>aUsage</name> =<init>
                                                <expr><name>pVtabIdx</name>-&gt;<name>aConstraintUsage</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> struct <name>sqlite3_index_constraint</name> *</type><name>aConstraint</name> =<init>
                                                <expr><name>pVtabIdx</name>-&gt;<name>aConstraint</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>iReg</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nConstraint</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=1</expr>;</init> <condition><expr><name>j</name>&lt;=<name>nConstraint</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <for>for(<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name><name>aUsage</name><index>[<expr><name>k</name></expr>]</index></name>.<name>argvIndex</name>==<name>j</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name> =<init> <expr><name><name>aConstraint</name><index>[<expr><name>k</name></expr>]</index></name>.<name>iTermOffset</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name>.<name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>iReg</name>+<name>j</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>k</name>==<name>nConstraint</name></expr> )</condition><then> <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>--</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>pVtabIdx</name>-&gt;<name>idxNum</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>j</name>-1</expr></argument>, <argument><expr><name>iReg</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VFilter</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>pVtabIdx</name>-&gt;<name>idxStr</name></expr></argument>,
                      <argument><expr><name>pVtabIdx</name>-&gt;<name>needToFreeIdxStr</name> ? <name>P4_MPRINTF</name> : <name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtabIdx</name>-&gt;<name>needToFreeIdxStr</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>nConstraint</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>aUsage</name><index>[<expr><name>j</name></expr>]</index></name>.<name>omit</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name> =<init> <expr><name><name>aConstraint</name><index>[<expr><name>j</name></expr>]</index></name>.<name>iTermOffset</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr>&amp;<name>pWC</name>-&gt;<name><name>a</name><index>[<expr><name>iTerm</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>OP_VNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p1</name> = <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p2</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = <name>regRowSet</name>&gt;=0 ? <call><name>whereRowReadyForOutput</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>codeRowSetEarly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VRowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name>nConstraint</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

  <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ROWID_EQ</name></expr> )</condition><then><block>{
    <comment type="block">/* Case 1:  We can directly reference a single row using an
    **          equality comparison against the ROWID field.  Or
    **          we reference multiple rows using a "rowid IN (...)"
    **          construct.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtmp</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pTerm</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_EQ</name>|<name>WO_IN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>pExpr</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>leftCursor</name>==<name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>omitTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r1</name> = <call><name>codeEqualityTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>rtmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrNxt</name> = <name>pLevel</name>-&gt;<name>addrNxt</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MustBeInt</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = (<name>pWC</name>-&gt;<name>nTerm</name>==1 &amp;&amp; <name>regRowSet</name>&gt;=0) ?1:0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>codeRowSetEarly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rtmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "pk")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>OP_Noop</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ROWID_RANGE</name></expr> )</condition><then><block>{
    <comment type="block">/* Case 2:  We have an inequality comparison against the ROWID field.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>testOp</name> =<init> <expr><name>OP_Noop</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>memEndValue</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pStart</name>, *<name>pEnd</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>omitTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pStart</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_GT</name>|<name>WO_GE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pEnd</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>WO_LT</name>|<name>WO_LE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>bRev</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTerm</name> = <name>pStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pStart</name> = <name>pEnd</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pEnd</name> = <name>pTerm</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pStart</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pX</name></decl>;</decl_stmt>             <comment type="block">/* The expression that defines the start bound */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name>, <name>rTemp</name></decl>;</decl_stmt>        <comment type="block">/* Registers for holding the start boundary */</comment>

      <comment type="block">/* The following constant maps TK_xx codes into corresponding 
      ** seek opcodes.  It depends on a particular ordering of TK_xx
      */</comment>
      <decl_stmt><decl><type><name>const</name> <name>u8</name></type> <name><name>aMoveOp</name><index>[]</index></name> =<init> <expr><block>{
           <comment type="block">/* TK_GT */</comment>  <expr><name>OP_SeekGt</name></expr>,
           <comment type="block">/* TK_LE */</comment>  <expr><name>OP_SeekLe</name></expr>,
           <comment type="block">/* TK_LT */</comment>  <expr><name>OP_SeekLt</name></expr>,
           <comment type="block">/* TK_GE */</comment>  <expr><name>OP_SeekGe</name></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LE</name>==<name>TK_GT</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* Make sure the ordering.. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_LT</name>==<name>TK_GT</name>+2</expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... of the TK_xx values... */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>TK_GE</name>==<name>TK_GT</name>+3</expr></argument> )</argument_list></call></expr>;</expr_stmt>      <comment type="block">/*  ... is correcct. */</comment>

      <expr_stmt><expr><name>pX</name> = <name>pStart</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pStart</name>-&gt;<name>leftCursor</name>==<name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r1</name> = <call><name>sqlite3ExprCodeTemp</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr>&amp;<name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aMoveOp</name><index>[<expr><name>pX</name>-&gt;<name>op</name>-<name>TK_GT</name></expr>]</index></name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "pk")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>rTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>bRev</name> ? <name>OP_Last</name> : <name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>pEnd</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pX</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pX</name> = <name>pEnd</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pX</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pEnd</name>-&gt;<name>leftCursor</name>==<name>iCur</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>memEndValue</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pX</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pX</name>-&gt;<name>op</name>==<name>TK_LT</name> || <name>pX</name>-&gt;<name>op</name>==<name>TK_GT</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>testOp</name> = <name>bRev</name> ? <name>OP_Le</name> : <name>OP_Ge</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>testOp</name> = <name>bRev</name> ? <name>OP_Lt</name> : <name>OP_Gt</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>start</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>bRev</name> ? <name>OP_Prev</name> : <name>OP_Next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p1</name> = <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p2</name> = <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p5</name> = (<name>pStart</name>==0 &amp;&amp; <name>pEnd</name>==0) ?1:0</expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = <name>regRowSet</name>&gt;=0 ? <call><name>whereRowReadyForOutput</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>codeRowSetEarly</name> || <name>testOp</name>!=<name>OP_Noop</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>testOp</name>!=<name>OP_Noop</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>testOp</name></expr></argument>, <argument><expr><name>memEndValue</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NUMERIC</name> | <name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>codeRowSetEarly</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; (<name>WHERE_COLUMN_RANGE</name>|<name>WHERE_COLUMN_EQ</name>)</expr> )</condition><then><block>{
    <comment type="block">/* Case 3: A scan using an index.
    **
    **         The WHERE clause may contain zero or more equality 
    **         terms ("==" or "IN" operators) that refer to the N
    **         left-most columns of the index. It may also contain
    **         inequality constraints (&gt;, &lt;, &gt;= or &lt;=) on the indexed
    **         column that immediately follows the N equalities. Only 
    **         the right-most column can be an inequality - the rest must
    **         use the "==" and "IN" operators. For example, if the 
    **         index is on (x,y,z), then the following clauses are all 
    **         optimized:
    **
    **            x=5
    **            x=5 AND y=10
    **            x=5 AND y&lt;10
    **            x=5 AND y&gt;5 AND y&lt;10
    **            x=5 AND y=5 AND z&lt;=10
    **
    **         The z&lt;10 term of the following cannot be used, only
    **         the x=5 term:
    **
    **            x=5 AND z&lt;10
    **
    **         N may be zero if there are inequality constraints.
    **         If there are no inequality constraints, then N is at
    **         least one.
    **
    **         This case is also used when there are no WHERE clause
    **         constraints but an index is selected anyway, in order
    **         to force the output order to conform to an ORDER BY.
    */</comment>  
    <decl_stmt><decl><type><name>int</name></type> <name><name>aStartOp</name><index>[]</index></name> =<init> <expr><block>{
      <expr>0</expr>,
      <expr>0</expr>,
      <expr><name>OP_Rewind</name></expr>,           <comment type="block">/* 2: (!start_constraints &amp;&amp; startEq &amp;&amp;  !bRev) */</comment>
      <expr><name>OP_Last</name></expr>,             <comment type="block">/* 3: (!start_constraints &amp;&amp; startEq &amp;&amp;   bRev) */</comment>
      <expr><name>OP_SeekGt</name></expr>,           <comment type="block">/* 4: (start_constraints  &amp;&amp; !startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLt</name></expr>,           <comment type="block">/* 5: (start_constraints  &amp;&amp; !startEq &amp;&amp;  bRev) */</comment>
      <expr><name>OP_SeekGe</name></expr>,           <comment type="block">/* 6: (start_constraints  &amp;&amp;  startEq &amp;&amp; !bRev) */</comment>
      <expr><name>OP_SeekLe</name></expr>            <comment type="block">/* 7: (start_constraints  &amp;&amp;  startEq &amp;&amp;  bRev) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>aEndOp</name><index>[]</index></name> =<init> <expr><block>{
      <expr><name>OP_Noop</name></expr>,             <comment type="block">/* 0: (!end_constraints) */</comment>
      <expr><name>OP_IdxGE</name></expr>,            <comment type="block">/* 1: (end_constraints &amp;&amp; !bRev) */</comment>
      <expr><name>OP_IdxLT</name></expr>             <comment type="block">/* 2: (end_constraints &amp;&amp; bRev) */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nEq</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>nEq</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isMinQuery</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* If this is an optimized SELECT min(x).. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>                 <comment type="block">/* Base register holding constraint values */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>                      <comment type="block">/* Temp register */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pRangeStart</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Inequality constraint at range start */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pRangeEnd</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Inequality constraint at range end */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>startEq</name></decl>;</decl_stmt>                 <comment type="block">/* True if range start uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>endEq</name></decl>;</decl_stmt>                   <comment type="block">/* True if range end uses ==, &gt;= or &lt;= */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>start_constraints</name></decl>;</decl_stmt>       <comment type="block">/* Start of range is constrained */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nConstraint</name></decl>;</decl_stmt>             <comment type="block">/* Number of constraint terms */</comment>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>         <comment type="block">/* The index we will be using */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name></decl>;</decl_stmt>         <comment type="block">/* The VDBE cursor for the index */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nExtraReg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Number of extra registers needed */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>              <comment type="block">/* Instruction opcode */</comment>

    <expr_stmt><expr><name>pIdx</name> = <name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iIdxCur</name> = <name>pLevel</name>-&gt;<name>iIdxCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> = <name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>nEq</name></expr>]</index></name></expr>;</expr_stmt>     <comment type="block">/* Column for inequality constraints */</comment>

    <comment type="block">/* If this loop satisfies a sort order (pOrderBy) request that 
    ** was passed to this function to implement a "SELECT min(x) ..." 
    ** query, then the caller will only allow the loop to run for
    ** a single iteration. This means that the first row returned
    ** should not have a NULL value stored in 'x'. If column 'x' is
    ** the first one after the nEq equality constraints in the index,
    ** this requires some special handling.
    */</comment>
    <if>if<condition>( <expr>(<name>wctrlFlags</name>&amp;<name>WHERE_ORDERBY_MIN</name>)!=0
     &amp;&amp; (<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name>&amp;<name>WHERE_ORDERBY</name>)
     &amp;&amp; (<name>pIdx</name>-&gt;<name>nColumn</name>&gt;<name>nEq</name>)</expr>
    )</condition><then><block>{
      <comment type="block">/* assert( pOrderBy-&gt;nExpr==1 ); */</comment>
      <comment type="block">/* assert( pOrderBy-&gt;a[0].pExpr-&gt;iColumn==pIdx-&gt;aiColumn[nEq] ); */</comment>
      <expr_stmt><expr><name>isMinQuery</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Find any inequality constraint terms for the start and end 
    ** of the range. 
    */</comment>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_TOP_LIMIT</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pRangeEnd</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr>(<name>WO_LT</name>|<name>WO_LE</name>)</expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_BTM_LIMIT</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pRangeStart</name> = <call><name>findTerm</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr>(<name>WO_GT</name>|<name>WO_GE</name>)</expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nExtraReg</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Generate code to evaluate all constraint terms using == or IN
    ** and store the values of those terms in an array of registers
    ** starting at regBase.
    */</comment>
    <expr_stmt><expr><name>regBase</name> = <call><name>codeAllEqualityTerms</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>, <argument><expr><name>nExtraReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>addrNxt</name> = <name>pLevel</name>-&gt;<name>addrNxt</name></expr>;</expr_stmt>


    <comment type="block">/* If we are doing a reverse order scan on an ascending index, or
    ** a forward order scan on a descending index, interchange the 
    ** start and end terms (pRangeStart and pRangeEnd).
    */</comment>
    <if>if<condition>( <expr><name>bRev</name>==(<name>pIdx</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>nEq</name></expr>]</index></name>==<name>SQLITE_SO_ASC</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>SWAP</name><argument_list>(<argument><expr><name>WhereTerm</name> *</expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> &amp;&amp; <name>pRangeStart</name>-&gt;<name>eOperator</name> &amp; <name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeStart</name> &amp;&amp; <name>pRangeStart</name>-&gt;<name>eOperator</name> &amp; <name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> &amp;&amp; <name>pRangeEnd</name>-&gt;<name>eOperator</name> &amp; <name>WO_LE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pRangeEnd</name> &amp;&amp; <name>pRangeEnd</name>-&gt;<name>eOperator</name> &amp; <name>WO_GE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>startEq</name> = !<name>pRangeStart</name> || <name>pRangeStart</name>-&gt;<name>eOperator</name> &amp; (<name>WO_LE</name>|<name>WO_GE</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>endEq</name> =   !<name>pRangeEnd</name> || <name>pRangeEnd</name>-&gt;<name>eOperator</name> &amp; (<name>WO_LE</name>|<name>WO_GE</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>start_constraints</name> = <name>pRangeStart</name> || <name>nEq</name>&gt;0</expr>;</expr_stmt>

    <comment type="block">/* Seek the index cursor to the start of the range. */</comment>
    <expr_stmt><expr><name>nConstraint</name> = <name>nEq</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pRangeStart</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>dcc</name> =<init> <expr><name>pParse</name>-&gt;<name>disableColCache</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pRangeEnd</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name>++</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRangeStart</name>-&gt;<name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name> = <name>dcc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name>++</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>isMinQuery</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regBase</name>+<name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>startEq</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>start_constraints</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nConstraint</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> = <name><name>aStartOp</name><index>[<expr>(<name>start_constraints</name>&lt;&lt;2) + (<name>startEq</name>&lt;&lt;1) + <name>bRev</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_Rewind</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_Last</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_SeekGt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_SeekGe</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_SeekLe</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_SeekLt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, 
                      <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Load the value for the inequality constraint at the end of the
    ** range (if any).
    */</comment>
    <expr_stmt><expr><name>nConstraint</name> = <name>nEq</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pRangeEnd</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ExprCode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pRangeEnd</name>-&gt;<name>pExpr</name>-&gt;<name>pRight</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nEq</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeApplyAffinity</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nEq</name>+1</expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nConstraint</name>++</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Top of the loop body */</comment>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p2</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check if the index cursor is past the end of the range. */</comment>
    <expr_stmt><expr><name>op</name> = <name><name>aEndOp</name><index>[<expr>(<name>pRangeEnd</name> || <name>nEq</name>) * (1 + <name>bRev</name>)</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_Noop</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_IdxGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>op</name>==<name>OP_IdxLT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>op</name>!=<name>OP_Noop</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>addrNxt</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>,
                        <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>nConstraint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>endEq</name>!=<name>bRev</name> ?1:0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If there are inequality constraints, check that the value
    ** of the table column that the inequality contrains is not NULL.
    ** If it is, jump to the next iteration of the loop.
    */</comment>
    <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_BTM_LIMIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_TOP_LIMIT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; (<name>WHERE_BTM_LIMIT</name>|<name>WHERE_TOP_LIMIT</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>nEq</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Seek the table cursor, if required */</comment>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pRangeEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = <name>regRowSet</name>&gt;=0 ? <call><name>whereRowReadyForOutput</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>omitTable</name> || <name>codeRowSetEarly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxRowid</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>codeRowSetEarly</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Seek</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Deferred seek */</comment>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Record the instruction used to terminate the loop. Disable 
    ** WHERE clause terms made redundant by the index range scan.
    */</comment>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>bRev</name> ? <name>OP_Prev</name> : <name>OP_Next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p1</name> = <name>iIdxCur</name></expr>;</expr_stmt>
  }</block></then><else>else

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_OR_OPTIMIZATION</name></cpp:ifndef>
  <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_MULTI_OR</name></expr> )</condition><then><block>{
    <comment type="block">/* Case 4:  Two or more separately indexed terms connected by OR
    **
    ** Example:
    **
    **   CREATE TABLE t1(a,b,c,d);
    **   CREATE INDEX i1 ON t1(a);
    **   CREATE INDEX i2 ON t1(b);
    **   CREATE INDEX i3 ON t1(c);
    **
    **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)
    **
    ** In the example, there are three indexed terms connected by OR.
    ** The top of the loop is constructed by creating a RowSet object
    ** and populating it.  Then looping over elements of the rowset.
    **
    **        Null 1
    **        # fill RowSet 1 with entries where a=5 using i1
    **        # fill Rowset 1 with entries where b=7 using i2
    **        # fill Rowset 1 with entries where c=11 and d=13 i3 and t1
    **     A: RowSetRead 1, B, 2
    **        Seek       i, 2
    **
    ** The bottom of the loop looks like this:
    **
    **        Goto       0, A
    **     B:
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regOrRowset</name></decl>;</decl_stmt>       <comment type="block">/* Register holding the RowSet object */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>regNextRowid</name></decl>;</decl_stmt>      <comment type="block">/* Register holding next rowid */</comment>
    <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pOrWc</name></decl>;</decl_stmt>    <comment type="block">/* The OR-clause broken out into subterms */</comment>
    <decl_stmt><decl><type><name>WhereTerm</name> *</type><name>pOrTerm</name></decl>;</decl_stmt>    <comment type="block">/* A single subterm within the OR-clause */</comment>
    <decl_stmt><decl><type><name>SrcList</name></type> <name>oneTab</name></decl>;</decl_stmt>        <comment type="block">/* Shortened table list */</comment>
   
    <expr_stmt><expr><name>pTerm</name> = <name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>eOperator</name>==<name>WO_OR</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_ORINFO</name>)!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOrWc</name> = &amp;<name>pTerm</name>-&gt;<name>u</name>.<name>pOrInfo</name>-&gt;<name>wc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = (<name>regRowSet</name>&gt;=0 &amp;&amp; <name>pWC</name>-&gt;<name>nTerm</name>==1) ?1:0</expr>;</expr_stmt>

    <if>if<condition>( <expr><name>codeRowSetEarly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>regOrRowset</name> = <name>regRowSet</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>regOrRowset</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>regOrRowset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>oneTab</name>.<name>nSrc</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>oneTab</name>.<name>nAlloc</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>oneTab</name>.<name><name>a</name><index>[<expr>0</expr>]</index></name> = *<name>pTabItem</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pOrTerm</name>=<name>pOrWc</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>pOrWc</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pOrTerm</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>WhereInfo</name> *</type><name>pSubWInfo</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pOrTerm</name>-&gt;<name>leftCursor</name>!=<name>iCur</name> &amp;&amp; <name>pOrTerm</name>-&gt;<name>eOperator</name>!=<name>WO_AND</name></expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><name>pSubWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>oneTab</name></expr></argument>, <argument><expr><name>pOrTerm</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr>0</expr></argument>,
                        <argument><expr><name>WHERE_FILL_ROWSET</name> | <name>WHERE_OMIT_OPEN</name> | <name>WHERE_OMIT_CLOSE</name></expr></argument>,
                        <argument><expr><name>regOrRowset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pSubWInfo</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pSubWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>codeRowSetEarly</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>regNextRowid</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>addrCont</name> = 
         <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetRead</name></expr></argument>, <argument><expr><name>regOrRowset</name></expr></argument>,<argument><expr><name>addrBrk</name></expr></argument>,<argument><expr><name>regNextRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Seek</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regNextRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regNextRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* sqlite3ReleaseTempReg(pParse, regOrRowset); // Preserve the RowSet */</comment>
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>OP_Goto</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>p2</name> = <name>addrCont</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>OP_Noop</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>disableTerm</name><argument_list>(<argument><expr><name>pLevel</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_OR_OPTIMIZATION */</comment>

  <block>{
    <comment type="block">/* Case 5:  There is no usable index.  We must do a complete
    **          scan of the entire table.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>omitTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bRev</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>op</name> = <name>OP_Next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p1</name> = <name>iCur</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p2</name> = 1 + <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>p5</name> = <name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>codeRowSetEarly</name> = 0</expr>;</expr_stmt>
  }</block></else></if></else></if></else></if></else></if></else></if>
  <expr_stmt><expr><name>notReady</name> &amp;= ~<call><name>getMask</name><argument_list>(<argument><expr><name>pWC</name>-&gt;<name>pMaskSet</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Insert code to test every subexpression that can be completely
  ** computed using the current set of tables.
  */</comment>
  <expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>, <expr><name>j</name>=<name>pWC</name>-&gt;<name>nTerm</name></expr>;</init> <condition><expr><name>j</name>&gt;0</expr>;</condition> <incr><expr><name>j</name>--</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pE</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; (<name>TERM_VIRTUAL</name>|<name>TERM_CODED</name>)</expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr>(<name>pTerm</name>-&gt;<name>prereqAll</name> &amp; <name>notReady</name>)!=0</expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>pE</name> = <name>pTerm</name>-&gt;<name>pExpr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pE</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>iLeftJoin</name> &amp;&amp; !<call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pE</name></expr></argument>, <argument><expr><name>EP_FromJoin</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <continue>continue;</continue>
    }</block></then></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name> += <name>k</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pE</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>disableColCache</name> -= <name>k</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_CODED</name></expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* For a LEFT OUTER JOIN, generate code that will record the fact that
  ** at least one row of the right table has matched the left table.  
  */</comment>
  <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>iLeftJoin</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>addrFirst</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iLeftJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "record LEFT JOIN hit")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprClearColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iTabCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprClearColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>pTerm</name>=<name>pWC</name>-&gt;<name>a</name></expr>, <expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pWC</name>-&gt;<name>nTerm</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pTerm</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_VIRTUAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; <name>TERM_CODED</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pTerm</name>-&gt;<name>wtFlags</name> &amp; (<name>TERM_VIRTUAL</name>|<name>TERM_CODED</name>)</expr> )</condition><then> <continue>continue;</continue></then></if>
      <if>if<condition>( <expr>(<name>pTerm</name>-&gt;<name>prereqAll</name> &amp; <name>notReady</name>)!=0</expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTerm</name>-&gt;<name>pExpr</name></expr></argument>, <argument><expr><name>addrCont</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTerm</name>-&gt;<name>wtFlags</name> |= <name>TERM_CODED</name></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>

  <comment type="block">/*
  ** If it was requested to store the results in a rowset and that has
  ** not already been do, then do so now.
  */</comment>
  <if>if<condition>( <expr><name>regRowSet</name>&gt;=0 &amp;&amp; !<name>codeRowSetEarly</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if>if<condition>(  <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_VIRTUALTABLE</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VRowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetAdd</name></expr></argument>, <argument><expr><name>regRowSet</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>notReady</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** The following variable holds a text description of query plan generated
** by the most recent call to sqlite3WhereBegin().  Each call to WhereBegin
** overwrites the previous.  This information is used for testing and
** analysis only.
*/</comment>
<decl_stmt><decl><type><name>char</name></type> <name><name>sqlite3_query_plan</name><index>[<expr><name>BMS</name>*2*40</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Text of the join */</comment>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>nQPlan</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>              <comment type="block">/* Next free slow in _query_plan[] */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST */</comment>


<comment type="block">/*
** Free a WhereInfo structure
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>whereInfoFree</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pWInfo</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pWInfo</name>-&gt;<name>nLevel</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>sqlite3_index_info</name> *</type><name>pInfo</name> =<init> <expr><name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pIdxInfo</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pInfo</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pInfo</name>-&gt;<name>needToFreeIdxStr</name>==0 || <name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pInfo</name>-&gt;<name>needToFreeIdxStr</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pInfo</name>-&gt;<name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>whereClauseClear</name><argument_list>(<argument><expr><name>pWInfo</name>-&gt;<name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<comment type="block">/*
** Generate the beginning of the loop used for WHERE clause processing.
** The return value is a pointer to an opaque structure that contains
** information needed to terminate the loop.  Later, the calling routine
** should invoke sqlite3WhereEnd() with the return value of this function
** in order to complete the WHERE clause processing.
**
** If an error occurs, this routine returns NULL.
**
** The basic idea is to do a nested loop, one loop for each table in
** the FROM clause of a select.  (INSERT and UPDATE statements are the
** same as a SELECT with only a single table in the FROM clause.)  For
** example, if the SQL is this:
**
**       SELECT * FROM t1, t2, t3 WHERE ...;
**
** Then the code generated is conceptually like the following:
**
**      foreach row1 in t1 do       \    Code generated
**        foreach row2 in t2 do      |-- by sqlite3WhereBegin()
**          foreach row3 in t3 do   /
**            ...
**          end                     \    Code generated
**        end                        |-- by sqlite3WhereEnd()
**      end                         /
**
** Note that the loops might not be nested in the order in which they
** appear in the FROM clause if a different order is better able to make
** use of indices.  Note also that when the IN operator appears in
** the WHERE clause, it might result in additional nested loops for
** scanning through all values on the right-hand side of the IN.
**
** There are Btree cursors associated with each table.  t1 uses cursor
** number pTabList-&gt;a[0].iCursor.  t2 uses the cursor pTabList-&gt;a[1].iCursor.
** And so forth.  This routine generates code to open those VDBE cursors
** and sqlite3WhereEnd() generates the code to close them.
**
** The code that sqlite3WhereBegin() generates leaves the cursors named
** in pTabList pointing at their appropriate entries.  The [...] code
** can use OP_Column and OP_Rowid opcodes on these cursors to extract
** data from the various tables of the loop.
**
** If the WHERE clause is empty, the foreach loops must each scan their
** entire tables.  Thus a three-way join is an O(N^3) operation.  But if
** the tables have indices and there are terms in the WHERE clause that
** refer to those indices, a complete table scan can be avoided and the
** code will run much faster.  Most of the work of this routine is checking
** to see if there are indices that can be used to speed up the loop.
**
** Terms of the WHERE clause are also used to limit which rows actually
** make it to the "..." in the middle of the loop.  After each "foreach",
** terms of the WHERE clause that use only terms in that loop and outer
** loops are evaluated and if false a jump is made around all subsequent
** inner loops (or around the "..." if the test occurs within the inner-
** most loop)
**
** OUTER JOINS
**
** An outer join of tables t1 and t2 is conceptally coded as follows:
**
**    foreach row1 in t1 do
**      flag = 0
**      foreach row2 in t2 do
**        start:
**          ...
**          flag = 1
**      end
**      if flag==0 then
**        move the row2 cursor to a null row
**        goto start
**      fi
**    end
**
** ORDER BY CLAUSE PROCESSING
**
** *ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,
** if there is one.  If there is no ORDER BY clause or if this routine
** is called from an UPDATE or DELETE statement, then ppOrderBy is NULL.
**
** If an index can be used so that the natural output order of the table
** scan is correct for the ORDER BY clause, then that index is used and
** *ppOrderBy is set to NULL.  This is an optimization that prevents an
** unnecessary sort of the result set if an index appropriate for the
** ORDER BY clause already exists.
**
** If the where clause loops cannot be arranged to provide the correct
** output order, then the *ppOrderBy is unchanged.
*/</comment>
<function><type><name>WhereInfo</name> *</type><name>sqlite3WhereBegin</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,    <comment type="block">/* A list of all tables to be scanned */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,         <comment type="block">/* The WHERE clause */</comment>
  <param><decl><type><name>ExprList</name> **</type><name>ppOrderBy</name></decl></param>, <comment type="block">/* An ORDER BY clause, or NULL */</comment>
  <param><decl><type><name>u8</name></type> <name>wctrlFlags</name></decl></param>,        <comment type="block">/* One of the WHERE_* flags defined in sqliteInt.h */</comment>
  <param><decl><type><name>int</name></type> <name>regRowSet</name></decl></param>         <comment type="block">/* Register hold RowSet if WHERE_FILL_ROWSET is set */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl>;</decl_stmt>         <comment type="block">/* Will become the return value of this function */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Bitmask</name></type> <name>notReady</name></decl>;</decl_stmt>          <comment type="block">/* Cursors that are not yet positioned */</comment>
  <decl_stmt><decl><type><name>WhereMaskSet</name> *</type><name>pMaskSet</name></decl>;</decl_stmt>    <comment type="block">/* The expression mask set */</comment>
  <decl_stmt><decl><type><name>WhereClause</name> *</type><name>pWC</name></decl>;</decl_stmt>               <comment type="block">/* Decomposition of the WHERE clause */</comment>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pTabItem</name></decl>;</decl_stmt>  <comment type="block">/* A single entry from pTabList */</comment>
  <decl_stmt><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl>;</decl_stmt>             <comment type="block">/* A single level in the pWInfo list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFrom</name></decl>;</decl_stmt>                      <comment type="block">/* First unused FROM clause element */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>andFlags</name></decl>;</decl_stmt>              <comment type="block">/* AND-ed combination of all pWC-&gt;a[].wtFlags */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pOrderBy</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* The number of tables in the FROM clause is limited by the number of
  ** bits in a Bitmask 
  */</comment>
  <if>if<condition>( <expr><name>pTabList</name>-&gt;<name>nSrc</name>&gt;<name>BMS</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"at most %d tables in a join"</expr></argument>, <argument><expr><name>BMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>ppOrderBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOrderBy</name> = *<name>ppOrderBy</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Allocate and initialize the WhereInfo structure that will become the
  ** return value.
  */</comment>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>,  
                      <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>WhereInfo</name></expr></argument>)</argument_list></call>
                      + (<name>pTabList</name>-&gt;<name>nSrc</name>-1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>WhereLevel</name></expr></argument>)</argument_list></call>
                      + <call><name>sizeof</name><argument_list>(<argument><expr><name>WhereClause</name></expr></argument>)</argument_list></call>
                      + <call><name>sizeof</name><argument_list>(<argument><expr><name>WhereMaskSet</name></expr></argument>)</argument_list></call></expr></argument>
           )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>whereBeginError</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>nLevel</name> = <name>pTabList</name>-&gt;<name>nSrc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>pTabList</name> = <name>pTabList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>iBreak</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>regRowSet</name> = (<name>wctrlFlags</name> &amp; <name>WHERE_FILL_ROWSET</name>) ? <name>regRowSet</name> : -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>pWC</name> = <name>pWC</name> = (<name>WhereClause</name>*)&amp;<name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>pWInfo</name>-&gt;<name>nLevel</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>wctrlFlags</name> = <name>wctrlFlags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMaskSet</name> = (<name>WhereMaskSet</name>*)&amp;<name><name>pWC</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* Split the WHERE clause into separate subexpressions where each
  ** subexpression is separated by an AND operator.
  */</comment>
  <expr_stmt><expr><call><name>initMaskSet</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereClauseInit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pMaskSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprCodeConstants</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>whereSplit</name><argument_list>(<argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>TK_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
  <comment type="block">/* Special case: a WHERE clause that is constant.  Evaluate the
  ** expression and either jump over all of the code or fall thru.
  */</comment>
  <if>if<condition>( <expr><name>pWhere</name> &amp;&amp; (<name>pTabList</name>-&gt;<name>nSrc</name>==0 || <call><name>sqlite3ExprIsConstantNotJoin</name><argument_list>(<argument><expr><name>pWhere</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprIfFalse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>pWInfo</name>-&gt;<name>iBreak</name></expr></argument>, <argument><expr><name>SQLITE_JUMPIFNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWhere</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Assign a bit from the bitmask to every term in the FROM clause.
  **
  ** When assigning bitmask values to FROM clause cursors, it must be
  ** the case that if X is the bitmask for the N-th FROM clause term then
  ** the bitmask for all FROM clause terms to the left of the N-th term
  ** is (X-1).   An expression from the ON clause of a LEFT JOIN can use
  ** its Expr.iRightJoinTable value to find the bitmask of the right table
  ** of the join.  Subtracting one from the right table bitmask gives a
  ** bitmask for all tables to the left of the join.  Knowing the bitmask
  ** for all tables to the left of a left join is important.  Ticket #3015.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>createMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>toTheLeft</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name> =<init> <expr><call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>m</name>-1)==<name>toTheLeft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>toTheLeft</name> |= <name>m</name></expr>;</expr_stmt>
    }</block></for>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Analyze all of the subexpressions.  Note that exprAnalyze() might
  ** add new virtual terms onto the end of the WHERE clause.  We do not
  ** want to analyze these virtual terms, so start analyzing at the end
  ** and work forward so that the added virtual terms are never processed.
  */</comment>
  <expr_stmt><expr><call><name>exprAnalyzeAll</name><argument_list>(<argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>whereBeginError</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Chose the best index to use for each table in the FROM clause.
  **
  ** This loop fills in the following fields:
  **
  **   pWInfo-&gt;a[].pIdx      The index to use for this level of the loop.
  **   pWInfo-&gt;a[].wsFlags   WHERE_xxx flags associated with pIdx
  **   pWInfo-&gt;a[].nEq       The number of == and IN constraints
  **   pWInfo-&gt;a[].iFrom     Which term of the FROM clause is being coded
  **   pWInfo-&gt;a[].iTabCur   The VDBE cursor for the database table
  **   pWInfo-&gt;a[].iIdxCur   The VDBE cursor for the index
  **   pWInfo-&gt;a[].pTerm     When wsFlags==WO_OR, the OR-clause term
  **
  ** This loop also figures out the nesting order of tables in the FROM
  ** clause.
  */</comment>
  <expr_stmt><expr><name>notReady</name> = ~(<name>Bitmask</name>)0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTabItem</name> = <name>pTabList</name>-&gt;<name>a</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLevel</name> = <name>pWInfo</name>-&gt;<name>a</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>andFlags</name> = ~0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("*** Optimizer Start ***\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>iFrom</name>=0</expr>, <expr><name>pLevel</name>=<name>pWInfo</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pLevel</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>WhereCost</name></type> <name>bestPlan</name></decl>;</decl_stmt>         <comment type="block">/* Most efficient plan seen so far */</comment>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>                <comment type="block">/* Index for FROM table at pTabItem */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>                      <comment type="block">/* For looping over FROM tables */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bestJ</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>              <comment type="block">/* The value of j */</comment>
    <decl_stmt><decl><type><name>Bitmask</name></type> <name>m</name></decl>;</decl_stmt>                  <comment type="block">/* Bitmask value for j or bestJ */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>once</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>               <comment type="block">/* True when first table is seen */</comment>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>bestPlan</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>bestPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bestPlan</name>.<name>rCost</name> = <name>SQLITE_BIG_DBL</name></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=<name>iFrom</name></expr>, <expr><name>pTabItem</name>=&amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pTabItem</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>doNotReorder</name></decl>;</decl_stmt>  <comment type="block">/* True if this table should not be reordered */</comment>
      <decl_stmt><decl><type><name>WhereCost</name></type> <name>sCost</name></decl>;</decl_stmt>   <comment type="block">/* Cost information from bestIndex() */</comment>

      <expr_stmt><expr><name>doNotReorder</name> =  (<name>pTabItem</name>-&gt;<name>jointype</name> &amp; (<name>JT_LEFT</name>|<name>JT_CROSS</name>))!=0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>once</name> &amp;&amp; <name>doNotReorder</name></expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><name>m</name> = <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pTabItem</name>-&gt;<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>m</name> &amp; <name>notReady</name>)==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>j</name>==<name>iFrom</name></expr> )</condition><then> <expr_stmt><expr><name>iFrom</name>++</expr>;</expr_stmt></then></if>
        <continue>continue;</continue>
      }</block></then></if>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabItem</name>-&gt;<name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTabItem</name>-&gt;<name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>sqlite3_index_info</name> *</type><name>pVtabIdx</name></decl>;</decl_stmt> <comment type="block">/* Current virtual index */</comment>
        <decl_stmt><decl><type><name>sqlite3_index_info</name> **</type><name>ppIdxInfo</name> =<init> <expr>&amp;<name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pIdxInfo</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>sCost</name>.<name>rCost</name> = <call><name>bestVirtualIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>,
                                       <argument><expr><name>ppOrderBy</name> ? *<name>ppOrderBy</name> : 0</expr></argument>, <argument><expr><name>i</name>==0</expr></argument>,
                                       <argument><expr><name>ppIdxInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sCost</name>.<name>plan</name>.<name>wsFlags</name> = <name>WHERE_VIRTUALTABLE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>sCost</name>.<name>plan</name>.<name>u</name>.<name>pVtabIdx</name> = <name>pVtabIdx</name> = *<name>ppIdxInfo</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pVtabIdx</name> &amp;&amp; <name>pVtabIdx</name>-&gt;<name>orderByConsumed</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>sCost</name>.<name>plan</name>.<name>wsFlags</name> = <name>WHERE_VIRTUALTABLE</name> | <name>WHERE_ORDERBY</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>sCost</name>.<name>plan</name>.<name>nEq</name> = 0</expr>;</expr_stmt>
        <if>if<condition>( <expr>(<name>SQLITE_BIG_DBL</name>/2.0)&lt;<name>sCost</name>.<name>rCost</name></expr> )</condition><then><block>{
          <comment type="block">/* The cost is not allowed to be larger than SQLITE_BIG_DBL (the
          ** inital value of lowestCost in this loop. If it is, then
          ** the (cost&lt;lowestCost) test below will never be true.
          */</comment> 
          <expr_stmt><expr><name>sCost</name>.<name>rCost</name> = (<name>SQLITE_BIG_DBL</name>/2.0)</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{
        <expr_stmt><expr><call><name>bestIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pWC</name></expr></argument>, <argument><expr><name>pTabItem</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>,
                  <argument><expr>(<name>i</name>==0 &amp;&amp; <name>ppOrderBy</name>) ? *<name>ppOrderBy</name> : 0</expr></argument>, <argument><expr>&amp;<name>sCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>once</name>==0 || <name>sCost</name>.<name>rCost</name>&lt;<name>bestPlan</name>.<name>rCost</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>once</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>bestPlan</name> = <name>sCost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bestJ</name> = <name>j</name></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>doNotReorder</name></expr> )</condition><then> <break>break;</break></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>once</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>notReady</name> &amp; <call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>bestJ</name></expr>]</index></name>.<name>iCursor</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("*** Optimizer selects table %d for loop %d\n", <name>bestJ</name>,
           <name>pLevel</name>-<name>pWInfo</name>-&gt;<name>a</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>bestPlan</name>.<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ORDERBY</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>ppOrderBy</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>andFlags</name> &amp;= <name>bestPlan</name>.<name>plan</name>.<name>wsFlags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>plan</name> = <name>bestPlan</name>.<name>plan</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>bestPlan</name>.<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>iIdxCur</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pLevel</name>-&gt;<name>iIdxCur</name> = -1</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>notReady</name> &amp;= ~<call><name>getMask</name><argument_list>(<argument><expr><name>pMaskSet</name></expr></argument>, <argument><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>bestJ</name></expr>]</index></name>.<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>iFrom</name> = <name>bestJ</name></expr>;</expr_stmt>

    <comment type="block">/* Check that if the table scanned by this loop iteration had an
    ** INDEXED BY clause attached to it, that the named index is being
    ** used for the scan. If not, then query compilation has failed.
    ** Return an error.
    */</comment>
    <expr_stmt><expr><name>pIdx</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>bestJ</name></expr>]</index></name>.<name>pIndex</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIdx</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>(<name>bestPlan</name>.<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"cannot use index: %s"</expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>whereBeginError</name>;</goto>
      }</block></then><else>else<block>{
        <comment type="block">/* If an INDEXED BY clause is used, the bestIndex() function is
        ** guaranteed to find the index specified in the INDEXED BY clause
        ** if it find an index at all. */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>bestPlan</name>.<name>plan</name>.<name>u</name>.<name>pIdx</name>==<name>pIdx</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>WHERETRACE</name><argument_list>(<argument><expr>("*** Optimizer Finished ***\n")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>whereBeginError</name>;</goto>
  }</block></then></if>

  <comment type="block">/* If the total query only selects a single row, then the ORDER BY
  ** clause is irrelevant.
  */</comment>
  <if>if<condition>( <expr>(<name>andFlags</name> &amp; <name>WHERE_UNIQUE</name>)!=0 &amp;&amp; <name>ppOrderBy</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>ppOrderBy</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the caller is an UPDATE or DELETE statement that is requesting
  ** to use a one-pass algorithm, determine if this is appropriate.
  ** The one-pass algorithm only works if the WHERE clause constraints
  ** the statement to update a single row.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>wctrlFlags</name> &amp; <name>WHERE_ONEPASS_DESIRED</name>)==0 || <name>pWInfo</name>-&gt;<name>nLevel</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>wctrlFlags</name> &amp; <name>WHERE_ONEPASS_DESIRED</name>)!=0 &amp;&amp; (<name>andFlags</name> &amp; <name>WHERE_UNIQUE</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pWInfo</name>-&gt;<name>okOnePass</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>plan</name>.<name>wsFlags</name> &amp;= ~<name>WHERE_IDX_ONLY</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Open all tables in the pTabList and any indices selected for
  ** searching those tables.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Insert the cookie verifier Goto */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pLevel</name>=<name>pWInfo</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pLevel</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>     <comment type="block">/* Table to open */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>         <comment type="block">/* Index of database containing table/index */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
    <if>if<condition>( <expr><name>pParse</name>-&gt;<name>explain</name>==2</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zMsg</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>pLevel</name>-&gt;<name>iFrom</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"TABLE %s"</expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>zAlias</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s AS %s"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s WITH INDEX %s"</expr></argument>,
           <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_MULTI_OR</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s VIA MULTI-INDEX UNION"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; (<name>WHERE_ROWID_EQ</name>|<name>WHERE_ROWID_RANGE</name>)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s USING PRIMARY KEY"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <else>else <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_VIRTUALTABLE</name>)!=0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>sqlite3_index_info</name> *</type><name>pVtabIdx</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pVtabIdx</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s VIRTUAL TABLE INDEX %d:%s"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>,
                    <argument><expr><name>pVtabIdx</name>-&gt;<name>idxNum</name></expr></argument>, <argument><expr><name>pVtabIdx</name>-&gt;<name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ORDERBY</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zMsg</name> = <call><name>sqlite3MAppendf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr>"%s ORDER BY"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Explain</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iFrom</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>
    <expr_stmt><expr><name>pTabItem</name> = &amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>pLevel</name>-&gt;<name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> = <name>pTabItem</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Ephemeral</name>)!=0 || <name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then> <continue>continue;</continue></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_VIRTUALTABLE</name>)!=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iCur</name> =<init> <expr><name>pTabItem</name>-&gt;<name>iCursor</name></expr></init></decl>;</decl_stmt>
      <macro><name>sqlite3VdbeAddOp4</name><argument_list>(<argument>v</argument>, <argument>OP_VOpen</argument>, <argument>iCur</argument>, <argument>0</argument>, <argument>0</argument>,
                        <argument>(const char*)pTab-&gt;pVtab</argument>, <argument>P4_VTAB</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IDX_ONLY</name>)==0
         &amp;&amp; (<name>wctrlFlags</name> &amp; <name>WHERE_OMIT_OPEN</name>)==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>op</name> =<init> <expr><name>pWInfo</name>-&gt;<name>okOnePass</name> ? <name>OP_OpenWrite</name> : <name>OP_OpenRead</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabItem</name>-&gt;<name>iCursor</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>pWInfo</name>-&gt;<name>okOnePass</name> &amp;&amp; <name>pTab</name>-&gt;<name>nCol</name>&lt;<name>BMS</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>Bitmask</name></type> <name>b</name> =<init> <expr><name>pTabItem</name>-&gt;<name>colUsed</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for(<init>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name>=<name>b</name>&gt;&gt;1</expr>, <expr><name>n</name>++</expr></incr>)<block>{}</block></for>
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-2</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name>&lt;=<name>pTab</name>-&gt;<name>nCol</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><name>pLevel</name>-&gt;<name>iTabCur</name> = <name>pTabItem</name>-&gt;<name>iCursor</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Index</name> *</type><name>pIx</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKey</name> =<init> <expr><call><name>sqlite3IndexKeyinfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iIdxCur</name> =<init> <expr><name>pLevel</name>-&gt;<name>iIdxCur</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIx</name>-&gt;<name>pSchema</name>==<name>pTab</name>-&gt;<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iIdxCur</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pIx</name>-&gt;<name>nColumn</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>, <argument><expr><name>iIdxCur</name></expr></argument>, <argument><expr><name>pIx</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>,
                        <argument><expr>(<name>char</name>*)<name>pKey</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%s", <name>pIx</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pWInfo</name>-&gt;<name>iTop</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Generate the code to do the search.  Each iteration of the for
  ** loop below generates code for a single nested loop of the VM
  ** program.
  */</comment>
  <expr_stmt><expr><name>notReady</name> = ~(<name>Bitmask</name>)0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>notReady</name> = <call><name>codeOneLoopStart</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>wctrlFlags</name></expr></argument>, <argument><expr><name>notReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name>-&gt;<name>iContinue</name> = <name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>addrCont</name></expr>;</expr_stmt>
  }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>  <comment type="block">/* For testing and debugging use only */</comment>
  <comment type="block">/* Record in the query plan information about the current table
  ** and the index used to access it (if any).  If the table itself
  ** is not used, its name is just '{}'.  If no index is used
  ** the index is listed as "{}".  If the primary key is used the
  ** index name is '*'.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pLevel</name> = &amp;<name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTabItem</name> = &amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>pLevel</name>-&gt;<name>iFrom</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <name>pTabItem</name>-&gt;<name>zAlias</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <expr_stmt><expr><name>z</name> = <name>pTabItem</name>-&gt;<name>pTab</name>-&gt;<name>zName</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>n</name>+<name>nQPlan</name> &lt; <call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3_query_plan</name></expr></argument>)</argument_list></call>-10</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IDX_ONLY</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name></expr></argument>, <argument><expr>"{}"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nQPlan</name> += 2</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nQPlan</name> += <name>n</name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ROWID_EQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_ROWID_RANGE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; (<name>WHERE_ROWID_EQ</name>|<name>WHERE_ROWID_RANGE</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name></expr></argument>, <argument><expr>"* "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nQPlan</name> += 2</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>n</name>+<name>nQPlan</name> &lt; <call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3_query_plan</name></expr></argument>)</argument_list></call>-2</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nQPlan</name> += <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name></expr></argument>, <argument><expr>"{} "</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nQPlan</name> += 3</expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></for>
  <while>while<condition>( <expr><name>nQPlan</name>&gt;0 &amp;&amp; <name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name>-1</expr>]</index></name>==' '</expr> )</condition><block>{
    <expr_stmt><expr><name><name>sqlite3_query_plan</name><index>[<expr>--<name>nQPlan</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name><name>sqlite3_query_plan</name><index>[<expr><name>nQPlan</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>nQPlan</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_TEST // Testing and debugging use only */</comment>

  <comment type="block">/* Record the continuation address in the WhereInfo structure.  Then
  ** clean up and return.
  */</comment>
  <return>return <expr><name>pWInfo</name></expr>;</return>

  <comment type="block">/* Jump here if malloc fails */</comment>
<label><name>whereBeginError</name>:</label>
  <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Generate the end of the WHERE loop.  See comments on 
** sqlite3WhereBegin() for additional information.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3WhereEnd</name><parameter_list>(<param><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name> *</type><name>pParse</name> =<init> <expr><name>pWInfo</name>-&gt;<name>pParse</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>WhereLevel</name> *</type><name>pLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pTabList</name> =<init> <expr><name>pWInfo</name>-&gt;<name>pTabList</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Generate loop termination code.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprClearColumnCache</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>pTabList</name>-&gt;<name>nSrc</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <expr_stmt><expr><name>pLevel</name> = &amp;<name>pWInfo</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>addrCont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>op</name>!=<name>OP_Noop</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>op</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>p1</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>p5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IN_ABLE</name> &amp;&amp; <name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name>&gt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type>struct <name>InLoop</name> *</type><name>pIn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>addrNxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>j</name>=<name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>nIn</name></expr>, <expr><name>pIn</name>=&amp;<name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name><name>aInLoop</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr>;</init> <condition><expr><name>j</name>&gt;0</expr>;</condition> <incr><expr><name>j</name>--</expr>, <expr><name>pIn</name>--</expr></incr>)<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>addrInTop</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>iCur</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>addrInTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pIn</name>-&gt;<name>addrInTop</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>u</name>.<name>in</name>.<name>aInLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>addrBrk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>iLeftJoin</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IfPos</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iLeftJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pLevel</name>-&gt;<name>iIdxCur</name>&gt;=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NullRow</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>addrFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* The "break" point is here, just past the end of the outer loop.
  ** Set it.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWInfo</name>-&gt;<name>iBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close all of the cursors that were opened by sqlite3WhereBegin.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pLevel</name>=<name>pWInfo</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pTabList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pLevel</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pTabItem</name> =<init> <expr>&amp;<name>pTabList</name>-&gt;<name><name>a</name><index>[<expr><name>pLevel</name>-&gt;<name>iFrom</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pTabItem</name>-&gt;<name>pTab</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Ephemeral</name>)!=0 || <name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr>(<name>pWInfo</name>-&gt;<name>wctrlFlags</name> &amp; <name>WHERE_OMIT_CLOSE</name>)==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>pWInfo</name>-&gt;<name>okOnePass</name> &amp;&amp; (<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IDX_ONLY</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>pTabItem</name>-&gt;<name>iCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>pLevel</name>-&gt;<name>iIdxCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If this scan uses an index, make code substitutions to read data
    ** from the index in preference to the table. Sometimes, this means
    ** the table need never be read from. This is a performance boost,
    ** as the vdbe level waits until the table is read before actually
    ** seeking the table cursor to the record corresponding to the current
    ** position in the index.
    ** 
    ** Calls to the code generator in between sqlite3WhereBegin and
    ** sqlite3WhereEnd will have created code that references the table
    ** directly.  This loop scans all that code looking for opcodes
    ** that reference the table and converts them into opcodes that
    ** reference the index.
    */</comment>
    <if>if<condition>( <expr>(<name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_INDEXED</name>)!=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>k</name>, <name>j</name>, <name>last</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>u</name>.<name>pIdx</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>useIndexOnly</name> =<init> <expr><name>pLevel</name>-&gt;<name>plan</name>.<name>wsFlags</name> &amp; <name>WHERE_IDX_ONLY</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOp</name> = <call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWInfo</name>-&gt;<name>iTop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>last</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>k</name>=<name>pWInfo</name>-&gt;<name>iTop</name></expr>;</init> <condition><expr><name>k</name>&lt;<name>last</name></expr>;</condition> <incr><expr><name>k</name>++</expr>, <expr><name>pOp</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p1</name>!=<name>pLevel</name>-&gt;<name>iTabCur</name></expr> )</condition><then> <continue>continue;</continue></then></if>
        <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Column</name></expr> )</condition><then><block>{
          <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>pIdx</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
            <if>if<condition>( <expr><name>pOp</name>-&gt;<name>p2</name>==<name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr> )</condition><then><block>{
              <expr_stmt><expr><name>pOp</name>-&gt;<name>p2</name> = <name>j</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>pOp</name>-&gt;<name>p1</name> = <name>pLevel</name>-&gt;<name>iIdxCur</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          }</block></for>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>useIndexOnly</name> || <name>j</name>&lt;<name>pIdx</name>-&gt;<name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Rowid</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pOp</name>-&gt;<name>p1</name> = <name>pLevel</name>-&gt;<name>iIdxCur</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_IdxRowid</name></expr>;</expr_stmt>
        }</block></then><else>else <if>if<condition>( <expr><name>pOp</name>-&gt;<name>opcode</name>==<name>OP_NullRow</name> &amp;&amp; <name>useIndexOnly</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pOp</name>-&gt;<name>opcode</name> = <name>OP_Noop</name></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
      }</block></for>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* Final cleanup
  */</comment>
  <expr_stmt><expr><call><name>whereInfoFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>
</unit>
