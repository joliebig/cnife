<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="os_unix.c" filename=""><comment type="block">/*
** 2004 May 22
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains the VFS implementation for unix-like operating systems
** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.
**
** There are actually several different VFS implementations in this file.
** The differences are in the way that file locking is done.  The default
** implementation uses Posix Advisory Locks.  Alternative implementations
** use flock(), dot-files, various proprietary locking schemas, or simply
** skip locking all together.
**
** This source file is organized into divisions where the logic for various
** subfunctions is contained within the appropriate division.  PLEASE
** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placed
** in the correct division and should be clearly labeled.
**
** The layout of divisions is as follows:
**
**   *  General-purpose declarations and utility functions.
**   *  Unique file ID logic used by VxWorks.
**   *  Various locking primitive implementations (all except proxy locking):
**      + for Posix Advisory Locks
**      + for no-op locks
**      + for dot-file locks
**      + for flock() locking
**      + for named semaphore locks (VxWorks only)
**      + for AFP filesystem locks (MacOSX only)
**   *  sqlite3_file methods not associated with locking.
**   *  Definitions of sqlite3_io_methods objects for all locking
**      methods plus "finder" functions for each locking method.
**   *  sqlite3_vfs method implementations.
**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)
**   *  Definitions of sqlite3_vfs objects for all locking methods
**      plus implementations of sqlite3_os_init() and sqlite3_os_end().
**
** $Id: os_unix.c,v 1.237 2009/01/15 04:30:03 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_UNIX</name></expr></cpp:if>              <comment type="block">/* This file is used on unix only */</comment>

<comment type="block">/*
** There are various methods for file locking used for concurrency
** control:
**
**   1. POSIX locking (the default),
**   2. No locking,
**   3. Dot-file locking,
**   4. flock() locking,
**   5. AFP locking (OSX only),
**   6. Named POSIX semaphores (VXWorks only),
**   7. proxy locking. (OSX only)
**
** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLE
** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automatic
** selection of the appropriate locking style based on the filesystem
** where the database is located.  
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <name>SQLITE_ENABLE_LOCKING_STYLE</name> 1</cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <name>SQLITE_ENABLE_LOCKING_STYLE</name> 0</cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Define the OS_VXWORKS pre-processor macro to 1 if building on 
** vxworks, or 0 otherwise.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OS_VXWORKS</name></cpp:ifndef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__RTP__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_WRS_KERNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <name>OS_VXWORKS</name> 1</cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <name>OS_VXWORKS</name> 0</cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** These #defines should enable &gt;2GB file support on Posix if the
** underlying operating system supports it.  If the OS lacks
** large file support, these should be no-ops.
**
** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch
** on the compiler command line.  This is necessary if you are compiling
** on a recent machine (ex: RedHat 7.2) but you want your code to work
** on an older machine (ex: RedHat 6.0).  If you compile on RedHat 7.2
** without this option, LFS is enable.  But LFS does not exist in the kernel
** in RedHat 6.0, so the code won't work.  Hence, for maximum binary
** portability you should omit LFS.
**
** The previous paragraph was written in 2005.  (This paragraph is written
** on 2008-11-28.) These days, all Linux kernels support large files, so
** you should probably leave LFS enabled.  But some embedded platforms might
** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_LFS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>_LARGE_FILE</name>       1</cpp:define>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>_FILE_OFFSET_BITS</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <name>_FILE_OFFSET_BITS</name> 64</cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define># <cpp:directive>define</cpp:directive> <name>_LARGEFILE_SOURCE</name> 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** standard include files.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;semaphore.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mount.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE */</comment>

<comment type="block">/*
** If we are to be thread-safe, include the pthreads header and define
** the SQLITE_UNIX_THREADS macro.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SQLITE_UNIX_THREADS</name> 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Default permissions when creating a new file
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SQLITE_DEFAULT_FILE_PERMISSIONS</name> 0644</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 ** Default permissions when creating auto proxy dir
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name> 0755</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Maximum supported path-length.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_PATHNAME</name> 512</cpp:define>

<comment type="block">/*
** Only set the lastErrno if the error code is a real error and not 
** a normal expected return code of SQLITE_BUSY or SQLITE_OK
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IS_LOCK_ERROR</name>(x)  ((x != SQLITE_OK) &amp;&amp; (x != SQLITE_BUSY))</cpp:define>


<comment type="block">/*
** The unixFile structure is subclass of sqlite3_file specific to the unix
** VFS implementations.
*/</comment>
<typedef>typedef <type><struct>struct <name>unixFile</name> unixFile;</struct></type></typedef>
<struct>struct <name>unixFile</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <name>const</name> *</type><name>pMethod</name></decl>;</decl_stmt>  <comment type="block">/* Always the first entry */</comment>
  <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name></decl>;</decl_stmt>       <comment type="block">/* Info about all open fd's on this inode */</comment>
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pLock</name></decl>;</decl_stmt>      <comment type="block">/* Info about locks on this inode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>                           <comment type="block">/* The file descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name></decl>;</decl_stmt>                       <comment type="block">/* File descriptor for the directory */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>locktype</name></decl>;</decl_stmt>          <comment type="block">/* The type of lock held on this fd */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lastErrno</name></decl>;</decl_stmt>                   <comment type="block">/* The unix errno from the last I/O error */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>lockingContext</name></decl>;</decl_stmt>            <comment type="block">/* Locking style specific state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name></decl>;</decl_stmt>                   <comment type="block">/* The flags specified at open */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>tid</name></decl>;</decl_stmt>                   <comment type="block">/* The thread that "owns" this unixFile */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name></decl>;</decl_stmt>                    <comment type="block">/* Delete on close if true */</comment>
  <decl_stmt><decl><type>struct <name>vxworksFileId</name> *</type><name>pId</name></decl>;</decl_stmt>       <comment type="block">/* Unique file ID */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* The next group of variables are used to track whether or not the
  ** transaction counter in bytes 24-27 of database files are updated
  ** whenever any part of the database changes.  An assertion fault will
  ** occur if a file is updated without also updating the transaction
  ** counter.  This test is made to avoid new problems similar to the
  ** one described by ticket #3584. 
  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>transCntrChng</name></decl>;</decl_stmt>   <comment type="block">/* True if the transaction counter changed */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>dbUpdate</name></decl>;</decl_stmt>        <comment type="block">/* True if any part of database file changed */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>inNormalWrite</name></decl>;</decl_stmt>   <comment type="block">/* True if in a normal write operation */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <comment type="block">/* In test mode, increase the size of this structure a bit so that 
  ** it is larger than the struct CrashFile defined in test6.c.
  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aPadding</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<comment type="block">/*
** Include code that is common to all os_*.c files
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_common.h"</cpp:file></cpp:include>

<comment type="block">/*
** Define various macros that are missing from some systems.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_LARGEFILE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>O_LARGEFILE</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DISABLE_LFS</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>O_LARGEFILE</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>O_LARGEFILE</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_NOFOLLOW</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>O_NOFOLLOW</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>O_BINARY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>O_BINARY</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The DJGPP compiler environment looks mostly like Unix, but it
** lacks the fcntl() system call.  So redefine fcntl() to be something
** that always succeeds.  This means that locking does not occur under
** DJGPP.  But it is DOS - what did you expect?
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__DJGPP__</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>fcntl</name>(A,B,C) 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The threadid macro resolves to the thread-id or to 0.  Used for
** testing and debugging only.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>threadid</name> <name>pthread_self</name>()</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>threadid</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Helper functions to obtain and relinquish the global mutex.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>unixEnterMutex</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>unixLeaveMutex</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MASTER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** Helper function for printing out trace information from debugging
** binaries. This returns the string represetation of the supplied
** integer lock-type.
*/</comment>
<function><type><name>static</name> <name>const</name> <name>char</name> *</type><name>locktypeName</name><parameter_list>(<param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list><block>{
  <switch>switch<condition>( <expr><name>locktype</name></expr> )</condition><block>{
  <case>case <expr><name>NO_LOCK</name></expr>: <return>return <expr>"NONE"</expr>;</return>
  </case><case>case <expr><name>SHARED_LOCK</name></expr>: <return>return <expr>"SHARED"</expr>;</return>
  </case><case>case <expr><name>RESERVED_LOCK</name></expr>: <return>return <expr>"RESERVED"</expr>;</return>
  </case><case>case <expr><name>PENDING_LOCK</name></expr>: <return>return <expr>"PENDING"</expr>;</return>
  </case><case>case <expr><name>EXCLUSIVE_LOCK</name></expr>: <return>return <expr>"EXCLUSIVE"</expr>;</return>
  </case>}</block></switch>
  <return>return <expr>"ERROR"</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LOCK_TRACE</name></cpp:ifdef>
<comment type="block">/*
** Print out information about all locking operations.
**
** This routine is used for troubleshooting locks on multithreaded
** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE
** command-line option on the compiler.  This code is normally
** turned off.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>lockTrace</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type>struct <name>flock</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zOpName</name>, *<name>zType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>savedErrno</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>op</name>==<name>F_GETLK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zOpName</name> = "GETLK"</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>op</name>==<name>F_SETLK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zOpName</name> = "SETLK"</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>s</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"fcntl unknown %d %d %d\n"</expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
  }</block></else></if></else></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>l_type</name>==<name>F_RDLCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zType</name> = "RDLCK"</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>l_type</name>==<name>F_WRLCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zType</name> = "WRLCK"</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>l_type</name>==<name>F_UNLCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zType</name> = "UNLCK"</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>l_whence</name>==<name>SEEK_SET</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>savedErrno</name> = <name>errno</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"fcntl %d %d %s %s %d %d %d %d\n"</expr></argument>,
     <argument><expr><name>threadid</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zOpName</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr>(<name>int</name>)<name>p</name>-&gt;<name>l_start</name></expr></argument>, <argument><expr>(<name>int</name>)<name>p</name>-&gt;<name>l_len</name></expr></argument>,
     <argument><expr>(<name>int</name>)<name>p</name>-&gt;<name>l_pid</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>s</name>==(-1) &amp;&amp; <name>op</name>==<name>F_SETLK</name> &amp;&amp; (<name>p</name>-&gt;<name>l_type</name>==<name>F_RDLCK</name> || <name>p</name>-&gt;<name>l_type</name>==<name>F_WRLCK</name>)</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>flock</name></type> <name>l2</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>l2</name> = *<name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr>&amp;<name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>l2</name>.<name>l_type</name>==<name>F_RDLCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zType</name> = "RDLCK"</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>l2</name>.<name>l_type</name>==<name>F_WRLCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zType</name> = "WRLCK"</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>l2</name>.<name>l_type</name>==<name>F_UNLCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zType</name> = "UNLCK"</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"fcntl-failure-reason: %s %d %d %d\n"</expr></argument>,
       <argument><expr><name>zType</name></expr></argument>, <argument><expr>(<name>int</name>)<name>l2</name>.<name>l_start</name></expr></argument>, <argument><expr>(<name>int</name>)<name>l2</name>.<name>l_len</name></expr></argument>, <argument><expr>(<name>int</name>)<name>l2</name>.<name>l_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>errno</name> = <name>savedErrno</name></expr>;</expr_stmt>
  <return>return <expr><name>s</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>fcntl</name> <name>lockTrace</name></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_LOCK_TRACE */</comment>



<comment type="block">/*
** This routine translates a standard POSIX errno code into something
** useful to the clients of the sqlite3 functions.  Specifically, it is
** intended to translate a variety of "try again" errors into SQLITE_BUSY
** and a variety of "please close the file descriptor NOW" errors into 
** SQLITE_IOERR
** 
** Errors during initialization of locks, or file system support for locks,
** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>sqliteErrorFromPosixError</name><parameter_list>(<param><decl><type><name>int</name></type> <name>posixError</name></decl></param>, <param><decl><type><name>int</name></type> <name>sqliteIOErr</name></decl></param>)</parameter_list> <block>{
  <switch>switch <condition>(<expr><name>posixError</name></expr>)</condition> <block>{
  <case>case <expr>0</expr>: 
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    
  </case><case>case <expr><name>EAGAIN</name></expr>:
  </case><case>case <expr><name>ETIMEDOUT</name></expr>:
  </case><case>case <expr><name>EBUSY</name></expr>:
  </case><case>case <expr><name>EINTR</name></expr>:
  </case><case>case <expr><name>ENOLCK</name></expr>:  
    <comment type="block">/* random NFS retry error, unless during file system support 
     * introspection, in which it actually means what it says */</comment>
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    
  </case><case>case <expr><name>EACCES</name></expr>: 
    <comment type="block">/* EACCES is like EAGAIN during locking operations, but not any other time*/</comment>
    <if>if<condition>( <expr>(<name>sqliteIOErr</name> == <name>SQLITE_IOERR_LOCK</name>) || 
	(<name>sqliteIOErr</name> == <name>SQLITE_IOERR_UNLOCK</name>) || 
	(<name>sqliteIOErr</name> == <name>SQLITE_IOERR_RDLOCK</name>) ||
	(<name>sqliteIOErr</name> == <name>SQLITE_IOERR_CHECKRESERVEDLOCK</name>)</expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* else fall through */</comment>
  </case><case>case <expr><name>EPERM</name></expr>: 
    <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
    
  </case><case>case <expr><name>EDEADLK</name></expr>:
    <return>return <expr><name>SQLITE_IOERR_BLOCKED</name></expr>;</return>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EOPNOTSUPP</name>!=<name>ENOTSUP</name></expr></cpp:if>
  </case><case>case <expr><name>EOPNOTSUPP</name></expr>: 
    <comment type="block">/* something went terribly awry, unless during file system support 
     * introspection, in which it actually means what it says */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENOTSUP</name></cpp:ifdef>
  </case><case>case <expr><name>ENOTSUP</name></expr>: 
    <comment type="block">/* invalid fd, unless during file system support introspection, in which 
     * it actually means what it says */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </case><case>case <expr><name>EIO</name></expr>:
  </case><case>case <expr><name>EBADF</name></expr>:
  </case><case>case <expr><name>EINVAL</name></expr>:
  </case><case>case <expr><name>ENOTCONN</name></expr>:
  </case><case>case <expr><name>ENODEV</name></expr>:
  </case><case>case <expr><name>ENXIO</name></expr>:
  </case><case>case <expr><name>ENOENT</name></expr>:
  </case><case>case <expr><name>ESTALE</name></expr>:
  </case><case>case <expr><name>ENOSYS</name></expr>:
    <comment type="block">/* these should force the client to close the file and reconnect */</comment>
    
  </case><default>default: 
    <return>return <expr><name>sqliteIOErr</name></expr>;</return>
  </default>}</block></switch>
}</block></function>



<comment type="block">/******************************************************************************
****************** Begin Unique File ID Utility Used By VxWorks ***************
**
** On most versions of unix, we can get a unique ID for a file by concatenating
** the device number and the inode number.  But this does not work on VxWorks.
** On VxWorks, a unique file id must be based on the canonical filename.
**
** A pointer to an instance of the following structure can be used as a
** unique file ID in VxWorks.  Each instance of this structure contains
** a copy of the canonical filename.  There is also a reference count.  
** The structure is reclaimed when the number of pointers to it drops to
** zero.
**
** There are never very many files open at one time and lookups are not
** a performance-critical path, so it is sufficient to put these
** structures on a linked list.
*/</comment>
<struct>struct <name>vxworksFileId</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>vxworksFileId</name> *</type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next in a list of them all */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                     <comment type="block">/* Number of references to this one */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                    <comment type="block">/* Length of the zCanonicalName[] string */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zCanonicalName</name></decl>;</decl_stmt>         <comment type="block">/* Canonical filename */</comment>
</public>}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<comment type="block">/* 
** All unique filenames are held on a linked list headed by this
** variable:
*/</comment>
<decl_stmt><decl><type><name>static</name> struct <name>vxworksFileId</name> *</type><name>vxworksFileList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Simplify a filename into its canonical form
** by making the following changes:
**
**  * removing any trailing and duplicate /
**  * convert /./ into just /
**  * convert /A/../ where A is any simple name into just /
**
** Changes are made in-place.  Return the new name length.
**
** The original filename is in z[0..n-1].  Return the number of
** characters in the simplified name.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>vxworksSimplifyName</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>n</name>&gt;1 &amp;&amp; <name><name>z</name><index>[<expr><name>n</name>-1</expr>]</index></name>=='/'</expr> )</condition><block>{ <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt> }</block></while>
  <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name>=='/'</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>=='/'</expr> )</condition><then> <continue>continue;</continue></then></if>
      <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>=='.' &amp;&amp; <name>i</name>+2&lt;<name>n</name> &amp;&amp; <name><name>z</name><index>[<expr><name>i</name>+2</expr>]</index></name>=='/'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>i</name> += 1</expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>
      <if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name>+1</expr>]</index></name>=='.' &amp;&amp; <name>i</name>+3&lt;<name>n</name> &amp;&amp; <name><name>z</name><index>[<expr><name>i</name>+2</expr>]</index></name>=='.' &amp;&amp; <name><name>z</name><index>[<expr><name>i</name>+3</expr>]</index></name>=='/'</expr> )</condition><then><block>{
        <while>while<condition>( <expr><name>j</name>&gt;0 &amp;&amp; <name><name>z</name><index>[<expr><name>j</name>-1</expr>]</index></name>!='/'</expr> )</condition><block>{ <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr><name>j</name>&gt;0</expr> )</condition><then><block>{ <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt> }</block></then></if>
        <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
        <continue>continue;</continue>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>j</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Find a unique file ID for the given absolute pathname.  Return
** a pointer to the vxworksFileId object.  This pointer is the unique
** file ID.
**
** The nRef field of the vxworksFileId object is incremented before
** the object is returned.  A new vxworksFileId object is created
** and added to the global list if necessary.
**
** If a memory allocation error occurs, return NULL.
*/</comment>
<function><type><name>static</name> struct <name>vxworksFileId</name> *</type><name>vxworksFindFileId</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zAbsoluteName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>vxworksFileId</name> *</type><name>pNew</name></decl>;</decl_stmt>         <comment type="block">/* search key and new file ID */</comment>
  <decl_stmt><decl><type>struct <name>vxworksFileId</name> *</type><name>pCandidate</name></decl>;</decl_stmt>   <comment type="block">/* For looping over existing file IDs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>                              <comment type="block">/* Length of zAbsoluteName string */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zAbsoluteName</name><index>[<expr>0</expr>]</index></name>=='/'</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>zAbsoluteName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call> + (<name>n</name>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zCanonicalName</name> = (<name>char</name>*)&amp;<name><name>pNew</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zCanonicalName</name></expr></argument>, <argument><expr><name>zAbsoluteName</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>vxworksSimplifyName</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zCanonicalName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Search for an existing entry that matching the canonical name.
  ** If found, increment the reference count and return a pointer to
  ** the existing file ID.
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>pCandidate</name>=<name>vxworksFileList</name></expr>;</init> <condition><expr><name>pCandidate</name></expr>;</condition> <incr><expr><name>pCandidate</name>=<name>pCandidate</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>pCandidate</name>-&gt;<name>nName</name>==<name>n</name> 
     &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>pCandidate</name>-&gt;<name>zCanonicalName</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>zCanonicalName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr>
    )</condition><then><block>{
       <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>pCandidate</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
       <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <return>return <expr><name>pCandidate</name></expr>;</return>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* No match was found.  We will make a new file ID */</comment>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nName</name> = <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pNext</name> = <name>vxworksFileList</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>vxworksFileList</name> = <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Decrement the reference count on a vxworksFileId object.  Free
** the object when the reference count reaches zero.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>vxworksReleaseFileId</name><parameter_list>(<param><decl><type>struct <name>vxworksFileId</name> *</type><name>pId</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pId</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pId</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pId</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>vxworksFileId</name> **</type><name>pp</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>pp</name>=&amp;<name>vxworksFileList</name></expr>;</init> <condition><expr>*<name>pp</name> &amp;&amp; *<name>pp</name>!=<name>pId</name></expr>;</condition> <incr><expr><name>pp</name> = &amp;((*<name>pp</name>)-&gt;<name>pNext</name>)</expr></incr>)<block>{}</block></for>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>*<name>pp</name>==<name>pId</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pp</name> = <name>pId</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>
<comment type="block">/*************** End of Unique File ID Utility Used By VxWorks ****************
******************************************************************************/</comment>


<comment type="block">/******************************************************************************
*************************** Posix Advisory Locking ****************************
**
** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)
** section 6.5.2.2 lines 483 through 490 specify that when a process
** sets or clears a lock, that operation overrides any prior locks set
** by the same process.  It does not explicitly say so, but this implies
** that it overrides locks set by the same process using a different
** file descriptor.  Consider this test case:
**
**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);
**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);
**
** Suppose ./file1 and ./file2 are really the same file (because
** one is a hard or symbolic link to the other) then if you set
** an exclusive lock on fd1, then try to get an exclusive lock
** on fd2, it works.  I would have expected the second lock to
** fail since there was already a lock on the file due to fd1.
** But not so.  Since both locks came from the same process, the
** second overrides the first, even though they were on different
** file descriptors opened on different file names.
**
** This means that we cannot use POSIX locks to synchronize file access
** among competing threads of the same process.  POSIX locks will work fine
** to synchronize access for threads in separate processes, but not
** threads within the same process.
**
** To work around the problem, SQLite has to manage file locks internally
** on its own.  Whenever a new database is opened, we have to find the
** specific inode of the database file (the inode is determined by the
** st_dev and st_ino fields of the stat structure that fstat() fills in)
** and check for locks already existing on that inode.  When locks are
** created or removed, we have to look at our own internal record of the
** locks to see if another thread has previously set a lock on that same
** inode.
**
** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.
** For VxWorks, we have to use the alternative unique ID system based on
** canonical filename and implemented in the previous division.)
**
** The sqlite3_file structure for POSIX is no longer just an integer file
** descriptor.  It is now a structure that holds the integer file
** descriptor and a pointer to a structure that describes the internal
** locks on the corresponding inode.  There is one locking structure
** per inode, so if the same inode is opened twice, both unixFile structures
** point to the same locking structure.  The locking structure keeps
** a reference count (so we will know when to delete it) and a "cnt"
** field that tells us its internal lock status.  cnt==0 means the
** file is unlocked.  cnt==-1 means the file has an exclusive lock.
** cnt&gt;0 means there are cnt shared locks on the file.
**
** Any attempt to lock or unlock a file first checks the locking
** structure.  The fcntl() system call is only invoked to set a 
** POSIX lock if the internal lock structure transitions between
** a locked and an unlocked state.
**
** But wait:  there are yet more problems with POSIX advisory locks.
**
** If you close a file descriptor that points to a file that has locks,
** all locks on that file that are owned by the current process are
** released.  To work around this problem, each unixFile structure contains
** a pointer to an unixOpenCnt structure.  There is one unixOpenCnt structure
** per open inode, which means that multiple unixFile can point to a single
** unixOpenCnt.  When an attempt is made to close an unixFile, if there are
** other unixFile open on the same inode that are holding locks, the call
** to close() the file descriptor is deferred until all of the locks clear.
** The unixOpenCnt structure keeps a list of file descriptors that need to
** be closed and that list is walked (and cleared) when the last lock
** clears.
**
** Yet another problem:  LinuxThreads do not play well with posix locks.
**
** Many older versions of linux use the LinuxThreads library which is
** not posix compliant.  Under LinuxThreads, a lock created by thread
** A cannot be modified or overridden by a different thread B.
** Only thread A can modify the lock.  Locking behavior is correct
** if the appliation uses the newer Native Posix Thread Library (NPTL)
** on linux - with NPTL a lock created by thread A can override locks
** in thread B.  But there is no way to know at compile-time which
** threading library is being used.  So there is no way to know at
** compile-time whether or not thread A can override locks on thread B.
** We have to do a run-time check to discover the behavior of the
** current process.
**
** On systems where thread A is unable to modify locks created by
** thread B, we have to keep track of which thread created each
** lock.  Hence there is an extra field in the key to the unixLockInfo
** structure to record this information.  And on those systems it
** is illegal to begin a transaction in one thread and finish it
** in another.  For this latter restriction, there is no work-around.
** It is a limitation of LinuxThreads.
*/</comment>

<comment type="block">/*
** Set or check the unixFile.tid field.  This field is set when an unixFile
** is first opened.  All subsequent uses of the unixFile verify that the
** same thread is operating on the unixFile.  Some operating systems do
** not allow locks to be overridden by other threads and that restriction
** means that sqlite3* database handles cannot be moved from one thread
** to another while locks are held.
**
** Version 3.3.1 (2006-01-15):  unixFile can be moved from one thread to
** another as long as we are running on a system that supports threads
** overriding each others locks (which is now the most common behavior)
** or if no locks are held.  But the unixFile.pLock field needs to be
** recomputed because its key includes the thread-id.  See the 
** transferOwnership() function below for additional information
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SET_THREADID</name>(X)   (X)-&gt;tid = pthread_self()</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CHECK_THREADID</name>(X) (threadsOverrideEachOthersLocks==0 &amp;&amp; \
                            !pthread_equal((X)-&gt;tid, pthread_self()))</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SET_THREADID</name>(X)</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>CHECK_THREADID</name>(X) 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** An instance of the following structure serves as the key used
** to locate a particular unixOpenCnt structure given its inode.  This
** is the same as the unixLockKey except that the thread ID is omitted.
*/</comment>
<struct>struct <name>unixFileId</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>dev_t</name></type> <name>dev</name></decl>;</decl_stmt>                  <comment type="block">/* Device number */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type>struct <name>vxworksFileId</name> *</type><name>pId</name></decl>;</decl_stmt>  <comment type="block">/* Unique file ID for vxworks. */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>ino_t</name></type> <name>ino</name></decl>;</decl_stmt>                  <comment type="block">/* Inode number */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<comment type="block">/*
** An instance of the following structure serves as the key used
** to locate a particular unixLockInfo structure given its inode.
**
** If threads cannot override each others locks (LinuxThreads), then we
** set the unixLockKey.tid field to the thread ID.  If threads can override
** each others locks (Posix and NPTL) then tid is always set to zero.
** tid is omitted if we compile without threading support or on an OS
** other than linux.
*/</comment>
<struct>struct <name>unixLockKey</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>unixFileId</name></type> <name>fid</name></decl>;</decl_stmt>  <comment type="block">/* Unique identifier for the file */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>tid</name></decl>;</decl_stmt>  <comment type="block">/* Thread ID of lock owner. Zero if not using LinuxThreads */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</public>}</block>;</struct>

<comment type="block">/*
** An instance of the following structure is allocated for each open
** inode.  Or, on LinuxThreads, there is one of these structures for
** each inode opened by each thread.
**
** A single inode can have multiple file descriptors, so each unixFile
** structure contains a pointer to an instance of this object and this
** object keeps a count of the number of unixFile pointing to it.
*/</comment>
<struct>struct <name>unixLockInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>unixLockKey</name></type> <name>lockKey</name></decl>;</decl_stmt>     <comment type="block">/* The lookup key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>                        <comment type="block">/* Number of SHARED locks held */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>locktype</name></decl>;</decl_stmt>                   <comment type="block">/* One of SHARED_LOCK, RESERVED_LOCK etc. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                       <comment type="block">/* Number of pointers to this structure */</comment>
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pNext</name></decl>;</decl_stmt>     <comment type="block">/* List of all unixLockInfo objects */</comment>
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pPrev</name></decl>;</decl_stmt>     <comment type="block">/*    .... doubly linked */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** An instance of the following structure is allocated for each open
** inode.  This structure keeps track of the number of locks on that
** inode.  If a close is attempted against an inode that is holding
** locks, the close is deferred until all locks clear by adding the
** file descriptor to be closed to the pending list.
**
** TODO:  Consider changing this so that there is only a single file
** descriptor for each open file, even when it is opened multiple times.
** The close() system call would only occur when the last database
** using the file closes.
*/</comment>
<struct>struct <name>unixOpenCnt</name> <block>{<public type="default">
  <decl_stmt><decl><type>struct <name>unixFileId</name></type> <name>fileId</name></decl>;</decl_stmt>   <comment type="block">/* The lookup key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                   <comment type="block">/* Number of pointers to this structure */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLock</name></decl>;</decl_stmt>                  <comment type="block">/* Number of outstanding locks */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPending</name></decl>;</decl_stmt>               <comment type="block">/* Number of pending close() operations */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aPending</name></decl>;</decl_stmt>            <comment type="block">/* Malloced space holding fd's awaiting a close() */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>sem_t</name> *</type><name>pSem</name></decl>;</decl_stmt>                     <comment type="block">/* Named POSIX semaphore */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>aSemName</name><index>[<expr><name>MAX_PATHNAME</name>+1</expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* Name of that semaphore */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pNext</name>, *<name>pPrev</name></decl>;</decl_stmt>   <comment type="block">/* List of all unixOpenCnt objects */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Lists of all unixLockInfo and unixOpenCnt objects.  These used to be hash
** tables.  But the number of objects is rarely more than a dozen and
** never exceeds a few thousand.  And lookup is not on a critical
** path so a simple linked list will suffice.
*/</comment>
<decl_stmt><decl><type><name>static</name> struct <name>unixLockInfo</name> *</type><name>lockList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>static</name> struct <name>unixOpenCnt</name> *</type><name>openList</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/*
** This variable remembers whether or not threads can override each others
** locks.
**
**    0:  No.  Threads cannot override each others locks.  (LinuxThreads)
**    1:  Yes.  Threads can override each others locks.  (Posix &amp; NLPT)
**   -1:  We don't know yet.
**
** On some systems, we know at compile-time if threads can override each
** others locks.  On those systems, the SQLITE_THREAD_OVERRIDE_LOCK macro
** will be set appropriately.  On other systems, we have to check at
** runtime.  On these latter systems, SQLTIE_THREAD_OVERRIDE_LOCK is
** undefined.
**
** This variable normally has file scope only.  But during testing, we make
** it a global so that the test code can change its value in order to verify
** that the right stuff happens in either case.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>SQLITE_THREAD_OVERRIDE_LOCK</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <name>SQLITE_THREAD_OVERRIDE_LOCK</name> -1</cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>threadsOverrideEachOthersLocks</name> =<init> <expr><name>SQLITE_THREAD_OVERRIDE_LOCK</name></expr></init></decl>;</decl_stmt>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>threadsOverrideEachOthersLocks</name> =<init> <expr><name>SQLITE_THREAD_OVERRIDE_LOCK</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This structure holds information passed into individual test
** threads by the testThreadLockingBehavior() routine.
*/</comment>
<struct>struct <name>threadTestData</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                <comment type="block">/* File to be locked */</comment>
  <decl_stmt><decl><type>struct <name>flock</name></type> <name>lock</name></decl>;</decl_stmt>     <comment type="block">/* The locking operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>            <comment type="block">/* Result of the locking operation */</comment>
</public>}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This function is used as the main routine for a thread launched by
** testThreadLockingBehavior(). It tests whether the shared-lock obtained
** by the main thread in testThreadLockingBehavior() conflicts with a
** hypothetical write-lock obtained by this thread on the same file.
**
** The write-lock is not actually acquired, as this is not possible if 
** the file is open in read-only mode (see ticket #3472).
*/</comment> 
<function><type><name>static</name> <name>void</name> *</type><name>threadLockingTest</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>threadTestData</name> *</type><name>pData</name> =<init> <expr>(struct <name>threadTestData</name>*)<name>pArg</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pData</name>-&gt;<name>result</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>pData</name>-&gt;<name>fd</name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr>&amp;<name>pData</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pArg</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_THREADSAFE &amp;&amp; defined(__linux__) */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** This procedure attempts to determine whether or not threads
** can override each others locks then sets the 
** threadsOverrideEachOthersLocks variable appropriately.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>testThreadLockingBehavior</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fd_orig</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>threadTestData</name></type> <name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>flock</name></type> <name>l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>t</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>fd</name> = <call><name>dup</name><argument_list>(<argument><expr><name>fd_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>l</name>.<name>l_type</name> = <name>F_RDLCK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>l</name>.<name>l_len</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>l</name>.<name>l_start</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>l</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd_orig</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name>.<name>fd</name> = <name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name>.<name>lock</name> = <name>l</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name>.<name>lock</name>.<name>l_type</name> = <name>F_WRLCK</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_create</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>threadLockingTest</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>d</name>.<name>result</name>!=0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>threadsOverrideEachOthersLocks</name> = (<name>d</name>.<name>lock</name>.<name>l_type</name>==<name>F_UNLCK</name>)</expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_THERADSAFE &amp;&amp; defined(__linux__) */</comment>

<comment type="block">/*
** Release a unixLockInfo structure previously allocated by findLockInfo().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>releaseLockInfo</name><parameter_list>(<param><decl><type>struct <name>unixLockInfo</name> *</type><name>pLock</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLock</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLock</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pLock</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name>==<name>pLock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLock</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>pLock</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>lockList</name>==<name>pLock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lockList</name> = <name>pLock</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>pLock</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name>==<name>pLock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pLock</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>pLock</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Release a unixOpenCnt structure previously allocated by findLockInfo().
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>releaseOpenCnt</name><parameter_list>(<param><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pOpen</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOpen</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOpen</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pOpen</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOpen</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name>==<name>pOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>pOpen</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>openList</name>==<name>pOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>openList</name> = <name>pOpen</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>pOpen</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOpen</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name>==<name>pOpen</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>pOpen</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name>aPending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Given a file descriptor, locate unixLockInfo and unixOpenCnt structures that
** describes that file descriptor.  Create new ones if necessary.  The
** return values might be uninitialized if an error occurs.
**
** Return an appropriate error code.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>findLockInfo</name><parameter_list>(
  <param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>,               <comment type="block">/* Unix file with file desc used in the key */</comment>
  <param><decl><type>struct <name>unixLockInfo</name> **</type><name>ppLock</name></decl></param>,  <comment type="block">/* Return the unixLockInfo structure here */</comment>
  <param><decl><type>struct <name>unixOpenCnt</name> **</type><name>ppOpen</name></decl></param>    <comment type="block">/* Return the unixOpenCnt structure here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                        <comment type="block">/* System call return code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                        <comment type="block">/* The file descriptor for pFile */</comment>
  <decl_stmt><decl><type>struct <name>unixLockKey</name></type> <name>lockKey</name></decl>;</decl_stmt>    <comment type="block">/* Lookup key for the unixLockInfo structure */</comment>
  <decl_stmt><decl><type>struct <name>unixFileId</name></type> <name>fileId</name></decl>;</decl_stmt>      <comment type="block">/* Lookup key for the unixOpenCnt struct */</comment>
  <decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>           <comment type="block">/* Low-level file information */</comment>
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pLock</name></decl>;</decl_stmt>    <comment type="block">/* Candidate unixLockInfo object */</comment>
  <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name></decl>;</decl_stmt>     <comment type="block">/* Candidate unixOpenCnt object */</comment>

  <comment type="block">/* Get low-level information about the file that we can used to
  ** create a unique name for the file.
  */</comment>
  <expr_stmt><expr><name>fd</name> = <name>pFile</name>-&gt;<name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EOVERFLOW</name></cpp:ifdef>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>lastErrno</name>==<name>EOVERFLOW</name></expr> )</condition><then> <return>return <expr><name>SQLITE_NOLFS</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* On OS X on an msdos filesystem, the inode number is reported
  ** incorrectly for zero-size files.  See ticket #3260.  To work
  ** around this problem (we consider it a bug in OS X, not SQLite)
  ** we always increase the file size to 1 by writing a single byte
  ** prior to accessing the inode number.  The one byte written is
  ** an ASCII 'S' character which also happens to be the first byte
  ** in the header of every SQLite database.  In this way, if there
  ** is a race condition such that another thread has already populated
  ** the first page of the database, no damage is done.
  */</comment>
  <if>if<condition>( <expr><name>statbuf</name>.<name>st_size</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>"S"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>lockKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>lockKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lockKey</name>.<name>fid</name>.<name>dev</name> = <name>statbuf</name>.<name>st_dev</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <expr_stmt><expr><name>lockKey</name>.<name>fid</name>.<name>pId</name> = <name>pFile</name>-&gt;<name>pId</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>lockKey</name>.<name>fid</name>.<name>ino</name> = <name>statbuf</name>.<name>st_ino</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if<condition>( <expr><name>threadsOverrideEachOthersLocks</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>testThreadLockingBehavior</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>lockKey</name>.<name>tid</name> = <name>threadsOverrideEachOthersLocks</name> ? 0 : <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>fileId</name> = <name>lockKey</name>.<name>fid</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>ppLock</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLock</name> = <name>lockList</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pLock</name> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>lockKey</name></expr></argument>, <argument><expr>&amp;<name>pLock</name>-&gt;<name>lockKey</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>lockKey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>pLock</name> = <name>pLock</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></while>
    <if>if<condition>( <expr><name>pLock</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pLock</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pLock</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pLock</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>exit_findlockinfo</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>lockKey</name> = <name>lockKey</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>cnt</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>locktype</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>pNext</name> = <name>lockList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>lockList</name></expr> )</condition><then> <expr_stmt><expr><name>lockList</name>-&gt;<name>pPrev</name> = <name>pLock</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>lockList</name> = <name>pLock</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pLock</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr>*<name>ppLock</name> = <name>pLock</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>ppOpen</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pOpen</name> = <name>openList</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pOpen</name> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name>fileId</name></expr></argument>, <argument><expr>&amp;<name>pOpen</name>-&gt;<name>fileId</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>fileId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr><name>pOpen</name> = <name>pOpen</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></while>
    <if>if<condition>( <expr><name>pOpen</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pOpen</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pOpen</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOpen</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>releaseLockInfo</name><argument_list>(<argument><expr><name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <goto>goto <name>exit_findlockinfo</name>;</goto>
      }</block></then></if>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>fileId</name> = <name>fileId</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nLock</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nPending</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>aPending</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>pNext</name> = <name>openList</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>openList</name></expr> )</condition><then> <expr_stmt><expr><name>openList</name>-&gt;<name>pPrev</name> = <name>pOpen</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>openList</name> = <name>pOpen</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>pSem</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name><name>aSemName</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr>*<name>ppOpen</name> = <name>pOpen</name></expr>;</expr_stmt>
  }</block></then></if>

<label><name>exit_findlockinfo</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If we are currently in a different thread than the thread that the
** unixFile argument belongs to, then transfer ownership of the unixFile
** over to the current thread.
**
** A unixFile is only owned by a thread on systems that use LinuxThreads.
**
** Ownership transfer is only allowed if the unixFile is currently unlocked.
** If the unixFile is locked and an ownership is wrong, then return
** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>static</name> <name>int</name></type> <name>transferOwnership</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pthread_t</name></type> <name>hSelf</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>threadsOverrideEachOthersLocks</name></expr> )</condition><then><block>{
    <comment type="block">/* Ownership transfers not needed on this system */</comment>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>hSelf</name> = <call><name>pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>pthread_equal</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>tid</name></expr></argument>, <argument><expr><name>hSelf</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <comment type="block">/* We are still in the same thread */</comment>
    <expr_stmt><expr><call><name>OSTRACE1</name><argument_list>(<argument><expr>"No-transfer, same thread\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name></expr> )</condition><then><block>{
    <comment type="block">/* We cannot change ownership while we are holding a lock! */</comment>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"Transfer ownership of %d from %d to %d\n"</expr></argument>,
            <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>tid</name></expr></argument>, <argument><expr><name>hSelf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>tid</name> = <name>hSelf</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>pFile</name>-&gt;<name>pLock</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>releaseLockInfo</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>findLockInfo</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr>&amp;<name>pFile</name>-&gt;<name>pLock</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"LOCK    %d is now %s(%s,%d)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pLock</name>-&gt;<name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>pLock</name>-&gt;<name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then> <else>else <block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></else></if>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* if not SQLITE_THREADSAFE */</comment>
  <comment type="block">/* On single-threaded builds, ownership transfer is a no-op */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <name>transferOwnership</name>(X) SQLITE_OK</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_THREADSAFE */</comment>


<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Because pFile-&gt;pLock is shared across threads */</comment>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pLock</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Otherwise see if some other process holds it.
  */</comment>
  <if>if<condition>( <expr>!<name>reserved</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>flock</name></type> <name>lock</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_len</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_WRLCK</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>-1 == <call><name>fcntl</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if<condition>( <expr><name>lock</name>.<name>l_type</name>!=<name>F_UNLCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TEST WR-LOCK %d %d %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>pResOut</name> = <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* The following describes the implementation of the various locks and
  ** lock transitions in terms of the POSIX advisory shared and exclusive
  ** lock primitives (called read-locks and write-locks below, to avoid
  ** confusion with SQLite lock names). The algorithms are complicated
  ** slightly in order to be compatible with windows systems simultaneously
  ** accessing the same database file, in case that is ever required.
  **
  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved
  ** byte', each single bytes at well known offsets, and the 'shared byte
  ** range', a range of 510 bytes at a well known offset.
  **
  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending
  ** byte'.  If this is successful, a random byte from the 'shared byte
  ** range' is read-locked and the lock on the 'pending byte' released.
  **
  ** A process may only obtain a RESERVED lock after it has a SHARED lock.
  ** A RESERVED lock is implemented by grabbing a write-lock on the
  ** 'reserved byte'. 
  **
  ** A process may only obtain a PENDING lock after it has obtained a
  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock
  ** on the 'pending byte'. This ensures that no new SHARED locks can be
  ** obtained, but existing SHARED locks are allowed to persist. A process
  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.
  ** This property is used by the algorithm for rolling back a journal file
  ** after a crash.
  **
  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is
  ** implemented by obtaining a write-lock on the entire 'shared byte
  ** range'. Since all other locks require a read-lock on one of the bytes
  ** within this range, this ensures that no other locks are held on the
  ** database. 
  **
  ** The reason a single byte cannot be used instead of the 'shared byte
  ** range' is that some versions of windows do not support read-locks. By
  ** locking a random byte from a range, concurrent SHARED locks may exist
  ** even if the locking primitive used is always a write-lock.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pLock</name> =<init> <expr><name>pFile</name>-&gt;<name>pLock</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>flock</name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE7</name><argument_list>(<argument><expr>"LOCK    %d %s was %s(%s,%d) pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
      <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>pLock</name>-&gt;<name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pLock</name>-&gt;<name>cnt</name></expr></argument> , <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>locktype</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"LOCK    %d %s ok (already held)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
            <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Make sure the locking sequence is correct
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name> || <name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>RESERVED_LOCK</name> || <name>pFile</name>-&gt;<name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This mutex is needed because pFile-&gt;pLock is shared across threads
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure the current thread owns the pFile.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>transferOwnership</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pLock</name> = <name>pFile</name>-&gt;<name>pLock</name></expr>;</expr_stmt>

  <comment type="block">/* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */</comment>
  <if>if<condition>( <expr>(<name>pFile</name>-&gt;<name>locktype</name>!=<name>pLock</name>-&gt;<name>locktype</name> &amp;&amp; 
          (<name>pLock</name>-&gt;<name>locktype</name>&gt;=<name>PENDING_LOCK</name> || <name>locktype</name>&gt;<name>SHARED_LOCK</name>))</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  }</block></then></if>

  <comment type="block">/* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return SQLITE_OK.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name> &amp;&amp; 
      (<name>pLock</name>-&gt;<name>locktype</name>==<name>SHARED_LOCK</name> || <name>pLock</name>-&gt;<name>locktype</name>==<name>RESERVED_LOCK</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>cnt</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>cnt</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>nLock</name>++</expr>;</expr_stmt>
    <goto>goto <name>end_lock</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><name>lock</name>.<name>l_len</name> = 1L</expr>;</expr_stmt>

  <expr_stmt><expr><name>lock</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>

  <comment type="block">/* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name> 
      || (<name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>&lt;<name>PENDING_LOCK</name>)</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>lock</name>.<name>l_type</name> = (<name>locktype</name>==<name>SHARED_LOCK</name>?<name>F_RDLCK</name>:<name>F_WRLCK</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>s</name>==(-1)</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then></if>
      <goto>goto <name>end_lock</name>;</goto>
    }</block></then></if>
  }</block></then></if>


  <comment type="block">/* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>cnt</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>locktype</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now get the read-lock */</comment>
    <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_len</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>s</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>)==(-1)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>tErrno</name> = <name>errno</name></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* Drop the temporary PENDING lock */</comment>
    <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_len</name> = 1L</expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_UNLCK</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>s</name> != -1</expr> )</condition><then><block>{
        <comment type="block">/* This could happen with a network mount */</comment>
        <expr_stmt><expr><name>tErrno</name> = <name>errno</name></expr>;</expr_stmt> 
        <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
        }</block></then></if>
        <goto>goto <name>end_lock</name>;</goto>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>s</name>==(-1)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>nLock</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>pLock</name>-&gt;<name>cnt</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>pLock</name>-&gt;<name>cnt</name>&gt;1</expr> )</condition><then><block>{
    <comment type="block">/* We are trying for an exclusive lock but another thread in this
    ** same process is still holding a shared lock. */</comment>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0!=<name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_WRLCK</name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>locktype</name></expr> )</condition><block>{
      <case>case <expr><name>RESERVED_LOCK</name></expr>:
        <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>RESERVED_BYTE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>EXCLUSIVE_LOCK</name></expr>:
        <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lock</name>.<name>l_len</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><name>s</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>s</name>==(-1)</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></else></if></else></if>
  

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* Set up the transaction-counter change checking flags when
  ** transitioning from a SHARED to a RESERVED lock.  The change
  ** from SHARED to RESERVED marks the beginning of a normal
  ** write operation (not a hot journal rollback).
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name>
   &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>&lt;=<name>SHARED_LOCK</name>
   &amp;&amp; <name>locktype</name>==<name>RESERVED_LOCK</name></expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>transCntrChng</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>dbUpdate</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>inNormalWrite</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>locktype</name>==<name>EXCLUSIVE_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>locktype</name> = <name>PENDING_LOCK</name></expr>;</expr_stmt>
  }</block></then></if></else></if>

<label><name>end_lock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"LOCK    %d %s %s\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, 
      <argument><expr><name>rc</name>==<name>SQLITE_OK</name> ? "ok" : "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>unixLockInfo</name> *</type><name>pLock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>flock</name></type> <name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE7</name><argument_list>(<argument><expr>"UNLOCK  %d %d was %d(%d,%d) pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>,
      <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>pLock</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>pLock</name>-&gt;<name>cnt</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&lt;=<name>locktype</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>CHECK_THREADID</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>h</name> = <name>pFile</name>-&gt;<name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pLock</name> = <name>pFile</name>-&gt;<name>pLock</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>cnt</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pLock</name>-&gt;<name>locktype</name>==<name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>SimulateIOError</name><argument_list>( <argument>h=(-1)</argument> )</argument_list></macro>
    <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <comment type="block">/* When reducing a lock such that other processes can start
    ** reading the database file again, make sure that the
    ** transaction counter was updated if any part of the database
    ** file changed.  If the transaction counter is not updated,
    ** other connections to the same file might not realize that
    ** the file has changed and hence might not know to flush their
    ** cache.  The use of a stale cache can lead to database corruption.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>inNormalWrite</name>==0
         || <name>pFile</name>-&gt;<name>dbUpdate</name>==0
         || <name>pFile</name>-&gt;<name>transCntrChng</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>inNormalWrite</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_RDLCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>SHARED_FIRST</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock</name>.<name>l_len</name> = <name>SHARED_SIZE</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>==(-1)</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_RDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
        }</block></then></if>
				<goto>goto <name>end_unlock</name>;</goto>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_UNLCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>PENDING_BYTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lock</name>.<name>l_len</name> = 2L</expr>;</expr_stmt>  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>PENDING_BYTE</name>+1==<name>RESERVED_BYTE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>!=(-1)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pLock</name>-&gt;<name>locktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then></if>
			<goto>goto <name>end_unlock</name>;</goto>
    }</block></else></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>locktype</name>==<name>NO_LOCK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name></decl>;</decl_stmt>

    <comment type="block">/* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */</comment>
    <expr_stmt><expr><name>pLock</name>-&gt;<name>cnt</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pLock</name>-&gt;<name>cnt</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>lock</name>.<name>l_type</name> = <name>F_UNLCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock</name>.<name>l_start</name> = <name>lock</name>.<name>l_len</name> = 0L</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <macro><name>SimulateIOError</name><argument_list>( <argument>h=(-1)</argument> )</argument_list></macro>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>F_SETLK</name></expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>!=(-1)</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pLock</name>-&gt;<name>locktype</name> = <name>NO_LOCK</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>pLock</name>-&gt;<name>cnt</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>end_unlock</name>;</goto>
      }</block></else></if>
    }</block></then></if>

    <comment type="block">/* Decrement the count of locks against this same file.  When the
    ** count reaches zero, close any other file descriptors whose close
    ** was deferred because of outstanding locks.
    */</comment>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pOpen</name> = <name>pFile</name>-&gt;<name>pOpen</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nLock</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOpen</name>-&gt;<name>nLock</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOpen</name>-&gt;<name>nLock</name>==0 &amp;&amp; <name>pOpen</name>-&gt;<name>nPending</name>&gt;0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pOpen</name>-&gt;<name>nPending</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <comment type="block">/* close pending fds, but if closing fails don't free the array
          ** assign -1 to the successfully closed descriptors and record the
          ** error.  The next attempt to unlock will try again. */</comment>
          <if>if<condition>( <expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name> &lt; 0</expr> )</condition><then> <continue>continue;</continue></then></if>
          <if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_CLOSE</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
          }</block></else></if>
        }</block></for>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name>aPending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOpen</name>-&gt;<name>nPending</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>pOpen</name>-&gt;<name>aPending</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
	
<label><name>end_unlock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then> <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function performs the parts of the "close file" operation 
** common to all locking schemes. It closes the directory and file
** handles, if they are valid, and sets all fields of the unixFile
** structure to 0.
**
** It is *not* necessary to hold the mutex when this routine is called,
** even on VxWorks.  A mutex will be acquired on VxWorks by the
** vxworksReleaseFileId() routine.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>closeUnixFile</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pFile</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>dirfd</name>&gt;=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> =<init> <expr><call><name>close</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>dirfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>err</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_IOERR_DIR_CLOSE</name></expr>;</return>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>dirfd</name>=-1</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>h</name>&gt;=0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> =<init> <expr><call><name>close</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>err</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_IOERR_CLOSE</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pId</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pFile</name>-&gt;<name>isDelete</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pId</name>-&gt;<name>zCanonicalName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>vxworksReleaseFileId</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>pId</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>(<argument><expr>"CLOSE   %-3d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name> *)<name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>unixUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pOpen</name> &amp;&amp; <name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>nLock</name></expr> )</condition><then><block>{
      <comment type="block">/* If there are outstanding locks, do not actually close the file just
      ** yet because that would clear those locks.  Instead, add the file
      ** descriptor to pOpen-&gt;aPending.  It will be automatically closed when
      ** the last lock is cleared.
      */</comment>
      <decl_stmt><decl><type><name>int</name> *</type><name>aNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>aNew</name> = <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name>aPending</name></expr></argument>, <argument><expr>(<name>pOpen</name>-&gt;<name>nPending</name>+1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>aNew</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* If a malloc fails, just leak the file descriptor */</comment>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>aPending</name> = <name>aNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>pOpen</name>-&gt;<name>nPending</name></expr>]</index></name> = <name>pFile</name>-&gt;<name>h</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>nPending</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>pFile</name>-&gt;<name>h</name> = -1</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>releaseLockInfo</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseOpenCnt</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/************** End of the posix advisory lock implementation *****************
******************************************************************************/</comment>

<comment type="block">/******************************************************************************
****************************** No-op Locking **********************************
**
** Of the various locking implementations available, this is by far the
** simplest:  locking is ignored.  No attempt is made to lock the database
** file for reading or writing.
**
** This locking mode is appropriate for use on read-only databases
** (ex: databases that are burned into CD-ROM, for example.)  It can
** also be used if the application employs some external mechanism to
** prevent simultaneous access of the same database by two or more
** database connections.  But there is a serious risk of database
** corruption if this locking mode is used in situations where multiple
** database connections are accessing the same database file at the same
** time and one or more of those connections are writing.
*/</comment>

<function><type><name>static</name> <name>int</name></type> <name>nolockCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pResOut</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>nolockLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>NotUsed2</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>nolockUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>NotUsed2</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close the file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>nolockClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <return>return <expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/******************* End of the no-op lock implementation *********************
******************************************************************************/</comment>

<comment type="block">/******************************************************************************
************************* Begin dot-file Locking ******************************
**
** The dotfile locking implementation uses the existing of separate lock
** files in order to control access to the database.  This works on just
** about every filesystem imaginable.  But there are serious downsides:
**
**    (1)  There is zero concurrency.  A single reader blocks all other
**         connections from reading or writing the database.
**
**    (2)  An application crash or power loss can leave stale lock files
**         sitting around that need to be cleared manually.
**
** Nevertheless, a dotlock is an appropriate locking mode for use if no
** other locking strategy is available.
**
** Dotfile locking works by creating a file in the same directory as the
** database and with the same name but with a ".lock" extension added.
** The existance of a lock file implies an EXCLUSIVE lock.  All other lock
** types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.
*/</comment>

<comment type="block">/*
** The file suffix added to the data base filename in order to create the
** lock file.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>DOTLOCK_SUFFIX</name> ".lock"</cpp:define>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
**
** In dotfile locking, either a lock exists or it does not.  So in this
** variation of CheckReservedLock(), *pResOut is set to true if any lock
** is held on the file and false if the file is unlocked.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dotlockCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <comment type="block">/* Either this connection or some other connection in the same process
    ** holds a lock on the file.  No need to check further. */</comment>
    <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* The lock is held if and only if the lockfile exists */</comment>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zLockFile</name> =<init> <expr>(<name>const</name> <name>char</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>reserved</name> = <call><name>access</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>==0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TEST WR-LOCK %d %d %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pResOut</name> = <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
**
** With dotfile locking, we really only support state (4): EXCLUSIVE.
** But we track the other locking levels internally.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dotlockLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zLockFile</name> =<init> <expr>(<name>char</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>


  <comment type="block">/* If we have any lock, then the lock file already exists.  All we have
  ** to do is adjust our internal record of the lock level.
  */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name> &gt; <name>NO_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OS_VXWORKS</name></expr></cpp:if>
    <comment type="block">/* Always update the timestamp on the old file */</comment>
    <expr_stmt><expr><call><name>utimes</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* grab an exclusive lock */</comment>
  <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>,<argument><expr><name>O_RDONLY</name>|<name>O_CREAT</name>|<name>O_EXCL</name></expr></argument>,<argument><expr>0600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
    <comment type="block">/* failed to open/create the file, someone else may have stolen the lock */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>EEXIST</name> == <name>tErrno</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if> 
  <if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_CLOSE</name></expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="block">/* got it, set the type and return ok */</comment>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** When the locking level reaches NO_LOCK, delete the lock file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dotlockUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zLockFile</name> =<init> <expr>(<name>char</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"UNLOCK  %d %d was %d pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>,
	   <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>==<name>locktype</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* To downgrade to shared, simply update our internal notion of the
  ** lock state.  No need to mess with the file on disk.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* To fully unlock the database, delete the lock file */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>==<name>NO_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>unlink</name><argument_list>(<argument><expr><name>zLockFile</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name>, <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>ENOENT</name> != <name>tErrno</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rc</name></expr>;</return> 
  }</block></then></if>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>NO_LOCK</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close a file.  Make sure the lock has been released before closing.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>dotlockClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>dotlockUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>rc</name> = <call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<comment type="block">/****************** End of the dot-file lock implementation *******************
******************************************************************************/</comment>

<comment type="block">/******************************************************************************
************************** Begin flock Locking ********************************
**
** Use the flock() system call to do file locking.
**
** flock() locking is like dot-file locking in that the various
** fine-grain locking levels supported by SQLite are collapsed into
** a single exclusive lock.  In other words, SHARED, RESERVED, and
** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLite
** still works when you do this, but concurrency is reduced since
** only a single process can be reading the database at a time.
**
** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off or if
** compiling for VXWORKS.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; !<name>OS_VXWORKS</name></expr></cpp:if>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>flockCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="block">/* Otherwise see if some other process holds it. */</comment>
  <if>if<condition>( <expr>!<name>reserved</name></expr> )</condition><then><block>{
    <comment type="block">/* attempt to get the lock */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lrc</name> =<init> <expr><call><name>flock</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>LOCK_EX</name> | <name>LOCK_NB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr>!<name>lrc</name></expr> )</condition><then><block>{
      <comment type="block">/* got the lock, unlock it */</comment>
      <expr_stmt><expr><name>lrc</name> = <call><name>flock</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>( <expr><name>lrc</name></expr> )</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* unlock failed with an error */</comment>
        <expr_stmt><expr><name>lrc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> = <name>lrc</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
      <comment type="block">/* someone else might have it reserved */</comment>
      <expr_stmt><expr><name>lrc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>lrc</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TEST WR-LOCK %d %d %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
  <if>if<condition>( <expr>(<name>rc</name> &amp; <name>SQLITE_IOERR</name>) == <name>SQLITE_IOERR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reserved</name>=1</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
  <expr_stmt><expr>*<name>pResOut</name> = <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** flock() only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>flockLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */</comment>
  <if>if <condition>(<expr><name>pFile</name>-&gt;<name>locktype</name> &gt; <name>NO_LOCK</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* grab an exclusive lock */</comment>
  
  <if>if <condition>(<expr><call><name>flock</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>LOCK_EX</name> | <name>LOCK_NB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* didn't get, must be busy */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then> <else>else <block>{
    <comment type="block">/* got it, set the type and return ok */</comment>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"LOCK    %d %s %s\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, 
           <argument><expr><name>rc</name>==<name>SQLITE_OK</name> ? "ok" : "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
  <if>if<condition>( <expr>(<name>rc</name> &amp; <name>SQLITE_IOERR</name>) == <name>SQLITE_IOERR</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>flockUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"UNLOCK  %d %d was %d pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>,
           <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>==<name>locktype</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* shared can just be set because we always have an exclusive */</comment>
  <if>if <condition>(<expr><name>locktype</name>==<name>SHARED_LOCK</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* no, really, unlock. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>flock</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r</name>, <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>r</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_FLOCK_LOCK_ERRORS</name></cpp:ifdef>
    <if>if<condition>( <expr>(<name>r</name> &amp; <name>SQLITE_IOERR</name>) == <name>SQLITE_IOERR</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>r</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */</comment>
    
    <return>return <expr><name>r</name></expr>;</return>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>NO_LOCK</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Close a file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>flockClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>flockUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE &amp;&amp; !OS_VXWORK */</comment>

<comment type="block">/******************* End of the flock lock implementation *********************
******************************************************************************/</comment>

<comment type="block">/******************************************************************************
************************ Begin Named Semaphore Locking ************************
**
** Named semaphore locking is only supported on VxWorks.
**
** Semaphore locking is like dot-lock and flock in that it really only
** supports EXCLUSIVE locking.  Only a single process can read or write
** the database file at a time.  This reduces potential concurrency, but
** makes the lock implementation much easier.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>semCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="block">/* Otherwise see if some other process holds it. */</comment>
  <if>if<condition>( <expr>!<name>reserved</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sem_t</name> *</type><name>pSem</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>stat</name></type> <name>statBuf</name></decl>;</decl_stmt>

    <if>if<condition>( <expr><call><name>sem_trywait</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call>==-1</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>EAGAIN</name> != <name>tErrno</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_CHECKRESERVEDLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <comment type="block">/* someone else has the lock when we are in NO_LOCK */</comment>
        <expr_stmt><expr><name>reserved</name> = (<name>pFile</name>-&gt;<name>locktype</name> &lt; <name>SHARED_LOCK</name>)</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <comment type="block">/* we could have it if we want it */</comment>
      <expr_stmt><expr><call><name>sem_post</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TEST WR-LOCK %d %d %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>pResOut</name> = <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** Semaphore locks only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>semLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sem_t</name> *</type><name>pSem</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */</comment>
  <if>if <condition>(<expr><name>pFile</name>-&gt;<name>locktype</name> &gt; <name>NO_LOCK</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
    <goto>goto <name>sem_end_lock</name>;</goto>
  }</block></then></if>
  
  <comment type="block">/* lock semaphore now but bail out when already locked. */</comment>
  <if>if<condition>( <expr><call><name>sem_trywait</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call>==-1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <goto>goto <name>sem_end_lock</name>;</goto>
  }</block></then></if>

  <comment type="block">/* got it, set the type and return ok */</comment>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>

 <label><name>sem_end_lock</name>:</label>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>semUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sem_t</name> *</type><name>pSem</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"UNLOCK  %d %d was %d pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>,
	   <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* no-op if possible */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>==<name>locktype</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* shared can just be set because we always have an exclusive */</comment>
  <if>if <condition>(<expr><name>locktype</name>==<name>SHARED_LOCK</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  
  <comment type="block">/* no, really unlock. */</comment>
  <if>if <condition>( <expr><call><name>sem_post</name><argument_list>(<argument><expr><name>pSem</name></expr></argument>)</argument_list></call>==-1</expr> )</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name>, <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>, <argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rc</name></expr>;</return> 
  }</block></then></if>
  <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>NO_LOCK</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 ** Close a file.
 */</comment>
<function><type><name>static</name> <name>int</name></type> <name>semClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>semUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseLockInfo</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>releaseOpenCnt</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS_VXWORKS */</comment>
<comment type="block">/*
** Named semaphore locking is only available on VxWorks.
**
*************** End of the named semaphore lock implementation ****************
******************************************************************************/</comment>


<comment type="block">/******************************************************************************
*************************** Begin AFP Locking *********************************
**
** AFP is the Apple Filing Protocol.  AFP is a network filesystem found
** on Apple Macintosh computers - both OS9 and OSX.
**
** Third-party implementations of AFP are available.  But this code here
** only works on OSX.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<comment type="block">/*
** The afpLockingContext structure contains all afp lock specific state
*/</comment>
<typedef>typedef <type><struct>struct <name>afpLockingContext</name> afpLockingContext;</struct></type></typedef>
<struct>struct <name>afpLockingContext</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>sharedByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>dbPath</name></decl>;</decl_stmt>             <comment type="block">/* Name of the open file */</comment>
</public>}</block>;</struct>

<struct>struct <name>ByteRangeLockPB2</name>
<block>{<public type="default">
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* offset to first byte to lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>length</name></decl>;</decl_stmt>        <comment type="block">/* nbr of bytes to lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>retRangeStart</name></decl>;</decl_stmt> <comment type="block">/* nbr of 1st byte locked if successful */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>unLockFlag</name></decl>;</decl_stmt>         <comment type="block">/* 1 = unlock, 0 = lock */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>startEndFlag</name></decl>;</decl_stmt>       <comment type="block">/* 1=rel to end of fork, 0=rel to start */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>                           <comment type="block">/* file desc to assoc this lock with */</comment>
</public>}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>afpfsByteRangeLock2FSCTL</name>        <name>_IOWR</name>('z', 23, struct ByteRangeLockPB2)</cpp:define>

<comment type="block">/*
** This is a utility for setting or clearing a bit-range lock on an
** AFP filesystem.
** 
** Return SQLITE_OK on success, SQLITE_BUSY on failure.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>afpSetLock</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>path</name></decl></param>,              <comment type="block">/* Name of the file to be locked or unlocked */</comment>
  <param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>,               <comment type="block">/* Open file descriptor on path */</comment>
  <param><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>offset</name></decl></param>,     <comment type="block">/* First byte to be locked */</comment>
  <param><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>length</name></decl></param>,     <comment type="block">/* Number of bytes to lock */</comment>
  <param><decl><type><name>int</name></type> <name>setLockFlag</name></decl></param>                <comment type="block">/* True to set lock.  False to clear lock */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>ByteRangeLockPB2</name></type> <name>pb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>pb</name>.<name>unLockFlag</name> = <name>setLockFlag</name> ? 0 : 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pb</name>.<name>startEndFlag</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pb</name>.<name>offset</name> = <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pb</name>.<name>length</name> = <name>length</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name>pb</name>.<name>fd</name> = <name>pFile</name>-&gt;<name>h</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>OSTRACE6</name><argument_list>(<argument><expr>"AFPSETLOCK [%s] for %d%s in range %llx:%llx\n"</expr></argument>, 
    <argument><expr>(<name>setLockFlag</name>?"ON":"OFF")</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>(<name>pb</name>.<name>fd</name>==-1?"[testval-1]":"")</expr></argument>,
    <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>fsctl</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>afpfsByteRangeLock2FSCTL</name></expr></argument>, <argument><expr>&amp;<name>pb</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>( <expr><name>err</name>==-1</expr> )</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tErrno</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"AFPSETLOCK failed to fsctl() '%s' %d %s\n"</expr></argument>,
             <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tErrno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_IGNORE_AFP_LOCK_ERRORS</name></cpp:ifdef>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_BUSY</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>rc</name> = <call><name>sqliteErrorFromPosixError</name><argument_list>(<argument><expr><name>tErrno</name></expr></argument>,
                    <argument><expr><name>setLockFlag</name> ? <name>SQLITE_IOERR_LOCK</name> : <name>SQLITE_IOERR_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_IGNORE_AFP_LOCK_ERRORS */</comment>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>tErrno</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then> <else>else <block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>afpCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reserved</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> *</type><name>context</name> =<init> <expr>(<name>afpLockingContext</name> *) <name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
  
  <comment type="block">/* Check if a thread in this process holds such a lock */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="block">/* Otherwise see if some other process holds it.
   */</comment>
  <if>if<condition>( <expr>!<name>reserved</name></expr> )</condition><then><block>{
    <comment type="block">/* lock the RESERVED byte */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lrc</name> =<init> <expr><call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  
    <if>if<condition>( <expr><name>SQLITE_OK</name>==<name>lrc</name></expr> )</condition><then><block>{
      <comment type="block">/* if we succeeded in taking the reserved lock, unlock it to restore
      ** the original state */</comment>
      <expr_stmt><expr><name>lrc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <comment type="block">/* if we failed to get the lock then someone else must have it */</comment>
      <expr_stmt><expr><name>reserved</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name>=<name>lrc</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TEST WR-LOCK %d %d %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr>*<name>pResOut</name> = <name>reserved</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>afpLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> *</type><name>context</name> =<init> <expr>(<name>afpLockingContext</name> *) <name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"LOCK    %d %s was %s pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
         <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */</comment>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>locktype</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"LOCK    %d %s ok (already held)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Make sure the locking sequence is correct
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name> || <name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>!=<name>RESERVED_LOCK</name> || <name>pFile</name>-&gt;<name>locktype</name>==<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* This mutex is needed because pFile-&gt;pLock is shared across threads
  */</comment>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure the current thread owns the pFile.
  */</comment>
  <expr_stmt><expr><name>rc</name> = <call><name>transferOwnership</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then></if>
    
  <comment type="block">/* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name> 
      || (<name>locktype</name>==<name>EXCLUSIVE_LOCK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>&lt;<name>PENDING_LOCK</name>)</expr>
  )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>failed</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>failed</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>failed</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>rc</name> = <name>failed</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    }</block></then></if>
  }</block></then></if>
  
  <comment type="block">/* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */</comment>
  <if>if<condition>( <expr><name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>lk</name>, <name>lrc1</name>, <name>lrc2</name>, <name>lrc1Errno</name></decl>;</decl_stmt>
    
    <comment type="block">/* Now get the read-lock SHARED_LOCK */</comment>
    <comment type="block">/* note that the quality of the randomness doesn't matter that much */</comment>
    <expr_stmt><expr><name>lk</name> = <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><name>context</name>-&gt;<name>sharedByte</name> = (<name>lk</name> &amp; 0x7fffffff)%(<name>SHARED_SIZE</name> - 1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>lrc1</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, 
          <argument><expr><name>SHARED_FIRST</name>+<name>context</name>-&gt;<name>sharedByte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc1</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>lrc1Errno</name> = <name>pFile</name>-&gt;<name>lastErrno</name></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* Drop the temporary PENDING lock */</comment>
    <expr_stmt><expr><name>lrc2</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc1</name></expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>lrc1Errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>lrc1</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    }</block></then> <else>else <if>if<condition>( <expr><call><name>IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>lrc2</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>lrc2</name></expr>;</expr_stmt>
      <goto>goto <name>afp_end_lock</name>;</goto>
    }</block></then> <else>else <if>if<condition>( <expr><name>lrc1</name> != <name>SQLITE_OK</name></expr> )</condition><then> <block>{
      <expr_stmt><expr><name>rc</name> = <name>lrc1</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>SHARED_LOCK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>nLock</name>++</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>
  }</block></then><else>else<block>{
    <comment type="block">/* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>failed</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0!=<name>pFile</name>-&gt;<name>locktype</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>locktype</name> &gt;= <name>RESERVED_LOCK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name> &lt; <name>RESERVED_LOCK</name></expr>)</condition><then> <block>{
        <comment type="block">/* Acquire a RESERVED lock */</comment>
        <expr_stmt><expr><name>failed</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>failed</name> &amp;&amp; <name>locktype</name> == <name>EXCLUSIVE_LOCK</name></expr>)</condition><then> <block>{
      <comment type="block">/* Acquire an EXCLUSIVE lock */</comment>
        
      <comment type="block">/* Remove the shared lock before trying the range.  we'll need to 
      ** reestablish the shared lock if we can't get the  afpUnlock
      */</comment>
      <if>if<condition>( <expr>!(<name>failed</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name> +
                         <name>context</name>-&gt;<name>sharedByte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>failed2</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* now attemmpt to get the exclusive lock range */</comment>
        <expr_stmt><expr><name>failed</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, 
                               <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>failed</name> &amp;&amp; (<name>failed2</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>context</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, 
                       <argument><expr><name>SHARED_FIRST</name> + <name>context</name>-&gt;<name>sharedByte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
          <comment type="block">/* Can't reestablish the shared lock.  Sqlite can't deal, this is
          ** a critical I/O error
          */</comment>
          <expr_stmt><expr><name>rc</name> = ((<name>failed</name> &amp; <name>SQLITE_IOERR</name>) == <name>SQLITE_IOERR</name>) ? <name>failed2</name> : 
               <name>SQLITE_IOERR_LOCK</name></expr>;</expr_stmt>
          <goto>goto <name>afp_end_lock</name>;</goto>
        }</block></then></if> 
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>rc</name> = <name>failed</name></expr>;</expr_stmt> 
      }</block></else></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>failed</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>failed</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>locktype</name>==<name>EXCLUSIVE_LOCK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>PENDING_LOCK</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  
<label><name>afp_end_lock</name>:</label>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"LOCK    %d %s %s\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><call><name>locktypeName</name><argument_list>(<argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr></argument>, 
         <argument><expr><name>rc</name>==<name>SQLITE_OK</name> ? "ok" : "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>afpUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>afpLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>afpLockingContext</name> *) <name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"UNLOCK  %d %d was %d pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>,
         <argument><expr><name>pFile</name>-&gt;<name>locktype</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name>&lt;=<name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&lt;=<name>locktype</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>CHECK_THREADID</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>&gt;<name>SHARED_LOCK</name></expr> )</condition><then><block>{
    
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>==<name>EXCLUSIVE_LOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>locktype</name>==<name>SHARED_LOCK</name></expr> )</condition><then><block>{
        <comment type="block">/* only re-establish the shared lock if necessary */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>sharedLockByte</name> =<init> <expr><name>SHARED_FIRST</name>+<name>pCtx</name>-&gt;<name>sharedByte</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>sharedLockByte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>PENDING_LOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if> 
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pFile</name>-&gt;<name>locktype</name>&gt;=<name>RESERVED_LOCK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>locktype</name>==<name>NO_LOCK</name></expr> )</condition><then><block>{
    <comment type="block">/* clear the shared lock */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>sharedLockByte</name> =<init> <expr><name>SHARED_FIRST</name>+<name>pCtx</name>-&gt;<name>sharedByte</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>afpSetLock</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>sharedLockByte</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>locktype</name>==<name>NO_LOCK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pOpen</name>-&gt;<name>nLock</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOpen</name>-&gt;<name>nLock</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pOpen</name>-&gt;<name>nLock</name>==0 &amp;&amp; <name>pOpen</name>-&gt;<name>nPending</name>&gt;0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pOpen</name>-&gt;<name>nPending</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name> &lt; 0</expr> )</condition><then> <continue>continue;</continue></then></if>
          <if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_CLOSE</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt>
          }</block></else></if>
        }</block></for>
        <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name>aPending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pOpen</name>-&gt;<name>nPending</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>pOpen</name>-&gt;<name>aPending</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then> <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>locktype</name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close a file &amp; cleanup AFP specific locking context 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>afpClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>afpUnlock</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pOpen</name> &amp;&amp; <name>pFile</name>-&gt;<name>pOpen</name>-&gt;<name>nLock</name></expr> )</condition><then><block>{
      <comment type="block">/* If there are outstanding locks, do not actually close the file just
      ** yet because that would clear those locks.  Instead, add the file
      ** descriptor to pOpen-&gt;aPending.  It will be automatically closed when
      ** the last lock is cleared.
      */</comment>
      <decl_stmt><decl><type><name>int</name> *</type><name>aNew</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>unixOpenCnt</name> *</type><name>pOpen</name> =<init> <expr><name>pFile</name>-&gt;<name>pOpen</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>aNew</name> = <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>pOpen</name>-&gt;<name>aPending</name></expr></argument>, <argument><expr>(<name>pOpen</name>-&gt;<name>nPending</name>+1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>aNew</name>==0</expr> )</condition><then><block>{
        <comment type="block">/* If a malloc fails, just leak the file descriptor */</comment>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>aPending</name> = <name>aNew</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name><name>aPending</name><index>[<expr><name>pOpen</name>-&gt;<name>nPending</name></expr>]</index></name> = <name>pFile</name>-&gt;<name>h</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pOpen</name>-&gt;<name>nPending</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>pFile</name>-&gt;<name>h</name> = -1</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>releaseOpenCnt</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>closeUnixFile</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
<comment type="block">/*
** The code above is the AFP lock implementation.  The code is specific
** to MacOSX and does not work on other unix platforms.  No alternative
** is available.  If you don't compile for a mac, then the "unix-afp"
** VFS is not available.
**
********************* End of the AFP lock implementation **********************
******************************************************************************/</comment>


<comment type="block">/******************************************************************************
**************** Non-locking sqlite3_file methods *****************************
**
** The next division contains implementations for all methods of the 
** sqlite3_file object other than the locking methods.  The locking
** methods were defined in divisions above (one locking method per
** division).  Those methods that are common to all locking modes
** are gather together into this division.
*/</comment>

<comment type="block">/*
** Seek to the offset passed as the second argument, then read cnt 
** bytes into pBuf. Return the number of bytes actually read.
**
** NB:  If you define USE_PREAD or USE_PREAD64, then it might also
** be necessary to define _XOPEN_SOURCE to be 500.  This varies from
** one system to another.  Since SQLite does not define USE_PREAD
** any any form by default, we will not attempt to define _XOPEN_SOURCE.
** See tickets #2741 and #2681.
**
** To avoid stomping the errno value on a failed read the lastErrno value
** is set before returning.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>seekAndRead</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>id</name></decl></param>, <param><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>cnt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>newOffset</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>TIMER_START</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>got</name> = <call><name>pread</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>got</name> = -1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>got</name> = <call><name>pread64</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>got</name> = -1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>newOffset</name> = <call><name>lseek</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>newOffset</name>--</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>newOffset</name>!=<name>offset</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>newOffset</name> == -1</expr> )</condition><then><block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = 0</expr>;</expr_stmt>			
    }</block></else></if>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>got</name> = <call><name>read</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>TIMER_END</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>got</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"READ    %-3d %5d %7lld %llu\n"</expr></argument>, <argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>got</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>TIMER_ELAPSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>got</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read data from a file into a buffer.  Return SQLITE_OK if all
** bytes were read successfully and SQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixRead</name><parameter_list>(
  <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, 
  <param><decl><type><name>void</name> *</type><name>pBuf</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>amt</name></decl></param>,
  <param><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>got</name> = <call><name>seekAndRead</name><argument_list>(<argument><expr>(<name>unixFile</name>*)<name>id</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>got</name>==<name>amt</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>got</name>&lt;0</expr> )</condition><then><block>{
    <comment type="block">/* lastErrno set by seekAndRead */</comment>
    <return>return <expr><name>SQLITE_IOERR_READ</name></expr>;</return>
  }</block></then><else>else<block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = 0</expr>;</expr_stmt> <comment type="block">/* not a system error */</comment>
    <comment type="block">/* Unread parts of the buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;((<name>char</name>*)<name>pBuf</name>)[<name>got</name>]</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>amt</name>-<name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  }</block></else></if></else></if>
}</block></function>

<comment type="block">/*
** Seek to the offset in id-&gt;offset then read cnt bytes into pBuf.
** Return the number of bytes actually read.  Update the offset.
**
** To avoid stomping the errno value on a failed write the lastErrno value
** is set before returning.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>seekAndWrite</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>id</name></decl></param>, <param><decl><type><name>i64</name></type> <name>offset</name></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type><name>pBuf</name></decl></param>, <param><decl><type><name>int</name></type> <name>cnt</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>got</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>newOffset</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>TIMER_START</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>got</name> = <call><name>pwrite</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_PREAD64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>got</name> = <call><name>pwrite64</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>newOffset</name> = <call><name>lseek</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>newOffset</name>!=<name>offset</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>newOffset</name> == -1</expr> )</condition><then><block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = 0</expr>;</expr_stmt>			
    }</block></else></if>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>got</name> = <call><name>write</name><argument_list>(<argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>TIMER_END</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>got</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>OSTRACE5</name><argument_list>(<argument><expr>"WRITE   %-3d %5d %7lld %llu\n"</expr></argument>, <argument><expr><name>id</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>got</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>TIMER_ELAPSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>got</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Write data from a buffer into a file.  Return SQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixWrite</name><parameter_list>(
  <param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, 
  <param><decl><type><name>const</name> <name>void</name> *</type><name>pBuf</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>amt</name></decl></param>,
  <param><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></param> 
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>wrote</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* If we are doing a normal write to a database file (as opposed to
  ** doing a hot-journal rollback or a write to some file other than a
  ** normal database file) then record the fact that the database
  ** has changed.  If the transaction counter is modified, record that
  ** fact too.
  */</comment>
  <if>if<condition>( <expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>inNormalWrite</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>dbUpdate</name> = 1</expr>;</expr_stmt>  <comment type="block">/* The database has been modified */</comment>
    <if>if<condition>( <expr><name>offset</name>&lt;=24 &amp;&amp; <name>offset</name>+<name>amt</name>&gt;=27</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name></type> <name><name>oldCntr</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>seekAndRead</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr>24</expr></argument>, <argument><expr><name>oldCntr</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>oldCntr</name></expr></argument>, <argument><expr>&amp;((<name>char</name>*)<name>pBuf</name>)[24-<name>offset</name>]</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>transCntrChng</name> = 1</expr>;</expr_stmt>  <comment type="block">/* The transaction counter has changed */</comment>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <while>while<condition>( <expr><name>amt</name>&gt;0 &amp;&amp; (<name>wrote</name> = <call><name>seekAndWrite</name><argument_list>(<argument><expr>(<name>unixFile</name>*)<name>id</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call>)&gt;0</expr> )</condition><block>{
    <expr_stmt><expr><name>amt</name> -= <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> += <name>wrote</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pBuf</name> = &amp;((<name>char</name>*)<name>pBuf</name>)[<name>wrote</name>]</expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>(<argument><expr>( <name>wrote</name>=(-1), <name>amt</name>=1 )</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateDiskfullError</name><argument_list>(<argument><expr>( <name>wrote</name>=0, <name>amt</name>=1 )</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>amt</name>&gt;0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>wrote</name>&lt;0</expr> )</condition><then><block>{
      <comment type="block">/* lastErrno set by seekAndWrite */</comment>
      <return>return <expr><name>SQLITE_IOERR_WRITE</name></expr>;</return>
    }</block></then><else>else<block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = 0</expr>;</expr_stmt> <comment type="block">/* not a system error */</comment>
      <return>return <expr><name>SQLITE_FULL</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Count the number of fullsyncs and normal syncs.  This is used to test
** that syncs and fullsyncs are occurring at the right times.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sync_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fullsync_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Use the fdatasync() API only if the HAVE_FDATASYNC macro is defined.
** Otherwise use fsync() in its place.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_FDATASYNC</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>fdatasync</name> <name>fsync</name></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not
** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently
** only available on Mac OS X.  But that could change.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>F_FULLFSYNC</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>HAVE_FULLFSYNC</name> 1</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>HAVE_FULLFSYNC</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** The fsync() system call does not work as advertised on many
** unix systems.  The following procedure is an attempt to make
** it work better.
**
** The SQLITE_NO_SYNC macro disables all fsync()s.  This is useful
** for testing when we want to run through the test suite quickly.
** You are strongly advised *not* to deploy with SQLITE_NO_SYNC
** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crash
** or power failure will likely corrupt the database file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>full_fsync</name><parameter_list>(<param><decl><type><name>int</name></type> <name>fd</name></decl></param>, <param><decl><type><name>int</name></type> <name>fullSync</name></decl></param>, <param><decl><type><name>int</name></type> <name>dataOnly</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* The following "ifdef/elif/else/" block has the same structure as
  ** the one below. It is replicated here solely to avoid cluttering 
  ** up the real code with the UNUSED_PARAMETER() macros.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fullSync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Record the number of times that we do a normal fsync() and 
  ** FULLSYNC.  This is used during testing to verify that this procedure
  ** gets called with the correct arguments.
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if>if<condition>( <expr><name>fullSync</name></expr> )</condition><then> <expr_stmt><expr><name>sqlite3_fullsync_count</name>++</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>sqlite3_sync_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a
  ** no-op
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_FULLFSYNC</name></expr></cpp:elif>
  <if>if<condition>( <expr><name>fullSync</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_FULLFSYNC</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
  <comment type="block">/* If the FULLFSYNC failed, fall back to attempting an fsync().
  ** It shouldn't be possible for fullfsync to fail on the local 
  ** file system (on OSX), so failure indicates that FULLFSYNC
  ** isn't supported for this file system. So, attempt an fsync 
  ** and (for now) ignore the overhead of a superfluous fcntl call.  
  ** It'd be better to detect fullfsync support once and avoid 
  ** the fcntl call every time sync is called.
  */</comment>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <expr_stmt><expr><name>rc</name> = <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
  <if>if<condition>( <expr><name>dataOnly</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>fdatasync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <if>if<condition>( <expr><name>rc</name>==-1 &amp;&amp; <name>errno</name>==<name>ENOTSUP</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */</comment>

  <if>if<condition>( <expr><name>OS_VXWORKS</name> &amp;&amp; <name>rc</name>!= -1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
**
** If dataOnly==0 then both the file itself and its metadata (file
** size, access time, etc) are synced.  If dataOnly!=0 then only the
** file data is synced.
**
** Under Unix, also make sure that the directory entry for the file
** has been created by fsync-ing the directory that contains the file.
** If we do not do this and we encounter a power failure, the directory
** entry for the journal might not exist after we reboot.  The next
** SQLite to access the file will not know that the journal exists (because
** the directory entry for the journal was never created) and the transaction
** will not roll back - possibly leading to database corruption.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixSync</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>isDataOnly</name> =<init> <expr>(<name>flags</name>&amp;<name>SQLITE_SYNC_DATAONLY</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isFullsync</name> =<init> <expr>(<name>flags</name>&amp;0x0F)==<name>SQLITE_SYNC_FULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>flags</name>&amp;0x0F)==<name>SQLITE_SYNC_NORMAL</name>
      || (<name>flags</name>&amp;0x0F)==<name>SQLITE_SYNC_FULL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Unix cannot, but some systems may return SQLITE_FULL from here. This
  ** line is to test that doing so does not cause any problems.
  */</comment>
  <macro><name>SimulateDiskfullError</name><argument_list>( <argument>return SQLITE_FULL</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>(<argument><expr>"SYNC    %-3d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>full_fsync</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>isFullsync</name></expr></argument>, <argument><expr><name>isDataOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>rc</name>=1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_FSYNC</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>dirfd</name>&gt;=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>dirfd</name></expr></argument>,
            <argument><expr><name>HAVE_FULLFSYNC</name></expr></argument>, <argument><expr><name>isFullsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
    <comment type="block">/* The directory sync is only attempted if full_fsync is
    ** turned off or unavailable.  If a full_fsync occurred above,
    ** then the directory sync is superfluous.
    */</comment>
    <if>if<condition>( <expr>(!<name>HAVE_FULLFSYNC</name> || !<name>isFullsync</name>) &amp;&amp; <call><name>full_fsync</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>dirfd</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
       <comment type="block">/*
       ** We have received multiple reports of fsync() returning
       ** errors when applied to directories on certain file systems.
       ** A failed directory sync is not a big deal.  So it seems
       ** better to ignore the error.  Ticket #1657
       */</comment>
       <comment type="block">/* pFile-&gt;lastErrno = errno; */</comment>
       <comment type="block">/* return SQLITE_IOERR; */</comment>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>err</name> = <call><name>close</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Only need to sync once, so close the */</comment>
    <if>if<condition>( <expr><name>err</name>==0</expr> )</condition><then><block>{              <comment type="block">/* directory when we are done */</comment>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>dirfd</name> = -1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_DIR_CLOSE</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixTruncate</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>i64</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_TRUNCATE</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>ftruncate</name><argument_list>(<argument><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>h</name></expr></argument>, <argument><expr>(<name>off_t</name>)<name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_TRUNCATE</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixFileSize</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>i64</name> *</type><name>pSize</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>fstat</name><argument_list>(<argument><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>rc</name>=1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pSize</name> = <name>buf</name>.<name>st_size</name></expr>;</expr_stmt>

  <comment type="block">/* When opening a zero-size database, the findLockInfo() procedure
  ** writes a single byte into that file in order to work around a bug
  ** in the OS-X msdos filesystem.  In order to avoid problems with upper
  ** layers, we need to report this file size as zero even though it is
  ** really 1.   Ticket #3260.
  */</comment>
  <if>if<condition>( <expr>*<name>pSize</name>==1</expr> )</condition><then> <expr_stmt><expr>*<name>pSize</name> = 0</expr>;</expr_stmt></then></if>


  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Handler for proxy-locking file-control verbs.  Defined below in the
** proxying locking division.
*/</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyFileControl</name><parameter_list>(<param><decl><type><name>sqlite3_file</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Information and control of an open file handle.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixFileControl</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr>: <block>{
      <expr_stmt><expr>*(<name>int</name>*)<name>pArg</name> = ((<name>unixFile</name>*)<name>id</name>)-&gt;<name>locktype</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block>
    </case><case>case <expr><name>SQLITE_LAST_ERRNO</name></expr>: <block>{
      <expr_stmt><expr>*(<name>int</name>*)<name>pArg</name> = ((<name>unixFile</name>*)<name>id</name>)-&gt;<name>lastErrno</name></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
    <comment type="block">/* The pager calls this method to signal that it has done
    ** a rollback and that the database is therefore unchanged and
    ** it hence it is OK for the transaction change counter to be
    ** unchanged.
    */</comment>
    </case><case>case <expr><name>SQLITE_FCNTL_DB_UNCHANGED</name></expr>: <block>{
      <expr_stmt><expr>((<name>unixFile</name>*)<name>id</name>)-&gt;<name>dbUpdate</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>SQLITE_SET_LOCKPROXYFILE</name></expr>:
    </case><case>case <expr><name>SQLITE_GET_LOCKPROXYFILE</name></expr>: <block>{
      <return>return <expr><call><name>proxyFileControl</name><argument_list>(<argument><expr><name>id</name></expr></argument>,<argument><expr><name>op</name></expr></argument>,<argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_LOCKING_STYLE &amp;&amp; defined(__APPLE__) */</comment>
  </case>}</block></switch>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixSectorSize</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the device characteristics for the file. This is always 0 for unix.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixDeviceCharacteristics</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>NotUsed</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Here ends the implementation of all sqlite3_file methods.
**
********************** End sqlite3_file Methods *******************************
******************************************************************************/</comment>

<comment type="block">/*
** This division contains definitions of sqlite3_io_methods objects that
** implement various file locking strategies.  It also contains definitions
** of "finder" functions.  A finder-function is used to locate the appropriate
** sqlite3_io_methods object for a particular database file.  The pAppData
** field of the sqlite3_vfs VFS objects are initialized to be pointers to
** the correct finder-function for that VFS.
**
** Most finder functions return a pointer to a fixed sqlite3_io_methods
** object.  The only interesting finder-function is autolockIoFinder, which
** looks at the filesystem type and tries to guess the best locking
** strategy from that.
**
** For finder-funtion F, two objects are created:
**
**    (1) The real finder-function named "FImpt()".
**
**    (2) A constant pointer to this functio named just "F".
**
**
** A pointer to the F pointer is used as the pAppData value for VFS
** objects.  We have to do this instead of letting pAppData point
** directly at the finder-function since C90 rules prevent a void*
** from be cast into a function pointer.
**
**
** Each instance of this macro generates two objects:
**
**   *  A constant sqlite3_io_methods object call METHOD that has locking
**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.
**
**   *  An I/O method finder function called FINDER that returns a pointer
**      to the METHOD object in the previous bullet.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>IOMETHODS</name>(FINDER, METHOD, CLOSE, LOCK, UNLOCK, CKLOCK)               \
static const sqlite3_io_methods METHOD = {                                   \
   1,                          <comment type="block">/* iVersion */</comment>                                \
   CLOSE,                      <comment type="block">/* xClose */</comment>                                  \
   unixRead,                   <comment type="block">/* xRead */</comment>                                   \
   unixWrite,                  <comment type="block">/* xWrite */</comment>                                  \
   unixTruncate,               <comment type="block">/* xTruncate */</comment>                               \
   unixSync,                   <comment type="block">/* xSync */</comment>                                   \
   unixFileSize,               <comment type="block">/* xFileSize */</comment>                               \
   LOCK,                       <comment type="block">/* xLock */</comment>                                   \
   UNLOCK,                     <comment type="block">/* xUnlock */</comment>                                 \
   CKLOCK,                     <comment type="block">/* xCheckReservedLock */</comment>                      \
   unixFileControl,            <comment type="block">/* xFileControl */</comment>                            \
   unixSectorSize,             <comment type="block">/* xSectorSize */</comment>                             \
   unixDeviceCharacteristics   <comment type="block">/* xDeviceCapabilities */</comment>                     \
};                                                                           \
static const sqlite3_io_methods *FINDER##Impl(const char *z, int h){         \
  UNUSED_PARAMETER(z); UNUSED_PARAMETER(h);                                  \
  return &amp;METHOD;                                                            \
}                                                                            \
static const sqlite3_io_methods *(*const FINDER)(const char*,int)            \
    = FINDER##Impl;</cpp:define>

<comment type="block">/*
** Here are all of the sqlite3_io_methods objects for each of the
** locking strategies.  Functions that return pointers to these methods
** are also created.
*/</comment>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>posixIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>posixIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>unixClose</argument>,                <comment type="block">/* xClose method */</comment>
  <argument>unixLock</argument>,                 <comment type="block">/* xLock method */</comment>
  <argument>unixUnlock</argument>,               <comment type="block">/* xUnlock method */</comment>
  <argument>unixCheckReservedLock</argument>     <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>nolockIoFinder</argument>,           <comment type="block">/* Finder function name */</comment>
  <argument>nolockIoMethods</argument>,          <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>nolockClose</argument>,              <comment type="block">/* xClose method */</comment>
  <argument>nolockLock</argument>,               <comment type="block">/* xLock method */</comment>
  <argument>nolockUnlock</argument>,             <comment type="block">/* xUnlock method */</comment>
  <argument>nolockCheckReservedLock</argument>   <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>dotlockIoFinder</argument>,          <comment type="block">/* Finder function name */</comment>
  <argument>dotlockIoMethods</argument>,         <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>dotlockClose</argument>,             <comment type="block">/* xClose method */</comment>
  <argument>dotlockLock</argument>,              <comment type="block">/* xLock method */</comment>
  <argument>dotlockUnlock</argument>,            <comment type="block">/* xUnlock method */</comment>
  <argument>dotlockCheckReservedLock</argument>  <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>flockIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>flockIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>flockClose</argument>,               <comment type="block">/* xClose method */</comment>
  <argument>flockLock</argument>,                <comment type="block">/* xLock method */</comment>
  <argument>flockUnlock</argument>,              <comment type="block">/* xUnlock method */</comment>
  <argument>flockCheckReservedLock</argument>    <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>semIoFinder</argument>,              <comment type="block">/* Finder function name */</comment>
  <argument>semIoMethods</argument>,             <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>semClose</argument>,                 <comment type="block">/* xClose method */</comment>
  <argument>semLock</argument>,                  <comment type="block">/* xLock method */</comment>
  <argument>semUnlock</argument>,                <comment type="block">/* xUnlock method */</comment>
  <argument>semCheckReservedLock</argument>      <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>afpIoFinder</argument>,              <comment type="block">/* Finder function name */</comment>
  <argument>afpIoMethods</argument>,             <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>afpClose</argument>,                 <comment type="block">/* xClose method */</comment>
  <argument>afpLock</argument>,                  <comment type="block">/* xLock method */</comment>
  <argument>afpUnlock</argument>,                <comment type="block">/* xUnlock method */</comment>
  <argument>afpCheckReservedLock</argument>      <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The proxy locking method is a "super-method" in the sense that it
** opens secondary file descriptors for the conch and lock files and
** it uses proxy, dot-file, AFP, and flock() locking methods on those
** secondary files.  For this reason, the division that implements
** proxy locking is located much further down in the file.  But we need
** to go ahead and define the sqlite3_io_methods and finder function
** for proxy locking here.  So we forward declare the I/O methods.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name>*</type></decl></param>, <param><decl><type><name>int</name>*</type></decl></param>)</parameter_list>;</function_decl>
<macro><name>IOMETHODS</name><argument_list>(
  <argument>proxyIoFinder</argument>,            <comment type="block">/* Finder function name */</comment>
  <argument>proxyIoMethods</argument>,           <comment type="block">/* sqlite3_io_methods object name */</comment>
  <argument>proxyClose</argument>,               <comment type="block">/* xClose method */</comment>
  <argument>proxyLock</argument>,                <comment type="block">/* xLock method */</comment>
  <argument>proxyUnlock</argument>,              <comment type="block">/* xUnlock method */</comment>
  <argument>proxyCheckReservedLock</argument>    <comment type="block">/* xCheckReservedLock method */</comment>
)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
<comment type="block">/* 
** This "finder" function attempts to determine the best locking strategy 
** for the database file "filePath".  It then returns the sqlite3_io_methods
** object that implements that strategy.
**
** This is for MacOSX only.
*/</comment>
<function><type><name>static</name> <name>const</name> <name>sqlite3_io_methods</name> *</type><name>autolockIoFinderImpl</name><parameter_list>(
  <param><decl><type><name>const</name> <name>char</name> *</type><name>filePath</name></decl></param>,    <comment type="block">/* name of the database file */</comment>
  <param><decl><type><name>int</name></type> <name>fd</name></decl></param>                   <comment type="block">/* file descriptor open on the database file */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> struct</type> <name>Mapping</name> <block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFilesystem</name></decl>;</decl_stmt>              <comment type="block">/* Filesystem type name */</comment>
    <decl_stmt><decl><type><name>const</name> <name>sqlite3_io_methods</name> *</type><name>pMethods</name></decl>;</decl_stmt>   <comment type="block">/* Appropriate locking method */</comment>
  }</block></decl></decl_stmt> <expr_stmt><expr><name><name>aMap</name><index>[]</index></name> = <block>{
    <expr><block>{ <expr>"hfs"</expr>,    <expr>&amp;<name>posixIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr>"ufs"</expr>,    <expr>&amp;<name>posixIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr>"afpfs"</expr>,  <expr>&amp;<name>afpIoMethods</name></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_AFP_LOCKING_SMB</name></cpp:ifdef>
    <expr><block>{ <expr>"smbfs"</expr>,  <expr>&amp;<name>afpIoMethods</name></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><block>{ <expr>"smbfs"</expr>,  <expr>&amp;<name>flockIoMethods</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{ <expr>"webdav"</expr>, <expr>&amp;<name>nolockIoMethods</name></expr> }</block></expr>,
    <expr><block>{ <expr>0</expr>, <expr>0</expr> }</block></expr>
  }</block></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>statfs</name></type> <name>fsInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>flock</name></type> <name>lockInfo</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>filePath</name></expr> )</condition><then><block>{
    <comment type="block">/* If filePath==NULL that means we are dealing with a transient file
    ** that does not need to be locked. */</comment>
    <return>return <expr>&amp;<name>nolockIoMethods</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>statfs</name><argument_list>(<argument><expr><name>filePath</name></expr></argument>, <argument><expr>&amp;<name>fsInfo</name></expr></argument>)</argument_list></call> != -1</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>fsInfo</name>.<name>f_flags</name> &amp; <name>MNT_RDONLY</name></expr> )</condition><then><block>{
      <return>return <expr>&amp;<name>nolockIoMethods</name></expr>;</return>
    }</block></then></if>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zFilesystem</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fsInfo</name>.<name>f_fstypename</name></expr></argument>, <argument><expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zFilesystem</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <return>return <expr><name><name>aMap</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pMethods</name></expr>;</return>
      }</block></then></if>
    }</block></for>
  }</block></then></if>

  <comment type="block">/* Default case. Handles, amongst others, "nfs".
  ** Test byte-range lock using fcntl(). If the call succeeds, 
  ** assume that the file-system supports POSIX style locks. 
  */</comment>
  <expr_stmt><expr><name>lockInfo</name>.<name>l_len</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>lockInfo</name>.<name>l_start</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>lockInfo</name>.<name>l_whence</name> = <name>SEEK_SET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>lockInfo</name>.<name>l_type</name> = <name>F_RDLCK</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETLK</name></expr></argument>, <argument><expr>&amp;<name>lockInfo</name></expr></argument>)</argument_list></call>!=-1</expr> )</condition><then> <block>{
    <return>return <expr>&amp;<name>posixIoMethods</name></expr>;</return>
  }</block></then><else>else<block>{
    <return>return <expr>&amp;<name>dotlockIoMethods</name></expr>;</return>
  }</block></else></if>
}</block></function>
<function_decl><type><name>static</name> <name>const</name> <name>sqlite3_io_methods</name> *</type>(*<name>const</name> <name>autolockIoFinder</name>)<parameter_list>(<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>
        <specifier/>= <specifier>autolockIoFinderImpl</specifier>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>

<comment type="block">/*
** An abstract type for a pointer to a IO method finder function:
*/</comment>
<typedef>typedef <function_decl><type><name>const</name> <name>sqlite3_io_methods</name> *</type>(*<name>finder_type</name>)<parameter_list>(<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl></typedef>


<comment type="block">/****************************************************************************
**************************** sqlite3_vfs methods ****************************
**
** This division contains the implementation of methods on the
** sqlite3_vfs object.
*/</comment>

<comment type="block">/*
** Initialize the contents of the unixFile structure pointed to by pId.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>fillInUnixFile</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,      <comment type="block">/* Pointer to vfs object */</comment>
  <param><decl><type><name>int</name></type> <name>h</name></decl></param>,                  <comment type="block">/* Open file descriptor of file being opened */</comment>
  <param><decl><type><name>int</name></type> <name>dirfd</name></decl></param>,              <comment type="block">/* Directory file descriptor */</comment>
  <param><decl><type><name>sqlite3_file</name> *</type><name>pId</name></decl></param>,      <comment type="block">/* Write to the unixFile structure here */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>,  <comment type="block">/* Name of the file being opened */</comment>
  <param><decl><type><name>int</name></type> <name>noLock</name></decl></param>,             <comment type="block">/* Omit locking if true */</comment>
  <param><decl><type><name>int</name></type> <name>isDelete</name></decl></param>            <comment type="block">/* Delete on close if true */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_io_methods</name> *</type><name>pLockingStyle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pNew</name> =<init> <expr>(<name>unixFile</name> *)<name>pId</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>pLock</name>==<name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>pOpen</name>==<name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Parameter isDelete is only used on vxworks.
  ** Express this explicitly here to prevent compiler warnings
  ** about unused parameters.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>OS_VXWORKS</name></expr></cpp:if>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"OPEN    %-3d %s\n"</expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  <expr_stmt><expr><name>pNew</name>-&gt;<name>h</name> = <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>dirfd</name> = <name>dirfd</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SET_THREADID</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pId</name> = <call><name>vxworksFindFileId</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>-&gt;<name>pId</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>noLock</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name>noLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pLockingStyle</name> = &amp;<name>nolockIoMethods</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pLockingStyle</name> = (**(<name>finder_type</name>*)<name>pVfs</name>-&gt;<name>pAppData</name>)(<name>zFilename</name>, <name>h</name>)</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
    <comment type="block">/* Cache zFilename in the locking context (AFP and dotlock override) for
    ** proxyLock activation is possible (remote proxy is based on db name)
    ** zFilename remains valid until file is closed, to support */</comment>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>lockingContext</name> = (<name>void</name>*)<name>zFilename</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></else></if>

  <if>if<condition>( <expr><name>pLockingStyle</name> == &amp;<name>posixIoMethods</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>findLockInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>pLock</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <else>else <if>if<condition>( <expr><name>pLockingStyle</name> == &amp;<name>afpIoMethods</name></expr> )</condition><then><block>{
    <comment type="block">/* AFP locking uses the file path so it needs to be included in
    ** the afpLockingContext.
    */</comment>
    <decl_stmt><decl><type><name>afpLockingContext</name> *</type><name>pCtx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>lockingContext</name> = <name>pCtx</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCtx</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCtx</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* NB: zFilename exists and remains valid until the file is closed
      ** according to requirement F11141.  So we do not need to make a
      ** copy of the filename. */</comment>
      <expr_stmt><expr><name>pCtx</name>-&gt;<name>dbPath</name> = <name>zFilename</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>srandomdev</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>findLockInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>        
    }</block></else></if>
  }</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <else>else <if>if<condition>( <expr><name>pLockingStyle</name> == &amp;<name>dotlockIoMethods</name></expr> )</condition><then><block>{
    <comment type="block">/* Dotfile locking uses the file path so it needs to be included in
    ** the dotlockLockingContext 
    */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zLockFile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nFilename</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nFilename</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call> + 6</expr>;</expr_stmt>
    <expr_stmt><expr><name>zLockFile</name> = (<name>char</name> *)<call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zLockFile</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nFilename</name></expr></argument>, <argument><expr><name>zLockFile</name></expr></argument>, <argument><expr>"%s" <name>DOTLOCK_SUFFIX</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pNew</name>-&gt;<name>lockingContext</name> = <name>zLockFile</name></expr>;</expr_stmt>
  }</block></then>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <else>else <if>if<condition>( <expr><name>pLockingStyle</name> == &amp;<name>semIoMethods</name></expr> )</condition><then><block>{
    <comment type="block">/* Named semaphore locking uses the file path so it needs to be
    ** included in the semLockingContext
    */</comment>
    <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>findLockInfo</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>pLock</name></expr></argument>, <argument><expr>&amp;<name>pNew</name>-&gt;<name>pOpen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>rc</name>==<name>SQLITE_OK</name>) &amp;&amp; (<name>pNew</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name>==<name>NULL</name>)</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zSemName</name> =<init> <expr><name>pNew</name>-&gt;<name>pOpen</name>-&gt;<name>aSemName</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>MAX_PATHNAME</name></expr></argument>, <argument><expr><name>zSemName</name></expr></argument>, <argument><expr>"%s.sem"</expr></argument>,
                       <argument><expr><name>pNew</name>-&gt;<name>pId</name>-&gt;<name>zCanonicalName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for( <init><expr><name>n</name>=0</expr>;</init> <condition><expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr> )
        <if>if<condition>( <expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name>=='/'</expr> )</condition><then> <expr_stmt><expr><name><name>zSemName</name><index>[<expr><name>n</name></expr>]</index></name> = '_'</expr>;</expr_stmt></then></if></for>
      <expr_stmt><expr><name>pNew</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name> = <call><name>sem_open</name><argument_list>(<argument><expr><name>zSemName</name></expr></argument>, <argument><expr><name>O_CREAT</name></expr></argument>, <argument><expr>0666</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pNew</name>-&gt;<name>pOpen</name>-&gt;<name>pSem</name> == <name>SEM_FAILED</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pNew</name>-&gt;<name>pOpen</name>-&gt;<name><name>aSemName</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>pNew</name>-&gt;<name>lastErrno</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isDelete</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>isDelete</name> = <name>isDelete</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>dirfd</name>&gt;=0</expr> )</condition><then> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* silent leak if fail, already in error */</comment>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pNew</name>-&gt;<name>pMethod</name> = <name>pLockingStyle</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Open a file descriptor to the directory containing file zFilename.
** If successful, *pFd is set to the opened file descriptor and
** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEM
** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined
** value.
**
** If SQLITE_OK is returned, the caller is responsible for closing
** the file descriptor *pFd using close().
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>openDirectory</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pFd</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zDirname</name><index>[<expr><name>MAX_PATHNAME</name>+1</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>MAX_PATHNAME</name></expr></argument>, <argument><expr><name>zDirname</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>ii</name>=(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ii</name>&gt;1 &amp;&amp; <name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name>!='/'</expr>;</condition> <incr><expr><name>ii</name>--</expr></incr>)<empty_stmt>;</empty_stmt></for>
  <if>if<condition>( <expr><name>ii</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name><name>zDirname</name><index>[<expr><name>ii</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>zDirname</name></expr></argument>, <argument><expr><name>O_RDONLY</name>|<name>O_BINARY</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>fd</name>&gt;=0</expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_CLOEXEC</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"OPENDIR %-3d %s\n"</expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zDirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr>*<name>pFd</name> = <name>fd</name></expr>;</expr_stmt>
  <return>return <expr>(<name>fd</name>&gt;=0?<name>SQLITE_OK</name>:<name>SQLITE_CANTOPEN</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
** Create a temporary file name in zBuf.  zBuf must be allocated
** by the calling process and must be big enough to hold at least
** pVfs-&gt;mxPathname bytes.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>getTempname</name><parameter_list>(<param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>azDirs</name><index>[]</index></name> =<init> <expr><block>{
     <expr>0</expr>,
     <expr>0</expr>,
     <expr>"/var/tmp"</expr>,
     <expr>"/usr/tmp"</expr>,
     <expr>"/tmp"</expr>,
     <expr>"."</expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>zChars</name><index>[]</index></name> =<init>
    <expr>"abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "0123456789"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDir</name> =<init> <expr>"."</expr></init></decl>;</decl_stmt>

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. 
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><name><name>azDirs</name><index>[<expr>0</expr>]</index></name> = <name>sqlite3_temp_directory</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>NULL</name> == <name><name>azDirs</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>azDirs</name><index>[<expr>1</expr>]</index></name> = <call><name>getenv</name><argument_list>(<argument><expr>"TMPDIR"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>sizeof</name><argument_list>(<argument><expr><name>azDirs</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>azDirs</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>azDirs</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><call><name>stat</name><argument_list>(<argument><expr><name><name>azDirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr>!<call><name>S_ISDIR</name><argument_list>(<argument><expr><name>buf</name>.<name>st_mode</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <if>if<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name><name>azDirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>07</expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>zDir</name> = <name><name>azDirs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>
  }</block></for>

  <comment type="block">/* Check that the output buffer is large enough for the temporary file 
  ** name. If it is not, return SQLITE_ERROR.
  */</comment>
  <if>if<condition>( <expr>(<call><name>strlen</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></call> + <call><name>strlen</name><argument_list>(<argument><expr><name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call> + 17) &gt;= (<name>size_t</name>)<name>nBuf</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>

  <do>do<block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name>-17</expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr>"%s/"<name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr>15</expr></argument>, <argument><expr>&amp;<name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;15</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> = (<name>char</name>)<name><name>zChars</name><index>[ <expr>((<name>unsigned</name> <name>char</name>)<name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name>)%(<call><name>sizeof</name><argument_list>(<argument><expr><name>zChars</name></expr></argument>)</argument_list></call>-1)</expr> ]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block>while<condition>( <expr><call><name>access</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>==0</expr> )</condition>;</do>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Routine to transform a unixFile into a proxy-locking unixFile.
** Implementation in the proxy-lock division, but used by unixOpen()
** if SQLITE_PREFER_PROXY_LOCKING is defined.
*/</comment>
<function_decl><type><name>static</name> <name>int</name></type> <name>proxyTransformUnixFile</name><parameter_list>(<param><decl><type><name>unixFile</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>char</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Open the file zPath.
** 
** Previously, the SQLite OS layer used three functions in place of this
** one:
**
**     sqlite3OsOpenReadWrite();
**     sqlite3OsOpenReadOnly();
**     sqlite3OsOpenExclusive();
**
** These calls correspond to the following combinations of flags:
**
**     ReadWrite() -&gt;     (READWRITE | CREATE)
**     ReadOnly()  -&gt;     (READONLY) 
**     OpenExclusive() -&gt; (READWRITE | CREATE | EXCLUSIVE)
**
** The old OpenExclusive() accepted a boolean argument - "delFlag". If
** true, the file was configured to be automatically deleted when the
** file handle closed. To achieve the same effect using this new 
** interface, add the DELETEONCLOSE flag to those specified above for 
** OpenExclusive().
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixOpen</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,           <comment type="block">/* The VFS for which this is the xOpen method */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zPath</name></decl></param>,           <comment type="block">/* Pathname of file to be opened */</comment>
  <param><decl><type><name>sqlite3_file</name> *</type><name>pFile</name></decl></param>,         <comment type="block">/* The file descriptor to be filled in */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,                   <comment type="block">/* Input flags to control the opening */</comment>
  <param><decl><type><name>int</name> *</type><name>pOutFlags</name></decl></param>               <comment type="block">/* Output flags returned to SQLite core */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>                    <comment type="block">/* File descriptor returned by open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>                <comment type="block">/* Directory file descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>openFlags</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* Flags to pass to open() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> =<init> <expr><name>flags</name>&amp;0xFFFFFF00</expr></init></decl>;</decl_stmt>  <comment type="block">/* Type of file to open */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>noLock</name></decl>;</decl_stmt>                    <comment type="block">/* True to omit locking primitives */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_OPEN_EXCLUSIVE</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_OPEN_DELETEONCLOSE</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_OPEN_CREATE</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name>   =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_OPEN_READONLY</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  =<init> <expr>(<name>flags</name> &amp; <name>SQLITE_OPEN_READWRITE</name>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* If creating a master or main-file journal, this function will open
  ** a file-descriptor on the directory too. The first time unixSync()
  ** is called the directory file descriptor will be fsync()ed and close()d.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isOpenDirectory</name> =<init> <expr>(<name>isCreate</name> &amp;&amp; 
      (<name>eType</name>==<name>SQLITE_OPEN_MASTER_JOURNAL</name> || <name>eType</name>==<name>SQLITE_OPEN_MAIN_JOURNAL</name>)
  )</expr></init></decl>;</decl_stmt>

  <comment type="block">/* If argument zPath is a NULL pointer, this function is required to open
  ** a temporary file. Use this buffer to store the file name in.
  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTmpname</name><index>[<expr><name>MAX_PATHNAME</name>+1</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name> =<init> <expr><name>zPath</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check the following statements are true: 
  **
  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and 
  **   (b) if CREATE is set, then READWRITE must also be set, and
  **   (c) if EXCLUSIVE is set, then CREATE must also be set.
  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>isReadonly</name>==0 || <name>isReadWrite</name>==0) &amp;&amp; (<name>isReadWrite</name> || <name>isReadonly</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isCreate</name>==0 || <name>isReadWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isExclusive</name>==0 || <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelete</name>==0 || <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The main DB, main journal, and master journal are never automatically
  ** deleted
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>!=<name>SQLITE_OPEN_MAIN_DB</name> || !<name>isDelete</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>!=<name>SQLITE_OPEN_MAIN_JOURNAL</name> || !<name>isDelete</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>!=<name>SQLITE_OPEN_MASTER_JOURNAL</name> || !<name>isDelete</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that the upper layer has set one of the "file-type" flags. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name>==<name>SQLITE_OPEN_MAIN_DB</name>      || <name>eType</name>==<name>SQLITE_OPEN_TEMP_DB</name> 
       || <name>eType</name>==<name>SQLITE_OPEN_MAIN_JOURNAL</name> || <name>eType</name>==<name>SQLITE_OPEN_TEMP_JOURNAL</name> 
       || <name>eType</name>==<name>SQLITE_OPEN_SUBJOURNAL</name>   || <name>eType</name>==<name>SQLITE_OPEN_MASTER_JOURNAL</name> 
       || <name>eType</name>==<name>SQLITE_OPEN_TRANSIENT_DB</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr>!<name>zName</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelete</name> &amp;&amp; !<name>isOpenDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>getTempname</name><argument_list>(<argument><expr><name>MAX_PATHNAME</name>+1</expr></argument>, <argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zName</name> = <name>zTmpname</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><then>  <expr_stmt><expr><name>openFlags</name> |= <name>O_RDONLY</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><then> <expr_stmt><expr><name>openFlags</name> |= <name>O_RDWR</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>isCreate</name></expr> )</condition><then>    <expr_stmt><expr><name>openFlags</name> |= <name>O_CREAT</name></expr>;</expr_stmt></then></if>
  <if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><then> <expr_stmt><expr><name>openFlags</name> |= (<name>O_EXCL</name>|<name>O_NOFOLLOW</name>)</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>openFlags</name> |= (<name>O_LARGEFILE</name>|<name>O_BINARY</name>)</expr>;</expr_stmt>

  <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><name>isDelete</name>?0600:<name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"OPENX   %-3d %s 0%o\n"</expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&lt;0 &amp;&amp; <name>errno</name>!=<name>EISDIR</name> &amp;&amp; <name>isReadWrite</name> &amp;&amp; !<name>isExclusive</name></expr> )</condition><then><block>{
    <comment type="block">/* Failed to open the file for read/write access. Try read-only. */</comment>
    <expr_stmt><expr><name>flags</name> &amp;= ~(<name>SQLITE_OPEN_READWRITE</name>|<name>SQLITE_OPEN_CREATE</name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
    <return>return <expr><call><name>unixOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>isDelete</name></expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <expr_stmt><expr><name>zPath</name> = <name>zName</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
  <else>else<block>{
    <expr_stmt><expr>((<name>unixFile</name>*)<name>pFile</name>)-&gt;<name>openFlags</name> = <name>openFlags</name></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pOutFlags</name> = <name>flags</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fd</name>!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>isOpenDirectory</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>openDirectory</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr>&amp;<name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak if fail, already in error */</comment>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FD_CLOEXEC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> | <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>noLock</name> = <name>eType</name>!=<name>SQLITE_OPEN_MAIN_DB</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_PREFER_PROXY_LOCKING</name></expr></cpp:if>
  <if>if<condition>( <expr><name>zPath</name>!=<name>NULL</name> &amp;&amp; !<name>noLock</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>envforce</name> =<init> <expr><call><name>getenv</name><argument_list>(<argument><expr>"SQLITE_FORCE_PROXY_LOCKING"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>useProxy</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 
    ** 0 means never use proxy, NULL means use proxy for non-local files only
    */</comment>
    <if>if<condition>( <expr><name>envforce</name>!=<name>NULL</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>useProxy</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>envforce</name></expr></argument>)</argument_list></call>&gt;0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type>struct <name>statfs</name></type> <name>fsInfo</name></decl>;</decl_stmt>

      <if>if<condition>( <expr><call><name>statfs</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr>&amp;<name>fsInfo</name></expr></argument>)</argument_list></call> == -1</expr> )</condition><then><block>{
				<expr_stmt><expr>((<name>unixFile</name>*)<name>pFile</name>)-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>dirfd</name>&gt;=0</expr> )</condition><then> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dirfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* silently leak if fail, in error */</comment>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak if fail, in error */</comment>
        <return>return <expr><name>SQLITE_IOERR_ACCESS</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>useProxy</name> = !(<name>fsInfo</name>.<name>f_flags</name>&amp;<name>MNT_LOCAL</name>)</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>useProxy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>fillInUnixFile</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>noLock</name></expr></argument>, <argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>proxyTransformUnixFile</name><argument_list>(<argument><expr>(<name>unixFile</name>*)<name>pFile</name></expr></argument>, <argument><expr>":auto:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <return>return <expr><call><name>fillInUnixFile</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>noLock</name></expr></argument>, <argument><expr><name>isDelete</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete the file at zPath. If the dirSync argument is true, fsync()
** the directory after deleting the file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixDelete</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>,     <comment type="block">/* VFS containing this as the xDelete method */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zPath</name></decl></param>,        <comment type="block">/* Name of file to be deleted */</comment>
  <param><decl><type><name>int</name></type> <name>dirSync</name></decl></param>               <comment type="block">/* If true, fsync() directory after deleting file */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_DELETE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_DISABLE_DIRSYNC</name></cpp:ifndef>
  <if>if<condition>( <expr><name>dirSync</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>openDirectory</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
      <if>if<condition>( <expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call>==-1</expr> )</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if>if<condition>( <expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> )</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_DIR_FSYNC</name></expr>;</expr_stmt>
      }</block></then></if></then></if>
      <if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call>&amp;&amp;!<name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_DIR_CLOSE</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Test the existance of or access permissions of file zPath. The
** test performed depends on the value of flags:
**
**     SQLITE_ACCESS_EXISTS: Return 1 if the file exists
**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.
**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.
**
** Otherwise return 0.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixAccess</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>,   <comment type="block">/* The VFS containing this xAccess method */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zPath</name></decl></param>,      <comment type="block">/* Path of the file to examine */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,              <comment type="block">/* What do we want to learn about the zPath file? */</comment>
  <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>            <comment type="block">/* Write result boolean here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>amode</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_ACCESS;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <switch>switch<condition>( <expr><name>flags</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_ACCESS_EXISTS</name></expr>:
      <expr_stmt><expr><name>amode</name> = <name>F_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SQLITE_ACCESS_READWRITE</name></expr>:
      <expr_stmt><expr><name>amode</name> = <name>W_OK</name>|<name>R_OK</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SQLITE_ACCESS_READ</name></expr>:
      <expr_stmt><expr><name>amode</name> = <name>R_OK</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!"Invalid flags argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>
  <expr_stmt><expr>*<name>pResOut</name> = (<call><name>access</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>amode</name></expr></argument>)</argument_list></call>==0)</expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Turn a relative pathname into a full pathname. The relative path
** is stored as a nul-terminated string in the buffer pointed to by
** zPath. 
**
** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes 
** (in this case, MAX_PATHNAME bytes). The full-path is written to
** this buffer before returning.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixFullPathname</name><parameter_list>(
  <param><decl><type><name>sqlite3_vfs</name> *</type><name>pVfs</name></decl></param>,            <comment type="block">/* Pointer to vfs object */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zPath</name></decl></param>,            <comment type="block">/* Possibly relative input path */</comment>
  <param><decl><type><name>int</name></type> <name>nOut</name></decl></param>,                     <comment type="block">/* Size of output buffer in bytes */</comment>
  <param><decl><type><name>char</name> *</type><name>zOut</name></decl></param>                    <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. This function could fail if, for example, the
  ** current working directory has been unlinked.
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_ERROR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVfs</name>-&gt;<name>mxPathname</name>==<name>MAX_PATHNAME</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>nOut</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <if>if<condition>( <expr><name><name>zPath</name><index>[<expr>0</expr>]</index></name>=='/'</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nOut</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nCwd</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>getcwd</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>nOut</name>-1</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nCwd</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nOut</name>-<name>nCwd</name></expr></argument>, <argument><expr>&amp;<name><name>zOut</name><index>[<expr><name>nCwd</name></expr>]</index></name></expr></argument>, <argument><expr>"/%s"</expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>
<function><type><name>static</name> <name>void</name> *</type><name>unixDlOpen</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFilename</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>dlopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>RTLD_NOW</name> | <name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** SQLite calls this function immediately after a call to unixDlSym() or
** unixDlOpen() fails (returns a null pointer). If a more detailed error
** message is available, it is written to zBufOut. If no error message
** is available, zBufOut is left unmodified and SQLite uses a default
** error message.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>unixDlError</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBufOut</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>unixEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> = <call><name>dlerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zErr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBufOut</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>unixLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><name>static</name></type> <name>void</name> <argument_list>(<argument><expr>*<call><name>unixDlSym</name><argument_list>(<argument><expr><name>sqlite3_vfs</name> *<name>NotUsed</name></expr></argument>, <argument><expr><name>void</name> *<name>p</name></expr></argument>, <argument><expr><name>const</name> <name>char</name>*<name>zSym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list><block>{
  <comment type="block">/* 
  ** GCC with -pedantic-errors says that C90 does not allow a void* to be
  ** cast into a pointer to a function.  And yet the library dlsym() routine
  ** returns a void* which is really a pointer to a function.  So how do we
  ** use dlsym() with -pedantic-errors?
  **
  ** Variable x below is defined to be a pointer to a function taking
  ** parameters void* and const char* and returning a pointer to a function.
  ** We initialize x by assigning it a pointer to the dlsym() function.
  ** (That assignment requires a cast.)  Then we call the function that
  ** x points to.  
  **
  ** This work-around is unlikely to work correctly on any system where
  ** you really cannot cast a function pointer into void*.  But then, on the
  ** other hand, dlsym() will not work on such a system either, so we have
  ** not really lost anything.
  */</comment>
  <macro><name>void</name> <argument_list>(<argument>*(*x)(void*,const char*)</argument>)</argument_list><argument_list>(<argument>void</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>x</name> = (<call><name>void</name><argument_list>(<argument><expr>*(*)(<name>void</name>*,<name>const</name> <name>char</name>*)</expr></argument>)</argument_list></call>(<name>void</name>))<name>dlsym</name></expr>;</expr_stmt>
  <return>return <expr>(*<name>x</name>)(<name>p</name>, <name>zSym</name>)</expr>;</return>
}</block></decl></decl_stmt>
<function><type><name>static</name> <name>void</name></type> <name>unixDlClose</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pHandle</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if SQLITE_OMIT_LOAD_EXTENSION is defined: */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>unixDlOpen</name>  0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>unixDlError</name> 0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>unixDlSym</name>   0</cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>unixDlClose</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write nBuf bytes of random data to the supplied buffer zBuf.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixRandomness</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>nBuf</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>size_t</name>)<name>nBuf</name>&gt;=(<call><name>sizeof</name><argument_list>(<argument><expr><name>time_t</name></expr></argument>)</argument_list></call>+<call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We have to initialize zBuf to prevent valgrind from reporting
  ** errors.  The reports issued by valgrind are incorrect - we would
  ** prefer that the randomness be increased by making use of the
  ** uninitialized space in zBuf - but valgrind errors tend to worry
  ** some users.  Rather than argue, it seems easier just to initialize
  ** the whole array and silence valgrind, even if that means less randomness
  ** in the random seed.
  **
  ** When testing, initializing zBuf[] to zero is all we do.  That means
  ** that we always use the same random number sequence.  This makes the
  ** tests repeatable.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name>, <name>fd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr>"/dev/urandom"</expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zBuf</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call>+<call><name>sizeof</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call>&lt;=(<name>size_t</name>)<name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nBuf</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nBuf</name> = <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>nBuf</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
** The argument is the number of microseconds we want to sleep.
** The return value is the number of microseconds of sleep actually
** requested from the underlying operating system, a number which
** might be greater than or equal to the argument, but not less
** than the argument.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixSleep</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>microseconds</name></decl></param>)</parameter_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
  <decl_stmt><decl><type>struct <name>timespec</name></type> <name>sp</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>sp</name>.<name>tv_sec</name> = <name>microseconds</name> / 1000000</expr>;</expr_stmt>
  <expr_stmt><expr><name>sp</name>.<name>tv_nsec</name> = (<name>microseconds</name> % 1000000) * 1000</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>nanosleep</name><argument_list>(<argument><expr>&amp;<name>sp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microseconds</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USLEEP</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HAVE_USLEEP</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>usleep</name><argument_list>(<argument><expr><name>microseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>microseconds</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>seconds</name> =<init> <expr>(<name>microseconds</name>+999999)/1000000</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>seconds</name>*1000000</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The following variable, if set to a non-zero value, is interpreted as
** the number of seconds since 1970 and is used to set the result of
** sqlite3OsCurrentTime() during testing.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_current_time</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Fake system time in seconds since 1970. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write the
** current time and date as a Julian Day number into *prNow and
** return 0.  Return 1 if the time and date cannot be found.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixCurrentTime</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>double</name> *</type><name>prNow</name></decl></param>)</parameter_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_GETTOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prNow</name> = <name>t</name>/86400.0 + 2440587.5</expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:elif>
  <decl_stmt><decl><type>struct <name>timespec</name></type> <name>sNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr>&amp;<name>sNow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prNow</name> = 2440587.5 + <name>sNow</name>.<name>tv_sec</name>/86400.0 + <name>sNow</name>.<name>tv_nsec</name>/86400000000000.0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type>struct <name>timeval</name></type> <name>sNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr>&amp;<name>sNow</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prNow</name> = 2440587.5 + <name>sNow</name>.<name>tv_sec</name>/86400.0 + <name>sNow</name>.<name>tv_usec</name>/86400000000.0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if>if<condition>( <expr><name>sqlite3_current_time</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>prNow</name> = <name>sqlite3_current_time</name>/86400.0 + 2440587.5</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** We added the xGetLastError() method with the intention of providing
** better low-level error messages when operating-system problems come up
** during SQLite operation.  But so far, none of that has been implemented
** in the core.  So this routine is never called.  For now, it is merely
** a place-holder.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>unixGetLastError</name><parameter_list>(<param><decl><type><name>sqlite3_vfs</name> *</type><name>NotUsed</name></decl></param>, <param><decl><type><name>int</name></type> <name>NotUsed2</name></decl></param>, <param><decl><type><name>char</name> *</type><name>NotUsed3</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
************************ End of sqlite3_vfs methods ***************************
******************************************************************************/</comment>

<comment type="block">/******************************************************************************
************************** Begin Proxy Locking ********************************
**
** Proxy locking is a "uber-locking-method" in this sense:  It uses the
** other locking methods on secondary lock files.  Proxy locking is a
** meta-layer over top of the primitive locking implemented above.  For
** this reason, the division that implements of proxy locking is deferred
** until late in the file (here) after all of the other I/O methods have
** been defined - so that the primitive locking methods are available
** as services to help with the implementation of proxy locking.
**
****
**
** The default locking schemes in SQLite use byte-range locks on the
** database file to coordinate safe, concurrent access by multiple readers
** and writers [http://sqlite.org/lockingv3.html].  The five file locking
** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implemented
** as POSIX read &amp; write locks over fixed set of locations (via fsctl),
** on AFP and SMB only exclusive byte-range locks are available via fsctl
** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.
** To simulate a F_RDLCK on the shared range, on AFP a randomly selected
** address in the shared range is taken for a SHARED lock, the entire
** shared range is taken for an EXCLUSIVE lock):
**
**      PENDING_BYTE        0x40000000		   	
**      RESERVED_BYTE       0x40000001
**      SHARED_RANGE        0x40000002 -&gt; 0x40000200
**
** This works well on the local file system, but shows a nearly 100x
** slowdown in read performance on AFP because the AFP client disables
** the read cache when byte-range locks are present.  Enabling the read
** cache exposes a cache coherency problem that is present on all OS X
** supported network file systems.  NFS and AFP both observe the
** close-to-open semantics for ensuring cache coherency
** [http://nfs.sourceforge.net/#faq_a8], which does not effectively
** address the requirements for concurrent database access by multiple
** readers and writers
** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].
**
** To address the performance and cache coherency issues, proxy file locking
** changes the way database access is controlled by limiting access to a
** single host at a time and moving file locks off of the database file
** and onto a proxy file on the local file system.  
**
**
** Using proxy locks
** -----------------
**
** C APIs
**
**  sqlite3_file_control(db, dbname, SQLITE_SET_LOCKPROXYFILE,
**                       &lt;proxy_path&gt; | ":auto:");
**  sqlite3_file_control(db, dbname, SQLITE_GET_LOCKPROXYFILE, &amp;&lt;proxy_path&gt;);
**
**
** SQL pragmas
**
**  PRAGMA [database.]lock_proxy_file=&lt;proxy_path&gt; | :auto:
**  PRAGMA [database.]lock_proxy_file
**
** Specifying ":auto:" means that if there is a conch file with a matching
** host ID in it, the proxy path in the conch file will be used, otherwise
** a proxy path based on the user's temp dir
** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and the
** actual proxy file name is generated from the name and path of the
** database file.  For example:
**
**       For database path "/Users/me/foo.db" 
**       The lock path will be "&lt;tmpdir&gt;/sqliteplocks/_Users_me_foo.db:auto:")
**
** Once a lock proxy is configured for a database connection, it can not
** be removed, however it may be switched to a different proxy path via
** the above APIs (assuming the conch file is not being held by another
** connection or process). 
**
**
** How proxy locking works
** -----------------------
**
** Proxy file locking relies primarily on two new supporting files: 
**
**   *  conch file to limit access to the database file to a single host
**      at a time
**
**   *  proxy file to act as a proxy for the advisory locks normally
**      taken on the database
**
** The conch file - to use a proxy file, sqlite must first "hold the conch"
** by taking an sqlite-style shared lock on the conch file, reading the
** contents and comparing the host's unique host ID (see below) and lock
** proxy path against the values stored in the conch.  The conch file is
** stored in the same directory as the database file and the file name
** is patterned after the database file name as ".&lt;databasename&gt;-conch".
** If the conch file does not exist, or it's contents do not match the
** host ID and/or proxy path, then the lock is escalated to an exclusive
** lock and the conch file contents is updated with the host ID and proxy
** path and the lock is downgraded to a shared lock again.  If the conch
** is held by another process (with a shared lock), the exclusive lock
** will fail and SQLITE_BUSY is returned.
**
** The proxy file - a single-byte file used for all advisory file locks
** normally taken on the database file.   This allows for safe sharing
** of the database file for multiple readers and writers on the same
** host (the conch ensures that they all use the same local lock file).
**
** There is a third file - the host ID file - used as a persistent record
** of a unique identifier for the host, a 128-byte unique host id file
** in the path defined by the HOSTIDPATH macro (default value is
** /Library/Caches/.com.apple.sqliteConchHostId).
**
** Requesting the lock proxy does not immediately take the conch, it is
** only taken when the first request to lock database file is made.  
** This matches the semantics of the traditional locking behavior, where
** opening a connection to a database file does not take a lock on it.
** The shared lock and an open file descriptor are maintained until 
** the connection to the database is closed. 
**
** The proxy file and the lock file are never deleted so they only need
** to be created the first time they are used.
**
** Configuration options
** ---------------------
**
**  SQLITE_PREFER_PROXY_LOCKING
**
**       Database files accessed on non-local file systems are
**       automatically configured for proxy locking, lock files are
**       named automatically using the same logic as
**       PRAGMA lock_proxy_file=":auto:"
**    
**  SQLITE_PROXY_DEBUG
**
**       Enables the logging of error messages during host id file
**       retrieval and creation
**
**  HOSTIDPATH
**
**       Overrides the default host ID file path location
**
**  LOCKPROXYDIR
**
**       Overrides the default directory used for lock proxy files that
**       are named automatically via the ":auto:" setting
**
**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
**
**       Permissions to use when creating a directory for storing the
**       lock proxy files, only used when LOCKPROXYDIR is not set.
**    
**    
** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,
** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 will
** force proxy locking to be used for every database file opened, and 0
** will force automatic proxy locking to be disabled for all database
** files (explicity calling the SQLITE_SET_LOCKPROXYFILE pragma or
** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).
*/</comment>

<comment type="block">/*
** Proxy locking is only available on MacOSX 
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/* simulate multiple hosts by creating unique hostid file paths */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_hostid_num</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The proxyLockingContext has the path and file structures for the remote 
** and local proxy files in it
*/</comment>
<typedef>typedef <type><struct>struct <name>proxyLockingContext</name> proxyLockingContext;</struct></type></typedef>
<struct>struct <name>proxyLockingContext</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>conchFile</name></decl>;</decl_stmt>         <comment type="block">/* Open conch file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>conchFilePath</name></decl>;</decl_stmt>         <comment type="block">/* Name of the conch file */</comment>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>lockProxy</name></decl>;</decl_stmt>         <comment type="block">/* Open proxy lock file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>lockProxyPath</name></decl>;</decl_stmt>         <comment type="block">/* Name of the proxy lock file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>dbPath</name></decl>;</decl_stmt>                <comment type="block">/* Name of the open file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>conchHeld</name></decl>;</decl_stmt>               <comment type="block">/* True if the conch is currently held */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>oldLockingContext</name></decl>;</decl_stmt>     <comment type="block">/* Original lockingcontext to restore on close */</comment>
  <decl_stmt><decl><type><name>sqlite3_io_methods</name> <name>const</name> *</type><name>pOldMethod</name></decl>;</decl_stmt>     <comment type="block">/* Original I/O methods for close */</comment>
</public>}</block>;</struct>

<comment type="block">/* HOSTIDLEN and CONCHLEN both include space for the string 
** terminating nul 
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>HOSTIDLEN</name>         128</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CONCHLEN</name>          (MAXPATHLEN+HOSTIDLEN+1)</cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HOSTIDPATH</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>HOSTIDPATH</name>       "/Library/Caches/.com.apple.sqliteConchHostId"</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* basically a copy of unixRandomness with different
** test behavior built in */</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyGenerateHostID</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pHostID</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>pid</name>, <name>fd</name>, <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>key</name> =<init> <expr>(<name>unsigned</name> <name>char</name> *)<name>pHostID</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>HOSTIDLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr>"/dev/urandom"</expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>len</name> = <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HOSTIDLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak the fd if it fails */</comment>
  }</block></then></if>
  <if>if<condition>( <expr><name>len</name> &lt; <name>HOSTIDLEN</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>time_t</name></type> <name>t</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>key</name><index>[<expr><call><name>sizeof</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAKE_PRETTY_HOSTID</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* filter the bytes into printable ascii characters and NUL terminate */</comment>
    <expr_stmt><expr><name><name>key</name><index>[<expr>(<name>HOSTIDLEN</name>-1)</expr>]</index></name> = 0x00</expr>;</expr_stmt>
    <for>for( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;(<name>HOSTIDLEN</name>-1)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr> )<block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>pa</name> =<init> <expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0x7F</expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pa</name>&lt;0x20</expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>key</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0x80 == 0x80) ? <name>pa</name>+0x40 : <name>pa</name>+0x20</expr>;</expr_stmt>
      }</block></then><else>else <if>if<condition>( <expr><name>pa</name>==0x7F</expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>key</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0x80 == 0x80) ? <name>pa</name>=0x20 : <name>pa</name>+0x7E</expr>;</expr_stmt>
      }</block></then></if></else></if>
    }</block></for>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/* writes the host id path to path, path should be an pre-allocated buffer
** with enough space for a path 
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>proxyGetHostIDPath</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>HOSTIDPATH</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if>if<condition>( <expr><name>sqlite3_hostid_num</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>suffix</name><index>[<expr>2</expr>]</index></name> =<init> <expr>"1"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>suffix</name><index>[<expr>0</expr>]</index></name> = <name><name>suffix</name><index>[<expr>0</expr>]</index></name> + <name>sqlite3_hostid_num</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"GETHOSTIDPATH  %s pid=%d\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* get the host ID from a sqlite hostid file stored in the 
** user-specific tmp directory, create the ID if it's not there already 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyGetHostID</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pHostID</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pError</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name>=<init><expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>proxyGetHostIDPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* try to create the host ID file, if it already exists read the contents */</comment>
  <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_CREAT</name>|<name>O_WRONLY</name>|<name>O_EXCL</name></expr></argument>, <argument><expr>0644</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>err</name>=<init><expr><name>errno</name></expr></init></decl>;</decl_stmt>
		
    <if>if<condition>( <expr><name>err</name>!=<name>EEXIST</name></expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PROXY_DEBUG</name></cpp:ifdef> <comment type="block">/* set the sqlite error message instead */</comment>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"sqlite error creating host ID file %s: %s\n"</expr></argument>,
              <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* couldn't create the file, read it instead */</comment>
    <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name>|<name>O_EXCL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_PROXY_DEBUG</name></cpp:ifdef> <comment type="block">/* set the sqlite error message instead */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"sqlite error opening host ID file %s: %s\n"</expr></argument>,
              <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return <expr><name>SQLITE_PERM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>len</name> = <call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pHostID</name></expr></argument>, <argument><expr><name>HOSTIDLEN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>len</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pError</name> = <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>len</name>&lt;<name>HOSTIDLEN</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pError</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_SHORT_READ</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak the fd if it fails */</comment>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"GETHOSTID  read %s pid=%d\n"</expr></argument>, <argument><expr><name>pHostID</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></then><else>else<block>{
    <comment type="block">/* we're creating the host ID file (use a random string of bytes) */</comment>
    <expr_stmt><expr><call><name>proxyGenerateHostID</name><argument_list>(<argument><expr><name>pHostID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>pwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>pHostID</name></expr></argument>, <argument><expr><name>HOSTIDLEN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>len</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pError</name> = <name>errno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>len</name>&lt;<name>HOSTIDLEN</name></expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pError</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak the fd if it fails */</comment>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"GETHOSTID  wrote %s pid=%d\n"</expr></argument>, <argument><expr><name>pHostID</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></else></if>
}</block></function>

<function><type><name>static</name> <name>int</name></type> <name>proxyGetLockPath</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>dbPath</name></decl></param>, <param><decl><type><name>char</name> *</type><name>lPath</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxLen</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dbLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCKPROXYDIR</name></cpp:ifdef>
  <expr_stmt><expr><name>len</name> = <call><name>strlcpy</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><name>LOCKPROXYDIR</name></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_CS_DARWIN_USER_TEMP_DIR</name></cpp:ifdef>
  <block>{
    <expr_stmt><expr><call><name>confstr</name><argument_list>(<argument><expr><name>_CS_DARWIN_USER_TEMP_DIR</name></expr></argument>, <argument><expr><name>lPath</name></expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr>"sqliteplocks"</expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>mkdir</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* if mkdir fails, handle as lock file creation failure */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>err</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
      <if>if<condition>( <expr><name>err</name>!=<name>EEXIST</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"proxyGetLockPath: mkdir(%s,0%o) error %d %s\n"</expr></argument>, <argument><expr><name>lPath</name></expr></argument>,
                <argument><expr><name>SQLITE_DEFAULT_PROXYDIR_PERMISSIONS</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"GETLOCKPATH  mkdir %s pid=%d\n"</expr></argument>, <argument><expr><name>lPath</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
  }</block>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>len</name> = <call><name>strlcpy</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr>"/tmp/"</expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><name><name>lPath</name><index>[<expr><name>len</name>-1</expr>]</index></name>!='/'</expr> )</condition><then><block>{
    <expr_stmt><expr><name>len</name> = <call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  
  <comment type="block">/* transform the db path to a unique cache name */</comment>
  <expr_stmt><expr><name>dbLen</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for( <init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>dbLen</name> &amp;&amp; (<name>i</name>+<name>len</name>+7)&lt;<name>maxLen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> =<init> <expr><name><name>dbPath</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>lPath</name><index>[<expr><name>i</name>+<name>len</name></expr>]</index></name> = (<name>c</name>=='/')?'_':<name>c</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name><name>lPath</name><index>[<expr><name>i</name>+<name>len</name></expr>]</index></name>='\0'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>lPath</name></expr></argument>, <argument><expr>":auto:"</expr></argument>, <argument><expr><name>maxLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Create a new VFS file descriptor (stored in memory obtained from
** sqlite3_malloc) and open the file named "path" in the file descriptor.
**
** The caller is responsible not only for closing the file descriptor
** but also for freeing the memory associated with the file descriptor.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyCreateUnixFile</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>unixFile</name> **</type><name>ppFile</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dirfd</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vfs</name></type> <name>dummyVfs</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> | <name>O_CREAT</name></expr></argument>, <argument><expr><name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>fd</name>&lt;0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
  }</block></then></if>
  
  <expr_stmt><expr><name>pNew</name> = (<name>unixFile</name> *)<call><name>sqlite3_malloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==<name>NULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <goto>goto <name>end_create_proxy</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>unixFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>dummyVfs</name>.<name>pAppData</name> = (<name>void</name>*)&amp;<name>autolockIoFinder</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>fillInUnixFile</name><argument_list>(<argument><expr>&amp;<name>dummyVfs</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr>(<name>sqlite3_file</name>*)<name>pNew</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>ppFile</name> = <name>pNew</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>
<label><name>end_create_proxy</name>:</label>    
  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak fd if error, we're already in error */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* takes the conch by taking a shared lock and read the contents conch, if 
** lockPath is non-NULL, the host ID and lock file path must match.  A NULL 
** lockPath means that the lockPath in the conch file will be used if the 
** host IDs match, or a new lock path will be generated automatically 
** and written to the conch file.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyTakeConch</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt> 
  
  <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>conchHeld</name>&gt;0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>conchFile</name> =<init> <expr><name>pCtx</name>-&gt;<name>conchFile</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>testValue</name><index>[<expr><name>CONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>conchValue</name><index>[<expr><name>CONCHLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>lockPath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tLockPath</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>readRc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>syncPerms</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TAKECONCH  %d for %s pid=%d\n"</expr></argument>, <argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>,
             <argument><expr>(<name>pCtx</name>-&gt;<name>lockProxyPath</name> ? <name>pCtx</name>-&gt;<name>lockProxyPath</name> : ":auto:")</expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = <name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xLock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>pError</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>testValue</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>CONCHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* conch is fixed size */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>proxyGetHostID</name><argument_list>(<argument><expr><name>testValue</name></expr></argument>, <argument><expr>&amp;<name>pError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>rc</name>&amp;0xff)==<name>SQLITE_IOERR</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>pError</name></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr>&amp;<name><name>testValue</name><index>[<expr><name>HOSTIDLEN</name></expr>]</index></name></expr></argument>, <argument><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <goto>goto <name>end_takeconch</name>;</goto>
    }</block></then></if>
    
    <expr_stmt><expr><name>readRc</name> = <call><name>unixRead</name><argument_list>(<argument><expr>(<name>sqlite3_file</name> *)<name>conchFile</name></expr></argument>, <argument><expr><name>conchValue</name></expr></argument>, <argument><expr><name>CONCHLEN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>readRc</name>!=<name>SQLITE_IOERR_SHORT_READ</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>readRc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr>(<name>rc</name>&amp;0xff)==<name>SQLITE_IOERR</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>conchFile</name>-&gt;<name>lastErrno</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>rc</name> = <name>readRc</name></expr>;</expr_stmt>
        <goto>goto <name>end_takeconch</name>;</goto>
      }</block></then></if>
      <comment type="block">/* if the conch has data compare the contents */</comment>
      <if>if<condition>( <expr>!<name>pCtx</name>-&gt;<name>lockProxyPath</name></expr> )</condition><then><block>{
        <comment type="block">/* for auto-named local lock file, just check the host ID and we'll
         ** use the local lock file path that's already in there */</comment>
        <if>if<condition>( <expr>!<call><name>memcmp</name><argument_list>(<argument><expr><name>testValue</name></expr></argument>, <argument><expr><name>conchValue</name></expr></argument>, <argument><expr><name>HOSTIDLEN</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>tLockPath</name> = (<name>char</name> *)&amp;<name><name>conchValue</name><index>[<expr><name>HOSTIDLEN</name></expr>]</index></name></expr>;</expr_stmt>
          <goto>goto <name>end_takeconch</name>;</goto>
        }</block></then></if>
      }</block></then><else>else<block>{
        <comment type="block">/* we've got the conch if conchValue matches our path and host ID */</comment>
        <if>if<condition>( <expr>!<call><name>memcmp</name><argument_list>(<argument><expr><name>testValue</name></expr></argument>, <argument><expr><name>conchValue</name></expr></argument>, <argument><expr><name>CONCHLEN</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <goto>goto <name>end_takeconch</name>;</goto>
        }</block></then></if>
      }</block></else></if>
    }</block></then><else>else<block>{
      <comment type="block">/* a short read means we're "creating" the conch (even though it could 
      ** have been user-intervention), if we acquire the exclusive lock,
      ** we'll try to match the current on-disk permissions of the database
      */</comment>
      <expr_stmt><expr><name>syncPerms</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
    
    <comment type="block">/* either conch was emtpy or didn't match */</comment>
    <if>if<condition>( <expr>!<name>pCtx</name>-&gt;<name>lockProxyPath</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>proxyGetLockPath</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>lockPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tLockPath</name> = <name>lockPath</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr>&amp;<name><name>testValue</name><index>[<expr><name>HOSTIDLEN</name></expr>]</index></name></expr></argument>, <argument><expr><name>lockPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/* update conch with host and path (this will fail if other process
     ** has a shared lock already) */</comment>
    <expr_stmt><expr><name>rc</name> = <name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xLock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>, <argument><expr><name>EXCLUSIVE_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>unixWrite</name><argument_list>(<argument><expr>(<name>sqlite3_file</name> *)<name>conchFile</name></expr></argument>, <argument><expr><name>testValue</name></expr></argument>, <argument><expr><name>CONCHLEN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>syncPerms</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>err</name> =<init> <expr><call><name>fstat</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>err</name>==0</expr> )</condition><then><block>{
          <comment type="block">/* try to match the database file permissions, ignore failure */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_PROXY_DEBUG</name></cpp:ifndef>
          <expr_stmt><expr><call><name>fchmod</name><argument_list>(<argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>buf</name>.<name>st_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <if>if<condition>( <expr><call><name>fchmod</name><argument_list>(<argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>buf</name>.<name>st_mode</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"fchmod %o FAILED with %d %s\n"</expr></argument>,
                             <argument><expr><name>buf</name>.<name>st_mode</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"fchmod %o SUCCEDED\n"</expr></argument>,<argument><expr><name>buf</name>.<name>st_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then><else>else<block>{
          <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name>errno</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"STAT FAILED[%d] with %d %s\n"</expr></argument>, 
                          <argument><expr><name>err</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xUnlock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>, <argument><expr><name>SHARED_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
<label><name>end_takeconch</name>:</label>
    <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>(<argument><expr>"TRANSPROXY: CLOSE  %d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pFile</name>-&gt;<name>openFlags</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pFile</name>-&gt;<name>h</name>&gt;=0</expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRICT_CLOSE_ERROR</name></cpp:ifdef>
        <if>if<condition>( <expr><call><name>close</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFile</name>-&gt;<name>lastErrno</name> = <name>errno</name></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_IOERR_CLOSE</name></expr>;</return>
        }</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* silently leak fd if fail */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
      <expr_stmt><expr><name>pFile</name>-&gt;<name>h</name> = -1</expr>;</expr_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>fd</name> =<init> <expr><call><name>open</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>openFlags</name></expr></argument>,
                    <argument><expr><name>SQLITE_DEFAULT_FILE_PERMISSIONS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>OSTRACE2</name><argument_list>(<argument><expr>"TRANSPROXY: OPEN  %d\n"</expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>fd</name>&gt;=0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pFile</name>-&gt;<name>h</name> = <name>fd</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>rc</name>=<name>SQLITE_CANTOPEN</name></expr>;</expr_stmt> <comment type="block">/* SQLITE_BUSY? proxyTakeConch called
                               during locking */</comment>
      }</block></else></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; !<name>pCtx</name>-&gt;<name>lockProxy</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>path</name> =<init> <expr><name>tLockPath</name> ? <name>tLockPath</name> : <name>pCtx</name>-&gt;<name>lockProxyPath</name></expr></init></decl>;</decl_stmt>
      <comment type="block">/* ACS: Need to make a copy of path sometimes */</comment>
      <expr_stmt><expr><name>rc</name> = <call><name>proxyCreateUnixFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>pCtx</name>-&gt;<name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCtx</name>-&gt;<name>conchHeld</name> = 1</expr>;</expr_stmt>

      <if>if<condition>( <expr><name>tLockPath</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>tLockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>lockProxy</name>-&gt;<name>pMethod</name> == &amp;<name>afpIoMethods</name></expr> )</condition><then><block>{
          <expr_stmt><expr>((<name>afpLockingContext</name> *)<name>pCtx</name>-&gt;<name>lockProxy</name>-&gt;<name>lockingContext</name>)-&gt;<name>dbPath</name> =
                     <name>pCtx</name>-&gt;<name>lockProxyPath</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xUnlock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"TAKECONCH  %d %s\n"</expr></argument>, <argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>, <argument><expr><name>rc</name>==<name>SQLITE_OK</name>?"ok":"failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** If pFile holds a lock on a conch file, then release that lock.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyReleaseConch</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                     <comment type="block">/* Subroutine return code */</comment>
  <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name></decl>;</decl_stmt>  <comment type="block">/* The locking context for the proxy lock */</comment>
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>conchFile</name></decl>;</decl_stmt>        <comment type="block">/* Name of the conch file */</comment>

  <expr_stmt><expr><name>pCtx</name> = (<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>conchFile</name> = <name>pCtx</name>-&gt;<name>conchFile</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"RELEASECONCH  %d for %s pid=%d\n"</expr></argument>, <argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr>(<name>pCtx</name>-&gt;<name>lockProxyPath</name> ? <name>pCtx</name>-&gt;<name>lockProxyPath</name> : ":auto:")</expr></argument>, 
           <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name>-&gt;<name>conchHeld</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xUnlock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"RELEASECONCH  %d %s\n"</expr></argument>, <argument><expr><name>conchFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr>(<name>rc</name>==<name>SQLITE_OK</name> ? "ok" : "failed")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Given the name of a database file, compute the name of its conch file.
** Store the conch filename in memory obtained from sqlite3_malloc().
** Make *pConchPath point to the new name.  Return SQLITE_OK on success
** or SQLITE_NOMEM if unable to obtain memory.
**
** The caller is responsible for ensuring that the allocated memory
** space is eventually freed.
**
** *pConchPath is set to NULL if a memory allocation error occurs.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyCreateConchPathname</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dbPath</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pConchPath</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                        <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Length of database filename - dbPath */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>conchPath</name></decl>;</decl_stmt>              <comment type="block">/* buffer in which to construct conch name */</comment>

  <comment type="block">/* Allocate space for the conch filename and initialize the name to
  ** the name of the original database file. */</comment>  
  <expr_stmt><expr>*<name>pConchPath</name> = <name>conchPath</name> = (<name>char</name> *)<call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>len</name> + 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>conchPath</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>conchPath</name></expr></argument>, <argument><expr><name>dbPath</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* now insert a "." before the last / character */</comment>
  <for>for( <init><expr><name>i</name>=(<name>len</name>-1)</expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr> )<block>{
    <if>if<condition>( <expr><name><name>conchPath</name><index>[<expr><name>i</name></expr>]</index></name>=='/'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name><name>conchPath</name><index>[<expr><name>i</name></expr>]</index></name>='.'</expr>;</expr_stmt>
  <while>while <condition>( <expr><name>i</name>&lt;<name>len</name></expr> )</condition><block>{
    <expr_stmt><expr><name><name>conchPath</name><index>[<expr><name>i</name>+1</expr>]</index></name>=<name><name>dbPath</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
  }</block></while>

  <comment type="block">/* append the "-conch" suffix to the file */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>conchPath</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>"-conch"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>conchPath</name></expr></argument>)</argument_list></call> == <name>len</name>+7</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>


<comment type="block">/* Takes a fully configured proxy locking-style unix file and switches
** the local lock file path 
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>switchLockProxyPath</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>oldPath</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  }</block></then></if>  

  <comment type="block">/* nothing to do if the path is NULL, :auto: or matches the existing path */</comment>
  <if>if<condition>( <expr>!<name>path</name> || <name><name>path</name><index>[<expr>0</expr>]</index></name>=='\0' || !<call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>":auto:"</expr></argument>)</argument_list></call> ||
    (<name>oldPath</name> &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>oldPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>lockProxy</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxy</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>lockProxy</name>=<name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>conchHeld</name> = 0</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>lockProxy</name>!=<name>NULL</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name>=<name>lockProxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr>(<name>sqlite3_file</name> *)<name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>oldPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** pFile is a file that has been opened by a prior xOpen call.  dbPath
** is a string buffer at least MAXPATHLEN+1 characters in size.
**
** This routine find the filename associated with pFile and writes it
** int dbPath.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyGetDbPathForUnixFile</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dbPath</name></decl></param>)</parameter_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pMethod</name> == &amp;<name>afpIoMethods</name></expr> )</condition><then><block>{
    <comment type="block">/* afp style keeps a reference to the db path in the filePath field 
    ** of the struct */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call>&lt;=<name>MAXPATHLEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr>((<name>afpLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name>)-&gt;<name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pMethod</name> == &amp;<name>dotlockIoMethods</name></expr> )</condition><then><block>{
    <comment type="block">/* dot lock style uses the locking context to store the dot lock
    ** file path */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr>(<name>char</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call> - <call><name>strlen</name><argument_list>(<argument><expr><name>DOTLOCK_SUFFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* all other styles use the locking context to store the db file path */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strlen</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call>&lt;=<name>MAXPATHLEN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Takes an already filled in unix file and alters it so all file locking 
** will be performed on the local proxy lock file.  The following fields
** are preserved in the locking context so that they can be restored and 
** the unix structure properly cleaned up at close time:
**  -&gt;lockingContext
**  -&gt;pMethod
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyTransformUnixFile</name><parameter_list>(<param><decl><type><name>unixFile</name> *</type><name>pFile</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>dbPath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>       <comment type="block">/* Name of the database file */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>lockPath</name>=<init><expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  
  <if>if<condition>( <expr><name>pFile</name>-&gt;<name>locktype</name>!=<name>NO_LOCK</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>proxyGetDbPathForUnixFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>path</name> || <name><name>path</name><index>[<expr>0</expr>]</index></name>=='\0' || !<call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>":auto:"</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>lockPath</name>=<name>NULL</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>lockPath</name>=(<name>char</name> *)<name>path</name></expr>;</expr_stmt>
  }</block></else></if>
  
  <expr_stmt><expr><call><name>OSTRACE4</name><argument_list>(<argument><expr>"TRANSPROXY  %d for %s pid=%d\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr>(<name>lockPath</name> ? <name>lockPath</name> : ":auto:")</expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCtx</name> = <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCtx</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCtx</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCtx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>proxyCreateConchPathname</name><argument_list>(<argument><expr><name>dbPath</name></expr></argument>, <argument><expr>&amp;<name>pCtx</name>-&gt;<name>conchFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <call><name>proxyCreateUnixFile</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>conchFilePath</name></expr></argument>, <argument><expr>&amp;<name>pCtx</name>-&gt;<name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>  
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>lockPath</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>lockPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <comment type="block">/* all memory is allocated, proxys are created and assigned, 
    ** switch the locking context and pMethod then return.
    */</comment>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>dbPath</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>oldLockingContext</name> = <name>pFile</name>-&gt;<name>lockingContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>lockingContext</name> = <name>pCtx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCtx</name>-&gt;<name>pOldMethod</name> = <name>pFile</name>-&gt;<name>pMethod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pMethod</name> = &amp;<name>proxyIoMethods</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>conchFile</name></expr> )</condition><then><block>{ 
      <expr_stmt><expr><name>rc</name> = <name>pCtx</name>-&gt;<name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr>(<name>sqlite3_file</name> *)<name>pCtx</name>-&gt;<name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>conchFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>OSTRACE3</name><argument_list>(<argument><expr>"TRANSPROXY  %d %s\n"</expr></argument>, <argument><expr><name>pFile</name>-&gt;<name>h</name></expr></argument>,
           <argument><expr>(<name>rc</name>==<name>SQLITE_OK</name> ? "ok" : "failed")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** This routine handles sqlite3_file_control() calls that are specific
** to proxy locking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyFileControl</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>)</parameter_list><block>{
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_GET_LOCKPROXYFILE</name></expr>: <block>{
      <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pFile</name>-&gt;<name>pMethod</name> == &amp;<name>proxyIoMethods</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr> )</condition><then><block>{
          <expr_stmt><expr>*(<name>const</name> <name>char</name> **)<name>pArg</name> = <name>pCtx</name>-&gt;<name>lockProxyPath</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr>*(<name>const</name> <name>char</name> **)<name>pArg</name> = ":auto: (not held)"</expr>;</expr_stmt>
        }</block></else></if>
      }</block></then> <else>else <block>{
        <expr_stmt><expr>*(<name>const</name> <name>char</name> **)<name>pArg</name> = <name>NULL</name></expr>;</expr_stmt>
      }</block></else></if>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    }</block>
    </case><case>case <expr><name>SQLITE_SET_LOCKPROXYFILE</name></expr>: <block>{
      <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>isProxyStyle</name> =<init> <expr>(<name>pFile</name>-&gt;<name>pMethod</name> == &amp;<name>proxyIoMethods</name>)</expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pArg</name>==<name>NULL</name> || (<name>const</name> <name>char</name> *)<name>pArg</name>==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>isProxyStyle</name></expr> )</condition><then><block>{
          <comment type="block">/* turn off proxy locking - not supported */</comment>
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr> <comment type="block">/*SQLITE_PROTOCOL? SQLITE_MISUSE?*/</comment>;</expr_stmt>
        }</block></then><else>else<block>{
          <comment type="block">/* turn off proxy locking - already off - NOOP */</comment>
          <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then><else>else<block>{
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>proxyPath</name> =<init> <expr>(<name>const</name> <name>char</name> *)<name>pArg</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>isProxyStyle</name></expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> 
            <expr>(<name>proxyLockingContext</name>*)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>pArg</name></expr></argument>, <argument><expr>":auto:"</expr></argument>)</argument_list></call> 
           || (<name>pCtx</name>-&gt;<name>lockProxyPath</name> &amp;&amp;
               !<call><name>strncmp</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call>)</expr>
          )</condition><then><block>{
            <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>rc</name> = <call><name>switchLockProxyPath</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then><else>else<block>{
          <comment type="block">/* turn on proxy file locking */</comment>
          <expr_stmt><expr><name>rc</name> = <call><name>proxyTransformUnixFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>proxyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
      <return>return <expr><name>rc</name></expr>;</return>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* The call assures that only valid opcodes are sent */</comment>
    }</block>
  </default>}</block></switch>
  <comment type="block">/*NOTREACHED*/</comment>
  <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Within this division (the proxying locking implementation) the procedures
** above this point are all utilities.  The lock-related methods of the
** proxy-locking sqlite3_io_method object follow.
*/</comment>


<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyCheckReservedLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pResOut</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>proxy</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxy</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>proxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xCheckReservedLock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>proxy</name></expr></argument>, <argument><expr><name>pResOut</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyLock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>proxy</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxy</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <name>proxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xLock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>proxy</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>proxy</name>-&gt;<name>locktype</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Lower the locking level on file descriptor pFile to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyUnlock</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>locktype</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>proxyTakeConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>proxy</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxy</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <name>proxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xUnlock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>proxy</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>locktype</name> = <name>proxy</name>-&gt;<name>locktype</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Close a file that uses proxy locks.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>proxyClose</name><parameter_list>(<param><decl><type><name>sqlite3_file</name> *</type><name>id</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>( <expr><name>id</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>pFile</name> =<init> <expr>(<name>unixFile</name>*)<name>id</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proxyLockingContext</name> *</type><name>pCtx</name> =<init> <expr>(<name>proxyLockingContext</name> *)<name>pFile</name>-&gt;<name>lockingContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>lockProxy</name> =<init> <expr><name>pCtx</name>-&gt;<name>lockProxy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unixFile</name> *</type><name>conchFile</name> =<init> <expr><name>pCtx</name>-&gt;<name>conchFile</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
    
    <if>if<condition>( <expr><name>lockProxy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>lockProxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xUnlock</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>lockProxy</name></expr></argument>, <argument><expr><name>NO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><name>rc</name> = <name>lockProxy</name>-&gt;<name>pMethod</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>lockProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCtx</name>-&gt;<name>lockProxy</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>conchFile</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pCtx</name>-&gt;<name>conchHeld</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <call><name>proxyReleaseConch</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>rc</name> = <name>conchFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr>(<name>sqlite3_file</name>*)<name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then> <return>return <expr><name>rc</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>conchFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>lockProxyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>conchFilePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name>-&gt;<name>dbPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* restore the original locking context and pMethod then close it */</comment>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>lockingContext</name> = <name>pCtx</name>-&gt;<name>oldLockingContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFile</name>-&gt;<name>pMethod</name> = <name>pCtx</name>-&gt;<name>pOldMethod</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pFile</name>-&gt;<name>pMethod</name>-&gt;<call><name>xClose</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__APPLE__) &amp;&amp; SQLITE_ENABLE_LOCKING_STYLE */</comment>
<comment type="block">/*
** The proxy locking style is intended for use with AFP filesystems.
** And since AFP is only supported on MacOSX, the proxy locking is also
** restricted to MacOSX.
** 
**
******************* End of the proxy lock implementation **********************
******************************************************************************/</comment>

<comment type="block">/*
** Initialize the operating system interface.
**
** This routine registers all VFS implementations for unix-like operating
** systems.  This routine, and the sqlite3_os_end() routine that follows,
** should be the only routines in this file that are visible from other
** files.
**
** This routine is called once during SQLite initialization and by a
** single thread.  The memory allocation and mutex subsystems have not
** necessarily been initialized when this routine is called, and so they
** should not be used.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ 
  <comment type="block">/* 
  ** The following macro defines an initializer for an sqlite3_vfs object.
  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
  ** to the "finder" function.  (pAppData is a pointer to a pointer because
  ** silly C90 rules prohibit a void* from being cast to a function pointer
  ** and so we have to go through the intermediate pointer to avoid problems
  ** when compiling with -pedantic-errors on GCC.)
  **
  ** The FINDER parameter to this macro is the name of the pointer to the
  ** finder-function.  The finder-function returns a pointer to the
  ** sqlite_io_methods object that implements the desired locking
  ** behaviors.  See the division above that contains the IOMETHODS
  ** macro for addition information on finder-functions.
  **
  ** Most finders simply return a pointer to a fixed sqlite3_io_methods
  ** object.  But the "autolockIoFinder" available on MacOSX does a little
  ** more than that; it looks at the filesystem type that hosts the 
  ** database file and tries to choose an locking method appropriate for
  ** that filesystem time.
  */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>UNIXVFS</name>(VFSNAME, FINDER) {                        \
    1,                    <comment type="block">/* iVersion */</comment>                    \
    sizeof(unixFile),     <comment type="block">/* szOsFile */</comment>                    \
    MAX_PATHNAME,         <comment type="block">/* mxPathname */</comment>                  \
    0,                    <comment type="block">/* pNext */</comment>                       \
    VFSNAME,              <comment type="block">/* zName */</comment>                       \
    (void*)&amp;FINDER,       <comment type="block">/* pAppData */</comment>                    \
    unixOpen,             <comment type="block">/* xOpen */</comment>                       \
    unixDelete,           <comment type="block">/* xDelete */</comment>                     \
    unixAccess,           <comment type="block">/* xAccess */</comment>                     \
    unixFullPathname,     <comment type="block">/* xFullPathname */</comment>               \
    unixDlOpen,           <comment type="block">/* xDlOpen */</comment>                     \
    unixDlError,          <comment type="block">/* xDlError */</comment>                    \
    unixDlSym,            <comment type="block">/* xDlSym */</comment>                      \
    unixDlClose,          <comment type="block">/* xDlClose */</comment>                    \
    unixRandomness,       <comment type="block">/* xRandomness */</comment>                 \
    unixSleep,            <comment type="block">/* xSleep */</comment>                      \
    unixCurrentTime,      <comment type="block">/* xCurrentTime */</comment>                \
    unixGetLastError      <comment type="block">/* xGetLastError */</comment>               \
  }</cpp:define>

  <comment type="block">/*
  ** All default VFSes for unix are contained in the following array.
  **
  ** Note that the sqlite3_vfs.pNext field of the VFS object is modified
  ** by the SQLite core when the VFS is registered.  So the following
  ** array cannot be const.
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>sqlite3_vfs</name></type> <name><name>aVfs</name><index>[]</index></name> =<init> <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix"</expr></argument>,          <argument><expr><name>autolockIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix"</expr></argument>,          <argument><expr><name>posixIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-none"</expr></argument>,     <argument><expr><name>nolockIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-dotfile"</expr></argument>,  <argument><expr><name>dotlockIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OS_VXWORKS</name></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-namedsem"</expr></argument>, <argument><expr><name>semIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-posix"</expr></argument>,    <argument><expr><name>posixIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-flock"</expr></argument>,    <argument><expr><name>flockIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_LOCKING_STYLE</name> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-afp"</expr></argument>,      <argument><expr><name>afpIoFinder</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>UNIXVFS</name><argument_list>(<argument><expr>"unix-proxy"</expr></argument>,    <argument><expr><name>proxyIoFinder</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>          <comment type="block">/* Loop counter */</comment>

  <comment type="block">/* Register all VFSes defined in the aVfs[] array */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;(<call><name>sizeof</name><argument_list>(<argument><expr><name>aVfs</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3_vfs</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr>&amp;<name><name>aVfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name>==0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
}</block></function>

<comment type="block">/*
** Shutdown the operating system interface.
**
** Some operating systems might need to do some cleanup in this routine,
** to release dynamically allocated objects.  But not on unix.
** This routine is a no-op for unix.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_end</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ 
  <return>return <expr><name>SQLITE_OK</name></expr>;</return> 
}</block></function>
 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_UNIX */</comment>
</unit>
