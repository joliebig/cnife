<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="alter.c" filename=""><comment type="block">/*
** 2005 February 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that used to generate VDBE code
** that implements the ALTER TABLE command.
**
** $Id: alter.c,v 1.51 2008/12/10 19:26:22 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** The code in this file only exists if we are not omitting the
** ALTER TABLE logic from the build.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>


<comment type="block">/*
** This function is used by SQL generated to implement the 
** ALTER TABLE command. The first argument is the text of a CREATE TABLE or
** CREATE INDEX command. The second is a table name. The table name in 
** the CREATE TABLE or CREATE INDEX statement is replaced with the third
** argument and the result returned. Examples:
**
** sqlite_rename_table('CREATE TABLE abc(a, b, c)', 'def')
**     -&gt; 'CREATE TABLE def(a, b, c)'
**
** sqlite_rename_table('CREATE INDEX i ON abc(a)', 'def')
**     -&gt; 'CREATE INDEX i ON def(a, b, c)'
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>renameTableFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zSql</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zTableName</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>tname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zCsr</name> =<init> <expr><name>zSql</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zRet</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The principle used to locate the table name in the CREATE TABLE 
  ** statement is that the table name is the first non-space token that
  ** is immediately followed by a TK_LP or TK_USING token.
  */</comment>
  <if>if<condition>( <expr><name>zSql</name></expr> )</condition><then><block>{
    <do>do <block>{
      <if>if<condition>( <expr>!*<name>zCsr</name></expr> )</condition><then><block>{
        <comment type="block">/* Ran out of input before finding an opening bracket. Return NULL. */</comment>
        <return>return;</return>
      }</block></then></if>

      <comment type="block">/* Store the token that zCsr points to in tname. */</comment>
      <expr_stmt><expr><name>tname</name>.<name>z</name> = <name>zCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tname</name>.<name>n</name> = <name>len</name></expr>;</expr_stmt>

      <comment type="block">/* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */</comment>
      <do>do <block>{
        <expr_stmt><expr><name>zCsr</name> += <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr>&amp;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block> while<condition>( <expr><name>token</name>==<name>TK_SPACE</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    }</block> while<condition>( <expr><name>token</name>!=<name>TK_LP</name> &amp;&amp; <name>token</name>!=<name>TK_USING</name></expr> )</condition>;</do>

    <expr_stmt><expr><name>zRet</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%.*s\"%w\"%s"</expr></argument>, <argument><expr><name>tname</name>.<name>z</name> - <name>zSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, 
       <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>tname</name>.<name>z</name>+<name>tname</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
<comment type="block">/* This function is used by SQL generated to implement the
** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER 
** statement. The second is a table name. The table name in the CREATE 
** TRIGGER statement is replaced with the third argument and the result 
** returned. This is analagous to renameTableFunc() above, except for CREATE
** TRIGGER, not CREATE INDEX and CREATE TABLE.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>renameTriggerFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zSql</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zTableName</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>tname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>dist</name> =<init> <expr>3</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <name>const</name> *</type><name>zCsr</name> =<init> <expr><name>zSql</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zRet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The principle used to locate the table name in the CREATE TRIGGER 
  ** statement is that the table name is the first token that is immediatedly
  ** preceded by either TK_ON or TK_DOT and immediatedly followed by one
  ** of TK_WHEN, TK_BEGIN or TK_FOR.
  */</comment>
  <if>if<condition>( <expr><name>zSql</name></expr> )</condition><then><block>{
    <do>do <block>{

      <if>if<condition>( <expr>!*<name>zCsr</name></expr> )</condition><then><block>{
        <comment type="block">/* Ran out of input before finding the table name. Return NULL. */</comment>
        <return>return;</return>
      }</block></then></if>

      <comment type="block">/* Store the token that zCsr points to in tname. */</comment>
      <expr_stmt><expr><name>tname</name>.<name>z</name> = <name>zCsr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tname</name>.<name>n</name> = <name>len</name></expr>;</expr_stmt>

      <comment type="block">/* Advance zCsr to the next token. Store that token type in 'token',
      ** and its length in 'len' (to be used next iteration of this loop).
      */</comment>
      <do>do <block>{
        <expr_stmt><expr><name>zCsr</name> += <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <call><name>sqlite3GetToken</name><argument_list>(<argument><expr><name>zCsr</name></expr></argument>, <argument><expr>&amp;<name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>while<condition>( <expr><name>token</name>==<name>TK_SPACE</name></expr> )</condition>;</do>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Variable 'dist' stores the number of tokens read since the most
      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN 
      ** token is read and 'dist' equals 2, the condition stated above
      ** to be met.
      **
      ** Note that ON cannot be a database, table or column name, so
      ** there is no need to worry about syntax like 
      ** "CREATE TRIGGER ... ON ON.ON BEGIN ..." etc.
      */</comment>
      <expr_stmt><expr><name>dist</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>token</name>==<name>TK_DOT</name> || <name>token</name>==<name>TK_ON</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>dist</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block> while<condition>( <expr><name>dist</name>!=2 || (<name>token</name>!=<name>TK_WHEN</name> &amp;&amp; <name>token</name>!=<name>TK_FOR</name> &amp;&amp; <name>token</name>!=<name>TK_BEGIN</name>)</expr> )</condition>;</do>

    <comment type="block">/* Variable tname now contains the token that is the old table-name
    ** in the CREATE TRIGGER statement.
    */</comment>
    <expr_stmt><expr><name>zRet</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%.*s\"%w\"%s"</expr></argument>, <argument><expr><name>tname</name>.<name>z</name> - <name>zSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, 
       <argument><expr><name>zTableName</name></expr></argument>, <argument><expr><name>tname</name>.<name>z</name>+<name>tname</name>.<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zRet</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* !SQLITE_OMIT_TRIGGER */</comment>

<comment type="block">/*
** Register built-in functions used to help implement ALTER TABLE
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFunctions</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_rename_table"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr><name>renameTableFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_rename_trigger"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr><name>renameTriggerFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Generate the text of a WHERE expression which can be used to select all
** temporary triggers on table pTab from the sqlite_temp_master table. If
** table pTab has no temporary triggers, or is itself stored in the 
** temporary database, NULL is returned.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>whereTempTriggers</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrig</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zWhere</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>Schema</name> *</type><name>pTempSchema</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Temp db schema */</comment>

  <comment type="block">/* If the table is not located in the temp-db (in which case NULL is 
  ** returned, loop through the tables list of triggers. For each trigger
  ** that is not part of the temp-db schema, add a clause to the WHERE 
  ** expression being built up in zWhere.
  */</comment>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSchema</name>!=<name>pTempSchema</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <for>for( <init><expr><name>pTrig</name>=<name>pTab</name>-&gt;<name>pTrigger</name></expr>;</init> <condition><expr><name>pTrig</name></expr>;</condition> <incr><expr><name>pTrig</name>=<name>pTrig</name>-&gt;<name>pNext</name></expr></incr> )<block>{
      <if>if<condition>( <expr><name>pTrig</name>-&gt;<name>pSchema</name>==<name>pTempSchema</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr>!<name>zWhere</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>zWhere</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"name=%Q"</expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><name>tmp</name> = <name>zWhere</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zWhere</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s OR name=%Q"</expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>zWhere</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code to drop and reload the internal representation of table
** pTab from the database, including triggers and temporary triggers.
** Argument zName is the name of the table in the database schema at
** the time the generated code is executed. This can be different from
** pTab-&gt;zName if this function is being called to code part of an 
** "ALTER TABLE RENAME TO" statement.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>reloadTableSchema</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zWhere</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                   <comment type="block">/* Index of database containing pTab */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrig</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>v</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* Drop any table triggers from the internal schema. */</comment>
  <for>for(<init><expr><name>pTrig</name>=<name>pTab</name>-&gt;<name>pTrigger</name></expr>;</init> <condition><expr><name>pTrig</name></expr>;</condition> <incr><expr><name>pTrig</name>=<name>pTrig</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iTrigDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTrigDb</name>==<name>iDb</name> || <name>iTrigDb</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTrigger</name></expr></argument>, <argument><expr><name>iTrigDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTrig</name>-&gt;<name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop the table and index from the internal schema */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTable</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reload the table, index and permanent trigger schemas. */</comment>
  <expr_stmt><expr><name>zWhere</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"tbl_name=%Q"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zWhere</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* Now, if the table is not stored in the temp database, reload any temp 
  ** triggers. Don't use IN(...) in case SQLITE_OMIT_SUBQUERY is defined. 
  */</comment>
  <if>if<condition>( <expr>(<name>zWhere</name>=<call><name>whereTempTriggers</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy" 
** command. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterRenameTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,            <comment type="block">/* Parser context. */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,            <comment type="block">/* The table to rename. */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>              <comment type="block">/* The new table name. */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database that contains the table */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zDb</name></decl>;</decl_stmt>                <comment type="block">/* Name of database iDb */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being renamed */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* NULL-terminated version of pName */</comment> 
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTabName</name></decl>;</decl_stmt>             <comment type="block">/* Number of UTF-8 characters in zTabName */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTabName</name></decl>;</decl_stmt>     <comment type="block">/* Original name of the table */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>char</name> *</type><name>zWhere</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>         <comment type="block">/* Where clause to locate temp triggers */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>isVirtualRename</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* True if this is a v-table with an xRename() */</comment>
  
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>exit_rename_table</name>;</goto></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSrc</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pTab</name></expr> )</condition><then> <goto>goto <name>exit_rename_table</name>;</goto></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>

  <comment type="block">/* Get a NULL terminated version of the new table name. */</comment>
  <expr_stmt><expr><name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zName</name></expr> )</condition><then> <goto>goto <name>exit_rename_table</name>;</goto></then></if>

  <comment type="block">/* Check that a table or index named 'zName' does not already exist
  ** in database iDb. If so, this is an error.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call> || <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"there is already another table or index with this name: %s"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Make sure it is not a system table being altered, or a reserved name
  ** that the table is being renamed to.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>&gt;6 
   &amp;&amp; 0==<call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>
  )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %s may not be altered"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"view %s may not be altered"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> &amp;&amp; <name>pTab</name>-&gt;<name>pMod</name>-&gt;<name>pModule</name>-&gt;<name>xRename</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>isVirtualRename</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Begin a transaction and code the VerifyCookie for database iDb. 
  ** Then modify the schema cookie (since the ALTER TABLE modifies the
  ** schema). Open a statement transaction if the table is a virtual
  ** table.
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then><block>{
    <goto>goto <name>exit_rename_table</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>isVirtualRename</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a virtual table, invoke the xRename() function if
  ** one is defined. The xRename() callback will modify the names
  ** of any resources used by the v-table implementation (including other
  ** SQLite tables) that are identified by the name of the virtual table.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><name>isVirtualRename</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_String8</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>sqlite3VdbeAddOp4</name><argument_list>(<argument>v</argument>, <argument>OP_VRename</argument>, <argument>i</argument>, <argument>0</argument>, <argument>0</argument>,<argument>(const char*)pTab-&gt;pVtab</argument>, <argument>P4_VTAB</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* figure out how many UTF-8 characters are in zName */</comment>
  <expr_stmt><expr><name>zTabName</name> = <name>pTab</name>-&gt;<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTabName</name> = <call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Modify the sqlite_master table to use the new table name. */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr>"UPDATE %Q.%s SET "
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifdef>
          "sql = sqlite_rename_table(sql, %Q), "
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          "sql = CASE "
            "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"
            "ELSE sqlite_rename_table(sql, %Q) END, "
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q AND "
          "(type='table' OR type='index' OR type='trigger');"</expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
      <argument><expr><name>zName</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nTabName</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <comment type="block">/* If the sqlite_sequence table exists in this database, then update 
  ** it with the new table name.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_sequence"</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr>"UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q"</expr></argument>,
        <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <comment type="block">/* If there are TEMP triggers on this table, modify the sqlite_temp_master
  ** table. Don't do this if the table being ALTERed is itself located in
  ** the temp database.
  */</comment>
  <if>if<condition>( <expr>(<name>zWhere</name>=<call><name>whereTempTriggers</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"UPDATE sqlite_temp_master SET "
            "sql = sqlite_rename_trigger(sql, %Q), "
            "tbl_name = %Q "
            "WHERE %s;"</expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Drop and reload the internal table schema. */</comment>
  <expr_stmt><expr><call><name>reloadTableSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_rename_table</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** This function is called after an "ALTER TABLE ... ADD" statement
** has been parsed. Argument pColDef contains the text of the new
** column definition.
**
** The Table structure pParse-&gt;pNewTable was extended to include
** the new column during parsing.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterFinishAddColumn</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pColDef</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pNew</name></decl>;</decl_stmt>              <comment type="block">/* Copy of pParse-&gt;pNewTable */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>              <comment type="block">/* Table being altered */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                  <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl>;</decl_stmt>          <comment type="block">/* Database name */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name></decl>;</decl_stmt>         <comment type="block">/* Table name */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zCol</name></decl>;</decl_stmt>               <comment type="block">/* Null-terminated column definition */</comment>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>             <comment type="block">/* The new column */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pDflt</name></decl>;</decl_stmt>              <comment type="block">/* Default value for the new column */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>              <comment type="block">/* The database connection; */</comment>

  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pNew</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTab</name> = <name>pNew</name>-&gt;<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name> = &amp;<name>pNew</name>-&gt;<name><name>aCol</name><index>[<expr><name>pNew</name>-&gt;<name>nCol</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDflt</name> = <name>pCol</name>-&gt;<name>pDflt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Invoke the authorization callback. */</comment>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_ALTER_TABLE</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the default value for the new column was specified with a 
  ** literal NULL, then set pDflt to 0. This simplifies checking
  ** for an SQL NULL default below.
  */</comment>
  <if>if<condition>( <expr><name>pDflt</name> &amp;&amp; <name>pDflt</name>-&gt;<name>op</name>==<name>TK_NULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pDflt</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Check that the new column is not specified as PRIMARY KEY or UNIQUE.
  ** If there is a NOT NULL constraint, then the default value for the
  ** column must not be NULL.
  */</comment>
  <if>if<condition>( <expr><name>pCol</name>-&gt;<name>isPrimKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"Cannot add a PRIMARY KEY column"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pNew</name>-&gt;<name>pIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"Cannot add a UNIQUE column"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCol</name>-&gt;<name>notNull</name> &amp;&amp; !<name>pDflt</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"Cannot add a NOT NULL column with default value NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="block">/* Ensure the default expression is something that sqlite3ValueFromExpr()
  ** can handle (i.e. not CURRENT_TIME etc.)
  */</comment>
  <if>if<condition>( <expr><name>pDflt</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pVal</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3ValueFromExpr</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDflt</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_AFF_NONE</name></expr></argument>, <argument><expr>&amp;<name>pVal</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <if>if<condition>( <expr>!<name>pVal</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"Cannot add a column with non-constant default"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Modify the CREATE TABLE statement. */</comment>
  <expr_stmt><expr><name>zCol</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pColDef</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pColDef</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zCol</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zEnd</name> =<init> <expr>&amp;<name><name>zCol</name><index>[<expr><name>pColDef</name>-&gt;<name>n</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr>(<name>zEnd</name>&gt;<name>zCol</name> &amp;&amp; *<name>zEnd</name>==';') || <call><name>isspace</name><argument_list>(<argument><expr>*(<name>unsigned</name> <name>char</name> *)<name>zEnd</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
      <expr_stmt><expr>*<name>zEnd</name>-- = '\0'</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"UPDATE \"%w\".%s SET "
          "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "
        "WHERE type = 'table' AND name = %Q"</expr></argument>, 
      <argument><expr><name>zDb</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>addColOffset</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>addColOffset</name>+1</expr></argument>,
      <argument><expr><name>zTab</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If the default value of the new column is NULL, then set the file
  ** format to 2. If the default value of the new column is not NULL,
  ** the file format becomes 3.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3MinimumFileFormat</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pDflt</name> ? 3 : 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reload the schema of the modified table. */</comment>
  <expr_stmt><expr><call><name>reloadTableSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This function is called by the parser after the table-name in
** an "ALTER TABLE &lt;table-name&gt; ADD" statement is parsed. Argument 
** pSrc is the full-name of the table being altered.
**
** This routine makes a (partial) copy of the Table structure
** for the table being altered and sets Parse.pNewTable to point
** to it. Routines called by the parser as the column definition
** is parsed (i.e. sqlite3AddColumn()) add the new Column data to 
** the copy. The copy of the Table structure is deleted by tokenize.c 
** after parsing is finished.
**
** Routine sqlite3AlterFinishAddColumn() will be called to complete
** coding the "ALTER TABLE ... ADD" statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AlterBeginAddColumn</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look up the table being altered. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>pNewTable</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>exit_begin_add_column</name>;</goto></then></if>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pTab</name></expr> )</condition><then> <goto>goto <name>exit_begin_add_column</name>;</goto></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"virtual tables may not be altered"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure this is not an attempt to ALTER a view. */</comment>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"Cannot add a column to a view"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>-&gt;<name>addColOffset</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Put a copy of the Table struct in Parse.pNewTable for the
  ** sqlite3AddColumn() function and friends to modify.
  */</comment>
  <expr_stmt><expr><name>pNew</name> = (<name>Table</name>*)<call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pNew</name></expr> )</condition><then> <goto>goto <name>exit_begin_add_column</name>;</goto></then></if>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTable</name> = <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nCol</name> = <name>pTab</name>-&gt;<name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pNew</name>-&gt;<name>nCol</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nAlloc</name> = (((<name>pNew</name>-&gt;<name>nCol</name>-1)/8)*8)+8</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAlloc</name>&gt;=<name>pNew</name>-&gt;<name>nCol</name> &amp;&amp; <name>nAlloc</name>%8==0 &amp;&amp; <name>nAlloc</name>-<name>pNew</name>-&gt;<name>nCol</name>&lt;8</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>aCol</name> = (<name>Column</name>*)<call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></call>*<name>nAlloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pNew</name>-&gt;<name>aCol</name> || !<name>pNew</name>-&gt;<name>zName</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>exit_begin_add_column</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>aCol</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>aCol</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Column</name></expr></argument>)</argument_list></call>*<name>pNew</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pNew</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name> =<init> <expr>&amp;<name>pNew</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>zName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>zColl</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>zType</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pCol</name>-&gt;<name>pDflt</name> = 0</expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pSchema</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>addColOffset</name> = <name>pTab</name>-&gt;<name>addColOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>

  <comment type="block">/* Begin a transaction and increment the schema cookie.  */</comment>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>v</name></expr> )</condition><then> <goto>goto <name>exit_begin_add_column</name>;</goto></then></if>
  <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_begin_add_column</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SQLITE_ALTER_TABLE */</comment>
</unit>
