<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="delete.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** in order to generate code for DELETE FROM statements.
**
** $Id: delete.c,v 1.191 2008/12/23 23:56:22 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Look up every table that is named in pSrc.  If any table is not found,
** add an error message to pParse-&gt;zErrMsg and return NULL.  If all tables
** are found, return a pointer to the last table.
*/</comment>
<function><type><name>Table</name> *</type><name>sqlite3SrcListLookup</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr><name>pSrc</name>-&gt;<name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name> &amp;&amp; <name>pSrc</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pItem</name>-&gt;<name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>pTab</name> = <name>pTab</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3IndexedByLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pTab</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Check to make sure the given table is writable.  If it is not
** writable, generate an error message and return 1.  If it is
** writable return 0;
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsReadOnly</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>, <param><decl><type><name>int</name></type> <name>viewOk</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>((<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Readonly</name>)!=0
        &amp;&amp; (<name>pParse</name>-&gt;<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_WriteSchema</name>)==0
        &amp;&amp; <name>pParse</name>-&gt;<name>nested</name>==0) 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      || (<name>pTab</name>-&gt;<name>pMod</name> &amp;&amp; <name>pTab</name>-&gt;<name>pMod</name>-&gt;<name>pModule</name>-&gt;<name>xUpdate</name>==0)</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %s may not be modified"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if>if<condition>( <expr>!<name>viewOk</name> &amp;&amp; <name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr>"cannot modify %s because it is a view"</expr></argument>,<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Generate code that will open a table for reading.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3OpenTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>p</name></decl></param>,       <comment type="block">/* Generate code into this VDBE */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,       <comment type="block">/* The cursor number of the table */</comment>
  <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>,        <comment type="block">/* The database index in sqlite3.aDb[] */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,    <comment type="block">/* The table to be opened */</comment>
  <param><decl><type><name>int</name></type> <name>opcode</name></decl></param>      <comment type="block">/* OP_OpenRead or OP_OpenWrite */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>opcode</name>==<name>OP_OpenWrite</name> || <name>opcode</name>==<name>OP_OpenRead</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr>(<name>opcode</name>==<name>OP_OpenWrite</name>)?1:0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>opcode</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>VdbeComment</name><argument_list>(<argument><expr>(<name>v</name>, "%s", <name>pTab</name>-&gt;<name>zName</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Evaluate a view and store its result in an ephemeral table.  The
** pWhere argument is an optional WHERE clause that restricts the
** set of rows in the view that are to be added to the ephemeral table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MaterializeView</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Table</name> *</type><name>pView</name></decl></param>,        <comment type="block">/* View definition */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,        <comment type="block">/* Optional WHERE clause to be added */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>             <comment type="block">/* Cursor number for ephemerial table */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pDup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pDup</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pView</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pWhere</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>SrcList</name> *</type><name>pFrom</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Token</name></type> <name>viewName</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>pWhere</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>viewName</name>.<name>z</name> = (<name>u8</name>*)<name>pView</name>-&gt;<name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>viewName</name>.<name>n</name> = (<name>unsigned</name> <name>int</name>)<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>(<name>const</name> <name>char</name>*)<name>viewName</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFrom</name> = <call><name>sqlite3SrcListAppendFromTerm</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>viewName</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDup</name> = <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pFrom</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_EphemTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIEW) &amp;&amp; !defined(SQLITE_OMIT_TRIGGER) */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_SUBQUERY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Generate an expression tree to implement the WHERE, ORDER BY,
** and LIMIT/OFFSET portion of DELETE and UPDATE statements.
**
**     DELETE FROM table_wxyz WHERE a&lt;5 ORDER BY a LIMIT 1;
**                            \__________________________/
**                               pLimitWhere (pInClause)
*/</comment>
<function><type><name>Expr</name> *</type><name>sqlite3LimitWhere</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,               <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,               <comment type="block">/* the FROM clause -- which tables to scan */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>,                <comment type="block">/* The WHERE clause.  May be null */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pOrderBy</name></decl></param>,          <comment type="block">/* The ORDER BY clause.  May be null */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pLimit</name></decl></param>,                <comment type="block">/* The LIMIT clause.  May be null */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pOffset</name></decl></param>,               <comment type="block">/* The OFFSET clause.  May be null */</comment>
  <param><decl><type><name>char</name> *</type><name>zStmtType</name></decl></param>              <comment type="block">/* Either DELETE or UPDATE.  For error messages. */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pWhereRowid</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* WHERE rowid .. */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pInClause</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* WHERE rowid IN ( select ) */</comment>
  <decl_stmt><decl><type><name>Expr</name> *</type><name>pSelectRowid</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* SELECT rowid ... */</comment>
  <decl_stmt><decl><type><name>ExprList</name> *</type><name>pEList</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Expression list contaning only pSelectRowid */</comment>
  <decl_stmt><decl><type><name>SrcList</name> *</type><name>pSelectSrc</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* SELECT rowid FROM x ... (dup of pSrc) */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pSelect</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Complete SELECT tree */</comment>

  <comment type="block">/* Check that there isn't an ORDER BY without a LIMIT clause.
  */</comment>
  <if>if<condition>( <expr><name>pOrderBy</name> &amp;&amp; (<name>pLimit</name> == 0)</expr> )</condition><then> <block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"ORDER BY without LIMIT on %s"</expr></argument>, <argument><expr><name>zStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>parseError</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>limit_where_cleanup_2</name>;</goto>
  }</block></then></if>

  <comment type="block">/* We only need to generate a select expression if there
  ** is a limit/offset term to enforce.
  */</comment>
  <if>if<condition>( <expr><name>pLimit</name> == 0</expr> )</condition><then> <block>{
    <comment type="block">/* if pLimit is null, pOffset will always be null as well. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOffset</name> == 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pWhere</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Generate a select expression tree to enforce the limit/offset 
  ** term for the DELETE or UPDATE statement.  For example:
  **   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  ** becomes:
  **   DELETE FROM table_a WHERE rowid IN ( 
  **     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  **   );
  */</comment>

  <expr_stmt><expr><name>pSelectRowid</name> = <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSelectRowid</name> == 0</expr> )</condition><then> <goto>goto <name>limit_where_cleanup_2</name>;</goto></then></if>
  <expr_stmt><expr><name>pEList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pSelectRowid</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pEList</name> == 0</expr> )</condition><then> <goto>goto <name>limit_where_cleanup_2</name>;</goto></then></if>

  <comment type="block">/* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree
  ** and the SELECT subtree. */</comment>
  <expr_stmt><expr><name>pSelectSrc</name> = <call><name>sqlite3SrcListDup</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSelectSrc</name> == 0</expr> )</condition><then> <block>{
    <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pEList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>limit_where_cleanup_2</name>;</goto>
  }</block></then></if>

  <comment type="block">/* generate the SELECT expression tree. */</comment>
  <expr_stmt><expr><name>pSelect</name> = <call><name>sqlite3SelectNew</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,<argument><expr><name>pEList</name></expr></argument>,<argument><expr><name>pSelectSrc</name></expr></argument>,<argument><expr><name>pWhere</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>pOrderBy</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>pLimit</name></expr></argument>,<argument><expr><name>pOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSelect</name> == 0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* now generate the new WHERE rowid IN clause for the DELETE/UDPATE */</comment>
  <expr_stmt><expr><name>pWhereRowid</name> = <call><name>sqlite3Expr</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>TK_ROW</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pWhereRowid</name> == 0</expr> )</condition><then> <goto>goto <name>limit_where_cleanup_1</name>;</goto></then></if>
  <expr_stmt><expr><name>pInClause</name> = <call><name>sqlite3PExpr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>, <argument><expr><name>pWhereRowid</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pInClause</name> == 0</expr> )</condition><then> <goto>goto <name>limit_where_cleanup_1</name>;</goto></then></if>

  <expr_stmt><expr><name>pInClause</name>-&gt;<name>pSelect</name> = <name>pSelect</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprSetHeight</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pInClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pInClause</name></expr>;</return>

  <comment type="block">/* something went wrong. clean up anything allocated. */</comment>
<label><name>limit_where_cleanup_1</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>

<label><name>limit_where_cleanup_2</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pOrderBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) &amp;&amp; !defined(SQLITE_OMIT_SUBQUERY) */</comment>

<comment type="block">/*
** Generate code for a DELETE FROM statement.
**
**     DELETE FROM table_wxyz WHERE a&lt;5 AND b NOT NULL;
**                 \________/       \________________/
**                  pTabList              pWhere
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteFrom</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* The parser context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTabList</name></decl></param>,     <comment type="block">/* The table from which we should delete things */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pWhere</name></decl></param>           <comment type="block">/* The WHERE clause.  May be null */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>               <comment type="block">/* The virtual database engine */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>           <comment type="block">/* The table from which records will be deleted */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl>;</decl_stmt>       <comment type="block">/* Name of database holding pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>end</name>, <name>addr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* A couple addresses of generated code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                 <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>WhereInfo</name> *</type><name>pWInfo</name></decl>;</decl_stmt>     <comment type="block">/* Information about the WHERE clause */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>           <comment type="block">/* For looping over indices of the table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iCur</name></decl>;</decl_stmt>              <comment type="block">/* VDBE Cursor number for pTab */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>           <comment type="block">/* Main database structure */</comment>
  <decl_stmt><decl><type><name>AuthContext</name></type> <name>sContext</name></decl>;</decl_stmt>  <comment type="block">/* Authorization context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>oldIdx</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>       <comment type="block">/* Cursor for the OLD table of AFTER triggers */</comment>
  <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>       <comment type="block">/* Name context to resolve expressions in */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>               <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>memCnt</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>       <comment type="block">/* Memory cell used for change counting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rcauth</name></decl>;</decl_stmt>            <comment type="block">/* Value returned by authorization callback */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isView</name></decl>;</decl_stmt>                  <comment type="block">/* True if attempting to delete from a view */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>triggers_exist</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* True if any triggers exist */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>iBeginAfterTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>  <comment type="block">/* Address of after trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEndAfterTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Exit of after trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBeginBeforeTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* Address of before trigger program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEndBeforeTrigger</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Exit of before trigger program */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>old_col_mask</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>        <comment type="block">/* Mask of OLD.* columns in use */</comment>

  <expr_stmt><expr><name>sContext</name>.<name>pParse</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabList</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locate the table which we want to delete.  This table has to be
  ** put in an SrcList structure because some of the subroutines we
  ** will be calling are designed to work with multiple tables and expect
  ** an SrcList* parameter instead of just a Table* parameter.
  */</comment>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then>  <goto>goto <name>delete_from_cleanup</name>;</goto></then></if>

  <comment type="block">/* Figure out if we have any triggers and if the table being
  ** deleted from is a view
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRIGGER</name></cpp:ifndef>
  <expr_stmt><expr><name>triggers_exist</name> = <call><name>sqlite3TriggersExist</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>isView</name> = <name>pTab</name>-&gt;<name>pSelect</name>!=0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>triggers_exist</name> 0</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>isView</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifdef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>isView</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if<condition>( <expr><call><name>sqlite3IsReadOnly</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>triggers_exist</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zDb</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rcauth</name> = <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rcauth</name>==<name>SQLITE_OK</name> || <name>rcauth</name>==<name>SQLITE_DENY</name> || <name>rcauth</name>==<name>SQLITE_IGNORE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rcauth</name>==<name>SQLITE_DENY</name></expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>isView</name> || <name>triggers_exist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pTab is really a view, make sure it has been initialized.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Allocate a cursor used to store the old.* data for a trigger.
  */</comment>
  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{ 
    <expr_stmt><expr><name>oldIdx</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Assign  cursor number to the table and all its indices.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTabList</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iCur</name> = <name>pTabList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>iCursor</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Start the view context
  */</comment>
  <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3AuthContextPush</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>&amp;<name>sContext</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Begin generating code.
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nested</name>==0</expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3VdbeCountChanges</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>triggers_exist</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>orconf</name> =<init> <expr>((<name>pParse</name>-&gt;<name>trigStack</name>)?<name>pParse</name>-&gt;<name>trigStack</name>-&gt;<name>orconf</name>:<name>OE_Default</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iGoto</name> =<init> <expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iBeginBeforeTrigger</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>TRIGGER_BEFORE</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>,
        <argument><expr>-1</expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>orconf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>&amp;<name>old_col_mask</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEndBeforeTrigger</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iBeginAfterTrigger</name> = <call><name>sqlite3VdbeCurrentAddr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3CodeRowTrigger</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>TK_DELETE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>TRIGGER_AFTER</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr>-1</expr></argument>,
        <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>orconf</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr>&amp;<name>old_col_mask</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEndAfterTrigger</name> = <call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iGoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If we are trying to delete from a view, realize that view into
  ** a ephemeral table.
  */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_TRIGGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3MaterializeView</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Resolve the column names in the WHERE clause.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = <name>pTabList</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>delete_from_cleanup</name>;</goto>
  }</block></then></if>

  <comment type="block">/* Initialize the counter of the number of rows deleted, if
  ** we are counting rows.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>memCnt</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>memCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRUNCATE_OPTIMIZATION</name></cpp:ifndef>
  <comment type="block">/* Special case: A DELETE without a WHERE clause deletes everything.
  ** It is easier just to erase the whole table.  Note, however, that
  ** this means that the row change count will be incorrect.
  */</comment>
  <if>if<condition>( <expr><name>rcauth</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pWhere</name>==0 &amp;&amp; !<name>triggers_exist</name> &amp;&amp; !<call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>isView</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>nested</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>pSchema</name>==<name>pTab</name>-&gt;<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */</comment>
  <comment type="block">/* The usual case: There is a WHERE clause so we have to scan through
  ** the table and pick which records to delete.
  */</comment>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iRowid</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Used for storing rowid values. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iRowSet</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Register for rowset of rows to delete */</comment>

    <comment type="block">/* Collect rowids of every row to be deleted.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pWInfo</name> = <call><name>sqlite3WhereBegin</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>, <argument><expr>0</expr></argument>,
                               <argument><expr><name>WHERE_FILL_ROWSET</name></expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pWInfo</name>==0</expr> )</condition><then> <goto>goto <name>delete_from_cleanup</name>;</goto></then></if>
    <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AddImm</name></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3WhereEnd</name><argument_list>(<argument><expr><name>pWInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Open the pseudo-table used to store OLD if there are triggers.
    */</comment>
    <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenPseudo</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Delete every item whose key was written to the list during the
    ** database scan.  We have to delete items after the scan is complete
    ** because deleting an item can change the scan order.
    */</comment>
    <expr_stmt><expr><name>end</name> = <call><name>sqlite3VdbeMakeLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr>!<name>isView</name></expr> )</condition><then><block>{
      <comment type="block">/* Open cursors for the table we are deleting from and 
      ** all its indices.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3OpenTableAndIndices</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* This is the beginning of the delete loop. If a trigger encounters
    ** an IGNORE constraint, it jumps back to here.
    */</comment>
    <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowSetRead</name></expr></argument>, <argument><expr><name>iRowSet</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iData</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* For storing row data of OLD table */</comment>

      <comment type="block">/* If the record is no longer present in the table, jump to the
      ** next iteration of the loop through the contents of the fifo.
      */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Populate the OLD.* pseudo-table */</comment>
      <if>if<condition>( <expr><name>old_col_mask</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_RowData</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr><name>oldIdx</name></expr></argument>, <argument><expr><name>iData</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Jump back and run the BEFORE triggers */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iBeginBeforeTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEndBeforeTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr>!<name>isView</name></expr> )</condition><then><block>{
      <comment type="block">/* Delete the row */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>pVtab</name> =<init> <expr>(<name>const</name> <name>char</name> *)<name>pTab</name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3VtabMakeWritable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VUpdate</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{
        <expr_stmt><expr><call><name>sqlite3GenerateRowDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>nested</name>==0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>

    <comment type="block">/* If there are row triggers, close all cursors then invoke
    ** the AFTER triggers
    */</comment>
    <if>if<condition>( <expr><name>triggers_exist</name></expr> )</condition><then><block>{
      <comment type="block">/* Jump back and run the AFTER triggers */</comment>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iBeginAfterTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEndAfterTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* End of the delete loop */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeResolveLabel</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Close the cursors after the loop if there are no row triggers */</comment>
    <if>if<condition>( <expr>!<name>isView</name>  &amp;&amp; !<call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <for>for(<init><expr><name>i</name>=1</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCur</name> + <name>i</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>tnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/*
  ** Return the number of rows that were deleted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_CountRows</name> &amp;&amp; <name>pParse</name>-&gt;<name>nested</name>==0 &amp;&amp; !<name>pParse</name>-&gt;<name>trigStack</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ResultRow</name></expr></argument>, <argument><expr><name>memCnt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetNumCols</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeSetColName</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>, <argument><expr>"rows deleted"</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<label><name>delete_from_cleanup</name>:</label>
  <expr_stmt><expr><call><name>sqlite3AuthContextPop</name><argument_list>(<argument><expr>&amp;<name>sContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTabList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** This routine generates VDBE code that causes a single row of a
** single table to be deleted.
**
** The VDBE must be in a particular state when this routine is called.
** These are the requirements:
**
**   1.  A read/write cursor pointing to pTab, the table containing the row
**       to be deleted, must be opened as cursor number "base".
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number base+i for the i-th index.
**
**   3.  The record number of the row to be deleted must be stored in
**       memory cell iRowid.
**
** This routine pops the top of the stack to remove the record number
** and then generates code to remove both the table record and all index
** entries that point to that record.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateRowDelete</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,       <comment type="block">/* Table containing the row to be deleted */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,          <comment type="block">/* Cursor number for the table */</comment>
  <param><decl><type><name>int</name></type> <name>iRowid</name></decl></param>,        <comment type="block">/* Memory cell that contains the rowid to delete */</comment>
  <param><decl><type><name>int</name></type> <name>count</name></decl></param>          <comment type="block">/* Increment the row change counter */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> = <name>pParse</name>-&gt;<name>pVdbe</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NotExists</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3GenerateRowIndexDelete</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Delete</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>(<name>count</name>?<name>OPFLAG_NCHANGE</name>:0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>count</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine generates VDBE code that causes the deletion of all
** index entries associated with a single row of a single table.
**
** The VDBE must be in a particular state when this routine is called.
** These are the requirements:
**
**   1.  A read/write cursor pointing to pTab, the table containing the row
**       to be deleted, must be opened as cursor number "iCur".
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number iCur+i for the i-th index.
**
**   3.  The "iCur" cursor must be pointing to the row that is to be
**       deleted.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3GenerateRowIndexDelete</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,       <comment type="block">/* Table containing the row to be deleted */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,          <comment type="block">/* Cursor number for the table */</comment>
  <param><decl><type><name>int</name> *</type><name>aRegIdx</name></decl></param>       <comment type="block">/* Only delete if aRegIdx!=0 &amp;&amp; aRegIdx[i]&gt;0 */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>;</decl_stmt>

  <for>for(<init><expr><name>i</name>=1</expr>, <expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>aRegIdx</name>!=0 &amp;&amp; <name><name>aRegIdx</name><index>[<expr><name>i</name>-1</expr>]</index></name>==0</expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>r1</name> = <call><name>sqlite3GenerateIndexKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></argument>, <argument><expr><name>OP_IdxDelete</name></expr></argument>, <argument><expr><name>iCur</name>+<name>i</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>,<argument><expr><name>pIdx</name>-&gt;<name>nColumn</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<comment type="block">/*
** Generate code that will assemble an index key and put it in register
** regOut.  The key with be for index pIdx which is an index on pTab.
** iCur is the index of a cursor open on the pTab table and pointing to
** the entry that needs indexing.
**
** Return a register number which is the first in a block of
** registers that holds the elements of the index key.  The
** block of registers has already been deallocated by the time
** this routine returns.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3GenerateIndexKey</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>,       <comment type="block">/* The index for which to generate a key */</comment>
  <param><decl><type><name>int</name></type> <name>iCur</name></decl></param>,          <comment type="block">/* Cursor number for the pIdx-&gt;pTable table */</comment>
  <param><decl><type><name>int</name></type> <name>regOut</name></decl></param>,        <comment type="block">/* Write the new index key to this register */</comment>
  <param><decl><type><name>int</name></type> <name>doMakeRec</name></decl></param>      <comment type="block">/* Run the OP_MakeRecord instruction if true */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pIdx</name>-&gt;<name>pTable</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>regBase</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nCol</name> = <name>pIdx</name>-&gt;<name>nColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>regBase</name> = <call><name>sqlite3GetTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>nCol</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rowid</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> =<init> <expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>idx</name>==<name>pTab</name>-&gt;<name>iPKey</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SCopy</name></expr></argument>, <argument><expr><name>regBase</name>+<name>nCol</name></expr></argument>, <argument><expr><name>regBase</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Column</name></expr></argument>, <argument><expr><name>iCur</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>regBase</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ColumnDefault</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>
  <if>if<condition>( <expr><name>doMakeRec</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_MakeRecord</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name>+1</expr></argument>, <argument><expr><name>regOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IndexAffinityStr</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprCacheAffinityChange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempRange</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regBase</name></expr></argument>, <argument><expr><name>nCol</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>regBase</name></expr>;</return>
}</block></function>

<comment type="block">/* Make sure "isView" gets undefined in case this file becomes part of
** the amalgamation - so that subsequent files do not see isView as a
** macro. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>isView</name></cpp:undef>
</unit>
