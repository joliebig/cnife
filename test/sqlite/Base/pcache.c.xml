<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="pcache.c" filename=""><comment type="block">/*
** 2008 August 05
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file implements that page cache.
**
** @(#) $Id: pcache.c,v 1.39 2008/12/04 20:40:10 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** A complete page cache is an instance of this structure.
*/</comment>
<struct>struct <name>PCache</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pDirty</name>, *<name>pDirtyTail</name></decl>;</decl_stmt>         <comment type="block">/* List of dirty pages in LRU order */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pSynced</name></decl>;</decl_stmt>                     <comment type="block">/* Last synced page in dirty page list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                           <comment type="block">/* Number of referenced pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>;</decl_stmt>                           <comment type="block">/* Configured cache size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMin</name></decl>;</decl_stmt>                           <comment type="block">/* Configured minimum cache size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                         <comment type="block">/* Size of every page in this cache */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szExtra</name></decl>;</decl_stmt>                        <comment type="block">/* Size of extra space for each page */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bPurgeable</name></decl>;</decl_stmt>                     <comment type="block">/* True if pages are on backing store */</comment>
  <function_decl><type><name>int</name></type> (*<name>xStress</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>PgHdr</name>*</type></decl></param>)</parameter_list>;</function_decl>       <comment type="block">/* Call to try make a page clean */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pStress</name></decl>;</decl_stmt>                      <comment type="block">/* Argument to xStress */</comment>
  <decl_stmt><decl><type><name>sqlite3_pcache</name> *</type><name>pCache</name></decl>;</decl_stmt>             <comment type="block">/* Pluggable cache module */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPage1</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
** Some of the assert() macros in this code are too expensive to run
** even during normal debugging.  Use them only rarely on long-running
** tests.  Enable the expensive asserts using the
** -DSQLITE_ENABLE_EXPENSIVE_ASSERT=1 compile-time option.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_EXPENSIVE_ASSERT</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>expensive_assert</name>(X)  assert(X)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>expensive_assert</name>(X)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/********************************** Linked List Management ********************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_EXPENSIVE_ASSERT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Check that the pCache-&gt;pSynced variable is set correctly. If it
** is not, either fail an assert or return zero. Otherwise, return
** non-zero. This is only used in debugging builds, as follows:
**
**   expensive_assert( pcacheCheckSynced(pCache) );
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>pcacheCheckSynced</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name>=<name>pCache</name>-&gt;<name>pDirtyTail</name></expr>;</init> <condition><expr><name>p</name>!=<name>pCache</name>-&gt;<name>pSynced</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pDirtyPrev</name></expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nRef</name> || (<name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr>(<name>p</name>==0 || <name>p</name>-&gt;<name>nRef</name> || (<name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)==0)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !NDEBUG &amp;&amp; SQLITE_ENABLE_EXPENSIVE_ASSERT */</comment>

<comment type="block">/*
** Remove page pPage from the list of dirty pages.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcacheRemoveFromDirtyList</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>p</name> =<init> <expr><name>pPage</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pDirtyNext</name> || <name>pPage</name>==<name>p</name>-&gt;<name>pDirtyTail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pDirtyPrev</name> || <name>pPage</name>==<name>p</name>-&gt;<name>pDirty</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the PCache1.pSynced variable if necessary. */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pSynced</name>==<name>pPage</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pSynced</name> =<init> <expr><name>pPage</name>-&gt;<name>pDirtyPrev</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>pSynced</name> &amp;&amp; (<name>pSynced</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)</expr> )</condition><block>{
      <expr_stmt><expr><name>pSynced</name> = <name>pSynced</name>-&gt;<name>pDirtyPrev</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>p</name>-&gt;<name>pSynced</name> = <name>pSynced</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pDirtyNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyNext</name>-&gt;<name>pDirtyPrev</name> = <name>pPage</name>-&gt;<name>pDirtyPrev</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>==<name>p</name>-&gt;<name>pDirtyTail</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pDirtyTail</name> = <name>pPage</name>-&gt;<name>pDirtyPrev</name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pDirtyPrev</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyPrev</name>-&gt;<name>pDirtyNext</name> = <name>pPage</name>-&gt;<name>pDirtyNext</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>==<name>p</name>-&gt;<name>pDirty</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pDirty</name> = <name>pPage</name>-&gt;<name>pDirtyNext</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyNext</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyPrev</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>expensive_assert</name><argument_list>( <argument><expr><call><name>pcacheCheckSynced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Add page pPage to the head of the dirty list (PCache1.pDirty is set to
** pPage).
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcacheAddToDirtyList</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>p</name> =<init> <expr><name>pPage</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pDirtyNext</name>==0 &amp;&amp; <name>pPage</name>-&gt;<name>pDirtyPrev</name>==0 &amp;&amp; <name>p</name>-&gt;<name>pDirty</name>!=<name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyNext</name> = <name>p</name>-&gt;<name>pDirty</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pPage</name>-&gt;<name>pDirtyNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name>-&gt;<name>pDirtyNext</name>-&gt;<name>pDirtyPrev</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pDirtyNext</name>-&gt;<name>pDirtyPrev</name> = <name>pPage</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>pDirty</name> = <name>pPage</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>pDirtyTail</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pDirtyTail</name> = <name>pPage</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>p</name>-&gt;<name>pSynced</name> &amp;&amp; 0==(<name>pPage</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pSynced</name> = <name>pPage</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>expensive_assert</name><argument_list>( <argument><expr><call><name>pcacheCheckSynced</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Wrapper around the pluggable caches xUnpin method. If the cache is
** being used for an in-memory database, this function is a no-op.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>pcacheUnpin</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>pCache</name> =<init> <expr><name>p</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>bPurgeable</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pgno</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCache</name>-&gt;<name>pPage1</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xUnpin</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*************************************************** General Interfaces ******
**
** Initialize and shutdown the page cache subsystem. Neither of these 
** functions are threadsafe.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheInitialize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<name>xInit</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3PCacheSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xInit</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<name>pArg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>sqlite3PcacheShutdown</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<name>xShutdown</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xShutdown</name><argument_list>(<argument><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Return the size in bytes of a PCache object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheSize</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{ <return>return <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PCache</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

<comment type="block">/*
** Create a new PCache object. Storage space to hold the object
** has already been allocated and is passed in as the p pointer. 
** The caller discovers how much space needs to be allocated by 
** calling sqlite3PcacheSize().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheOpen</name><parameter_list>(
  <param><decl><type><name>int</name></type> <name>szPage</name></decl></param>,                  <comment type="block">/* Size of every page */</comment>
  <param><decl><type><name>int</name></type> <name>szExtra</name></decl></param>,                 <comment type="block">/* Extra space associated with each page */</comment>
  <param><decl><type><name>int</name></type> <name>bPurgeable</name></decl></param>,              <comment type="block">/* True if pages are on backing store */</comment>
  <param><function_decl><type><name>int</name></type> (*<name>xStress</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>PgHdr</name>*</type></decl></param>)</parameter_list>,<comment type="block">/* Call to try to make pages clean */</comment>
  <param><decl><type><name>void</name> *</type><name>pStress</name></decl></param>,               <comment type="block">/* Argument to xStress */</comment>
  <param><decl><type><name>PCache</name> *</type><name>p</name></decl></param></function_decl></param>                    <comment type="block">/* Preallocated space for the PCache */</comment>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>PCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>szPage</name> = <name>szPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>szExtra</name> = <name>szExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>bPurgeable</name> = <name>bPurgeable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>xStress</name> = <name>xStress</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pStress</name> = <name>pStress</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nMax</name> = 100</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nMin</name> = 10</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Change the page size for PCache object. The caller must ensure that there
** are no outstanding page references when this function is called.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheSetPageSize</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>, <param><decl><type><name>int</name></type> <name>szPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCache</name>-&gt;<name>nRef</name>==0 &amp;&amp; <name>pCache</name>-&gt;<name>pDirty</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xDestroy</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>pCache</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pCache</name>-&gt;<name>szPage</name> = <name>szPage</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Try to obtain a page from the cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheFetch</name><parameter_list>(
  <param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>,       <comment type="block">/* Obtain the page from this cache */</comment>
  <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>,            <comment type="block">/* Page number to obtain */</comment>
  <param><decl><type><name>int</name></type> <name>createFlag</name></decl></param>,       <comment type="block">/* If true, create page if it does not exist already */</comment>
  <param><decl><type><name>PgHdr</name> **</type><name>ppPage</name></decl></param>        <comment type="block">/* Write the page here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eCreate</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCache</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the pluggable cache (sqlite3_pcache*) has not been allocated,
  ** allocate it now.
  */</comment>
  <if>if<condition>( <expr>!<name>pCache</name>-&gt;<name>pCache</name> &amp;&amp; <name>createFlag</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_pcache</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nByte</name> = <name>pCache</name>-&gt;<name>szPage</name> + <name>pCache</name>-&gt;<name>szExtra</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xCreate</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>pCache</name>-&gt;<name>bPurgeable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>p</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xCachesize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pCache</name>-&gt;<name>nMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>pCache</name> = <name>p</name></expr>;</expr_stmt>
  }</block></then></if>

  <expr_stmt><expr><name>eCreate</name> = <name>createFlag</name> ? 1 : 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>eCreate</name> &amp;&amp; (!<name>pCache</name>-&gt;<name>bPurgeable</name> || !<name>pCache</name>-&gt;<name>pDirty</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>eCreate</name> = 2</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pPage</name> = <name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xFetch</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>eCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr>!<name>pPage</name> &amp;&amp; <name>eCreate</name>==1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pPg</name></decl>;</decl_stmt>

    <comment type="block">/* Find a dirty page to write-out and recycle. First try to find a 
    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC
    ** cleared), but if that is not possible settle for any other 
    ** unreferenced dirty page.
    */</comment>
    <expr_stmt><expr><call><name>expensive_assert</name><argument_list>( <argument><expr><call><name>pcacheCheckSynced</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>pPg</name>=<name>pCache</name>-&gt;<name>pSynced</name></expr>;</init> 
        <condition><expr><name>pPg</name> &amp;&amp; (<name>pPg</name>-&gt;<name>nRef</name> || (<name>pPg</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>))</expr>;</condition> 
        <incr><expr><name>pPg</name>=<name>pPg</name>-&gt;<name>pDirtyPrev</name></expr></incr>
    )<empty_stmt>;</empty_stmt></for>
    <if>if<condition>( <expr>!<name>pPg</name></expr> )</condition><then><block>{
      <for>for(<init><expr><name>pPg</name>=<name>pCache</name>-&gt;<name>pDirtyTail</name></expr>;</init> <condition><expr><name>pPg</name> &amp;&amp; <name>pPg</name>-&gt;<name>nRef</name></expr>;</condition> <incr><expr><name>pPg</name>=<name>pPg</name>-&gt;<name>pDirtyPrev</name></expr></incr>)<empty_stmt>;</empty_stmt></for>
    }</block></then></if>
    <if>if<condition>( <expr><name>pPg</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> = <name>pCache</name>-&gt;<call><name>xStress</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pStress</name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name> &amp;&amp; <name>rc</name>!=<name>SQLITE_BUSY</name></expr> )</condition><then><block>{
        <return>return <expr><name>rc</name></expr>;</return>
      }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>pPage</name> = <name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xFetch</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>pPage</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr>0==<name>pPage</name>-&gt;<name>nRef</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCache</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pData</name> = (<name>void</name>*)&amp;<name><name>pPage</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pExtra</name> = (<name>void</name>*)&amp;((<name>char</name>*)<name>pPage</name>-&gt;<name>pData</name>)[<name>pCache</name>-&gt;<name>szPage</name>]</expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pCache</name> = <name>pCache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPage</name>-&gt;<name>pgno</name> = <name>pgno</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pgno</name>==1</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pCache</name>-&gt;<name>pPage1</name> = <name>pPage</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr>*<name>ppPage</name> = <name>pPage</name></expr>;</expr_stmt>
  <return>return <expr>(<name>pPage</name>==0 &amp;&amp; <name>eCreate</name>) ? <name>SQLITE_NOMEM</name> : <name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Decrement the reference count on a page. If the page is clean and the
** reference count drops to 0, then it is made elible for recycling.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheRelease</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PCache</name> *</type><name>pCache</name> =<init> <expr><name>p</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pCache</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name>)==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pcacheUnpin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* Move the page to the head of the dirty list. */</comment>
      <expr_stmt><expr><call><name>pcacheRemoveFromDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcacheAddToDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Increase the reference count of a supplied page by 1.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheRef</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>nRef</name>&gt;0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Drop a page from the cache. There must be exactly one reference to the
** page. This function deletes that reference, so after it returns the
** page pointed to by p is invalid.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheDrop</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>pCache</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nRef</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcacheRemoveFromDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pCache</name> = <name>p</name>-&gt;<name>pCache</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCache</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pgno</name>==1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCache</name>-&gt;<name>pPage1</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xUnpin</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Make sure the page is marked as dirty. If it isn't dirty already,
** make it so.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMakeDirty</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>pCache</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_DONT_WRITE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>0==(<name>p</name>-&gt;<name>flags</name> &amp; <name>PGHDR_DIRTY</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCache</name> = <name>p</name>-&gt;<name>pCache</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> |= <name>PGHDR_DIRTY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcacheAddToDirtyList</name><argument_list>( <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Make sure the page is marked as clean. If it isn't clean already,
** make it so.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMakeClean</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name> &amp; <name>PGHDR_DIRTY</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcacheRemoveFromDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> &amp;= ~(<name>PGHDR_DIRTY</name>|<name>PGHDR_NEED_SYNC</name>)</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>pcacheUnpin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Make every page in the cache clean.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheCleanAll</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
  <while>while<condition>( <expr>(<name>p</name> = <name>pCache</name>-&gt;<name>pDirty</name>)!=0</expr> )</condition><block>{
    <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
}</block></function>

<comment type="block">/*
** Clear the PGHDR_NEED_SYNC flag from all dirty pages.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheClearSyncFlags</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name>=<name>pCache</name>-&gt;<name>pDirty</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pDirtyNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>flags</name> &amp;= ~<name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pCache</name>-&gt;<name>pSynced</name> = <name>pCache</name>-&gt;<name>pDirtyTail</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Change the page number of page p to newPgno. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMove</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>newPgno</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PCache</name> *</type><name>pCache</name> =<init> <expr><name>p</name>-&gt;<name>pCache</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>nRef</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>newPgno</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xRekey</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>newPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pgno</name> = <name>newPgno</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name>) &amp;&amp; (<name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_NEED_SYNC</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>pcacheRemoveFromDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcacheAddToDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Drop every cache entry whose page number is greater than "pgno". The
** caller must ensure that there are no outstanding references to any pages
** other than page 1 with a page number greater than pgno.
**
** If there is a reference to page 1 and the pgno parameter passed to this
** function is 0, then the data area associated with page 1 is zeroed, but
** the page object is not dropped.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheTruncate</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>, <param><decl><type><name>Pgno</name></type> <name>pgno</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pNext</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>p</name>=<name>pCache</name>-&gt;<name>pDirty</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>pNext</name></expr></incr>)<block>{
      <expr_stmt><expr><name>pNext</name> = <name>p</name>-&gt;<name>pDirtyNext</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>p</name>-&gt;<name>pgno</name>&gt;<name>pgno</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>flags</name>&amp;<name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>pgno</name>==0 &amp;&amp; <name>pCache</name>-&gt;<name>pPage1</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pPage1</name>-&gt;<name>pData</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pCache</name>-&gt;<name>szPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pgno</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xTruncate</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>pgno</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Close a cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheClose</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xDestroy</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/* 
** Discard the contents of the cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheClear</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>sqlite3PcacheTruncate</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Merge two lists of pages connected by pDirty and in pgno order.
** Do not both fixing the pDirtyPrev pointers.
*/</comment>
<function><type><name>static</name> <name>PgHdr</name> *</type><name>pcacheMergeDirtyList</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pA</name></decl></param>, <param><decl><type><name>PgHdr</name> *</type><name>pB</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name></type> <name>result</name>, *<name>pTail</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pTail</name> = &amp;<name>result</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> &amp;&amp; <name>pB</name></expr> )</condition><block>{
    <if>if<condition>( <expr><name>pA</name>-&gt;<name>pgno</name>&lt;<name>pB</name>-&gt;<name>pgno</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTail</name>-&gt;<name>pDirty</name> = <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> = <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> = <name>pA</name>-&gt;<name>pDirty</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pTail</name>-&gt;<name>pDirty</name> = <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> = <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> = <name>pB</name>-&gt;<name>pDirty</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>
  <if>if<condition>( <expr><name>pA</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTail</name>-&gt;<name>pDirty</name> = <name>pA</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTail</name>-&gt;<name>pDirty</name> = <name>pB</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pTail</name>-&gt;<name>pDirty</name> = 0</expr>;</expr_stmt>
  }</block></else></if></else></if>
  <return>return <expr><name>result</name>.<name>pDirty</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Sort the list of pages in accending order by pgno.  Pages are
** connected by pDirty pointers.  The pDirtyPrev pointers are
** corrupted by this sort.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>N_SORT_BUCKET_ALLOC</name> 25</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>N_SORT_BUCKET</name>       25</cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>sqlite3_pager_n_sort_bucket</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>N_SORT_BUCKET</name></cpp:undef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>N_SORT_BUCKET</name> \
   (sqlite3_pager_n_sort_bucket?sqlite3_pager_n_sort_bucket:N_SORT_BUCKET_ALLOC)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>static</name> <name>PgHdr</name> *</type><name>pcacheSortDirtyList</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>pIn</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name><name>a</name><index>[<expr><name>N_SORT_BUCKET_ALLOC</name></expr>]</index></name>, *<name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{
    <expr_stmt><expr><name>p</name> = <name>pIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> = <name>p</name>-&gt;<name>pDirty</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pDirty</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>N_SORT_BUCKET</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = <name>p</name></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>p</name> = <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <if>if<condition>( <expr><name>i</name>==<name>N_SORT_BUCKET</name>-1</expr> )</condition><then><block>{
      <comment type="block">/* Coverage: To get here, there need to be 2^(N_SORT_BUCKET) 
      ** elements in the input list. This is possible, but impractical.
      ** Testing this line is the point of global variable
      ** sqlite3_pager_n_sort_bucket.
      */</comment>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>
  <expr_stmt><expr><name>p</name> = <name><name>a</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>N_SORT_BUCKET</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return a list of all dirty pages in the cache, sorted by page number.
*/</comment>
<function><type><name>PgHdr</name> *</type><name>sqlite3PcacheDirtyList</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>p</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>p</name>=<name>pCache</name>-&gt;<name>pDirty</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pDirtyNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pDirty</name> = <name>p</name>-&gt;<name>pDirtyNext</name></expr>;</expr_stmt>
  }</block></for>
  <return>return <expr><call><name>pcacheSortDirtyList</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pDirty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* 
** Return the total number of referenced pages held by the cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheRefCount</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pCache</name>-&gt;<name>nRef</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Return the number of references to the page supplied as an argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcachePageRefcount</name><parameter_list>(<param><decl><type><name>PgHdr</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>p</name>-&gt;<name>nRef</name></expr>;</return>
}</block></function>

<comment type="block">/* 
** Return the total number of pages in the cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcachePagecount</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nPage</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nPage</name> = <name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xPagecount</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>nPage</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Get the suggested cache-size value.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheGetCachesize</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>pCache</name>-&gt;<name>nMax</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Set the suggested cache-size value.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheSetCachesize</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>, <param><decl><type><name>int</name></type> <name>mxPage</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pCache</name>-&gt;<name>nMax</name> = <name>mxPage</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pCache</name>-&gt;<name>pCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>sqlite3GlobalConfig</name>.<name>pcache</name>.<call><name>xCachesize</name><argument_list>(<argument><expr><name>pCache</name>-&gt;<name>pCache</name></expr></argument>, <argument><expr><name>mxPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CHECK_PAGES</name></cpp:ifdef>
<comment type="block">/*
** For all dirty pages currently in the cache, invoke the specified
** callback. This is only used if the SQLITE_CHECK_PAGES macro is
** defined.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheIterateDirty</name><parameter_list>(<param><decl><type><name>PCache</name> *</type><name>pCache</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>xIter</name>)<parameter_list>(<param><decl><type><name>PgHdr</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>PgHdr</name> *</type><name>pDirty</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>pDirty</name>=<name>pCache</name>-&gt;<name>pDirty</name></expr>;</init> <condition><expr><name>pDirty</name></expr>;</condition> <incr><expr><name>pDirty</name>=<name>pDirty</name>-&gt;<name>pDirtyNext</name></expr></incr>)<block>{
    <expr_stmt><expr><call><name>xIter</name><argument_list>(<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
