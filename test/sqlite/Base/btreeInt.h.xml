<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="btreeInt.h"><comment type="block">/*
** 2004 April 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** $Id: btreeInt.h,v 1.38 2008/12/27 15:23:13 danielk1977 Exp $
**
** This file implements a external (disk-based) database using BTrees.
** For a detailed discussion of BTrees, refer to
**
**     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
**     "Sorting And Searching", pages 473-480. Addison-Wesley
**     Publishing Company, Reading, Massachusetts.
**
** The basic idea is that each page of the file contains N database
** entries and N+1 pointers to subpages.
**
**   ----------------------------------------------------------------
**   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
**   ----------------------------------------------------------------
**
** All of the keys on the page that Ptr(0) points to have values less
** than Key(0).  All of the keys on page Ptr(1) and its subpages have
** values greater than Key(0) and less than Key(1).  All of the keys
** on Ptr(N) and its subpages have values greater than Key(N-1).  And
** so forth.
**
** Finding a particular key requires reading O(log(M)) pages from the 
** disk where M is the number of entries in the tree.
**
** In this implementation, a single file can hold one or more separate 
** BTrees.  Each BTree is identified by the index of its root page.  The
** key and data for any entry are combined to form the "payload".  A
** fixed amount of payload can be carried directly on the database
** page.  If the payload is larger than the preset amount then surplus
** bytes are stored on overflow pages.  The payload for an entry
** and the preceding pointer are combined to form a "Cell".  Each 
** page has a small header which contains the Ptr(N) pointer and other
** information such as the size of key and data.
**
** FORMAT DETAILS
**
** The file is divided into pages.  The first page is called page 1,
** the second is page 2, and so forth.  A page number of zero indicates
** "no such page".  The page size can be anything between 512 and 65536.
** Each page can be either a btree page, a freelist page or an overflow
** page.
**
** The first page is always a btree page.  The first 100 bytes of the first
** page contain a special header (the "file header") that describes the file.
** The format of the file header is as follows:
**
**   OFFSET   SIZE    DESCRIPTION
**      0      16     Header string: "SQLite format 3\000"
**     16       2     Page size in bytes.  
**     18       1     File format write version
**     19       1     File format read version
**     20       1     Bytes of unused space at the end of each page
**     21       1     Max embedded payload fraction
**     22       1     Min embedded payload fraction
**     23       1     Min leaf payload fraction
**     24       4     File change counter
**     28       4     Reserved for future use
**     32       4     First freelist page
**     36       4     Number of freelist pages in the file
**     40      60     15 4-byte meta values passed to higher layers
**
** All of the integer values are big-endian (most significant byte first).
**
** The file change counter is incremented when the database is changed
** This counter allows other processes to know when the file has changed
** and thus when they need to flush their cache.
**
** The max embedded payload fraction is the amount of the total usable
** space in a page that can be consumed by a single cell for standard
** B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
** is to limit the maximum cell size so that at least 4 cells will fit
** on one page.  Thus the default max embedded payload fraction is 64.
**
** If the payload for a cell is larger than the max payload, then extra
** payload is spilled to overflow pages.  Once an overflow page is allocated,
** as many bytes as possible are moved into the overflow pages without letting
** the cell size drop below the min embedded payload fraction.
**
** The min leaf payload fraction is like the min embedded payload fraction
** except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
** payload fraction for a LEAFDATA tree is always 100% (or 255) and it
** not specified in the header.
**
** Each btree pages is divided into three sections:  The header, the
** cell pointer array, and the cell content area.  Page 1 also has a 100-byte
** file header that occurs before the page header.
**
**      |----------------|
**      | file header    |   100 bytes.  Page 1 only.
**      |----------------|
**      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
**      |----------------|
**      | cell pointer   |   |  2 bytes per cell.  Sorted order.
**      | array          |   |  Grows downward
**      |                |   v
**      |----------------|
**      | unallocated    |
**      | space          |
**      |----------------|   ^  Grows upwards
**      | cell content   |   |  Arbitrary order interspersed with freeblocks.
**      | area           |   |  and free space fragments.
**      |----------------|
**
** The page headers looks like this:
**
**   OFFSET   SIZE     DESCRIPTION
**      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
**      1       2      byte offset to the first freeblock
**      3       2      number of cells on this page
**      5       2      first byte of the cell content area
**      7       1      number of fragmented free bytes
**      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
**
** The flags define the format of this btree page.  The leaf flag means that
** this page has no children.  The zerodata flag means that this page carries
** only keys and no data.  The intkey flag means that the key is a integer
** which is stored in the key size entry of the cell header rather than in
** the payload area.
**
** The cell pointer array begins on the first byte after the page header.
** The cell pointer array contains zero or more 2-byte numbers which are
** offsets from the beginning of the page to the cell content in the cell
** content area.  The cell pointers occur in sorted order.  The system strives
** to keep free space after the last cell pointer so that new cells can
** be easily added without having to defragment the page.
**
** Cell content is stored at the very end of the page and grows toward the
** beginning of the page.
**
** Unused space within the cell content area is collected into a linked list of
** freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
** to the first freeblock is given in the header.  Freeblocks occur in
** increasing order.  Because a freeblock must be at least 4 bytes in size,
** any group of 3 or fewer unused bytes in the cell content area cannot
** exist on the freeblock chain.  A group of 3 or fewer free bytes is called
** a fragment.  The total number of bytes in all fragments is recorded.
** in the page header at offset 7.
**
**    SIZE    DESCRIPTION
**      2     Byte offset of the next freeblock
**      2     Bytes in this freeblock
**
** Cells are of variable length.  Cells are stored in the cell content area at
** the end of the page.  Pointers to the cells are in the cell pointer array
** that immediately follows the page header.  Cells is not necessarily
** contiguous or in order, but cell pointers are contiguous and in order.
**
** Cell content makes use of variable length integers.  A variable
** length integer is 1 to 9 bytes where the lower 7 bits of each 
** byte are used.  The integer consists of all bytes that have bit 8 set and
** the first byte with bit 8 clear.  The most significant byte of the integer
** appears first.  A variable-length integer may not be more than 9 bytes long.
** As a special case, all 8 bytes of the 9th byte are used as data.  This
** allows a 64-bit integer to be encoded in 9 bytes.
**
**    0x00                      becomes  0x00000000
**    0x7f                      becomes  0x0000007f
**    0x81 0x00                 becomes  0x00000080
**    0x82 0x00                 becomes  0x00000100
**    0x80 0x7f                 becomes  0x0000007f
**    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
**    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
**
** Variable length integers are used for rowids and to hold the number of
** bytes of key and data in a btree cell.
**
** The content of a cell looks like this:
**
**    SIZE    DESCRIPTION
**      4     Page number of the left child. Omitted if leaf flag is set.
**     var    Number of bytes of data. Omitted if the zerodata flag is set.
**     var    Number of bytes of key. Or the key itself if intkey flag is set.
**      *     Payload
**      4     First page of the overflow chain.  Omitted if no overflow
**
** Overflow pages form a linked list.  Each page except the last is completely
** filled with data (pagesize - 4 bytes).  The last page can have as little
** as 1 byte of data.
**
**    SIZE    DESCRIPTION
**      4     Page number of next overflow page
**      *     Data
**
** Freelist pages come in two subtypes: trunk pages and leaf pages.  The
** file header points to the first in a linked list of trunk page.  Each trunk
** page points to multiple leaf pages.  The content of a leaf page is
** unspecified.  A trunk page looks like this:
**
**    SIZE    DESCRIPTION
**      4     Page number of next trunk page
**      4     Number of leaf pointers on this page
**      *     zero or more pages numbers of leaves
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Round up a number to the next larger multiple of 8.  This is used
** to force 8-byte alignment on 64-bit architectures.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ROUND8</name>(x)   ((x+7)&amp;~7)</cpp:define>


<comment type="block">/* The following value is the maximum cell size assuming a maximum page
** size give above.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MX_CELL_SIZE</name>(pBt)  (pBt-&gt;pageSize-8)</cpp:define>

<comment type="block">/* The maximum number of cells on a single page of the database.  This
** assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
** plus 2 bytes for the index to the cell in the page header).  Such
** small cells will be rare, but they are possible.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MX_CELL</name>(pBt) ((pBt-&gt;pageSize-8)/6)</cpp:define>

<comment type="block">/* Forward declarations */</comment>
<typedef>typedef <type><struct>struct <name>MemPage</name> MemPage;</struct></type></typedef>
<typedef>typedef <type><struct>struct <name>BtLock</name> BtLock;</struct></type></typedef>

<comment type="block">/*
** This is a magic string that appears at the beginning of every
** SQLite database in order to identify the file as a real database.
**
** You can change this value at compile-time by specifying a
** -DSQLITE_FILE_HEADER="..." on the compiler command-line.  The
** header must be exactly 16 bytes including the zero-terminator so
** the string itself should be 15 characters long.  If you change
** the header, then your custom library will not be able to read 
** databases generated by the standard tools and the standard tools
** will not be able to read databases created by your custom library.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_FILE_HEADER</name></cpp:ifndef> <comment type="block">/* 123456789 123456 */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <name>SQLITE_FILE_HEADER</name> "SQLite format 3"</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Page type flags.  An ORed combination of these flags appear as the
** first byte of on-disk image of every BTree page.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTF_INTKEY</name>    0x01</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTF_ZERODATA</name>  0x02</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTF_LEAFDATA</name>  0x04</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTF_LEAF</name>      0x08</cpp:define>

<comment type="block">/*
** As each page of the file is loaded into memory, an instance of the following
** structure is appended and initialized to zero.  This structure stores
** information about the page that is decoded from the raw file page.
**
** The pParent field points back to the parent page.  This allows us to
** walk up the BTree from any leaf to the root.  Care must be taken to
** unref() the parent page pointer when this page is no longer referenced.
** The pageDestructor() routine handles that chore.
**
** Access to all fields of this structure is controlled by the mutex
** stored in MemPage.pBt-&gt;mutex.
*/</comment>
<struct>struct <name>MemPage</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>isInit</name></decl>;</decl_stmt>           <comment type="block">/* True if previously initialized. MUST BE FIRST! */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nOverflow</name></decl>;</decl_stmt>        <comment type="block">/* Number of overflow cell bodies in aCell[] */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>intKey</name></decl>;</decl_stmt>           <comment type="block">/* True if intkey flag is set */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>leaf</name></decl>;</decl_stmt>             <comment type="block">/* True if leaf flag is set */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hasData</name></decl>;</decl_stmt>          <comment type="block">/* True if this page stores data */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hdrOffset</name></decl>;</decl_stmt>        <comment type="block">/* 100 for page 1.  0 otherwise */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>childPtrSize</name></decl>;</decl_stmt>     <comment type="block">/* 0 if leaf==1.  4 if leaf==0 */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>maxLocal</name></decl>;</decl_stmt>        <comment type="block">/* Copy of BtShared.maxLocal or BtShared.maxLeaf */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>minLocal</name></decl>;</decl_stmt>        <comment type="block">/* Copy of BtShared.minLocal or BtShared.minLeaf */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>cellOffset</name></decl>;</decl_stmt>      <comment type="block">/* Index in aData of first cell pointer */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nFree</name></decl>;</decl_stmt>           <comment type="block">/* Number of free bytes on the page */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nCell</name></decl>;</decl_stmt>           <comment type="block">/* Number of cells on this page, local and ovfl */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>maskPage</name></decl>;</decl_stmt>        <comment type="block">/* Mask for page offset */</comment>
  <struct>struct <name>_OvflCell</name> <block>{   <comment type="block">/* Cells that will not fit on aData[] */</comment>
    <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>          <comment type="block">/* Pointers to the body of the overflow cell */</comment>
    <decl_stmt><decl><type><name>u16</name></type> <name>idx</name></decl>;</decl_stmt>            <comment type="block">/* Insert this cell before idx-th non-overflow cell */</comment>
  }</block> <decl><name><name>aOvfl</name><index>[<expr>5</expr>]</index></name></decl>;</struct>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>       <comment type="block">/* Pointer to BtShared that this page is part of */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aData</name></decl>;</decl_stmt>           <comment type="block">/* Pointer to disk image of the page data */</comment>
  <decl_stmt><decl><type><name>DbPage</name> *</type><name>pDbPage</name></decl>;</decl_stmt>     <comment type="block">/* Pager page handle */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgno</name></decl>;</decl_stmt>           <comment type="block">/* Page number for this page */</comment>
}</block>;</struct>

<comment type="block">/*
** The in-memory image of a disk page has the auxiliary information appended
** to the end.  EXTRA_SIZE is the number of bytes of space needed to hold
** that extra information.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>EXTRA_SIZE</name> <name>sizeof</name>(MemPage)</cpp:define>

<comment type="block">/* A Btree handle
**
** A database connection contains a pointer to an instance of
** this object for every database file that it has open.  This structure
** is opaque to the database connection.  The database connection cannot
** see the internals of this structure and only deals with pointers to
** this structure.
**
** For some database files, the same underlying database cache might be 
** shared between multiple connections.  In that case, each contection
** has it own pointer to this object.  But each instance of this object
** points to the same BtShared object.  The database cache and the
** schema associated with the database file are all contained within
** the BtShared object.
**
** All fields in this structure are accessed under sqlite3.mutex.
** The pBt pointer itself may not be changed while there exists cursors 
** in the referenced BtShared that point back to this Btree since those
** cursors have to do go through this Btree to find their BtShared and
** they often do so without holding sqlite3.mutex.
*/</comment>
<struct>struct <name>Btree</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>       <comment type="block">/* The database connection holding this btree */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>     <comment type="block">/* Sharable content of this btree */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>inTrans</name></decl>;</decl_stmt>        <comment type="block">/* TRANS_NONE, TRANS_READ or TRANS_WRITE */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>sharable</name></decl>;</decl_stmt>       <comment type="block">/* True if we can share pBt with another db */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>locked</name></decl>;</decl_stmt>         <comment type="block">/* True if db currently has pBt locked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>wantToLock</name></decl>;</decl_stmt>    <comment type="block">/* Number of nested calls to sqlite3BtreeEnter() */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pNext</name></decl>;</decl_stmt>      <comment type="block">/* List of other sharable Btrees from the same db */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pPrev</name></decl>;</decl_stmt>      <comment type="block">/* Back pointer of the same list */</comment>
}</block>;</struct>

<comment type="block">/*
** Btree.inTrans may take one of the following values.
**
** If the shared-data extension is enabled, there may be multiple users
** of the Btree structure. At most one of these may open a write transaction,
** but any number may have active read transactions.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRANS_NONE</name>  0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRANS_READ</name>  1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TRANS_WRITE</name> 2</cpp:define>

<comment type="block">/*
** An instance of this object represents a single database file.
** 
** A single database file can be in use as the same time by two
** or more database connections.  When two or more connections are
** sharing the same database file, each connection has it own
** private Btree object for the file and each of those Btrees points
** to this one BtShared object.  BtShared.nRef is the number of
** connections currently sharing this database file.
**
** Fields in this structure are accessed under the BtShared.mutex
** mutex, except for nRef and pNext which are accessed under the
** global SQLITE_MUTEX_STATIC_MASTER mutex.  The pPager field
** may not be modified once it is initially set as long as nRef&gt;0.
** The pSchema field may be set once under BtShared.mutex and
** thereafter is unchanged as long as nRef&gt;0.
*/</comment>
<struct>struct <name>BtShared</name> <block>{
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name></decl>;</decl_stmt>        <comment type="block">/* The page cache */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection currently using this Btree */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCursor</name></decl>;</decl_stmt>    <comment type="block">/* A list of all open cursors */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage1</name></decl>;</decl_stmt>      <comment type="block">/* First page of the database */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>inStmt</name></decl>;</decl_stmt>            <comment type="block">/* True if we are in a statement subtransaction */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>readOnly</name></decl>;</decl_stmt>          <comment type="block">/* True if the underlying file is readonly */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>pageSizeFixed</name></decl>;</decl_stmt>     <comment type="block">/* True if the page size can no longer be changed */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u8</name></type> <name>autoVacuum</name></decl>;</decl_stmt>        <comment type="block">/* True if auto-vacuum is enabled */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>incrVacuum</name></decl>;</decl_stmt>        <comment type="block">/* True if incr-vacuum is enabled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>u16</name></type> <name>pageSize</name></decl>;</decl_stmt>         <comment type="block">/* Total number of bytes on a page */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>usableSize</name></decl>;</decl_stmt>       <comment type="block">/* Number of usable bytes on each page */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>maxLocal</name></decl>;</decl_stmt>         <comment type="block">/* Maximum local payload in non-LEAFDATA tables */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>minLocal</name></decl>;</decl_stmt>         <comment type="block">/* Minimum local payload in non-LEAFDATA tables */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>maxLeaf</name></decl>;</decl_stmt>          <comment type="block">/* Maximum local payload in a LEAFDATA table */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>minLeaf</name></decl>;</decl_stmt>          <comment type="block">/* Minimum local payload in a LEAFDATA table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>inTransaction</name></decl>;</decl_stmt>     <comment type="block">/* Transaction state */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTransaction</name></decl>;</decl_stmt>     <comment type="block">/* Number of open transactions (read + write) */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pSchema</name></decl>;</decl_stmt>        <comment type="block">/* Pointer to space allocated by sqlite3BtreeSchema() */</comment>
  <function_decl><type><name>void</name></type> (*<name>xFreeSchema</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list>;</function_decl>  <comment type="block">/* Destructor for BtShared.pSchema */</comment>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> *</type><name>mutex</name></decl>;</decl_stmt> <comment type="block">/* Non-recursive mutex required to access this struct */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>             <comment type="block">/* Number of references to this structure */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pNext</name></decl>;</decl_stmt>      <comment type="block">/* Next on a list of sharable BtShared structs */</comment>
  <decl_stmt><decl><type><name>BtLock</name> *</type><name>pLock</name></decl>;</decl_stmt>        <comment type="block">/* List of locks held on this shared-btree struct */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pExclusive</name></decl>;</decl_stmt>    <comment type="block">/* Btree with an EXCLUSIVE lock on the whole db */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>u8</name> *</type><name>pTmpSpace</name></decl>;</decl_stmt>        <comment type="block">/* BtShared.pageSize bytes of space for tmp use */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the following structure is used to hold information
** about a cell.  The parseCellPtr() function fills in this structure
** based on information extract from the raw disk page.
*/</comment>
<typedef>typedef <type><struct>struct <name>CellInfo</name> CellInfo;</struct></type></typedef>
<struct>struct <name>CellInfo</name> <block>{
  <decl_stmt><decl><type><name>u8</name> *</type><name>pCell</name></decl>;</decl_stmt>     <comment type="block">/* Pointer to the start of cell content */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nKey</name></decl>;</decl_stmt>      <comment type="block">/* The key for INTKEY tables, or number of bytes in key */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nData</name></decl>;</decl_stmt>     <comment type="block">/* Number of bytes of data */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nPayload</name></decl>;</decl_stmt>  <comment type="block">/* Total amount of payload */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nHeader</name></decl>;</decl_stmt>   <comment type="block">/* Size of the cell content header in bytes */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nLocal</name></decl>;</decl_stmt>    <comment type="block">/* Amount of payload held locally */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>iOverflow</name></decl>;</decl_stmt> <comment type="block">/* Offset to overflow page number.  Zero if no overflow */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>nSize</name></decl>;</decl_stmt>     <comment type="block">/* Size of the cell content on the main b-tree page */</comment>
}</block>;</struct>

<comment type="block">/*
** Maximum depth of an SQLite B-Tree structure. Any B-Tree deeper than
** this will be declared corrupt. This value is calculated based on a
** maximum database size of 2^31 pages a minimum fanout of 2 for a
** root-node and 3 for all other internal nodes.
**
** If a tree that appears to be taller than this is encountered, it is
** assumed that the database is corrupt.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>BTCURSOR_MAX_DEPTH</name> 20</cpp:define>

<comment type="block">/*
** A cursor is a pointer to a particular entry within a particular
** b-tree within a database file.
**
** The entry is identified by its MemPage and the index in
** MemPage.aCell[] of the entry.
**
** When a single database file can shared by two more database connections,
** but cursors cannot be shared.  Each cursor is associated with a
** particular database connection identified BtCursor.pBtree.db.
**
** Fields in this structure are accessed under the BtShared.mutex
** found at self-&gt;pBt-&gt;mutex. 
*/</comment>
<struct>struct <name>BtCursor</name> <block>{
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBtree</name></decl>;</decl_stmt>            <comment type="block">/* The Btree to which this cursor belongs */</comment>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>            <comment type="block">/* The BtShared this cursor points to */</comment>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pNext</name>, *<name>pPrev</name></decl>;</decl_stmt>  <comment type="block">/* Forms a linked list of all cursors */</comment>
  <decl_stmt><decl><type>struct <name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt> <comment type="block">/* Argument passed to comparison function */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>pgnoRoot</name></decl>;</decl_stmt>            <comment type="block">/* The root page of this tree */</comment>
  <decl_stmt><decl><type><name>CellInfo</name></type> <name>info</name></decl>;</decl_stmt>            <comment type="block">/* A parse of the cell we are pointing at */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>wrFlag</name></decl>;</decl_stmt>                <comment type="block">/* True if writable */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>atLast</name></decl>;</decl_stmt>                <comment type="block">/* Cursor pointing to the last entry */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>validNKey</name></decl>;</decl_stmt>             <comment type="block">/* True if info.nKey is valid */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eState</name></decl>;</decl_stmt>                <comment type="block">/* One of the CURSOR_XXX constants (see below) */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>pKey</name></decl>;</decl_stmt>      <comment type="block">/* Saved key that was cursor's last known position */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nKey</name></decl>;</decl_stmt>        <comment type="block">/* Size of pKey, or last integer key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>;</decl_stmt>        <comment type="block">/* (skip&lt;0) -&gt; Prev() is a no-op. (skip&gt;0) -&gt; Next() is */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u8</name></type> <name>isIncrblobHandle</name></decl>;</decl_stmt>      <comment type="block">/* True if this cursor is an incr. io handle */</comment>
  <decl_stmt><decl><type><name>Pgno</name> *</type><name>aOverflow</name></decl>;</decl_stmt>          <comment type="block">/* Cache of overflow page locations */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>u8</name></type> <name>pagesShuffled</name></decl>;</decl_stmt>         <comment type="block">/* True if Btree pages are rearranged by balance()*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>i16</name></type> <name>iPage</name></decl>;</decl_stmt>                            <comment type="block">/* Index of current page in apPage */</comment>
  <decl_stmt><decl><type><name>MemPage</name> *</type><name><name>apPage</name><index>[<expr><name>BTCURSOR_MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* Pages from root to current page */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name><name>aiIdx</name><index>[<expr><name>BTCURSOR_MAX_DEPTH</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Current index in apPage[i] */</comment>
}</block>;</struct>

<comment type="block">/*
** Potential values for BtCursor.eState.
**
** CURSOR_VALID:
**   Cursor points to a valid entry. getPayload() etc. may be called.
**
** CURSOR_INVALID:
**   Cursor does not point to a valid entry. This can happen (for example) 
**   because the table is empty or because BtreeCursorFirst() has not been
**   called.
**
** CURSOR_REQUIRESEEK:
**   The table that this cursor was opened on still exists, but has been 
**   modified since the cursor was last used. The cursor position is saved
**   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in 
**   this state, restoreCursorPosition() can be called to attempt to
**   seek the cursor to the saved position.
**
** CURSOR_FAULT:
**   A unrecoverable error (an I/O error or a malloc failure) has occurred
**   on a different connection that shares the BtShared cache with this
**   cursor.  The error has left the cache in an inconsistent state.
**   Do nothing else with this cursor.  Any attempt to use the cursor
**   should return the error code stored in BtCursor.skip
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CURSOR_INVALID</name>           0</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CURSOR_VALID</name>             1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CURSOR_REQUIRESEEK</name>       2</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CURSOR_FAULT</name>             3</cpp:define>

<comment type="block">/* The database page the PENDING_BYTE occupies. This page is never used.
** TODO: This macro is very similary to PAGER_MJ_PGNO() in pager.c. They
** should possibly be consolidated (presumably in pager.h).
**
** If disk I/O is omitted (meaning that the database is stored purely
** in memory) then there is no pending byte.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_DISKIO</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>PENDING_BYTE_PAGE</name>(pBt)  0x7fffffff</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>PENDING_BYTE_PAGE</name>(pBt) ((Pgno)((PENDING_BYTE/(pBt)-&gt;pageSize)+1))</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** A linked list of the following structures is stored at BtShared.pLock.
** Locks are added (or upgraded from READ_LOCK to WRITE_LOCK) when a cursor 
** is opened on the table with root page BtShared.iTable. Locks are removed
** from this list when a transaction is committed or rolled back, or when
** a btree handle is closed.
*/</comment>
<struct>struct <name>BtLock</name> <block>{
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBtree</name></decl>;</decl_stmt>        <comment type="block">/* Btree handle holding this lock */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>iTable</name></decl>;</decl_stmt>          <comment type="block">/* Root page of table */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eLock</name></decl>;</decl_stmt>             <comment type="block">/* READ_LOCK or WRITE_LOCK */</comment>
  <decl_stmt><decl><type><name>BtLock</name> *</type><name>pNext</name></decl>;</decl_stmt>        <comment type="block">/* Next in BtShared.pLock list */</comment>
}</block>;</struct>

<comment type="block">/* Candidate values for BtLock.eLock */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>READ_LOCK</name>     1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>WRITE_LOCK</name>    2</cpp:define>

<comment type="block">/*
** These macros define the location of the pointer-map entry for a 
** database page. The first argument to each is the number of usable
** bytes on each page of the database (often 1024). The second is the
** page number to look up in the pointer map.
**
** PTRMAP_PAGENO returns the database page number of the pointer-map
** page that stores the required pointer. PTRMAP_PTROFFSET returns
** the offset of the requested map entry.
**
** If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
** then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
** used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
** this test.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_PAGENO</name>(pBt, pgno) ptrmapPageno(pBt, pgno)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_PTROFFSET</name>(pgptrmap, pgno) (5*(pgno-pgptrmap-1))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_ISPAGE</name>(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))</cpp:define>

<comment type="block">/*
** The pointer map is a lookup table that identifies the parent page for
** each child page in the database file.  The parent page is the page that
** contains a pointer to the child.  Every page in the database contains
** 0 or 1 parent pages.  (In this context 'database page' refers
** to any page that is not part of the pointer map itself.)  Each pointer map
** entry consists of a single byte 'type' and a 4 byte parent page number.
** The PTRMAP_XXX identifiers below are the valid types.
**
** The purpose of the pointer map is to facility moving pages from one
** position in the file to another as part of autovacuum.  When a page
** is moved, the pointer in its parent must be updated to point to the
** new location.  The pointer map is used to locate the parent page quickly.
**
** PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
**                  used in this case.
**
** PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number 
**                  is not used in this case.
**
** PTRMAP_OVERFLOW1: The database page is the first page in a list of 
**                   overflow pages. The page number identifies the page that
**                   contains the cell with a pointer to this overflow page.
**
** PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
**                   overflow pages. The page-number identifies the previous
**                   page in the overflow page list.
**
** PTRMAP_BTREE: The database page is a non-root btree page. The page number
**               identifies the parent page in the btree.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_ROOTPAGE</name> 1</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_FREEPAGE</name> 2</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_OVERFLOW1</name> 3</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_OVERFLOW2</name> 4</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>PTRMAP_BTREE</name> 5</cpp:define>

<comment type="block">/* A bunch of assert() statements to check the transaction state variables
** of handle p (type Btree*) are internally consistent.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>btreeIntegrity</name>(p) \
  assert( p-&gt;pBt-&gt;inTransaction!=TRANS_NONE || p-&gt;pBt-&gt;nTransaction==0 ); \
  assert( p-&gt;pBt-&gt;inTransaction&gt;=p-&gt;inTrans );</cpp:define> 


<comment type="block">/*
** The ISAUTOVACUUM macro is used within balance_nonroot() to determine
** if the database supports auto-vacuum or not. Because it is used
** within an expression that is an argument to another macro 
** (sqliteMallocRaw), it is not possible to use conditional compilation.
** So, this macro is defined instead.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ISAUTOVACUUM</name> (pBt-&gt;autoVacuum)</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>ISAUTOVACUUM</name> 0</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** This structure is passed around through all the sanity checking routines
** in order to keep track of some global state information.
*/</comment>
<typedef>typedef <type><struct>struct <name>IntegrityCk</name> IntegrityCk;</struct></type></typedef>
<struct>struct <name>IntegrityCk</name> <block>{
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>    <comment type="block">/* The tree being checked out */</comment>
  <decl_stmt><decl><type><name>Pager</name> *</type><name>pPager</name></decl>;</decl_stmt>    <comment type="block">/* The associated pager.  Also accessible by pBt-&gt;pPager */</comment>
  <decl_stmt><decl><type><name>Pgno</name></type> <name>nPage</name></decl>;</decl_stmt>       <comment type="block">/* Number of pages in the database */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>anRef</name></decl>;</decl_stmt>       <comment type="block">/* Number of times each page is referenced */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mxErr</name></decl>;</decl_stmt>        <comment type="block">/* Stop accumulating errors when this reaches zero */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name></decl>;</decl_stmt>         <comment type="block">/* Number of messages written to zErrMsg so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mallocFailed</name></decl>;</decl_stmt> <comment type="block">/* A memory allocation error has occurred */</comment>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>errMsg</name></decl>;</decl_stmt>  <comment type="block">/* Accumulate the error message text here */</comment>
}</block>;</struct>

<comment type="block">/*
** Read or write a two- and four-byte big-endian integer values.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>get2byte</name>(x)   ((x)[0]&lt;&lt;8 | (x)[1])</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>put2byte</name>(p,v) ((p)[0] = (u8)((v)&gt;&gt;8), (p)[1] = (u8)(v))</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>get4byte</name> <name>sqlite3Get4byte</name></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>put4byte</name> <name>sqlite3Put4byte</name></cpp:define>

<comment type="block">/*
** Internal routines that should be accessed by the btree layer only.
*/</comment>
<function_decl><type><name>int</name></type> <name>sqlite3BtreeGetPage</name><parameter_list>(<param><decl><type><name>BtShared</name>*</type></decl></param>, <param><decl><type><name>Pgno</name></type></decl></param>, <param><decl><type><name>MemPage</name>**</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3BtreeInitPage</name><parameter_list>(<param><decl><type><name>MemPage</name> *</type><name>pPage</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3BtreeParseCellPtr</name><parameter_list>(<param><decl><type><name>MemPage</name>*</type></decl></param>, <param><decl><type><name>u8</name>*</type></decl></param>, <param><decl><type><name>CellInfo</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3BtreeParseCell</name><parameter_list>(<param><decl><type><name>MemPage</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>CellInfo</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3BtreeRestoreCursorPosition</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3BtreeGetTempCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>BtCursor</name> *</type><name>pTempCur</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3BtreeReleaseTempCursor</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3BtreeMoveToParent</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>)</parameter_list>;</function_decl>
</unit>
