<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="vdbeInt.h"><comment type="block">/*
** 2003 September 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This is the header file for information that is private to the
** VDBE.  This information used to all be at the top of the single
** source code file "vdbe.c".  When that file became too big (over
** 6000 lines long) it was split up into several smaller files and
** this header information was factored out.
**
** $Id: vdbeInt.h,v 1.161 2009/01/05 18:02:27 drh Exp $
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_VDBEINT_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>_VDBEINT_H_</name></cpp:define>

<comment type="block">/*
** intToKey() and keyToInt() used to transform the rowid.  But with
** the latest versions of the design they are no-ops.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>keyToInt</name>(X)   (X)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>intToKey</name>(X)   (X)</cpp:define>


<comment type="block">/*
** SQL is translated into a sequence of instructions to be
** executed by a virtual machine.  Each instruction is an instance
** of the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>VdbeOp</name> Op;</struct></type></typedef>

<comment type="block">/*
** Boolean values
*/</comment>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>Bool</name>;</typedef>

<comment type="block">/*
** A cursor is a pointer into a single BTree within a database file.
** The cursor can seek to a BTree entry with a particular key, or
** loop over all entries of the Btree.  You can also insert new BTree
** entries or retrieve the key or data from the entry that the cursor
** is currently pointing to.
** 
** Every cursor that the virtual machine has open is represented by an
** instance of the following structure.
**
** If the VdbeCursor.isTriggerRow flag is set it means that this cursor is
** really a single row that represents the NEW or OLD pseudo-table of
** a row trigger.  The data for the row is stored in VdbeCursor.pData and
** the rowid is in VdbeCursor.iKey.
*/</comment>
<struct>struct <name>VdbeCursor</name> <block>{
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCursor</name></decl>;</decl_stmt>    <comment type="block">/* The cursor structure of the backend */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* Index of cursor database in db-&gt;aDb[] (or -1) */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>lastRowid</name></decl>;</decl_stmt>        <comment type="block">/* Last rowid from a Next or NextIdx operation */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nextRowid</name></decl>;</decl_stmt>        <comment type="block">/* Next rowid returned by OP_NewRowid */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>zeroed</name></decl>;</decl_stmt>          <comment type="block">/* True if zeroed out and ready for reuse */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>rowidIsValid</name></decl>;</decl_stmt>    <comment type="block">/* True if lastRowid is valid */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>atFirst</name></decl>;</decl_stmt>         <comment type="block">/* True if pointing to first entry */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>useRandomRowid</name></decl>;</decl_stmt>  <comment type="block">/* Generate new record numbers semi-randomly */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>nullRow</name></decl>;</decl_stmt>         <comment type="block">/* True if pointing to a row with no data */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>nextRowidValid</name></decl>;</decl_stmt>  <comment type="block">/* True if the nextRowid field is valid */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>pseudoTable</name></decl>;</decl_stmt>     <comment type="block">/* This is a NEW or OLD pseudo-tables of a trigger */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>ephemPseudoTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Bool</name></type> <name>deferredMoveto</name></decl>;</decl_stmt>  <comment type="block">/* A call to sqlite3BtreeMoveto() is needed */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>isTable</name></decl>;</decl_stmt>         <comment type="block">/* True if a table requiring integer keys */</comment>
  <decl_stmt><decl><type><name>Bool</name></type> <name>isIndex</name></decl>;</decl_stmt>         <comment type="block">/* True if an index containing keys only - no data */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>movetoTarget</name></decl>;</decl_stmt>     <comment type="block">/* Argument to the deferred sqlite3BtreeMoveto() */</comment>
  <decl_stmt><decl><type><name>Btree</name> *</type><name>pBt</name></decl>;</decl_stmt>           <comment type="block">/* Separate file holding temporary table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>            <comment type="block">/* Number of bytes in pData */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>pData</name></decl>;</decl_stmt>          <comment type="block">/* Data for a NEW or OLD pseudo-table */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iKey</name></decl>;</decl_stmt>             <comment type="block">/* Key for the NEW or OLD pseudo-table row */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKeyInfo</name></decl>;</decl_stmt>    <comment type="block">/* Info about index keys needed by index cursors */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nField</name></decl>;</decl_stmt>           <comment type="block">/* Number of fields in the header */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>seqCount</name></decl>;</decl_stmt>         <comment type="block">/* Sequence counter */</comment>
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name> *</type><name>pVtabCursor</name></decl>;</decl_stmt>  <comment type="block">/* The cursor for a virtual table */</comment>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>     <comment type="block">/* Module for cursor pVtabCursor */</comment>

  <comment type="block">/* Cached information about the header for the data record that the
  ** cursor is currently pointing to.  Only valid if cacheValid is true.
  ** aRow might point to (ephemeral) data for the current row, or it might
  ** be NULL.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cacheStatus</name></decl>;</decl_stmt>      <comment type="block">/* Cache is valid if this matches Vdbe.cacheCtr */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>payloadSize</name></decl>;</decl_stmt>      <comment type="block">/* Total number of bytes in the record */</comment>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aType</name></decl>;</decl_stmt>           <comment type="block">/* Type values for all entries in the record */</comment>
  <decl_stmt><decl><type><name>u32</name> *</type><name>aOffset</name></decl>;</decl_stmt>         <comment type="block">/* Cached offsets to the start of each columns data */</comment>
  <decl_stmt><decl><type><name>u8</name> *</type><name>aRow</name></decl>;</decl_stmt>             <comment type="block">/* Data for the current row, if all on one page */</comment>
}</block>;</struct>
<typedef>typedef <type><struct>struct <name>VdbeCursor</name> VdbeCursor;</struct></type></typedef>

<comment type="block">/*
** A value for VdbeCursor.cacheValid that means the cache is always invalid.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>CACHE_STALE</name> 0</cpp:define>

<comment type="block">/*
** Internally, the vdbe manipulates nearly all SQL values as Mem
** structures. Each Mem struct may cache multiple representations (string,
** integer etc.) of the same value.  A value (and therefore Mem structure)
** has the following properties:
**
** Each value has a manifest type. The manifest type of the value stored
** in a Mem struct is returned by the MemType(Mem*) macro. The type is
** one of SQLITE_NULL, SQLITE_INTEGER, SQLITE_REAL, SQLITE_TEXT or
** SQLITE_BLOB.
*/</comment>
<struct>struct <name>Mem</name> <block>{
  union <block>{
    <decl_stmt><decl><type><name>i64</name></type> <name>i</name></decl>;</decl_stmt>              <comment type="block">/* Integer value. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nZero</name></decl>;</decl_stmt>          <comment type="block">/* Used when bit MEM_Zero is set in flags */</comment>
    <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl>;</decl_stmt>      <comment type="block">/* Used only when flags==MEM_Agg */</comment>
    <decl_stmt><decl><type><name>RowSet</name> *</type><name>pRowSet</name></decl>;</decl_stmt>    <comment type="block">/* Used only when flags==MEM_RowSet */</comment>
  }</block> <expr_stmt><expr><name>u</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>           <comment type="block">/* Real value */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>        <comment type="block">/* The associated database connection */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>            <comment type="block">/* String or BLOB value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>              <comment type="block">/* Number of characters in string value, excluding '\0' */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>flags</name></decl>;</decl_stmt>          <comment type="block">/* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */</comment>
  <decl_stmt><decl><type><name>u8</name></type>  <name>type</name></decl>;</decl_stmt>           <comment type="block">/* One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc */</comment>
  <decl_stmt><decl><type><name>u8</name></type>  <name>enc</name></decl>;</decl_stmt>            <comment type="block">/* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */</comment>
  <function_decl><type><name>void</name></type> (*<name>xDel</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>  <comment type="block">/* If not null, call this function to delete Mem.z */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zMalloc</name></decl>;</decl_stmt>      <comment type="block">/* Dynamic buffer allocated by sqlite3_malloc() */</comment>
}</block>;</struct>

<comment type="block">/* One or more of the following flags are set to indicate the validOK
** representations of the value stored in the Mem struct.
**
** If the MEM_Null flag is set, then the value is an SQL NULL value.
** No other flags may be set in this case.
**
** If the MEM_Str flag is set then Mem.z points at a string representation.
** Usually this is encoded in the same unicode encoding as the main
** database (see below for exceptions). If the MEM_Term flag is also
** set, then the string is nul terminated. The MEM_Int and MEM_Real 
** flags may coexist with the MEM_Str flag.
**
** Multiple of these values can appear in Mem.flags.  But only one
** at a time can appear in Mem.type.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Null</name>      0x0001</cpp:define>   <comment type="block">/* Value is NULL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Str</name>       0x0002</cpp:define>   <comment type="block">/* Value is a string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Int</name>       0x0004</cpp:define>   <comment type="block">/* Value is an integer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Real</name>      0x0008</cpp:define>   <comment type="block">/* Value is a real number */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Blob</name>      0x0010</cpp:define>   <comment type="block">/* Value is a BLOB */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_RowSet</name>    0x0020</cpp:define>   <comment type="block">/* Value is a RowSet object */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_TypeMask</name>  0x00ff</cpp:define>   <comment type="block">/* Mask of type bits */</comment>

<comment type="block">/* Whenever Mem contains a valid string or blob representation, one of
** the following flags must be set to determine the memory management
** policy for Mem.z.  The MEM_Term flag tells us whether or not the
** string is \000 or \u0000 terminated
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Term</name>      0x0200</cpp:define>   <comment type="block">/* String rep is nul terminated */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Dyn</name>       0x0400</cpp:define>   <comment type="block">/* Need to call sqliteFree() on Mem.z */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Static</name>    0x0800</cpp:define>   <comment type="block">/* Mem.z points to a static string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Ephem</name>     0x1000</cpp:define>   <comment type="block">/* Mem.z points to an ephemeral string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Agg</name>       0x2000</cpp:define>   <comment type="block">/* Mem.z points to an agg function context */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Zero</name>      0x4000</cpp:define>   <comment type="block">/* Mem.i contains count of 0s appended to blob */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifdef>
  <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MEM_Zero</name></cpp:undef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>MEM_Zero</name> 0x0000</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Clear any existing type flags from a Mem and replace them with f
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MemSetTypeFlag</name>(p, f) \
   ((p)-&gt;flags = ((p)-&gt;flags&amp;~(MEM_TypeMask|MEM_Zero))|f)</cpp:define>


<comment type="block">/* A VdbeFunc is just a FuncDef (defined in sqliteInt.h) that contains
** additional information about auxiliary information bound to arguments
** of the function.  This is used to implement the sqlite3_get_auxdata()
** and sqlite3_set_auxdata() APIs.  The "auxdata" is some auxiliary data
** that can be associated with a constant argument to a function.  This
** allows functions such as "regexp" to compile their constant regular
** expression argument once and reused the compiled code for multiple
** invocations.
*/</comment>
<struct>struct <name>VdbeFunc</name> <block>{
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pFunc</name></decl>;</decl_stmt>               <comment type="block">/* The definition of the function */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAux</name></decl>;</decl_stmt>                     <comment type="block">/* Number of entries allocated for apAux[] */</comment>
  <struct>struct <name>AuxData</name> <block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>pAux</name></decl>;</decl_stmt>                   <comment type="block">/* Aux data for the i-th argument */</comment>
    <function_decl><type><name>void</name></type> (*<name>xDelete</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>      <comment type="block">/* Destructor for the aux data */</comment>
  }</block> <decl><name><name>apAux</name><index>[<expr>1</expr>]</index></name></decl>;</struct>                   <comment type="block">/* One slot for each function argument */</comment>
}</block>;</struct>

<comment type="block">/*
** The "context" argument for a installable function.  A pointer to an
** instance of this structure is the first argument to the routines used
** implement the SQL functions.
**
** There is a typedef for this structure in sqlite.h.  So all routines,
** even the public interface to SQLite, can use a pointer to this structure.
** But this file is the only place where the internal details of this
** structure are known.
**
** This structure is defined inside of vdbeInt.h because it uses substructures
** (Mem) which are only defined there.
*/</comment>
<struct>struct <name>sqlite3_context</name> <block>{
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pFunc</name></decl>;</decl_stmt>       <comment type="block">/* Pointer to function information.  MUST BE FIRST */</comment>
  <decl_stmt><decl><type><name>VdbeFunc</name> *</type><name>pVdbeFunc</name></decl>;</decl_stmt>  <comment type="block">/* Auxilary data, if created. */</comment>
  <decl_stmt><decl><type><name>Mem</name></type> <name>s</name></decl>;</decl_stmt>                <comment type="block">/* The return value is stored here */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pMem</name></decl>;</decl_stmt>            <comment type="block">/* Memory cell used to store aggregate context */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>isError</name></decl>;</decl_stmt>          <comment type="block">/* Error code returned by the function. */</comment>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>       <comment type="block">/* Collating sequence */</comment>
}</block>;</struct>

<comment type="block">/*
** A Set structure is used for quick testing to see if a value
** is part of a small set.  Sets are used to implement code like
** this:
**            x.y IN ('hi','hoo','hum')
*/</comment>
<typedef>typedef <type><struct>struct <name>Set</name> Set;</struct></type></typedef>
<struct>struct <name>Set</name> <block>{
  <decl_stmt><decl><type><name>Hash</name></type> <name>hash</name></decl>;</decl_stmt>             <comment type="block">/* A set is just a hash table */</comment>
  <decl_stmt><decl><type><name>HashElem</name> *</type><name>prev</name></decl>;</decl_stmt>        <comment type="block">/* Previously accessed hash elemen */</comment>
}</block>;</struct>

<comment type="block">/*
** A Context stores the last insert rowid, the last statement change count,
** and the current statement change count (i.e. changes since last statement).
** The current keylist is also stored in the context.
** Elements of Context structure type make up the ContextStack, which is
** updated by the ContextPush and ContextPop opcodes (used by triggers).
** The context is pushed before executing a trigger a popped when the
** trigger finishes.
*/</comment>
<typedef>typedef <type><struct>struct <name>Context</name> Context;</struct></type></typedef>
<struct>struct <name>Context</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>lastRowid</name></decl>;</decl_stmt>    <comment type="block">/* Last insert rowid (sqlite3.lastRowid) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>      <comment type="block">/* Statement changes (Vdbe.nChanges)     */</comment>
}</block>;</struct>

<comment type="block">/*
** An instance of the virtual machine.  This structure contains the complete
** state of the virtual machine.
**
** The "sqlite3_stmt" structure pointer that is returned by sqlite3_compile()
** is really a pointer to an instance of this structure.
**
** The Vdbe.inVtabMethod variable is set to non-zero for the duration of
** any virtual table method invocations made by the vdbe program. It is
** set to 2 for xDestroy method calls and 1 for all other methods. This
** variable is used for two purposes: to allow xDestroy methods to execute
** "DROP TABLE" statements and to prevent some nasty side effects of
** malloc failure when SQLite is invoked recursively by a virtual table 
** method function.
*/</comment>
<struct>struct <name>Vdbe</name> <block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>        <comment type="block">/* The whole database */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>pPrev</name>,*<name>pNext</name></decl>;</decl_stmt> <comment type="block">/* Linked list of VDBEs with the same Vdbe.db */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOp</name></decl>;</decl_stmt>            <comment type="block">/* Number of instructions in the program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOpAlloc</name></decl>;</decl_stmt>       <comment type="block">/* Number of slots allocated for aOp[] */</comment>
  <decl_stmt><decl><type><name>Op</name> *</type><name>aOp</name></decl>;</decl_stmt>            <comment type="block">/* Space to hold the virtual machine's program */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLabel</name></decl>;</decl_stmt>         <comment type="block">/* Number of labels used */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nLabelAlloc</name></decl>;</decl_stmt>    <comment type="block">/* Number of slots allocated in aLabel[] */</comment>
  <decl_stmt><decl><type><name>int</name> *</type><name>aLabel</name></decl>;</decl_stmt>        <comment type="block">/* Space to hold the labels */</comment>
  <decl_stmt><decl><type><name>Mem</name> **</type><name>apArg</name></decl>;</decl_stmt>        <comment type="block">/* Arguments to currently executing user function */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>aColName</name></decl>;</decl_stmt>      <comment type="block">/* Column names to return */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCursor</name></decl>;</decl_stmt>        <comment type="block">/* Number of slots in apCsr[] */</comment>
  <decl_stmt><decl><type><name>VdbeCursor</name> **</type><name>apCsr</name></decl>;</decl_stmt> <comment type="block">/* One element of this array for each open cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>           <comment type="block">/* Number of entries in aVar[] */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>aVar</name></decl>;</decl_stmt>          <comment type="block">/* Values for the OP_Variable opcode. */</comment>
  <decl_stmt><decl><type><name>char</name> **</type><name>azVar</name></decl>;</decl_stmt>       <comment type="block">/* Name of variables */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>okVar</name></decl>;</decl_stmt>          <comment type="block">/* True if azVar[] has been initialized */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>magic</name></decl>;</decl_stmt>              <comment type="block">/* Magic number for sanity checking */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMem</name></decl>;</decl_stmt>               <comment type="block">/* Number of memory locations currently allocated */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>aMem</name></decl>;</decl_stmt>              <comment type="block">/* The memory locations */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCallback</name></decl>;</decl_stmt>          <comment type="block">/* Number of callbacks invoked so far */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cacheCtr</name></decl>;</decl_stmt>           <comment type="block">/* VdbeCursor row cache generation counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>contextStackTop</name></decl>;</decl_stmt>    <comment type="block">/* Index of top element in the context stack */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>contextStackDepth</name></decl>;</decl_stmt>  <comment type="block">/* The size of the "context" stack */</comment>
  <decl_stmt><decl><type><name>Context</name> *</type><name>contextStack</name></decl>;</decl_stmt>  <comment type="block">/* Stack used by opcodes ContextPush &amp; ContextPop*/</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>                 <comment type="block">/* The program counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                 <comment type="block">/* Value to return */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>uniqueCnt</name></decl>;</decl_stmt>     <comment type="block">/* Used by OP_MakeRecord when P2!=0 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>errorAction</name></decl>;</decl_stmt>        <comment type="block">/* Recovery action to do in case of an error */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>inTempTrans</name></decl>;</decl_stmt>        <comment type="block">/* True if temp database is transactioned */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nResColumn</name></decl>;</decl_stmt>         <comment type="block">/* Number of columns in one row of the result set */</comment>
  <decl_stmt><decl><type><name>char</name> **</type><name>azResColumn</name></decl>;</decl_stmt>     <comment type="block">/* Values for one row of result */</comment> 
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name></decl>;</decl_stmt>          <comment type="block">/* Error message written here */</comment>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pResultSet</name></decl>;</decl_stmt>        <comment type="block">/* Pointer to an array of results */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>explain</name></decl>;</decl_stmt>             <comment type="block">/* True if EXPLAIN present on SQL command */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>changeCntOn</name></decl>;</decl_stmt>         <comment type="block">/* True to update the change-counter */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>expired</name></decl>;</decl_stmt>             <comment type="block">/* True if the VM needs to be recompiled */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>minWriteFileFormat</name></decl>;</decl_stmt>  <comment type="block">/* Minimum file format for writable database files */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>inVtabMethod</name></decl>;</decl_stmt>        <comment type="block">/* See comments above */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>usesStmtJournal</name></decl>;</decl_stmt>     <comment type="block">/* True if uses a statement journal */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>readOnly</name></decl>;</decl_stmt>            <comment type="block">/* True for read-only statements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChange</name></decl>;</decl_stmt>            <comment type="block">/* Number of db changes made since last reset */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>startTime</name></decl>;</decl_stmt>          <comment type="block">/* Time when query started - used for profiling */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>btreeMask</name></decl>;</decl_stmt>          <comment type="block">/* Bitmask of db-&gt;aDb[] entries referenced */</comment>
  <decl_stmt><decl><type><name>BtreeMutexArray</name></type> <name>aMutex</name></decl>;</decl_stmt> <comment type="block">/* An array of Btree used here and needing locks */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>aCounter</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Counters used by sqlite3_stmt_status() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSql</name></decl>;</decl_stmt>             <comment type="block">/* Number of bytes in zSql */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>           <comment type="block">/* Text of the SQL statement that generated this */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>trace</name></decl>;</decl_stmt>          <comment type="block">/* Write an execution trace here, if not NULL */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>openedStatement</name></decl>;</decl_stmt>  <comment type="block">/* True if this VM has opened a statement journal */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SSE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>fetchId</name></decl>;</decl_stmt>          <comment type="block">/* Statement number used by sqlite3_fetch_statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>lru</name></decl>;</decl_stmt>              <comment type="block">/* Counter used for LRU cache replacement */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>pLruPrev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>pLruNext</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** The following are allowed values for Vdbe.magic
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VDBE_MAGIC_INIT</name>     0x26bceaa5</cpp:define>    <comment type="block">/* Building a VDBE program */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VDBE_MAGIC_RUN</name>      0xbdf20da3</cpp:define>    <comment type="block">/* VDBE is ready to execute */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VDBE_MAGIC_HALT</name>     0x519c2973</cpp:define>    <comment type="block">/* VDBE has completed execution */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>VDBE_MAGIC_DEAD</name>     0xb606c3c8</cpp:define>    <comment type="block">/* The VDBE has been deallocated */</comment>

<comment type="block">/*
** Function prototypes
*/</comment>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeFreeCursor</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type></decl></param>, <param><decl><type><name>VdbeCursor</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqliteVdbePopStack</name><parameter_list>(<param><decl><type><name>Vdbe</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeCursorMoveto</name><parameter_list>(<param><decl><type><name>VdbeCursor</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>VDBE_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>sqlite3VdbePrintOp</name><parameter_list>(<param><decl><type><name>FILE</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>Op</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeSerialTypeLen</name><parameter_list>(<param><decl><type><name>u32</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>u32</name></type> <name>sqlite3VdbeSerialType</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeSerialPut</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeSerialGet</name><parameter_list>(<param><decl><type><name>const</name> <name>unsigned</name> <name>char</name>*</type></decl></param>, <param><decl><type><name>u32</name></type></decl></param>, <param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeDeleteAuxData</name><parameter_list>(<param><decl><type><name>VdbeFunc</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>sqlite2BtreeKeyCompare</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type></decl></param>, <param><decl><type><name>const</name> <name>void</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeIdxKeyCompare</name><parameter_list>(<param><decl><type><name>VdbeCursor</name>*</type></decl></param>,<param><decl><type><name>UnpackedRecord</name>*</type></decl></param>,<param><decl><type><name>int</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeIdxRowid</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type></decl></param>, <param><decl><type><name>i64</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3MemCompare</name><parameter_list>(<param><decl><type><name>const</name> <name>Mem</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>Mem</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>CollSeq</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeExec</name><parameter_list>(<param><decl><type><name>Vdbe</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeList</name><parameter_list>(<param><decl><type><name>Vdbe</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeHalt</name><parameter_list>(<param><decl><type><name>Vdbe</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeChangeEncoding</name><parameter_list>(<param><decl><type><name>Mem</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemTooBig</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemCopy</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemShallowCopy</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>Mem</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemMove</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemNulTerminate</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemSetStr</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>const</name> <name>char</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>u8</name></type></decl></param>, <param><function_decl><type><name>void</name></type>(*)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSetInt64</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>i64</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSetDouble</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSetNull</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSetZeroBlob</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSetRowSet</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemMakeWriteable</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemStringify</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>i64</name></type> <name>sqlite3VdbeIntValue</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemIntegerify</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>double</name></type> <name>sqlite3VdbeRealValue</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeIntegerAffinity</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemRealify</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemNumerify</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemFromBtree</name><parameter_list>(<param><decl><type><name>BtCursor</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemRelease</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3VdbeMemReleaseExternal</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemFinalize</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>FuncDef</name>*</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>const</name> <name>char</name> *</type><name>sqlite3OpcodeName</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeOpcodeHasProperty</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemGrow</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>int</name></type> <name>preserve</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMORY_MANAGEMENT</name></cpp:ifdef>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeReleaseBuffers</name><parameter_list>(<param><decl><type><name>Vdbe</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <function_decl><type><name>void</name></type> <name>sqlite3VdbeMemSanity</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemTranslate</name><parameter_list>(<param><decl><type><name>Mem</name>*</type></decl></param>, <param><decl><type><name>u8</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <function_decl><type><name>void</name></type> <name>sqlite3VdbePrintSql</name><parameter_list>(<param><decl><type><name>Vdbe</name>*</type></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>void</name></type> <name>sqlite3VdbeMemPrettyPrint</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zBuf</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type> <name>sqlite3VdbeMemHandleBom</name><parameter_list>(<param><decl><type><name>Mem</name> *</type><name>pMem</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
  <function_decl><type><name>int</name></type> <name>sqlite3VdbeMemExpandBlob</name><parameter_list>(<param><decl><type><name>Mem</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>sqlite3VdbeMemExpandBlob</name>(x) SQLITE_OK</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(_VDBEINT_H_) */</comment>
</unit>
