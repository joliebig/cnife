<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="func.c" filename=""><comment type="block">/*
** 2002 February 23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C functions that implement various SQL
** functions of SQLite.  
**
** There is only one exported symbol in this file - the function
** sqliteRegisterBuildinFunctions() found at the bottom of the file.
** All other code has file scope.
**
** $Id: func.c,v 1.209 2008/12/10 23:04:13 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Return the collating function associated with a function.
*/</comment>
<function><type><name>static</name> <name>CollSeq</name> *</type><name>sqlite3GetFuncCollSeq</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>context</name>-&gt;<name>pColl</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of the non-aggregate min() and max() functions
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>minmaxFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>;</decl_stmt>    <comment type="block">/* 0 for min() or 0xffffffff for max() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>argc</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>mask</name> = <call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>==0 ? 0 : -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mask</name>==-1 || <name>mask</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iBest</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
    <if>if<condition>( <expr>(<call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iBest</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call>^<name>mask</name>)&gt;=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>iBest</name> = <name>i</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>iBest</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the type of the argument.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>typeofFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_NULL</name></expr>:    <expr_stmt><expr><name>z</name> = "null"</expr>;</expr_stmt>    <break>break;</break>
    </case><case>case <expr><name>SQLITE_INTEGER</name></expr>: <expr_stmt><expr><name>z</name> = "integer"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_TEXT</name></expr>:    <expr_stmt><expr><name>z</name> = "text"</expr>;</expr_stmt>    <break>break;</break>
    </case><case>case <expr><name>SQLITE_FLOAT</name></expr>:   <expr_stmt><expr><name>z</name> = "real"</expr>;</expr_stmt>    <break>break;</break>
    </case><case>case <expr><name>SQLITE_BLOB</name></expr>:    <expr_stmt><expr><name>z</name> = "blob"</expr>;</expr_stmt>    <break>break;</break>
  </case>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/*
** Implementation of the length() function
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>lengthFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_BLOB</name></expr>:
    </case><case>case <expr><name>SQLITE_INTEGER</name></expr>:
    </case><case>case <expr><name>SQLITE_FLOAT</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_TEXT</name></expr>: <block>{
      <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>z</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
      <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
      <while>while<condition>( <expr>*<name>z</name></expr> )</condition><block>{
        <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
}</block></function>

<comment type="block">/*
** Implementation of the abs() function
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>absFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_INTEGER</name></expr>: <block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> =<init> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>iVal</name>&lt;0</expr> )</condition><then><block>{
        <if>if<condition>( <expr>(<name>iVal</name>&lt;&lt;1)==0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>"integer overflow"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>iVal</name> = -<name>iVal</name></expr>;</expr_stmt>
      }</block></then></if> 
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_NULL</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><default>default: <block>{
      <decl_stmt><decl><type><name>double</name></type> <name>rVal</name> =<init> <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>rVal</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>rVal</name> = -<name>rVal</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
  </default>}</block></switch>
}</block></function>

<comment type="block">/*
** Implementation of the substr() function.
**
** substr(x,p1,p2)  returns p2 characters of x[] beginning with p1.
** p1 is 1-indexed.  So substr(x,1,1) returns the first character
** of x.  If x is text, then we actually count UTF-8 characters.
** If x is a blob, then we count bytes.
**
** If p1 is negative, then we begin abs(p1) from the end of x[].
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>substrFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p0type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>p1</name>, <name>p2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==3 || <name>argc</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p0type</name> = <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p0type</name>==<name>SQLITE_BLOB</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>len</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name>==<call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
    <for>for(<init><expr><name>z2</name>=<name>z</name></expr>;</init> <condition><expr>*<name>z2</name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></else></if>
  <expr_stmt><expr><name>p1</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>argc</name>==3</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p2</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>p2</name> = <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>p1</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p1</name> += <name>len</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p1</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>p2</name> += <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else <if>if<condition>( <expr><name>p1</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>p1</name>--</expr>;</expr_stmt>
  }</block></then></if></else></if>
  <if>if<condition>( <expr><name>p1</name>+<name>p2</name>&gt;<name>len</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p2</name> = <name>len</name>-<name>p1</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p0type</name>!=<name>SQLITE_BLOB</name></expr> )</condition><then><block>{
    <while>while<condition>( <expr>*<name>z</name> &amp;&amp; <name>p1</name></expr> )</condition><block>{
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name>--</expr>;</expr_stmt>
    }</block></while>
    <for>for(<init><expr><name>z2</name>=<name>z</name></expr>;</init> <condition><expr>*<name>z2</name> &amp;&amp; <name>p2</name></expr>;</condition> <incr><expr><name>p2</name>--</expr></incr>)<block>{
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>z</name></expr></argument>, <argument><expr>(<name>int</name>)(<name>z2</name>-<name>z</name>)</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <if>if<condition>( <expr><name>p2</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>p2</name> = 0</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)&amp;<name><name>z</name><index>[<expr><name>p1</name></expr>]</index></name></expr></argument>, <argument><expr>(<name>int</name>)<name>p2</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Implementation of the round() function
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>roundFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr>500</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* larger than the %f representation of the largest double */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1 || <name>argc</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>argc</name>==2</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>SQLITE_NULL</name>==<call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>n</name>&gt;30</expr> )</condition><then> <expr_stmt><expr><name>n</name> = 30</expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><name>n</name>&lt;0</expr> )</condition><then> <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>r</name> = <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>zBuf</name></expr></argument>,<argument><expr>"%.*f"</expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Allocate nByte bytes of space using sqlite3_malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed.
*/</comment>
<function><type><name>static</name> <name>void</name> *</type><name>contextMalloc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>i64</name></type> <name>nByte</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>nByte</name>&gt;<call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>z</name> = <call><name>sqlite3Malloc</name><argument_list>(<argument><expr>(<name>int</name>)<name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>z</name> &amp;&amp; <name>nByte</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></else></if>
  <return>return <expr><name>z</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Implementation of the upper() and lower() SQL functions.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>upperFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>argc</name>&lt;1 || <name>SQLITE_NULL</name>==<call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>z2</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Verify that the call to _bytes() does not invalidate the _text() pointer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z2</name>==(<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>z1</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>((<name>i64</name>)<name>n</name>)+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z1</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>)<call><name>toupper</name><argument_list>(<argument><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>lowerFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>argc</name>&lt;1 || <name>SQLITE_NULL</name>==<call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>z2</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Verify that the call to _bytes() does not invalidate the _text() pointer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z2</name>==(<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z2</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>z1</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>((<name>i64</name>)<name>n</name>)+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z1</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>)<call><name>tolower</name><argument_list>(<argument><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the IFNULL(), NVL(), and COALESCE() functions.  
** All three do the same thing.  They return the first non-NULL
** argument.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>ifnullFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>SQLITE_NULL</name>!=<call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
  }</block></for>
}</block></function>

<comment type="block">/*
** Implementation of random().  Return a random integer.  
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>randomFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>NotUsed2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>r</name>&lt;&lt;1)==0</expr> )</condition><then> <expr_stmt><expr><name>r</name> = 0</expr>;</expr_stmt></then></if>  <comment type="block">/* Prevent 0x8000.... as the result so that we */</comment>
                          <comment type="block">/* can always do abs() of the result */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of randomblob(N).  Return a random blob
** that is N bytes long.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>randomBlob</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>&lt;1</expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>p</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the last_insert_rowid() SQL function.  The return
** value is the same as the sqlite3_last_insert_rowid() API function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>last_insert_rowid</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>, 
  <param><decl><type><name>sqlite3_value</name> **</type><name>NotUsed2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the changes() SQL function.  The return value is the
** same as the sqlite3_changes() API function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>changes</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>NotUsed2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_changes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the total_changes() SQL function.  The return value is
** the same as the sqlite3_total_changes() API function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>total_changes</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>NotUsed2</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_total_changes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** A structure defining how to do GLOB-style comparisons.
*/</comment>
<struct>struct <name>compareInfo</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>u8</name></type> <name>matchAll</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchOne</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchSet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>noCase</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
** For LIKE and GLOB matching on EBCDIC machines, assume that every
** character is exactly one byte in size.  Also, all characters are
** able to participate in upper-case-to-lower-case mappings in EBCDIC
** whereas only characters less than 0x80 do in ASCII.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_EBCDIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>sqlite3Utf8Read</name>(A,B,C)  (*(A++))</cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <name>GlogUpperToLower</name>(A)     A = sqlite3UpperToLower[A]</cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>GlogUpperToLower</name>(A)     if( A&lt;0x80 ){ A = sqlite3UpperToLower[A]; }</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>static</name> <name>const</name> struct <name>compareInfo</name></type> <name>globInfo</name> =<init> <expr><block>{ <expr>'*'</expr>, <expr>'?'</expr>, <expr>'['</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* The correct SQL-92 behavior is for the LIKE operator to ignore
** case.  Thus  'a' LIKE 'A' would be true. */</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> struct <name>compareInfo</name></type> <name>likeInfoNorm</name> =<init> <expr><block>{ <expr>'%'</expr>, <expr>'_'</expr>,   <expr>0</expr>, <expr>1</expr> }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator
** is case sensitive causing 'a' LIKE 'A' to be false */</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> struct <name>compareInfo</name></type> <name>likeInfoAlt</name> =<init> <expr><block>{ <expr>'%'</expr>, <expr>'_'</expr>,   <expr>0</expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Compare two UTF-8 strings for equality where the first string can
** potentially be a "glob" expression.  Return true (1) if they
** are the same and false (0) if they are different.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
** With the [...] and [^...] matching, a ']' character can be included
** in the list by making it the first character after '[' or '^'.  A
** range of characters can be specified using '-'.  Example:
** "[a-z]" matches any single lower-case letter.  To match a '-', make
** it the last character in the list.
**
** This routine is usually quick, but can be N**2 in the worst case.
**
** Hints: to match '*' or '?', put them in "[]".  Like this:
**
**         abc[*]xyz        Matches "abc*xyz" only
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>patternCompare</name><parameter_list>(
  <param><decl><type><name>const</name> <name>u8</name> *</type><name>zPattern</name></decl></param>,              <comment type="block">/* The glob pattern */</comment>
  <param><decl><type><name>const</name> <name>u8</name> *</type><name>zString</name></decl></param>,               <comment type="block">/* The string to compare against the glob */</comment>
  <param><decl><type><name>const</name> struct <name>compareInfo</name> *</type><name>pInfo</name></decl></param>, <comment type="block">/* Information about how to do the compare */</comment>
  <param><decl><type><name>const</name> <name>int</name></type> <name>esc</name></decl></param>                    <comment type="block">/* The escape character */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>c</name>, <name>c2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>invert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>seen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchOne</name> =<init> <expr><name>pInfo</name>-&gt;<name>matchOne</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchAll</name> =<init> <expr><name>pInfo</name>-&gt;<name>matchAll</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchSet</name> =<init> <expr><name>pInfo</name>-&gt;<name>matchSet</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>noCase</name> =<init> <expr><name>pInfo</name>-&gt;<name>noCase</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>int</name></type> <name>prevEscape</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* True if the previous character was 'escape' */</comment>

  <while>while<condition>( <expr>(<name>c</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><block>{
    <if>if<condition>( <expr>!<name>prevEscape</name> &amp;&amp; <name>c</name>==<name>matchAll</name></expr> )</condition><then><block>{
      <while>while<condition>( <expr>(<name>c</name>=<call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call>) == <name>matchAll</name>
               || <name>c</name> == <name>matchOne</name></expr> )</condition><block>{
        <if>if<condition>( <expr><name>c</name>==<name>matchOne</name> &amp;&amp; <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
          <return>return <expr>0</expr>;</return>
        }</block></then></if>
      }</block></while>
      <if>if<condition>( <expr><name>c</name>==0</expr> )</condition><then><block>{
        <return>return <expr>1</expr>;</return>
      }</block></then><else>else <if>if<condition>( <expr><name>c</name>==<name>esc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>c</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>c</name>==0</expr> )</condition><then><block>{
          <return>return <expr>0</expr>;</return>
        }</block></then></if>
      }</block></then><else>else <if>if<condition>( <expr><name>c</name>==<name>matchSet</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>esc</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* This is GLOB, not LIKE */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>matchSet</name>&lt;0x80</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* '[' is a single-byte character */</comment>
        <while>while<condition>( <expr>*<name>zString</name> &amp;&amp; <call><name>patternCompare</name><argument_list>(<argument><expr>&amp;<name><name>zPattern</name><index>[<expr>-1</expr>]</index></name></expr></argument>,<argument><expr><name>zString</name></expr></argument>,<argument><expr><name>pInfo</name></expr></argument>,<argument><expr><name>esc</name></expr></argument>)</argument_list></call>==0</expr> )</condition><block>{
          <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr>*<name>zString</name>!=0</expr>;</return>
      }</block></then></if></else></if></else></if>
      <while>while<condition>( <expr>(<name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><block>{
        <if>if<condition>( <expr><name>noCase</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>GlogUpperToLower</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>GlogUpperToLower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while<condition>( <expr><name>c2</name> != 0 &amp;&amp; <name>c2</name> != <name>c</name></expr> )</condition><block>{
            <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GlogUpperToLower</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></while>
        }</block></then><else>else<block>{
          <while>while<condition>( <expr><name>c2</name> != 0 &amp;&amp; <name>c2</name> != <name>c</name></expr> )</condition><block>{
            <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></while>
        }</block></else></if>
        <if>if<condition>( <expr><name>c2</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
        <if>if<condition>( <expr><call><name>patternCompare</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><name>zString</name></expr></argument>,<argument><expr><name>pInfo</name></expr></argument>,<argument><expr><name>esc</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>1</expr>;</return></then></if>
      }</block></while>
      <return>return <expr>0</expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr>!<name>prevEscape</name> &amp;&amp; <name>c</name>==<name>matchOne</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>==<name>matchSet</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>prior_c</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>esc</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* This only occurs for GLOB, not LIKE */</comment>
      <expr_stmt><expr><name>seen</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>invert</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
      <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>c2</name>=='^'</expr> )</condition><then><block>{
        <expr_stmt><expr><name>invert</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>c2</name>==']'</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>c</name>==']'</expr> )</condition><then> <expr_stmt><expr><name>seen</name> = 1</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <while>while<condition>( <expr><name>c2</name> &amp;&amp; <name>c2</name>!=']'</expr> )</condition><block>{
        <if>if<condition>( <expr><name>c2</name>=='-' &amp;&amp; <name><name>zPattern</name><index>[<expr>0</expr>]</index></name>!=']' &amp;&amp; <name><name>zPattern</name><index>[<expr>0</expr>]</index></name>!=0 &amp;&amp; <name>prior_c</name>&gt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>c</name>&gt;=<name>prior_c</name> &amp;&amp; <name>c</name>&lt;=<name>c2</name></expr> )</condition><then> <expr_stmt><expr><name>seen</name> = 1</expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>prior_c</name> = 0</expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <if>if<condition>( <expr><name>c</name>==<name>c2</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>seen</name> = 1</expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name>prior_c</name> = <name>c2</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <if>if<condition>( <expr><name>c2</name>==0 || (<name>seen</name> ^ <name>invert</name>)==0</expr> )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>esc</name>==<name>c</name> &amp;&amp; !<name>prevEscape</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>prevEscape</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>c2</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>noCase</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>GlogUpperToLower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GlogUpperToLower</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>c</name>!=<name>c2</name></expr> )</condition><then><block>{
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>prevEscape</name> = 0</expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if>
  }</block></while>
  <return>return <expr>*<name>zString</name>==0</expr>;</return>
}</block></function>

<comment type="block">/*
** Count the number of times that the LIKE operator (or GLOB which is
** just a variation of LIKE) gets called.  This is used for testing
** only.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_like_count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Implementation of the like() SQL function.  This function implements
** the build-in LIKE operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A LIKE B
**
** is implemented as like(B,A).
**
** This same function (with a different compareInfo structure) computes
** the GLOB operator.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>likeFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, 
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zA</name>, *<name>zB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>escape</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zB</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zA</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Limit the length of the LIKE or GLOB pattern to avoid problems
  ** of deep recursion and N*N behavior in patternCompare().
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> &gt;
        <name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>"LIKE or GLOB pattern too complex"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zB</name>==<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Encoding did not change */</comment>

  <if>if<condition>( <expr><name>argc</name>==3</expr> )</condition><then><block>{
    <comment type="block">/* The escape character string must consist of a single UTF-8 character.
    ** Otherwise, return an error.
    */</comment>
    <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zEsc</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>zEsc</name>==0</expr> )</condition><then> <return>return;</return></then></if>
    <if>if<condition>( <expr><call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr>(<name>char</name>*)<name>zEsc</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call>!=1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, 
          <argument><expr>"ESCAPE expression must be a single character"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>escape</name> = <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><name>zEsc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>zEsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>zA</name> &amp;&amp; <name>zB</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>compareInfo</name> *</type><name>pInfo</name> =<init> <expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_like_count</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>patternCompare</name><argument_list>(<argument><expr><name>zB</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>escape</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the NULLIF(x,y) function.  The result is the first
** argument if the arguments are different.  The result is NULL if the
** arguments are equal to each other.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>nullifFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr><call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Implementation of the VERSION(*) function.  The result is the version
** of the SQLite library that is running.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>versionFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>NotUsed2</name></decl></param>
)</parameter_list><block>{
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>sqlite3_version</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Array for converting from half-bytes (nybbles) into ASCII hex
** digits. */</comment>
<decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name></type> <name><name>hexdigits</name><index>[]</index></name> =<init> <expr><block>{
  <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>,
  <expr>'8'</expr>, <expr>'9'</expr>, <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr> 
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** EXPERIMENTAL - This is not an official function.  The interface may
** change.  This function may disappear.  Do not write code that depends
** on this function.
**
** Implementation of the QUOTE() function.  This function takes a single
** argument.  If the argument is numeric, the return value is the same as
** the argument.  If the argument is NULL, the return value is the string
** "NULL".  Otherwise, the argument is enclosed in single quotes with
** single-quote escapes.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>quoteFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>argc</name>&lt;1</expr> )</condition><then> <return>return;</return></then></if>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_NULL</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>"NULL"</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_INTEGER</name></expr>:
    </case><case>case <expr><name>SQLITE_FLOAT</name></expr>: <block>{
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_BLOB</name></expr>: <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zText</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zBlob</name> =<init> <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> =<init> <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zBlob</name>==<call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* No encoding change */</comment>
      <expr_stmt><expr><name>zText</name> = (<name>char</name> *)<call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(2*(<name>i64</name>)<name>nBlob</name>)+4</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if>if<condition>( <expr><name>zText</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nBlob</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name><name>zText</name><index>[<expr>(<name>i</name>*2)+2</expr>]</index></name> = <name><name>hexdigits</name><index>[<expr>(<name><name>zBlob</name><index>[<expr><name>i</name></expr>]</index></name>&gt;&gt;4)&amp;0x0F</expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zText</name><index>[<expr>(<name>i</name>*2)+3</expr>]</index></name> = <name><name>hexdigits</name><index>[<expr>(<name><name>zBlob</name><index>[<expr><name>i</name></expr>]</index></name>)&amp;0x0F</expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name><name>zText</name><index>[<expr>(<name>nBlob</name>*2)+2</expr>]</index></name> = '\''</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr>(<name>nBlob</name>*2)+3</expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr>0</expr>]</index></name> = 'X'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr>1</expr>]</index></name> = '\''</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    }</block>
    </case><case>case <expr><name>SQLITE_TEXT</name></expr>: <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name>,<name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zArg</name> =<init> <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>

      <if>if<condition>( <expr><name>zArg</name>==0</expr> )</condition><then> <return>return;</return></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>n</name>=0</expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ <if>if<condition>( <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then> <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if> }</block></for>
      <expr_stmt><expr><name>z</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>((<name>i64</name>)<name>i</name>)+((<name>i64</name>)<name>n</name>)+3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>z</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name><name>z</name><index>[<expr>0</expr>]</index></name> = '\''</expr>;</expr_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>j</name>=1</expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name>=='\''</expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = '\''</expr>;</expr_stmt>
          }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name>++</expr>]</index></name> = '\''</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block>
  </case>}</block></switch>
}</block></function>

<comment type="block">/*
** The hex() function.  Interpret the argument as a blob.  Return
** a hexadecimal rendering as text.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>hexFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zHex</name>, *<name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> = <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBlob</name>==<call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>z</name> = <name>zHex</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>((<name>i64</name>)<name>n</name>)*2 + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zHex</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pBlob</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> =<init> <expr>*<name>pBlob</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*(<name>z</name>++) = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;4)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr>*(<name>z</name>++) = <name><name>hexdigits</name><index>[<expr><name>c</name>&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr>*<name>z</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zHex</name></expr></argument>, <argument><expr><name>n</name>*2</expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** The zeroblob(N) function returns a zero-filled blob of size N bytes.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>zeroblobFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>&gt;<name>SQLITE_MAX_LENGTH</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_result_zeroblob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** The replace() function.  Three arguments are all strings: call
** them A, B, and C. The result is also a string which is derived
** from A by replacing every occurance of B with C.  The match
** must be exact.  Collating sequences are not used.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>replaceFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zStr</name></decl>;</decl_stmt>        <comment type="block">/* The input string A */</comment>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zPattern</name></decl>;</decl_stmt>    <comment type="block">/* The pattern string B */</comment>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zRep</name></decl>;</decl_stmt>        <comment type="block">/* The replacement string C */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>zOut</name></decl>;</decl_stmt>              <comment type="block">/* The output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name></decl>;</decl_stmt>                <comment type="block">/* Size of zStr */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name></decl>;</decl_stmt>            <comment type="block">/* Size of zPattern */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRep</name></decl>;</decl_stmt>                <comment type="block">/* Size of zRep */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nOut</name></decl>;</decl_stmt>                <comment type="block">/* Maximum size of zOut */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>loopLimit</name></decl>;</decl_stmt>           <comment type="block">/* Last zStr[] that might match zPattern[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                <comment type="block">/* Loop counters */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==3</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zStr</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zStr</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>nStr</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zStr</name>==<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>zPattern</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zPattern</name>==0 || <name><name>zPattern</name><index>[<expr>0</expr>]</index></name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>nPattern</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zPattern</name>==<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>zRep</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zRep</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>nRep</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zRep</name>==<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOut</name> = <name>nStr</name> + 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOut</name>&lt;<name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>i64</name>)<name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zOut</name>==0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>loopLimit</name> = <name>nStr</name> - <name>nPattern</name></expr>;</expr_stmt>  
  <for>for(<init><expr><name>i</name>=<name>j</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;=<name>loopLimit</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name>!=<name><name>zPattern</name><index>[<expr>0</expr>]</index></name> || <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>nPattern</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>u8</name> *</type><name>zOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nOut</name> += <name>nRep</name> - <name>nPattern</name></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nOut</name>&gt;=<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><name>zOld</name> = <name>zOut</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zOut</name> = <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zOut</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>zRep</name></expr></argument>, <argument><expr><name>nRep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> += <name>nRep</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> += <name>nPattern</name>-1</expr>;</expr_stmt>
    }</block></else></if>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>+<name>nStr</name>-<name>i</name>+1==<name>nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nStr</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> += <name>nStr</name> - <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name>&lt;=<name>nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>zOut</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Implementation of the TRIM(), LTRIM(), and RTRIM() functions.
** The userdata is 0x1 for left trim, 0x2 for right trim, 0x3 for both.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>trimFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zIn</name></decl>;</decl_stmt>         <comment type="block">/* Input string */</comment>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zCharSet</name></decl>;</decl_stmt>    <comment type="block">/* Set of characters to trim */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name></decl>;</decl_stmt>                          <comment type="block">/* Number of bytes in input */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                        <comment type="block">/* 1: trimleft  2: trimright  3: trim */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>aLen</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>          <comment type="block">/* Length of each character in zCharSet */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> **</type><name>azChar</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>       <comment type="block">/* Individual characters in zCharSet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChar</name></decl>;</decl_stmt>                        <comment type="block">/* Number of characters in zCharSet */</comment>

  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>zIn</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zIn</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>nIn</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zIn</name>==<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>argc</name>==1</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>lenOne</name><index>[]</index></name> =<init> <expr><block>{ <expr>1</expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>unsigned</name> <name>char</name> * <name>const</name></type> <name><name>azOne</name><index>[]</index></name> =<init> <expr><block>{ <expr>(<name>u8</name>*)" "</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nChar</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>aLen</name> = (<name>u8</name>*)<name>lenOne</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>azChar</name> = (<name>unsigned</name> <name>char</name> **)<name>azOne</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCharSet</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr>(<name>zCharSet</name> = <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>)==0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>z</name>=<name>zCharSet</name></expr>, <expr><name>nChar</name>=0</expr>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>nChar</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr><name>nChar</name>&gt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>azChar</name> = <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>((<name>i64</name>)<name>nChar</name>)*(<call><name>sizeof</name><argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></call>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>azChar</name>==0</expr> )</condition><then><block>{
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><name>aLen</name> = (<name>unsigned</name> <name>char</name>*)&amp;<name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name></expr>;</expr_stmt>
      <for>for(<init><expr><name>z</name>=<name>zCharSet</name></expr>, <expr><name>nChar</name>=0</expr>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>nChar</name>++</expr></incr>)<block>{
        <expr_stmt><expr><name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name> = (<name>unsigned</name> <name>char</name> *)<name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aLen</name><index>[<expr><name>nChar</name></expr>]</index></name> = (<name>u8</name>)(<name>z</name> - <name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name>)</expr>;</expr_stmt>
      }</block></for>
    }</block></then></if>
  }</block></else></if></else></if>
  <if>if<condition>( <expr><name>nChar</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>flags</name> = <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>flags</name> &amp; 1</expr> )</condition><then><block>{
      <while>while<condition>( <expr><name>nIn</name>&gt;0</expr> )</condition><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nChar</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name>len</name> = <name><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name><name>azChar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <break>break;</break></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>i</name>&gt;=<name>nChar</name></expr> )</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><name>zIn</name> += <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nIn</name> -= <name>len</name></expr>;</expr_stmt>
      }</block></while>
    }</block></then></if>
    <if>if<condition>( <expr><name>flags</name> &amp; 2</expr> )</condition><then><block>{
      <while>while<condition>( <expr><name>nIn</name>&gt;0</expr> )</condition><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nChar</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name>len</name> = <name><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>len</name>&lt;=<name>nIn</name> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>zIn</name><index>[<expr><name>nIn</name>-<name>len</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>azChar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <break>break;</break></then></if>
        }</block></for>
        <if>if<condition>( <expr><name>i</name>&gt;=<name>nChar</name></expr> )</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><name>nIn</name> -= <name>len</name></expr>;</expr_stmt>
      }</block></while>
    }</block></then></if>
    <if>if<condition>( <expr><name>zCharSet</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SOUNDEX</name></cpp:ifdef>
<comment type="block">/*
** Compute the soundex encoding of a word.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>soundexFunc</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>zResult</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>u8</name> *</type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>unsigned</name> <name>char</name></type> <name><name>iCode</name><index>[]</index></name> =<init> <expr><block>{
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>0</expr>, <expr>0</expr>, <expr>2</expr>, <expr>2</expr>, <expr>4</expr>, <expr>5</expr>, <expr>5</expr>, <expr>0</expr>,
    <expr>1</expr>, <expr>2</expr>, <expr>6</expr>, <expr>2</expr>, <expr>3</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>2</expr>, <expr>0</expr>, <expr>2</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
    <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>0</expr>, <expr>0</expr>, <expr>2</expr>, <expr>2</expr>, <expr>4</expr>, <expr>5</expr>, <expr>5</expr>, <expr>0</expr>,
    <expr>1</expr>, <expr>2</expr>, <expr>6</expr>, <expr>2</expr>, <expr>3</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>2</expr>, <expr>0</expr>, <expr>2</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zIn</name> = (<name>u8</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zIn</name>==0</expr> )</condition><then> <expr_stmt><expr><name>zIn</name> = (<name>u8</name>*)""</expr>;</expr_stmt></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{}</block></for>
  <if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>u8</name></type> <name>prevcode</name> =<init> <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0x7f</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zResult</name><index>[<expr>0</expr>]</index></name> = <call><name>toupper</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>j</name>=1</expr>;</init> <condition><expr><name>j</name>&lt;4 &amp;&amp; <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0x7f</expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>code</name>&gt;0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>code</name>!=<name>prevcode</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>prevcode</name> = <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name>++</expr>]</index></name> = <name>code</name> + '0'</expr>;</expr_stmt>
        }</block></then></if>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>prevcode</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <while>while<condition>( <expr><name>j</name>&lt;4</expr> )</condition><block>{
      <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name>++</expr>]</index></name> = '0'</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>"?000"</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** A function that loads a shared-library extension then returns NULL.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>loadExt</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFile</name> =<init> <expr>(<name>const</name> <name>char</name> *)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zProc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>argc</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><name>zProc</name> = (<name>const</name> <name>char</name> *)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zProc</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <if>if<condition>( <expr><name>zFile</name> &amp;&amp; <call><name>sqlite3_load_extension</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zProc</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** An instance of the following structure holds the context of a
** sum() or avg() aggregate computation.
*/</comment>
<typedef>typedef <type><struct>struct <name>SumCtx</name> SumCtx;</struct></type></typedef>
<struct>struct <name>SumCtx</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>double</name></type> <name>rSum</name></decl>;</decl_stmt>      <comment type="block">/* Floating point sum */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iSum</name></decl>;</decl_stmt>         <comment type="block">/* Integer sum */</comment>   
  <decl_stmt><decl><type><name>i64</name></type> <name>cnt</name></decl>;</decl_stmt>          <comment type="block">/* Number of elements summed */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>overflow</name></decl>;</decl_stmt>      <comment type="block">/* True if integer overflow seen */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>approx</name></decl>;</decl_stmt>        <comment type="block">/* True if non-integer value was input to the sum */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Routines used to compute the sum, average, and total.
**
** The SUM() function follows the (broken) SQL standard which means
** that it returns NULL if it sums over no inputs.  TOTAL returns
** 0.0 in that case.  In addition, TOTAL always returns a float where
** SUM might return an integer if it never encounters a floating point
** value.  TOTAL never fails, but SUM might through an exception if
** it overflows an integer.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sumStep</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SumCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>type</name> = <call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>type</name>!=<name>SQLITE_NULL</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>cnt</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>type</name>==<name>SQLITE_INTEGER</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>i64</name></type> <name>v</name> =<init> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>rSum</name> += <name>v</name></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>p</name>-&gt;<name>approx</name>|<name>p</name>-&gt;<name>overflow</name>)==0</expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>i64</name></type> <name>iNewSum</name> =<init> <expr><name>p</name>-&gt;<name>iSum</name> + <name>v</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>s1</name> =<init> <expr>(<name>int</name>)(<name>p</name>-&gt;<name>iSum</name> &gt;&gt; (<call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call>*8-1))</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>s2</name> =<init> <expr>(<name>int</name>)(<name>v</name>       &gt;&gt; (<call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call>*8-1))</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>s3</name> =<init> <expr>(<name>int</name>)(<name>iNewSum</name> &gt;&gt; (<call><name>sizeof</name><argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></call>*8-1))</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>overflow</name> = ((<name>s1</name>&amp;<name>s2</name>&amp;~<name>s3</name>) | (~<name>s1</name>&amp;~<name>s2</name>&amp;<name>s3</name>))?1:0</expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>iSum</name> = <name>iNewSum</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>rSum</name> += <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>approx</name> = 1</expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>sumFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SumCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>cnt</name>&gt;0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>p</name>-&gt;<name>overflow</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr>"integer overflow"</expr></argument>,<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>p</name>-&gt;<name>approx</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>rSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>avgFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SumCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>cnt</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>rSum</name>/(<name>double</name>)<name>p</name>-&gt;<name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>totalFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SumCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name> ? <name>p</name>-&gt;<name>rSum</name> : 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The following structure keeps track of state information for the
** count() aggregate function.
*/</comment>
<typedef>typedef <type><struct>struct <name>CountCtx</name> CountCtx;</struct></type></typedef>
<struct>struct <name>CountCtx</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<comment type="block">/*
** Routines to implement the count() aggregate function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>countStep</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CountCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>argc</name>==0 || <name>SQLITE_NULL</name>!=<call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp; <name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>n</name>++</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>   
<function><type><name>static</name> <name>void</name></type> <name>countFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CountCtx</name> *</type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>p</name> ? <name>p</name>-&gt;<name>n</name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Routines to implement min() and max() aggregate functions.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>minmaxStep</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>NotUsed</name></decl></param>, 
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pArg</name>  =<init> <expr>(<name>Mem</name> *)<name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> *</type><name>pBest</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pBest</name> = (<name>Mem</name> *)<call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pBest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pBest</name></expr> )</condition><then> <return>return;</return></then></if>

  <if>if<condition>( <expr><name>pBest</name>-&gt;<name>flags</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name> =<init> <expr><call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* This step function is used for both the min() and max() aggregates,
    ** the only difference between the two being that the sense of the
    ** comparison is inverted. For the max() aggregate, the
    ** sqlite3_user_data() function returns (void *)-1. For min() it
    ** returns (void *)db, where db is the sqlite3* database pointer.
    ** Therefore the next statement sets variable 'max' to 1 for the max()
    ** aggregate, or 0 for min().
    */</comment>
    <expr_stmt><expr><name>max</name> = <call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>!=0</expr>;</expr_stmt>
    <expr_stmt><expr><name>cmp</name> = <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>max</name> &amp;&amp; <name>cmp</name>&lt;0) || (!<name>max</name> &amp;&amp; <name>cmp</name>&gt;0)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>minMaxFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pRes</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pRes</name> = (<name>sqlite3_value</name> *)<call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pRes</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pRes</name>-&gt;<name>flags</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** group_concat(EXPR, ?SEPARATOR?)
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>groupConcatStep</name><parameter_list>(
  <param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>argc</name></decl></param>,
  <param><decl><type><name>sqlite3_value</name> **</type><name>argv</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name> *</type><name>pAccum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name>, <name>nSep</name>, <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>argc</name>==0 || <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>==<name>SQLITE_NULL</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pAccum</name> = (<name>StrAccum</name>*)<call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pAccum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pAccum</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pAccum</name>-&gt;<name>useMalloc</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pAccum</name>-&gt;<name>mxAlloc</name> = <name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pAccum</name>-&gt;<name>nChar</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>argc</name>&gt;1</expr> )</condition><then><block>{
        <expr_stmt><expr><name>zSep</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSep</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zSep</name> = ","</expr>;</expr_stmt>
        <expr_stmt><expr><name>nSep</name> = 1</expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>nSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
    <do>do<block>{
      <expr_stmt><expr><name>zVal</name> = (<name>char</name>*)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nVal</name> = <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block>while<condition>( <expr><name>i</name>&lt;<name>argc</name>-1</expr> )</condition>;</do>
  }</block></then></if>
}</block></function>
<function><type><name>static</name> <name>void</name></type> <name>groupConcatFinalize</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>StrAccum</name> *</type><name>pAccum</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pAccum</name> = <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pAccum</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pAccum</name>-&gt;<name>tooBig</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pAccum</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{    
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>, 
                          <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** This function registered all of the above C functions as SQL
** functions.  This should be the only routine in this file with
** external linkage.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterBuiltinFunctions</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3AlterFunctions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"MATCH"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_NOMEM</name> || <name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_NOMEM</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SSE</name></cpp:ifdef>
  <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SseFunctions</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Set the LIKEOPT flag on the 2-argument function with the given name.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>setLikeOptFlag</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, <param><decl><type><name>u8</name></type> <name>flagVal</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pDef</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pDef</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pDef</name>-&gt;<name>flags</name> = <name>flagVal</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Register the built-in LIKE and GLOB functions.  The caseSensitive
** parameter determines whether or not the LIKE operator is case
** sensitive.  GLOB is always case sensitive.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterLikeFunctions</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>caseSensitive</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>compareInfo</name> *</type><name>pInfo</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>caseSensitive</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pInfo</name> = (struct <name>compareInfo</name>*)&amp;<name>likeInfoAlt</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pInfo</name> = (struct <name>compareInfo</name>*)&amp;<name>likeInfoNorm</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"like"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"like"</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"glob"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, 
      <argument><expr>(struct <name>compareInfo</name>*)&amp;<name>globInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setLikeOptFlag</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"glob"</expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name> | <name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setLikeOptFlag</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"like"</expr></argument>, 
      <argument><expr><name>caseSensitive</name> ? (<name>SQLITE_FUNC_LIKE</name> | <name>SQLITE_FUNC_CASE</name>) : <name>SQLITE_FUNC_LIKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** pExpr points to an expression which implements a function.  If
** it is appropriate to apply the LIKE optimization to that function
** then set aWc[0] through aWc[2] to the wildcard characters and
** return TRUE.  If the function is not a LIKE-style function then
** return FALSE.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsLikeFunction</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pIsNocase</name></decl></param>, <param><decl><type><name>char</name> *</type><name>aWc</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_FUNCTION</name> || !<name>pExpr</name>-&gt;<name>pList</name></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>pList</name>-&gt;<name>nExpr</name>!=2</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pDef</name> = <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pExpr</name>-&gt;<name>token</name>.<name>z</name></expr></argument>, <argument><expr><name>pExpr</name>-&gt;<name>token</name>.<name>n</name></expr></argument>, <argument><expr>2</expr></argument>,
                             <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pDef</name>==0 || (<name>pDef</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_LIKE</name>)==0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <comment type="block">/* The memcpy() statement assumes that the wildcard characters are
  ** the first three statements in the compareInfo structure.  The
  ** asserts() that follow verify that assumption
  */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aWc</name></expr></argument>, <argument><expr><name>pDef</name>-&gt;<name>pUserData</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>char</name>*)&amp;<name>likeInfoAlt</name> == (<name>char</name>*)&amp;<name>likeInfoAlt</name>.<name>matchAll</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>&amp;((<name>char</name>*)&amp;<name>likeInfoAlt</name>)[1] == (<name>char</name>*)&amp;<name>likeInfoAlt</name>.<name>matchOne</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>&amp;((<name>char</name>*)&amp;<name>likeInfoAlt</name>)[2] == (<name>char</name>*)&amp;<name>likeInfoAlt</name>.<name>matchSet</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pIsNocase</name> = (<name>pDef</name>-&gt;<name>flags</name> &amp; <name>SQLITE_FUNC_CASE</name>)==0</expr>;</expr_stmt>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** All all of the FuncDef structures in the aBuiltinFunc[] array above
** to the global function hash table.  This occurs at start-time (as
** a consequence of calling sqlite3_initialize()).
**
** After this routine runs
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterGlobalFunctions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list><block>{
  <comment type="block">/*
  ** The following array holds FuncDef structures for all of the functions
  ** defined in this file.
  **
  ** The array cannot be constant since changes are made to the
  ** FuncDef.pHash elements at start-time.  The elements of this array
  ** are read-only after initialization is complete.
  */</comment>
  <decl_stmt><decl><type><name>static</name> <name>SQLITE_WSD</name> <name>FuncDef</name></type> <name><name>aBuiltinFunc</name><index>[]</index></name> =<init> <expr><block>{
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>ltrim</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>ltrim</name></expr></argument>,              <argument><expr>2</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>rtrim</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>rtrim</name></expr></argument>,              <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>trim</name></expr></argument>,               <argument><expr>1</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>trim</name></expr></argument>,               <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>min</name></expr></argument>,               <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>minmaxFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>min</name></expr></argument>,                <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>min</name></expr></argument>,               <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>minmaxStep</name></expr></argument>,      <argument><expr><name>minMaxFinalize</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>max</name></expr></argument>,               <argument><expr>-1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>minmaxFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>max</name></expr></argument>,                <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>max</name></expr></argument>,               <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>minmaxStep</name></expr></argument>,      <argument><expr><name>minMaxFinalize</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>typeof</name></expr></argument>,             <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>typeofFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>length</name></expr></argument>,             <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>lengthFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>substr</name></expr></argument>,             <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>substrFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>substr</name></expr></argument>,             <argument><expr>3</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>substrFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>abs</name></expr></argument>,                <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>absFunc</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>round</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>roundFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>round</name></expr></argument>,              <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>roundFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>upper</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>upperFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>lower</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>lowerFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,           <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,          <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ifnullFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,           <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>hex</name></expr></argument>,                <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>hexFunc</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>ifnull</name></expr></argument>,             <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>ifnullFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>random</name></expr></argument>,            <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>randomFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>randomblob</name></expr></argument>,         <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>randomBlob</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>nullif</name></expr></argument>,             <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>nullifFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_version</name></expr></argument>,     <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>versionFunc</name></expr></argument>      )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>quote</name></expr></argument>,              <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>quoteFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>last_insert_rowid</name></expr></argument>,  <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>last_insert_rowid</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>changes</name></expr></argument>,            <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>changes</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>total_changes</name></expr></argument>,      <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>total_changes</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>replace</name></expr></argument>,            <argument><expr>3</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>replaceFunc</name></expr></argument>      )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>zeroblob</name></expr></argument>,           <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zeroblobFunc</name></expr></argument>     )</argument_list></call></expr>,
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SOUNDEX</name></cpp:ifdef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>soundex</name></expr></argument>,            <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>soundexFunc</name></expr></argument>      )</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>load_extension</name></expr></argument>,     <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>loadExt</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>load_extension</name></expr></argument>,     <argument><expr>2</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>loadExt</name></expr></argument>          )</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>sum</name></expr></argument>,               <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>sumFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>total</name></expr></argument>,             <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>totalFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>avg</name></expr></argument>,               <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>avgFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>count</name></expr></argument>,             <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>countStep</name></expr></argument>,       <argument><expr><name>countFinalize</name></expr></argument>  )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>count</name></expr></argument>,             <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>countStep</name></expr></argument>,       <argument><expr><name>countFinalize</name></expr></argument>  )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>group_concat</name></expr></argument>,     <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>groupConcatStep</name></expr></argument>, <argument><expr><name>groupConcatFinalize</name></expr></argument>)</argument_list></call></expr>,
  
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>globInfo</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name>|<name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CASE_SENSITIVE_LIKE</name></cpp:ifdef>
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>likeInfoAlt</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name>|<name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>likeInfoAlt</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name>|<name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>likeInfoNorm</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>&amp;<name>likeInfoNorm</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDefHash</name> *</type><name>pHash</name> =<init> <expr>&amp;<call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDefHash</name></expr></argument>, <argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>aFunc</name> =<init> <expr>(<name>FuncDef</name>*)&amp;<call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDef</name></expr></argument>, <argument><expr><name>aBuiltinFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<call><name>ArraySize</name><argument_list>(<argument><expr><name>aBuiltinFunc</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3FuncDefInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr>&amp;<name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3RegisterDateTimeFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
