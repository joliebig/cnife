<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="build.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the SQLite parser
** when syntax rules are reduced.  The routines in this file handle the
** following kinds of SQL syntax:
**
**     CREATE TABLE
**     DROP TABLE
**     CREATE INDEX
**     DROP INDEX
**     creating ID lists
**     BEGIN TRANSACTION
**     COMMIT
**     ROLLBACK
**
** $Id: build.c,v 1.511 2008/12/30 06:24:58 danielk1977 Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** This routine is called when a new SQL statement is beginning to
** be parsed.  Initialize the pParse structure as needed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginParse</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>explainFlag</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pParse</name>-&gt;<name>explain</name> = (<name>u8</name>)<name>explainFlag</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nVar</name> = 0</expr>;</expr_stmt>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
<comment type="block">/*
** The TableLock structure is only used by the sqlite3TableLock() and
** codeTableLocks() functions.
*/</comment>
<struct>struct <name>TableLock</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>             <comment type="block">/* The database containing the table to be locked */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name></decl>;</decl_stmt>            <comment type="block">/* The root page of the table to be locked */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>isWriteLock</name></decl>;</decl_stmt>      <comment type="block">/* True for write lock.  False for a read lock */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl>;</decl_stmt>   <comment type="block">/* Name of the table */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Record the fact that we want to lock a table at run-time.  
**
** The table to be locked has root page iTab and is found in database iDb.
** A read or a write lock can be taken depending on isWritelock.
**
** This routine just records the fact that the lock is desired.  The
** code to make the lock occur is generated by a later call to
** codeTableLocks() which occurs during sqlite3FinishCoding().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3TableLock</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>,           <comment type="block">/* Index of the database containing the table to lock */</comment>
  <param><decl><type><name>int</name></type> <name>iTab</name></decl></param>,          <comment type="block">/* Root page number of the table to be locked */</comment>
  <param><decl><type><name>u8</name></type> <name>isWriteLock</name></decl></param>,    <comment type="block">/* True for a write lock */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>  <comment type="block">/* Name of the table to be locked */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TableLock</name> *</type><name>p</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nTableLock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>p</name> = &amp;<name>pParse</name>-&gt;<name><name>aTableLock</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>iDb</name>==<name>iDb</name> &amp;&amp; <name>p</name>-&gt;<name>iTab</name>==<name>iTab</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name>-&gt;<name>isWriteLock</name> = (<name>p</name>-&gt;<name>isWriteLock</name> || <name>isWriteLock</name>)</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></for>

  <expr_stmt><expr><name>nBytes</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>TableLock</name></expr></argument>)</argument_list></call> * (<name>pParse</name>-&gt;<name>nTableLock</name>+1)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>aTableLock</name> = 
      <call><name>sqlite3DbReallocOrFree</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>aTableLock</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>aTableLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name> = &amp;<name>pParse</name>-&gt;<name><name>aTableLock</name><index>[<expr><name>pParse</name>-&gt;<name>nTableLock</name>++</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iDb</name> = <name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>iTab</name> = <name>iTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>isWriteLock</name> = <name>isWriteLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>zName</name> = <name>zName</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nTableLock</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Code an OP_TableLock instruction for each table locked by the
** statement (configured by calls to sqlite3TableLock()).
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>codeTableLocks</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>pVdbe</name></decl>;</decl_stmt> 

  <if>if<condition>( <expr>0==(<name>pVdbe</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nTableLock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>TableLock</name> *</type><name>p</name> =<init> <expr>&amp;<name>pParse</name>-&gt;<name><name>aTableLock</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p1</name> =<init> <expr><name>p</name>-&gt;<name>iDb</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>pVdbe</name></expr></argument>, <argument><expr><name>OP_TableLock</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iTab</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>isWriteLock</name></expr></argument>,
                      <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>codeTableLocks</name>(x)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called after a single SQL statement has been
** parsed and a VDBE program to execute that statement has been
** prepared.  This routine puts the finishing touches on the
** VDBE program and resets the pParse structure for the next
** parse.
**
** Note that if an error occurred, it might be the case that
** no VDBE code was generated.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3FinishCoding</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nested</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then> <return>return;</return></then></if>

  <comment type="block">/* Begin by generating some termination code at the end of the
  ** vdbe program
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The cookie mask contains one bit for each database file open.
    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are
    ** set for each database that is used.  Generate code to start a
    ** transaction on each used database and to verify the schema cookie
    ** on each used database.
    */</comment>
    <if>if<condition>( <expr><name>pParse</name>-&gt;<name>cookieGoto</name>&gt;0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>u32</name></type> <name>mask</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>cookieGoto</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>iDb</name>=0</expr>, <expr><name>mask</name>=1</expr>;</init> <condition><expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>mask</name>&lt;&lt;=1</expr>, <expr><name>iDb</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr>(<name>mask</name> &amp; <name>pParse</name>-&gt;<name>cookieMask</name>)==0</expr> )</condition><then> <continue>continue;</continue></then></if>
        <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>OP_Transaction</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>(<name>mask</name> &amp; <name>pParse</name>-&gt;<name>writeMask</name>)!=0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>,<argument><expr><name>OP_VerifyCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name><name>cookieValue</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nVtabLock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>vtab</name> =<init> <expr>(<name>char</name> *)<name>pParse</name>-&gt;<name><name>apVtabLock</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vtab</name></expr></argument>, <argument><expr><name>P4_VTAB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>pParse</name>-&gt;<name>nVtabLock</name> = 0</expr>;</expr_stmt>
      }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Once all the cookies have been verified and transactions opened, 
      ** obtain the required table-locks. This is a no-op unless the 
      ** shared-cache feature is enabled.
      */</comment>
      <expr_stmt><expr><call><name>codeTableLocks</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>cookieGoto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
      <comment type="block">/* Change the P4 argument of the first opcode (which will always be
      ** an OP_Trace) to be the complete text of the current SQL statement.
      */</comment>
      <decl_stmt><decl><type><name>VdbeOp</name> *</type><name>pOp</name> =<init> <expr><call><name>sqlite3VdbeGetOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pOp</name> &amp;&amp; <name>pOp</name>-&gt;<name>opcode</name>==<name>OP_Trace</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeChangeP4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>zSql</name></expr></argument>,
                            <argument><expr>(<name>int</name>)(<name>pParse</name>-&gt;<name>zTail</name> - <name>pParse</name>-&gt;<name>zSql</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_TRACE */</comment>
  }</block></then></if>


  <comment type="block">/* Get the VDBE program ready for execution
  */</comment>
  <if>if<condition>( <expr><name>v</name> &amp;&amp; <name>pParse</name>-&gt;<name>nErr</name>==0 &amp;&amp; !<name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>trace</name> =<init> <expr>(<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_VdbeTrace</name>)!=0 ? <name>stdout</name> : 0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeTrace</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>disableColCache</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Disables and re-enables match */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeMakeReady</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>nVar</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>nMem</name>+3</expr></argument>,
                         <argument><expr><name>pParse</name>-&gt;<name>nTab</name>+3</expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>explain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_DONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>colNamesSet</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pParse</name>-&gt;<name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nTab</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nMem</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nSet</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nVar</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>cookieMask</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>cookieGoto</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Run the parser and code generator recursively in order to generate
** code for the SQL statement given onto the end of the pParse context
** currently under construction.  When the parser is run recursively
** this way, the final OP_Halt is not appended and other initialization
** and finalization steps are omitted because those are handling by the
** outermost parser.
**
** Not everything is nestable.  This facility is designed to permit
** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use
** care if you decide to try to use this routine for some other purposes.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3NestedParse</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name></decl></param>, <param>...</param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <name>SAVE_SZ</name>  (sizeof(Parse) - offsetof(Parse,nVar))</cpp:define>
  <decl_stmt><decl><type><name>char</name></type> <name><name>saveBuf</name><index>[<expr><name>SAVE_SZ</name></expr>]</index></name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pParse</name>-&gt;<name>nested</name>&lt;10</expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Nesting should only be of limited depth */</comment>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3VMPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then><block>{
    <return>return;</return>   <comment type="block">/* A malloc must have failed */</comment>
  }</block></then></if>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nested</name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>saveBuf</name></expr></argument>, <argument><expr>&amp;<name>pParse</name>-&gt;<name>nVar</name></expr></argument>, <argument><expr><name>SAVE_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pParse</name>-&gt;<name>nVar</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SAVE_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3RunParser</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>&amp;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pParse</name>-&gt;<name>nVar</name></expr></argument>, <argument><expr><name>saveBuf</name></expr></argument>, <argument><expr><name>SAVE_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>nested</name>--</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Locate the in-memory structure that describes a particular database
** table given the name of that table and (optionally) the name of the
** database containing the table.  Return NULL if not found.
**
** If zDatabase is 0, all databases are searched for the table and the
** first matching table is returned.  (No checking for duplicate table
** names is done.)  The search order is TEMP first, then MAIN, then any
** auxiliary databases added using the ATTACH command.
**
** See also sqlite3LocateTable().
*/</comment>
<function><type><name>Table</name> *</type><name>sqlite3FindTable</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zDatabase</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zName</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>OMIT_TEMPDB</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>(<name>i</name>&lt;2) ? <name>i</name>^1 : <name>i</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Search TEMP before MAIN */</comment>
    <if>if<condition>( <expr><name>zDatabase</name>!=0 &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDatabase</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><name>p</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name></expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Locate the in-memory structure that describes a particular database
** table given the name of that table and (optionally) the name of the
** database containing the table.  Return NULL if not found.  Also leave an
** error message in pParse-&gt;zErrMsg.
**
** The difference between this routine and sqlite3FindTable() is that this
** routine leaves an error message in pParse-&gt;zErrMsg where
** sqlite3FindTable() does not.
*/</comment>
<function><type><name>Table</name> *</type><name>sqlite3LocateTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,         <comment type="block">/* context in which to report errors */</comment>
  <param><decl><type><name>int</name></type> <name>isView</name></decl></param>,            <comment type="block">/* True if looking for a VIEW rather than a TABLE */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,     <comment type="block">/* Name of the table we are looking for */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zDbase</name></decl></param>     <comment type="block">/* Name of the database.  Might be NULL */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* Read the database schema. If an error occurs, leave an error message
  ** and code in pParse and return NULL. */</comment>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>p</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>zDbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zMsg</name> =<init> <expr><name>isView</name> ? "no such view" : "no such table"</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>zDbase</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"%s: %s.%s"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zDbase</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"%s: %s"</expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>checkSchema</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Locate the in-memory structure that describes 
** a particular index given the name of that index
** and the name of the database that contains the index.
** Return NULL if not found.
**
** If zDatabase is 0, all databases are searched for the
** table and the first matching index is returned.  (No checking
** for duplicate index names is done.)  The search order is
** TEMP first, then MAIN, then any auxiliary databases added
** using the ATTACH command.
*/</comment>
<function><type><name>Index</name> *</type><name>sqlite3FindIndex</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>p</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name> =<init> <expr><call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>+1</expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=<name>OMIT_TEMPDB</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr>(<name>i</name>&lt;2) ? <name>i</name>^1 : <name>i</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Search TEMP before MAIN */</comment>
    <decl_stmt><decl><type><name>Schema</name> *</type><name>pSchema</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>pSchema</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>zDb</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then> <continue>continue;</continue></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSchema</name> || (<name>j</name>==1 &amp;&amp; !<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pBt</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pSchema</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>p</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pSchema</name>-&gt;<name>idxHash</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>p</name></expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Reclaim the memory used by an index
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>freeIndex</name><parameter_list>(<param><decl><type><name>Index</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>pTable</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zColAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Remove the given index from the index hash table, and free
** its memory structures.
**
** The index is removed from the database hash tables but
** it is not unlinked from the Table that it indexes.
** Unlinking from the Table must be done by the calling function.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqliteDeleteIndex</name><parameter_list>(<param><decl><type><name>Index</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>pOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name> =<init> <expr><name>p</name>-&gt;<name>zName</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>pOld</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>p</name>-&gt;<name>pSchema</name>-&gt;<name>idxHash</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>,
                           <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call>+1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pOld</name>==0 || <name>pOld</name>==<name>p</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** For the index called zIdxName which is found in the database iDb,
** unlike that index from its Table then remove the index from
** the index hash table and free all memory structures associated
** with the index.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UnlinkAndDeleteIndex</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zIdxName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> *</type><name>pHash</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>idxHash</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zIdxName</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIndex</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>pIndex</name>-&gt;<name>pTable</name>-&gt;<name>pIndex</name>==<name>pIndex</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pIndex</name>-&gt;<name>pTable</name>-&gt;<name>pIndex</name> = <name>pIndex</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Index</name> *</type><name>p</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>p</name>=<name>pIndex</name>-&gt;<name>pTable</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>pNext</name>!=<name>pIndex</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{}</block></for>
      <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>pNext</name>==<name>pIndex</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>pIndex</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <expr_stmt><expr><call><name>freeIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Erase all schema information from the in-memory hash tables of
** a single database.  This routine is called to reclaim memory
** before the database closes.  It is also called during a rollback
** if there were schema changes during the transaction or if a
** schema-cookie mismatch occurs.
**
** If iDb&lt;=0 then reset the internal schema tables for all database
** files.  If iDb&gt;=2 then reset the internal schema for only the
** single file indicated.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ResetInternalSchema</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>iDb</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BtreeEnterAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=<name>iDb</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pSchema</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name>==1 || (<name>pDb</name>-&gt;<name>pBt</name> &amp;&amp; <call><name>sqlite3BtreeHoldsMutex</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pBt</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SchemaFree</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>( <expr><name>iDb</name>&gt;0</expr> )</condition><then> <return>return;</return></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> &amp;= ~<name>SQLITE_InternChanges</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3BtreeLeaveAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If one or more of the auxiliary database files has been closed,
  ** then remove them from the auxiliary database list.  We take the
  ** opportunity to do this here since we have just deleted all of the
  ** schema hash tables and therefore do not have to make any changes
  ** to any of those tables.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pBt</name>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pAux</name> &amp;&amp; <name>pDb</name>-&gt;<name>xFreeAux</name></expr> )</condition><then> <expr_stmt><expr><name>pDb</name>-&gt;<call><name>xFreeAux</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>pDb</name>-&gt;<name>pAux</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <for>for(<init><expr><name>i</name>=<name>j</name>=2</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type>struct <name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pBt</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name>-&gt;<name>zName</name> = 0</expr>;</expr_stmt>
      <continue>continue;</continue>
    }</block></then></if>
    <if>if<condition>( <expr><name>j</name>&lt;<name>i</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>db</name>-&gt;<name>nDb</name>-<name>j</name>)*<call><name>sizeof</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>nDb</name> = <name>j</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>nDb</name>&lt;=2 &amp;&amp; <name>db</name>-&gt;<name>aDb</name>!=<name>db</name>-&gt;<name>aDbStatic</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>aDbStatic</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name>aDb</name></expr></argument>, <argument><expr>2*<call><name>sizeof</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name>aDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>aDb</name> = <name>db</name>-&gt;<name>aDbStatic</name></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** This routine is called when a commit occurs.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CommitInternalChanges</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> &amp;= ~<name>SQLITE_InternChanges</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Clear the column names from a table or view.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqliteResetColumnNames</name><parameter_list>(<param><decl><type><name>Table</name> *</type><name>pTable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pTable</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>pCol</name> = <name>pTable</name>-&gt;<name>aCol</name>)!=0</expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pTable</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>pDflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>aCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>aCol</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>nCol</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Remove the memory data structures associated with the given
** Table.  No changes are made to disk by this routine.
**
** This routine just deletes the data structure.  It does not unlink
** the table data structure from the hash table.  Nor does it remove
** foreign keys from the sqlite.aFKey hash table.  But it does destroy
** memory structures of the indices and foreign keys associated with 
** the table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeleteTable</name><parameter_list>(<param><decl><type><name>Table</name> *</type><name>pTable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name>, *<name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FKey</name> *</type><name>pFKey</name>, *<name>pNextFKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pTable</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>db</name> = <name>pTable</name>-&gt;<name>db</name></expr>;</expr_stmt>

  <comment type="block">/* Do not delete the table until the reference count reaches zero. */</comment>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTable</name>-&gt;<name>nRef</name>&gt;0</expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>-&gt;<name>nRef</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Delete all indices associated with this table
  */</comment>
  <for>for(<init><expr><name>pIndex</name> = <name>pTable</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name>=<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pNext</name> = <name>pIndex</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIndex</name>-&gt;<name>pSchema</name>==<name>pTable</name>-&gt;<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqliteDeleteIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <comment type="block">/* Delete all foreign keys associated with this table.  The keys
  ** should have already been unlinked from the pSchema-&gt;aFKey hash table 
  */</comment>
  <for>for(<init><expr><name>pFKey</name>=<name>pTable</name>-&gt;<name>pFKey</name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name>=<name>pNextFKey</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pNextFKey</name> = <name>pFKey</name>-&gt;<name>pNextFrom</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pTable</name>-&gt;<name>pSchema</name>-&gt;<name>aFKey</name></expr></argument>,
                           <argument><expr><name>pFKey</name>-&gt;<name>zTo</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pFKey</name>-&gt;<name>zTo</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call>!=<name>pFKey</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Delete the Table structure itself.
  */</comment>
  <expr_stmt><expr><call><name>sqliteResetColumnNames</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zColAff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>pCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3VtabClear</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Unlink the given table from the hash tables and the delete the
** table structure with all its indices and foreign keys.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3UnlinkAndDeleteTable</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zTabName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FKey</name> *</type><name>pF1</name>, *<name>pF2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zTabName</name> &amp;&amp; <name><name>zTabName</name><index>[<expr>0</expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name> = &amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>zTabName</name></expr></argument>,
                        <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zTabName</name></expr></argument>)</argument_list></call>+1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
    <for>for(<init><expr><name>pF1</name>=<name>p</name>-&gt;<name>pFKey</name></expr>;</init> <condition><expr><name>pF1</name></expr>;</condition> <incr><expr><name>pF1</name>=<name>pF1</name>-&gt;<name>pNextFrom</name></expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>nTo</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pF1</name>-&gt;<name>zTo</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pF2</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>aFKey</name></expr></argument>, <argument><expr><name>pF1</name>-&gt;<name>zTo</name></expr></argument>, <argument><expr><name>nTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pF2</name>==<name>pF1</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>aFKey</name></expr></argument>, <argument><expr><name>pF1</name>-&gt;<name>zTo</name></expr></argument>, <argument><expr><name>nTo</name></expr></argument>, <argument><expr><name>pF1</name>-&gt;<name>pNextTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <while>while<condition>( <expr><name>pF2</name> &amp;&amp; <name>pF2</name>-&gt;<name>pNextTo</name>!=<name>pF1</name></expr> )</condition><block>{ <expr_stmt><expr><name>pF2</name>=<name>pF2</name>-&gt;<name>pNextTo</name></expr>;</expr_stmt> }</block></while>
        <if>if<condition>( <expr><name>pF2</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pF2</name>-&gt;<name>pNextTo</name> = <name>pF1</name>-&gt;<name>pNextTo</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></else></if>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Given a token, return a string that consists of the text of that
** token with any quotations removed.  Space to hold the returned string
** is obtained from sqliteMalloc() and must be freed by the calling
** function.
**
** Tokens are often just pointers into the original SQL text and so
** are not \000 terminated and are not persistent.  The returned string
** is \000 terminated and is persistent.
*/</comment>
<function><type><name>char</name> *</type><name>sqlite3NameFromToken</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pName</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zName</name> = <call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>pName</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pName</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3Dequote</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zName</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>zName</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Open the sqlite_master table stored in database number iDb for
** writing. The table is opened using cursor 0.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3OpenMasterTable</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>MASTER_ROOT</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetNumColumns</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* sqlite_master has 5 columns */</comment>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>MASTER_ROOT</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The token *pName contains the name of a database (either "main" or
** "temp" or the name of an attached db). This routine returns the
** index of the named database in db-&gt;aDb[], or -1 if the named db 
** does not exist.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3FindDb</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>    <comment type="block">/* Database number */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>         <comment type="block">/* Number of characters in the name */</comment>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>       <comment type="block">/* A database whose name space is being searched */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>   <comment type="block">/* Name we are searching for */</comment>

  <expr_stmt><expr><name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zName</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=(<name>db</name>-&gt;<name>nDb</name>-1)</expr>, <expr><name>pDb</name>=&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name>&gt;=0</expr>;</condition> <incr><expr><name>i</name>--</expr>, <expr><name>pDb</name>--</expr></incr>)<block>{
      <if>if<condition>( <expr>(!<name>OMIT_TEMPDB</name> || <name>i</name>!=1 ) &amp;&amp; <name>n</name>==<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call> &amp;&amp; 
          0==<call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>i</name></expr>;</return>
}</block></function>

<comment type="block">/* The table or view or trigger name is passed to this routine via tokens
** pName1 and pName2. If the table name was fully qualified, for example:
**
** CREATE TABLE xxx.yyy (...);
** 
** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if
** the table name is not fully qualified, i.e.:
**
** CREATE TABLE yyy(...);
**
** Then pName1 is set to "yyy" and pName2 is "".
**
** This routine sets the *ppUnqual pointer to point at the token (pName1 or
** pName2) that stores the unqualified table name.  The index of the
** database "xxx" is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3TwoPartName</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,      <comment type="block">/* Parsing and code generating context */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,      <comment type="block">/* The "xxx" in the name "xxx.yyy" or "xxx" */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,      <comment type="block">/* The "yyy" in the name "xxx.yyy" */</comment>
  <param><decl><type><name>Token</name> **</type><name>pUnqual</name></decl></param>     <comment type="block">/* Write the unqualified object name here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* Database holding the object */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pName2</name> &amp;&amp; <name>pName2</name>-&gt;<name>n</name>&gt;0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then> <block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"corrupt database"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nErr</name>++</expr>;</expr_stmt>
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>pUnqual</name> = <name>pName2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3FindDb</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"unknown database %T"</expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nErr</name>++</expr>;</expr_stmt>
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>init</name>.<name>iDb</name>==0 || <name>db</name>-&gt;<name>init</name>.<name>busy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> = <name>db</name>-&gt;<name>init</name>.<name>iDb</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>pUnqual</name> = <name>pName1</name></expr>;</expr_stmt>
  }</block></else></if>
  <return>return <expr><name>iDb</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is used to check if the UTF-8 string zName is a legal
** unqualified name for a new schema object (table, index, view or
** trigger). All names are legal except those that begin with the string
** "sqlite_" (in upper, lower or mixed case). This portion of the namespace
** is reserved for internal use.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3CheckObjectName</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>db</name>-&gt;<name>init</name>.<name>busy</name> &amp;&amp; <name>pParse</name>-&gt;<name>nested</name>==0 
          &amp;&amp; (<name>pParse</name>-&gt;<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_WriteSchema</name>)==0
          &amp;&amp; 0==<call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"object name reserved for internal use: %s"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Begin constructing a new table representation in memory.  This is
** the first of several action routines that get called in response
** to a CREATE TABLE statement.  In particular, this routine is called
** after seeing tokens "CREATE" and "TABLE" and the table name. The isTemp
** flag is true if the table should be stored in the auxiliary database
** file instead of in the main database file.  This is normally the case
** when the "TEMP" or "TEMPORARY" keyword occurs in between
** CREATE and TABLE.
**
** The new table record is initialized and put in pParse-&gt;pNewTable.
** As more of the CREATE TABLE statement is parsed, additional action
** routines will be called to add more information to this record.
** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine
** is called to complete the construction of the new table record.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3StartTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,   <comment type="block">/* Parser context */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,   <comment type="block">/* First part of the name of the table or view */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,   <comment type="block">/* Second part of the name of the table or view */</comment>
  <param><decl><type><name>int</name></type> <name>isTemp</name></decl></param>,      <comment type="block">/* True if this is a TEMP table */</comment>
  <param><decl><type><name>int</name></type> <name>isView</name></decl></param>,      <comment type="block">/* True if this is a VIEW */</comment>
  <param><decl><type><name>int</name></type> <name>isVirtual</name></decl></param>,   <comment type="block">/* True if this is a VIRTUAL table */</comment>
  <param><decl><type><name>int</name></type> <name>noErr</name></decl></param>        <comment type="block">/* Do nothing if table already exists */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* The name of the new table */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>         <comment type="block">/* Database number to create the table in */</comment>
  <decl_stmt><decl><type><name>Token</name> *</type><name>pName</name></decl>;</decl_stmt>    <comment type="block">/* Unqualified name of the table to create */</comment>

  <comment type="block">/* The table or view name to create is passed to this routine via tokens
  ** pName1 and pName2. If the table name was fully qualified, for example:
  **
  ** CREATE TABLE xxx.yyy (...);
  ** 
  ** Then pName1 is set to "xxx" and pName2 "yyy". On the other hand if
  ** the table name is not fully qualified, i.e.:
  **
  ** CREATE TABLE yyy(...);
  **
  ** Then pName1 is set to "yyy" and pName2 is "".
  **
  ** The call below sets the pName pointer to point at the token (pName1 or
  ** pName2) that stores the unqualified table name. The variable iDb is
  ** set to the index of the database that the table or view is to be
  ** created in.
  */</comment>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>&amp;<name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>isTemp</name> &amp;&amp; <name>iDb</name>&gt;1</expr> )</condition><then><block>{
    <comment type="block">/* If creating a temp table, the name may not be qualified */</comment>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"temporary table name must be unqualified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>isTemp</name></expr> )</condition><then> <expr_stmt><expr><name>iDb</name> = 1</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>pParse</name>-&gt;<name>sNameToken</name> = *<name>pName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zName</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>begin_table_error</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>iDb</name>==1</expr> )</condition><then> <expr_stmt><expr><name>isTemp</name> = 1</expr>;</expr_stmt></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>isTemp</name> &amp; 1)==<name>isTemp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>isTemp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>begin_table_error</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>isTemp</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_CREATE_TEMP_VIEW</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_CREATE_VIEW</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>isTemp</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_CREATE_TEMP_TABLE</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_CREATE_TABLE</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <if>if<condition>( <expr>!<name>isVirtual</name> &amp;&amp; <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>begin_table_error</name>;</goto>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Make sure the new table name does not collide with an existing
  ** index or table name in the same database.  Issue an error message if
  ** it does. The exception is if the statement being parsed was passed
  ** to an sqlite3_declare_vtab() call. In that case only the column names
  ** and types will be used, so there is no need to test for namespace
  ** collisions.
  */</comment>
  <if>if<condition>( <expr>!<name>IN_DECLARE_VTAB</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>begin_table_error</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pTable</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTable</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>noErr</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %T already exists"</expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <goto>goto <name>begin_table_error</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>!=0 &amp;&amp; (<name>iDb</name>==0 || !<name>db</name>-&gt;<name>init</name>.<name>busy</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"there is already an index named %s"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>begin_table_error</name>;</goto>
    }</block></then></if>
  }</block></then></if>

  <expr_stmt><expr><name>pTable</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTable</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nErr</name>++</expr>;</expr_stmt>
    <goto>goto <name>begin_table_error</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>zName</name> = <name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>iPKey</name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>pSchema</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>db</name> = <name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>pNewTable</name></expr> )</condition><then> <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>pNewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTable</name> = <name>pTable</name></expr>;</expr_stmt>

  <comment type="block">/* If this is the magic sqlite_sequence table used by autoincrement,
  ** then record a pointer to this table in the main database structure
  ** so that INSERT can find the table easily.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
  <if>if<condition>( <expr>!<name>pParse</name>-&gt;<name>nested</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr>"sqlite_sequence"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTable</name>-&gt;<name>pSchema</name>-&gt;<name>pSeqTab</name> = <name>pTable</name></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Begin generating the code that will insert the table record into
  ** the SQLITE_MASTER table.  Note in particular that we must go ahead
  ** and allocate the record number for the table entry now.  Before any
  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause
  ** indices to be created and the table record must come before the 
  ** indices.  Hence, the record number for the table must be allocated
  ** now.
  */</comment>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name> &amp;&amp; (<name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fileFormat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>reg1</name>, <name>reg2</name>, <name>reg3</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if>if<condition>( <expr><name>isVirtual</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If the file format and encoding in the database have not been set, 
    ** set them now.
    */</comment>
    <expr_stmt><expr><name>reg1</name> = <name>pParse</name>-&gt;<name>regRowid</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reg2</name> = <name>pParse</name>-&gt;<name>regRoot</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reg3</name> = ++<name>pParse</name>-&gt;<name>nMem</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ReadCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>reg3</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* file_format */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_If</name></expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fileFormat</name> = (<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_LegacyFileFmt</name>)!=0 ?
                  1 : <name>SQLITE_MAX_FILE_FORMAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>fileFormat</name></expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This just creates a place-holder record in the sqlite_master table.
    ** The record created does not contain anything yet.  It will be replaced
    ** by the real entry in code generated at sqlite3EndTable().
    **
    ** The rowid for the new entry is left on the top of the stack.
    ** The rowid value is needed by the code that sqlite3EndTable will
    ** generate.
    */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if>if<condition>( <expr><name>isView</name> || <name>isVirtual</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CreateTable</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3OpenMasterTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_NewRowid</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Null</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>reg3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Insert</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>reg3</name></expr></argument>, <argument><expr><name>reg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OPFLAG_APPEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Normal (non-error) return. */</comment>
  <return>return;</return>

  <comment type="block">/* If an error occurs, we jump here */</comment>
<label><name>begin_table_error</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** This macro is used to compare two strings in a case-insensitive manner.
** It is slightly faster than calling sqlite3StrICmp() directly, but
** produces larger code.
**
** WARNING: This macro is not compatible with the strcmp() family. It
** returns true if the two strings are equal, otherwise false.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>STRICMP</name>(x, y) (\
sqlite3UpperToLower[*(unsigned char *)(x)]==   \
sqlite3UpperToLower[*(unsigned char *)(y)]     \
&amp;&amp; sqlite3StrICmp((x)+1,(y)+1)==0 )</cpp:define>

<comment type="block">/*
** Add a new column to the table currently being constructed.
**
** The parser calls this routine once for each column declaration
** in a CREATE TABLE statement.  sqlite3StartTable() gets called
** first to get things going.  Then this routine is called for each
** column.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddColumn</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)==0</expr> )</condition><then> <return>return;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_COLUMN</name></expr></cpp:if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>nCol</name>+1&gt;<name>db</name>-&gt;<name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_COLUMN</name></expr>]</index></name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"too many columns on %s"</expr></argument>, <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"duplicate column name: %s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
  }</block></for>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>nCol</name> &amp; 0x7)==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Column</name> *</type><name>aNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>aNew</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>,<argument><expr><name>p</name>-&gt;<name>aCol</name></expr></argument>,<argument><expr>(<name>p</name>-&gt;<name>nCol</name>+8)*<call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>aNew</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>p</name>-&gt;<name>aCol</name> = <name>aNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pCol</name> = &amp;<name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>p</name>-&gt;<name>nCol</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCol</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name>-&gt;<name>zName</name> = <name>z</name></expr>;</expr_stmt>
 
  <comment type="block">/* If there is no type specified, columns have the default affinity
  ** 'NONE'. If there is a type specified, then sqlite3AddColumnType() will
  ** be called next to set pCol-&gt;affinity correctly.
  */</comment>
  <expr_stmt><expr><name>pCol</name>-&gt;<name>affinity</name> = <name>SQLITE_AFF_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>nCol</name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.  A "NOT NULL" constraint has
** been seen on a column.  This routine sets the notNull flag on
** the column currently under construction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddNotNull</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>onError</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>nCol</name>-1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>i</name>&gt;=0</expr> )</condition><then> <expr_stmt><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>notNull</name> = (<name>u8</name>)<name>onError</name></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/*
** Scan the column type name zType (length nType) and return the
** associated affinity type.
**
** This routine does a case-independent search of zType for the 
** substrings in the following table. If one of the substrings is
** found, the corresponding affinity is returned. If zType contains
** more than one of the substrings, entries toward the top of 
** the table take priority. For example, if zType is 'BLOBINT', 
** SQLITE_AFF_INTEGER is returned.
**
** Substring     | Affinity
** --------------------------------
** 'INT'         | SQLITE_AFF_INTEGER
** 'CHAR'        | SQLITE_AFF_TEXT
** 'CLOB'        | SQLITE_AFF_TEXT
** 'TEXT'        | SQLITE_AFF_TEXT
** 'BLOB'        | SQLITE_AFF_NONE
** 'REAL'        | SQLITE_AFF_REAL
** 'FLOA'        | SQLITE_AFF_REAL
** 'DOUB'        | SQLITE_AFF_REAL
**
** If none of the substrings in the above table are found,
** SQLITE_AFF_NUMERIC is returned.
*/</comment>
<function><type><name>char</name></type> <name>sqlite3AffinityType</name><parameter_list>(<param><decl><type><name>const</name> <name>Token</name> *</type><name>pType</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>h</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>aff</name> =<init> <expr><name>SQLITE_AFF_NUMERIC</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zIn</name> =<init> <expr><name>pType</name>-&gt;<name>z</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>zEnd</name> =<init> <expr>&amp;<name>pType</name>-&gt;<name><name>z</name><index>[<expr><name>pType</name>-&gt;<name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>zIn</name>!=<name>zEnd</name></expr> )</condition><block>{
    <expr_stmt><expr><name>h</name> = (<name>h</name>&lt;&lt;8) + <name><name>sqlite3UpperToLower</name><index>[<expr>*<name>zIn</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zIn</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>h</name>==(('c'&lt;&lt;24)+('h'&lt;&lt;16)+('a'&lt;&lt;8)+'r')</expr> )</condition><then><block>{             <comment type="block">/* CHAR */</comment>
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt> 
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('c'&lt;&lt;24)+('l'&lt;&lt;16)+('o'&lt;&lt;8)+'b')</expr> )</condition><then><block>{       <comment type="block">/* CLOB */</comment>
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('t'&lt;&lt;24)+('e'&lt;&lt;16)+('x'&lt;&lt;8)+'t')</expr> )</condition><then><block>{       <comment type="block">/* TEXT */</comment>
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_TEXT</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('b'&lt;&lt;24)+('l'&lt;&lt;16)+('o'&lt;&lt;8)+'b')          <comment type="block">/* BLOB */</comment>
        &amp;&amp; (<name>aff</name>==<name>SQLITE_AFF_NUMERIC</name> || <name>aff</name>==<name>SQLITE_AFF_REAL</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_NONE</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('r'&lt;&lt;24)+('e'&lt;&lt;16)+('a'&lt;&lt;8)+'l')          <comment type="block">/* REAL */</comment>
        &amp;&amp; <name>aff</name>==<name>SQLITE_AFF_NUMERIC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('f'&lt;&lt;24)+('l'&lt;&lt;16)+('o'&lt;&lt;8)+'a')          <comment type="block">/* FLOA */</comment>
        &amp;&amp; <name>aff</name>==<name>SQLITE_AFF_NUMERIC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>h</name>==(('d'&lt;&lt;24)+('o'&lt;&lt;16)+('u'&lt;&lt;8)+'b')          <comment type="block">/* DOUB */</comment>
        &amp;&amp; <name>aff</name>==<name>SQLITE_AFF_NUMERIC</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_REAL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else <if>if<condition>( <expr>(<name>h</name>&amp;0x00FFFFFF)==(('i'&lt;&lt;16)+('n'&lt;&lt;8)+'t')</expr> )</condition><then><block>{    <comment type="block">/* INT */</comment>
      <expr_stmt><expr><name>aff</name> = <name>SQLITE_AFF_INTEGER</name></expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
  }</block></while>

  <return>return <expr><name>aff</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.  The pFirst token is the first
** token in the sequence of tokens that describe the type of the
** column currently under construction.   pLast is the last token
** in the sequence.  Use this information to construct a string
** that contains the typename of the column and store that string
** in zType.
*/</comment> 
<function><type><name>void</name></type> <name>sqlite3AddColumnType</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pType</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>(<name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>nCol</name>-1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>i</name>&lt;0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>pCol</name> = &amp;<name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name>-&gt;<name>zType</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCol</name>-&gt;<name>affinity</name> = <call><name>sqlite3AffinityType</name><argument_list>(<argument><expr><name>pType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The expression is the default value for the most recently added column
** of the table currently under construction.
**
** Default value expressions must be constant.  Raise an exception if this
** is not the case.
**
** This routine is called by the parser while in the middle of
** parsing a CREATE TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddDefaultValue</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pCol</name> = &amp;(<name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>p</name>-&gt;<name>nCol</name>-1</expr>]</index></name>)</expr>;</expr_stmt>
    <if>if<condition>( <expr>!<call><name>sqlite3ExprIsConstantOrFunction</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"default value of column [%s] is not constant"</expr></argument>,
          <argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Expr</name> *</type><name>pCopy</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>pDflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pCol</name>-&gt;<name>pDflt</name> = <name>pCopy</name> = <call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pCopy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3TokenCopy</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name>pCopy</name>-&gt;<name>span</name></expr></argument>, <argument><expr>&amp;<name>pExpr</name>-&gt;<name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Designate the PRIMARY KEY for the table.  pList is a list of names 
** of columns that form the primary key.  If pList is NULL, then the
** most recently added column of the table is the primary key.
**
** A table can have at most one primary key.  If the table already has
** a primary key (and this is the second primary key) then create an
** error.
**
** If the PRIMARY KEY is on a single column whose datatype is INTEGER,
** then we will try to use that column as the rowid.  Set the Table.iPKey
** field of the table under construction to be the index of the
** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is
** no INTEGER PRIMARY KEY.
**
** If the key is not an INTEGER PRIMARY KEY, then create a unique
** index for the key.  No index is created for INTEGER PRIMARY KEYs.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddPrimaryKey</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,  <comment type="block">/* List of field names to be indexed */</comment>
  <param><decl><type><name>int</name></type> <name>onError</name></decl></param>,      <comment type="block">/* What to do with a uniqueness conflict */</comment>
  <param><decl><type><name>int</name></type> <name>autoInc</name></decl></param>,      <comment type="block">/* True if the AUTOINCREMENT keyword is present */</comment>
  <param><decl><type><name>int</name></type> <name>sortOrder</name></decl></param>     <comment type="block">/* SQLITE_SO_ASC or SQLITE_SO_DESC */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pParse</name>-&gt;<name>pNewTable</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zType</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr>-1</expr>, <expr><name>i</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0 || <name>IN_DECLARE_VTAB</name></expr> )</condition><then> <goto>goto <name>primary_key_exit</name>;</goto></then></if>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_HasPrimaryKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
      <argument><expr>"table \"%s\" has more than one primary key"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>primary_key_exit</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>tabFlags</name> |= <name>TF_HasPrimaryKey</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>iCol</name> = <name>pTab</name>-&gt;<name>nCol</name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>isPrimKey</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <for>for(<init><expr><name>iCol</name>=0</expr>;</init> <condition><expr><name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>isPrimKey</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>pList</name>-&gt;<name>nExpr</name>&gt;1</expr> )</condition><then> <expr_stmt><expr><name>iCol</name> = -1</expr>;</expr_stmt></then></if>
  }</block></else></if>
  <if>if<condition>( <expr><name>iCol</name>&gt;=0 &amp;&amp; <name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zType</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zType</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>zType</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>, <argument><expr>"INTEGER"</expr></argument>)</argument_list></call>==0
        &amp;&amp; <name>sortOrder</name>==<name>SQLITE_SO_ASC</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name>-&gt;<name>iPKey</name> = <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>keyConf</name> = (<name>u8</name>)<name>onError</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>autoInc</name>==0 || <name>autoInc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>tabFlags</name> |= <name>autoInc</name>*<name>TF_Autoincrement</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>autoInc</name></expr> )</condition><then><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"AUTOINCREMENT is only allowed on an "
       "INTEGER PRIMARY KEY"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3CreateIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr><name>onError</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>sortOrder</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> = 0</expr>;</expr_stmt>
  }</block></else></if></else></if>

<label><name>primary_key_exit</name>:</label>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** Add a new CHECK constraint to the table currently under construction.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddCheckConstraint</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,    <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pCheckExpr</name></decl></param>  <comment type="block">/* The check expression */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pParse</name>-&gt;<name>pNewTable</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pTab</name> &amp;&amp; !<name>IN_DECLARE_VTAB</name></expr> )</condition><then><block>{
    <comment type="block">/* The CHECK expression must be duplicated so that tokens refer
    ** to malloced space and not the (ephemeral) text of the CREATE TABLE
    ** statement */</comment>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>pCheck</name> = <call><name>sqlite3ExprAnd</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pCheck</name></expr></argument>, 
                                  <argument><expr><call><name>sqlite3ExprDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCheckExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pCheckExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Set the collation function of the most recently parsed table column
** to the CollSeq given.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3AddCollateType</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pToken</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zColl</name></decl>;</decl_stmt>              <comment type="block">/* Dequoted name of collation sequence */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>(<name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>i</name> = <name>p</name>-&gt;<name>nCol</name>-1</expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zColl</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>zColl</name></expr> )</condition><then> <return>return;</return></then></if>

  <if>if<condition>( <expr><call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zColl</name> = <name>zColl</name></expr>;</expr_stmt>
  
    <comment type="block">/* If the column is declared as "&lt;name&gt; PRIMARY KEY COLLATE &lt;type&gt;",
    ** then an index may have been created on this column before the
    ** collation type was added. Correct this if it is the case.
    */</comment>
    <for>for(<init><expr><name>pIdx</name>=<name>p</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>nColumn</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr>0</expr>]</index></name>==<name>i</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr>0</expr>]</index></name> = <name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zColl</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** This function returns the collation sequence for database native text
** encoding identified by the string zName, length nName.
**
** If the requested collation sequence is not available, or not available
** in the database native encoding, the collation factory is invoked to
** request it. If the collation factory does not supply such a sequence,
** and the sequence is available in another text encoding, then that is
** returned instead.
**
** If no versions of the requested collations sequence are available, or
** another error occurs, NULL is returned and an error message written into
** pParse.
**
** This routine is a wrapper around sqlite3FindCollSeq().  This routine
** invokes the collation factory if the named collation cannot be found
** and generates an error message.
*/</comment>
<function><type><name>CollSeq</name> *</type><name>sqlite3LocateCollSeq</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>, <param><decl><type><name>int</name></type> <name>nName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>enc</name> =<init> <expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u8</name></type> <name>initbusy</name> =<init> <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>initbusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>initbusy</name> &amp;&amp; (!<name>pColl</name> || !<name>pColl</name>-&gt;<name>xCmp</name>)</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3GetCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pColl</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>nName</name>&lt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such collation sequence: %.*s"</expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pColl</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>pColl</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Generate code that will increment the schema cookie.
**
** The schema cookie is used to determine when the schema for the
** database changes.  After each schema change, the cookie value
** changes.  When a process first reads the schema it records the
** cookie.  Thereafter, whenever it goes to access the database,
** it checks the cookie to make sure the schema has not changed
** since it was last read.
**
** This plan is not completely bullet-proof.  It is possible for
** the schema to change multiple times and for the cookie to be
** set back to prior value.  But schema changes are infrequent
** and the probability of hitting the same cookie value is only
** 1 chance in 2^32.  So we're safe enough.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3ChangeCookie</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><name>pParse</name>-&gt;<name>pVdbe</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>schema_cookie</name>+1</expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Measure the number of characters needed to output the given
** identifier.  The number returned includes any quotes used
** but does not include the null terminator.
**
** The estimate is conservative.  It might be larger that what is
** really needed.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>identLength</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>n</name>=0</expr>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>n</name>++</expr>, <expr><name>z</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>*<name>z</name>=='"'</expr> )</condition><then><block>{ <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt> }</block></then></if>
  }</block></for>
  <return>return <expr><name>n</name> + 2</expr>;</return>
}</block></function>

<comment type="block">/*
** Write an identifier onto the end of the given string.  Add
** quote characters as needed.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>identPut</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>z</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pIdx</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zSignedIdent</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>zIdent</name> =<init> <expr>(<name>unsigned</name> <name>char</name>*)<name>zSignedIdent</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name>, <name>needQuote</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> = *<name>pIdx</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr>!<call><name>isalnum</name><argument_list>(<argument><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name>!='_'</expr> )</condition><then> <break>break;</break></then></if>
  }</block></for>
  <expr_stmt><expr><name>needQuote</name> =  <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name>!=0 || <call><name>isdigit</name><argument_list>(<argument><expr><name><name>zIdent</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>
                  || <call><name>sqlite3KeywordCode</name><argument_list>(<argument><expr><name>zIdent</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call>!=<name>TK_ID</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name>++</expr>]</index></name> = '"'</expr>;</expr_stmt></then></if>
  <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name><name>zIdent</name><index>[<expr><name>j</name></expr>]</index></name>=='"'</expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name>++</expr>]</index></name> = '"'</expr>;</expr_stmt></then></if>
  }</block></for>
  <if>if<condition>( <expr><name>needQuote</name></expr> )</condition><then> <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name>++</expr>]</index></name> = '"'</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pIdx</name> = <name>i</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Generate a CREATE TABLE statement appropriate for the given
** table.  Memory to hold the text of the statement is obtained
** from sqliteMalloc() and must be freed by the calling function.
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>createTableStmt</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>isTemp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>k</name>, <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zStmt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zSep</name>, *<name>zSep2</name>, *<name>zEnd</name>, *<name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Column</name> *</type><name>pCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>pCol</name> = <name>p</name>-&gt;<name>aCol</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>n</name> += <call><name>identLength</name><argument_list>(<argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> = <name>pCol</name>-&gt;<name>zType</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>z</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name> += (<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> + 1)</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>n</name> += <call><name>identLength</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>n</name>&lt;50</expr> )</condition><then><block>{
    <expr_stmt><expr><name>zSep</name> = ""</expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep2</name> = ","</expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> = ")"</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>zSep</name> = "\n  "</expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep2</name> = ",\n  "</expr>;</expr_stmt>
    <expr_stmt><expr><name>zEnd</name> = "\n)"</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>n</name> += 35 + 6*<name>p</name>-&gt;<name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zStmt</name> = <call><name>sqlite3Malloc</name><argument_list>( <argument><expr><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zStmt</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>,
                  <argument><expr>!<name>OMIT_TEMPDB</name>&amp;&amp;<name>isTemp</name> ? "CREATE TEMP TABLE ":"CREATE TABLE "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>identPut</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zStmt</name><index>[<expr><name>k</name>++</expr>]</index></name> = '('</expr>;</expr_stmt>
  <for>for(<init><expr><name>pCol</name>=<name>p</name>-&gt;<name>aCol</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pCol</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name>-<name>k</name></expr></argument>, <argument><expr>&amp;<name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>&amp;<name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> = <name>zSep2</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>identPut</name><argument_list>(<argument><expr><name>zStmt</name></expr></argument>, <argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr><name>pCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>z</name> = <name>pCol</name>-&gt;<name>zType</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name><name>zStmt</name><index>[<expr><name>k</name>++</expr>]</index></name> = ' '</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>int</name>)(<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>+<name>k</name>+1)&lt;=<name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name>-<name>k</name></expr></argument>, <argument><expr>&amp;<name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>k</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>n</name>-<name>k</name></expr></argument>, <argument><expr>&amp;<name><name>zStmt</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zStmt</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called to report the final ")" that terminates
** a CREATE TABLE statement.
**
** The table structure that other action routines have been building
** is added to the internal hash tables, assuming no errors have
** occurred.
**
** An entry for the table is made in the master table on disk, unless
** this is a temporary table or db-&gt;init.busy==1.  When db-&gt;init.busy==1
** it means we are reading the sqlite_master table because we just
** connected to the database or because the sqlite_master table has
** recently changed, so the entry for this table already exists in
** the sqlite_master table.  We do not want to create it again.
**
** If the pSelect argument is not NULL, it means that this routine
** was called to create a table generated from a 
** "CREATE TABLE ... AS SELECT ..." statement.  The column names of
** the new table will match the result set of the SELECT.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3EndTable</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parse context */</comment>
  <param><decl><type><name>Token</name> *</type><name>pCons</name></decl></param>,           <comment type="block">/* The ',' token after the last column defn. */</comment>
  <param><decl><type><name>Token</name> *</type><name>pEnd</name></decl></param>,            <comment type="block">/* The final ')' token in the CREATE TABLE */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>         <comment type="block">/* Select from a "CREATE ... AS SELECT" */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <if>if<condition>( <expr>(<name>pEnd</name>==0 &amp;&amp; <name>pSelect</name>==0) || <name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <block>{
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then> <return>return;</return></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name> || !<name>pSelect</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_CHECK</name></cpp:ifndef>
  <comment type="block">/* Resolve names in all CHECK constraint expressions.
  */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pCheck</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>SrcList</name></type> <name>sSrc</name></decl>;</decl_stmt>                   <comment type="block">/* Fake SrcList for pParse-&gt;pNewTable */</comment>
    <decl_stmt><decl><type><name>NameContext</name></type> <name>sNC</name></decl>;</decl_stmt>                <comment type="block">/* Name context for pParse-&gt;pNewTable */</comment>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sSrc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sSrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sSrc</name>.<name>nSrc</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>sSrc</name>.<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name> = <name>p</name>-&gt;<name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sSrc</name>.<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>pTab</name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sSrc</name>.<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>iCursor</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>pParse</name> = <name>pParse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>pSrcList</name> = &amp;<name>sSrc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sNC</name>.<name>isCheck</name> = 1</expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3ResolveExprNames</name><argument_list>(<argument><expr>&amp;<name>sNC</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pCheck</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return;</return>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_CHECK) */</comment>

  <comment type="block">/* If the db-&gt;init.busy is 1 it means we are reading the SQL off the
  ** "sqlite_master" or "sqlite_temp_master" table on the disk.
  ** So do not write to the disk again.  Extract the root page number
  ** for the table from the db-&gt;init.newTnum field.  (The page number
  ** should have been put there by the sqliteOpenCb routine.)
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>tnum</name> = <name>db</name>-&gt;<name>init</name>.<name>newTnum</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* If not initializing, then create a record for the new table
  ** in the SQLITE_MASTER table of the database.  The record number
  ** for the new table entry should already be on the stack.
  **
  ** If this is a TEMPORARY table, write the entry into the auxiliary
  ** file instead of into the main database file.
  */</comment>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zType</name></decl>;</decl_stmt>    <comment type="block">/* "view" or "table" */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zType2</name></decl>;</decl_stmt>   <comment type="block">/* "VIEW" or "TABLE" */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zStmt</name></decl>;</decl_stmt>    <comment type="block">/* Text of the CREATE TABLE or CREATE VIEW statement */</comment>

    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the rootpage for the new table and push it onto the stack.
    ** A view has no rootpage, so just push a zero onto the stack for
    ** views.  Initialize zType at the same time.
    */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>pSelect</name>==0</expr> )</condition><then><block>{
      <comment type="block">/* A regular table */</comment>
      <expr_stmt><expr><name>zType</name> = "table"</expr>;</expr_stmt>
      <expr_stmt><expr><name>zType2</name> = "TABLE"</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
    }</block></then><else>else<block>{
      <comment type="block">/* A view */</comment>
      <expr_stmt><expr><name>zType</name> = "view"</expr>;</expr_stmt>
      <expr_stmt><expr><name>zType2</name> = "VIEW"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>

    <comment type="block">/* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT
    ** statement to populate the new table. The root-page number for the
    ** new table is on the top of the vdbe stack.
    **
    ** Once the SELECT has been coded by sqlite3Select(), it is in a
    ** suitable state to query for the column names and types to be used
    ** by the new table.
    **
    ** A shared-cache write-lock is not required to write to the new table,
    ** as a schema-lock must have already been obtained to create it. Since
    ** a schema-lock excludes all other database users, the write-lock would
    ** be redundant.
    */</comment>
    <if>if<condition>( <expr><name>pSelect</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>SelectDest</name></type> <name>dest</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Table</name> *</type><name>pSelTab</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>nTab</name>==0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>regRoot</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>nTab</name> = 2</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3SelectDestInit</name><argument_list>(<argument><expr>&amp;<name>dest</name></expr></argument>, <argument><expr><name>SRT_Table</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Select</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>, <argument><expr>&amp;<name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pSelTab</name> = <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pSelTab</name>==0</expr> )</condition><then> <return>return;</return></then></if>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>aCol</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>nCol</name> = <name>pSelTab</name>-&gt;<name>nCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name>-&gt;<name>aCol</name> = <name>pSelTab</name>-&gt;<name>aCol</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pSelTab</name>-&gt;<name>nCol</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>pSelTab</name>-&gt;<name>aCol</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pSelTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Compute the complete text of the CREATE statement */</comment>
    <if>if<condition>( <expr><name>pSelect</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zStmt</name> = <call><name>createTableStmt</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSchema</name>==<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>n</name> = (<name>int</name>)(<name>pEnd</name>-&gt;<name>z</name> - <name>pParse</name>-&gt;<name>sNameToken</name>.<name>z</name>) + 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>zStmt</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
          <argument><expr>"CREATE %s %.*s"</expr></argument>, <argument><expr><name>zType2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>sNameToken</name>.<name>z</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* A slot for the record has already been allocated in the 
    ** SQLITE_MASTER table.  We just need to update that slot with all
    ** the information we've collected.  The rowid for the preallocated
    ** slot is the 2nd item on the stack.  The top of the stack is the
    ** root page for the new table (or a 0 if this is a view).
    */</comment>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr>"UPDATE %Q.%s "
         "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q "
       "WHERE rowid=#%d"</expr></argument>,
      <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>zType</name></expr></argument>,
      <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>,
      <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>,
      <argument><expr><name>pParse</name>-&gt;<name>regRoot</name></expr></argument>,
      <argument><expr><name>zStmt</name></expr></argument>,
      <argument><expr><name>pParse</name>-&gt;<name>regRowid</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <comment type="block">/* Check to see if we need to create an sqlite_sequence table for
    ** keeping track of autoincrement keys.
    */</comment>
    <if>if<condition>( <expr><name>p</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Autoincrement</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>pSeqTab</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
          <argument><expr>"CREATE TABLE %Q.sqlite_sequence(name,seq)"</expr></argument>,
          <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Reparse everything to update our internal data structures */</comment>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
        <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"tbl_name='%q'"</expr></argument>,<argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>


  <comment type="block">/* Add the table to the in-memory representation of the database.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name> &amp;&amp; <name>pParse</name>-&gt;<name>nErr</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FKey</name> *</type><name>pFKey</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>Schema</name> *</type><name>pSchema</name> =<init> <expr><name>p</name>-&gt;<name>pSchema</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOld</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>,
                             <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>+1</expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOld</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==<name>pOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed inside HashInsert() */</comment>
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
    <for>for(<init><expr><name>pFKey</name>=<name>p</name>-&gt;<name>pFKey</name></expr>;</init> <condition><expr><name>pFKey</name></expr>;</condition> <incr><expr><name>pFKey</name>=<name>pFKey</name>-&gt;<name>pNextFrom</name></expr></incr>)<block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>data</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nTo</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pFKey</name>-&gt;<name>zTo</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pFKey</name>-&gt;<name>pNextTo</name> = <call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>pSchema</name>-&gt;<name>aFKey</name></expr></argument>, <argument><expr><name>pFKey</name>-&gt;<name>zTo</name></expr></argument>, <argument><expr><name>nTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>data</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pSchema</name>-&gt;<name>aFKey</name></expr></argument>, <argument><expr><name>pFKey</name>-&gt;<name>zTo</name></expr></argument>, <argument><expr><name>nTo</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>data</name>==(<name>void</name> *)<name>pFKey</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTable</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>nTable</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name> =<init> <expr>(<name>const</name> <name>char</name> *)<name>pParse</name>-&gt;<name>sNameToken</name>.<name>z</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>pSelect</name> &amp;&amp; <name>pCons</name> &amp;&amp; <name>pEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pCons</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pCons</name> = <name>pEnd</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>nName</name> = (<name>int</name>)((<name>const</name> <name>char</name> *)<name>pCons</name>-&gt;<name>z</name> - <name>zName</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name>-&gt;<name>addColOffset</name> = 13 + <call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
<comment type="block">/*
** The parser calls this routine in order to create a new VIEW
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateView</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* The parsing context */</comment>
  <param><decl><type><name>Token</name> *</type><name>pBegin</name></decl></param>,     <comment type="block">/* The CREATE token that begins the statement */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,     <comment type="block">/* The token that holds the name of the view */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,     <comment type="block">/* The token that holds the name of the view */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSelect</name></decl></param>,   <comment type="block">/* A SELECT statement that will become the new view */</comment>
  <param><decl><type><name>int</name></type> <name>isTemp</name></decl></param>,        <comment type="block">/* TRUE for a TEMPORARY view */</comment>
  <param><decl><type><name>int</name></type> <name>noErr</name></decl></param>          <comment type="block">/* Suppress error messages if VIEW already exists */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>unsigned</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>sEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> *</type><name>pName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nVar</name>&gt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"parameters are not allowed in views"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3StartTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><name>isTemp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>noErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0 || <name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>&amp;<name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>"view"</expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call>
    &amp;&amp; <call><name>sqlite3FixSelect</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>
  )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <comment type="block">/* Make a copy of the entire SELECT statement that defines the view.
  ** This will force all the Expr.token.z values to be dynamically
  ** allocated rather than point to the input string - which means that
  ** they will persist after the current sqlite3_exec() call returns.
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>pSelect</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Locate the end of the CREATE VIEW statement.  Make sEnd point to
  ** the end.
  */</comment>
  <expr_stmt><expr><name>sEnd</name> = <name>pParse</name>-&gt;<name>sLastToken</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>sEnd</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>!=0 &amp;&amp; <name>sEnd</name>.<name><name>z</name><index>[<expr>0</expr>]</index></name>!=';'</expr> )</condition><then><block>{
    <expr_stmt><expr><name>sEnd</name>.<name>z</name> += <name>sEnd</name>.<name>n</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>sEnd</name>.<name>n</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = (<name>int</name>)(<name>sEnd</name>.<name>z</name> - <name>pBegin</name>-&gt;<name>z</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = (<name>const</name> <name>unsigned</name> <name>char</name>*)<name>pBegin</name>-&gt;<name>z</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name>&gt;0 &amp;&amp; (<name><name>z</name><index>[<expr><name>n</name>-1</expr>]</index></name>==';' || <call><name>isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr> )</condition><block>{ <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt> }</block></while>
  <expr_stmt><expr><name>sEnd</name>.<name>z</name> = &amp;<name><name>z</name><index>[<expr><name>n</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>sEnd</name>.<name>n</name> = 1</expr>;</expr_stmt>

  <comment type="block">/* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */</comment>
  <expr_stmt><expr><call><name>sqlite3EndTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>sEnd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIEW</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_VIRTUALTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** The Table structure pTable is really a VIEW.  Fill in the names of
** the columns of the view in the pTable structure.  Return the number
** of errors.  If an error is seen leave an error message in pParse-&gt;zErrMsg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3ViewGetColumnNames</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pSelTab</name></decl>;</decl_stmt>   <comment type="block">/* A fake table from which we get the result set */</comment>
  <decl_stmt><decl><type><name>Select</name> *</type><name>pSel</name></decl>;</decl_stmt>     <comment type="block">/* Copy of the SELECT that implements the view */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Number of errors encountered */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>            <comment type="block">/* Temporarily holds the number of cursors assigned */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Database connection for malloc errors */</comment>
  <function_decl><type><name>int</name></type> (*<name>xAuth</name>)<parameter_list>(<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*</type></decl></param>)</parameter_list>;</function_decl>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3VtabCallConnect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <comment type="block">/* A positive nCol means the columns names for this view are
  ** already known.
  */</comment>
  <if>if<condition>( <expr><name>pTable</name>-&gt;<name>nCol</name>&gt;0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* A negative nCol is a special marker meaning that we are currently
  ** trying to compute the column names.  If we enter this routine with
  ** a negative nCol, it means two or more views form a loop, like this:
  **
  **     CREATE VIEW one AS SELECT * FROM two;
  **     CREATE VIEW two AS SELECT * FROM one;
  **
  ** Actually, this error is caught previously and so the following test
  ** should always fail.  But we will leave it in place just to be safe.
  */</comment>
  <if>if<condition>( <expr><name>pTable</name>-&gt;<name>nCol</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"view %s is circularly defined"</expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>-&gt;<name>nCol</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we get this far, it means we need to compute the table names.
  ** Note that the call to sqlite3ResultSetOfSelect() will expand any
  ** "*" elements in the results set of the view and will assign cursors
  ** to the elements of the FROM clause.  But we do not want these changes
  ** to be permanent.  So the computation is done on a copy of the SELECT
  ** statement that defines the view.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>-&gt;<name>pSelect</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pSel</name> = <call><name>sqlite3SelectDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSel</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>n</name> = <name>pParse</name>-&gt;<name>nTab</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name>-&gt;<name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTable</name>-&gt;<name>nCol</name> = -1</expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <expr_stmt><expr><name>xAuth</name> = <name>db</name>-&gt;<name>xAuth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>xAuth</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pSelTab</name> = <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>xAuth</name> = <name>xAuth</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pSelTab</name> = <call><name>sqlite3ResultSetOfSelect</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>nTab</name> = <name>n</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pSelTab</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTable</name>-&gt;<name>aCol</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTable</name>-&gt;<name>nCol</name> = <name>pSelTab</name>-&gt;<name>nCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTable</name>-&gt;<name>aCol</name> = <name>pSelTab</name>-&gt;<name>aCol</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pSelTab</name>-&gt;<name>nCol</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pSelTab</name>-&gt;<name>aCol</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pSelTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTable</name>-&gt;<name>pSchema</name>-&gt;<name>flags</name> |= <name>DB_UnresetViews</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pTable</name>-&gt;<name>nCol</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>nErr</name>++</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><name>nErr</name>++</expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>
  <return>return <expr><name>nErr</name></expr>;</return>  
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
<comment type="block">/*
** Clear the column names from every VIEW in database idx.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqliteViewResetAll</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>idx</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>HashElem</name> *</type><name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>!<call><name>DbHasProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>DB_UnresetViews</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name></expr>;</condition><incr><expr><name>i</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqliteResetColumnNames</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><call><name>DbClearProperty</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>DB_UnresetViews</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <name>sqliteViewResetAll</name>(A,B)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIEW */</comment>

<comment type="block">/*
** This function is called by the VDBE to adjust the internal schema
** used by SQLite when the btree layer moves a table root page. The
** root-page of a table or index in database iDb has changed from iFrom
** to iTo.
**
** Ticket #1728:  The symbol table might still contain information
** on tables and/or indices that are the process of being deleted.
** If you are unlucky, one of those deleted indices or tables might
** have the same rootpage number as the real table or index that is
** being moved.  So we cannot stop searching after the first match 
** because the first match might be for one of the deleted indices
** or tables and not the table/index that is actually being moved.
** We must continue looping until all tables and indices with
** rootpage==iFrom have been converted to have a rootpage of iTo
** in order to be certain that we got the right one.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3RootPageMoved</name><parameter_list>(<param><decl><type><name>Db</name> *</type><name>pDb</name></decl></param>, <param><decl><type><name>int</name></type> <name>iFrom</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTo</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>HashElem</name> *</type><name>pElem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name> *</type><name>pHash</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pHash</name> = &amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>tblHash</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>pElem</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pTab</name>-&gt;<name>tnum</name>==<name>iFrom</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTab</name>-&gt;<name>tnum</name> = <name>iTo</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>pHash</name> = &amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>idxHash</name></expr>;</expr_stmt>
  <for>for(<init><expr><name>pElem</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pElem</name></expr>;</condition> <incr><expr><name>pElem</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name> =<init> <expr><call><name>sqliteHashData</name><argument_list>(<argument><expr><name>pElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>tnum</name>==<name>iFrom</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pIdx</name>-&gt;<name>tnum</name> = <name>iTo</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Write code to erase the table with root-page iTable from database iDb.
** Also write code to modify the sqlite_master table and internal schema
** if a root-page of another table is moved by the btree-layer whilst
** erasing iTable (this can happen with an auto-vacuum database).
*/</comment> 
<function><type><name>static</name> <name>void</name></type> <name>destroyRootPage</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iTable</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Destroy</name></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifndef>
  <comment type="block">/* OP_Destroy stores an in integer r1. If this integer
  ** is non-zero, then it is the root page number of a table moved to
  ** location iTable. The following code modifies the sqlite_master table to
  ** reflect this.
  **
  ** The "#%d" in the SQL is a special constant that means whatever value
  ** is on the top of the stack.  See sqlite3RegisterExpr().
  */</comment>
  <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
     <argument><expr>"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d"</expr></argument>,
     <argument><expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iTable</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Write VDBE code to erase table pTab and all associated indices on disk.
** Code to update the sqlite_master tables and internal schema definitions
** in case a root-page belonging to another table is moved by the btree layer
** is also added (this can happen with an auto-vacuum database).
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>destroyTable</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTOVACUUM</name></cpp:ifdef>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIdx</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM
  ** is not defined), then it is important to call OP_Destroy on the
  ** table and index root-pages in order, starting with the numerically 
  ** largest root-page number. This guarantees that none of the root-pages
  ** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the
  ** following were coded:
  **
  ** OP_Destroy 4 0
  ** ...
  ** OP_Destroy 5 0
  **
  ** and root page 5 happened to be the largest root-page number in the
  ** database, then root page 5 would be moved to page 4 by the 
  ** "OP_Destroy 4 0" opcode. The subsequent "OP_Destroy 5 0" would hit
  ** a free-list page.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> =<init> <expr><name>pTab</name>-&gt;<name>tnum</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDestroyed</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr>1</expr> )</condition><block>{
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iLargest</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

    <if>if<condition>( <expr><name>iDestroyed</name>==0 || <name>iTab</name>&lt;<name>iDestroyed</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>iLargest</name> = <name>iTab</name></expr>;</expr_stmt>
    }</block></then></if>
    <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> =<init> <expr><name>pIdx</name>-&gt;<name>tnum</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>pSchema</name>==<name>pTab</name>-&gt;<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr>(<name>iDestroyed</name>==0 || (<name>iIdx</name>&lt;<name>iDestroyed</name>)) &amp;&amp; <name>iIdx</name>&gt;<name>iLargest</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>iLargest</name> = <name>iIdx</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>iLargest</name>==0</expr> )</condition><then><block>{
      <return>return;</return>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iLargest</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iDestroyed</name> = <name>iLargest</name></expr>;</expr_stmt>
    }</block></else></if>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** This routine is called to do the work of a DROP TABLE statement.
** pName is the name of the table to be dropped.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DropTable</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pName</name></decl></param>, <param><decl><type><name>int</name></type> <name>isView</name></decl></param>, <param><decl><type><name>int</name></type> <name>noErr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>isView</name></expr></argument>, 
                            <argument><expr><name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>noErr</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorClear</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0 &amp;&amp; <name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pTab is a virtual table, call ViewGetColumnNames() to ensure
  ** it is initialized.
  */</comment>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>sqlite3ViewGetColumnNames</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name> =<init> <expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zArg2</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>)</condition><then><block>{
      <goto>goto <name>exit_drop_table</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><name>isView</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>iDb</name>==1</expr> )</condition><then><block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_TEMP_VIEW</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_VIEW</name></expr>;</expr_stmt>
      }</block></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    }</block></then><else>else <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_VTABLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zArg2</name> = <name>pTab</name>-&gt;<name>pMod</name>-&gt;<name>zName</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>iDb</name>==1</expr> )</condition><then><block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_TEMP_TABLE</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_TABLE</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zArg2</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_drop_table</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_drop_table</name>;</goto>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %s may not be dropped"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <comment type="block">/* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used
  ** on a table.
  */</comment>
  <if>if<condition>( <expr><name>isView</name> &amp;&amp; <name>pTab</name>-&gt;<name>pSelect</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"use DROP TABLE to delete table %s"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>isView</name> &amp;&amp; <name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"use DROP VIEW to delete view %s"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_table</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Generate code to remove the table from the master table
  ** on disk.
  */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Trigger</name> *</type><name>pTrigger</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name> =<init> <expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
    <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3VdbeAddOp0</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VBegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Drop all triggers associated with the table being dropped. Code
    ** is generated to remove entries from sqlite_master and/or
    ** sqlite_temp_master if required.
    */</comment>
    <expr_stmt><expr><name>pTrigger</name> = <name>pTab</name>-&gt;<name>pTrigger</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>pTrigger</name></expr> )</condition><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTrigger</name>-&gt;<name>pSchema</name>==<name>pTab</name>-&gt;<name>pSchema</name> || 
          <name>pTrigger</name>-&gt;<name>pSchema</name>==<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DropTriggerPtr</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTrigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTrigger</name> = <name>pTrigger</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    }</block></while>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTOINCREMENT</name></cpp:ifndef>
    <comment type="block">/* Remove any entries of the sqlite_sequence table associated with
    ** the table being dropped. This is done before the table is dropped
    ** at the btree level, in case the sqlite_sequence table needs to
    ** move as a result of the drop (can happen in auto-vacuum mode).
    */</comment>
    <if>if<condition>( <expr><name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Autoincrement</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr>"DELETE FROM %s.sqlite_sequence WHERE name=%Q"</expr></argument>,
        <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Drop all SQLITE_MASTER table and index entries that refer to the
    ** table. The program name loops through the master table and deletes
    ** every row that refers to a table of the same name as the one being
    ** dropped. Triggers are handled seperately because a trigger can be
    ** created in the temp database that refers to a table in another
    ** database.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'"</expr></argument>,
        <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Drop any statistics from the sqlite_stat1 table, if it exists */</comment>
    <if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_stat1"</expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr>"DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q"</expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr>!<name>isView</name> &amp;&amp; !<call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>destroyTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Remove the table entry from SQLite's internal schema and modify
    ** the schema cookie.
    */</comment>
    <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VDestroy</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropTable</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqliteViewResetAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_drop_table</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called to create a new foreign key on the table
** currently under construction.  pFromCol determines which columns
** in the current table point to the foreign key.  If pFromCol==0 then
** connect the key to the last column inserted.  pTo is the name of
** the table referred to.  pToCol is a list of tables in the other
** pTo table that the foreign key points to.  flags contains all
** information about the conflict resolution algorithms specified
** in the ON DELETE, ON UPDATE and ON INSERT clauses.
**
** An FKey structure is created and added to the table currently
** under construction in the pParse-&gt;pNewTable field.  The new FKey
** is not linked into db-&gt;aFKey at this point - that does not happen
** until sqlite3EndTable().
**
** The foreign key is set for IMMEDIATE processing.  A subsequent call
** to sqlite3DeferForeignKey() might change this to DEFERRED.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateForeignKey</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,       <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pFromCol</name></decl></param>,  <comment type="block">/* Columns in this table that point to other table */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTo</name></decl></param>,          <comment type="block">/* Name of the other table */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pToCol</name></decl></param>,    <comment type="block">/* Columns in the other table */</comment>
  <param><decl><type><name>int</name></type> <name>flags</name></decl></param>            <comment type="block">/* Conflict resolution algorithms. */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>FKey</name> *</type><name>pFKey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>p</name> =<init> <expr><name>pParse</name>-&gt;<name>pNewTable</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTo</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0 || <name>pParse</name>-&gt;<name>nErr</name> || <name>IN_DECLARE_VTAB</name></expr> )</condition><then> <goto>goto <name>fk_end</name>;</goto></then></if>
  <if>if<condition>( <expr><name>pFromCol</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name> =<init> <expr><name>p</name>-&gt;<name>nCol</name>-1</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>iCol</name>&lt;0</expr> )</condition><then> <goto>goto <name>fk_end</name>;</goto></then></if>
    <if>if<condition>( <expr><name>pToCol</name> &amp;&amp; <name>pToCol</name>-&gt;<name>nExpr</name>!=1</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"foreign key on %s"
         " should reference only one column of table %T"</expr></argument>,
         <argument><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pTo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>fk_end</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>nCol</name> = 1</expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>pToCol</name> &amp;&amp; <name>pToCol</name>-&gt;<name>nExpr</name>!=<name>pFromCol</name>-&gt;<name>nExpr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr>"number of columns in foreign key does not match the number of "
        "columns in the referenced table"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>fk_end</name>;</goto>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>nCol</name> = <name>pFromCol</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  }</block></else></if></else></if>
  <expr_stmt><expr><name>nByte</name> = <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pFKey</name></expr></argument>)</argument_list></call> + <name>nCol</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name>pFKey</name>-&gt;<name><name>aCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> + <name>pTo</name>-&gt;<name>n</name> + 1</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pToCol</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pToCol</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name>nByte</name> += <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pToCol</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><name>pFKey</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFKey</name>==0</expr> )</condition><then><block>{
    <goto>goto <name>fk_end</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>pFrom</name> = <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>pNextFrom</name> = <name>p</name>-&gt;<name>pFKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> = (<name>char</name>*)&amp;<name><name>pFKey</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>aCol</name> = (struct <name>sColMap</name>*)<name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> += <call><name>sizeof</name><argument_list>(<argument><expr>struct <name>sColMap</name></expr></argument>)</argument_list></call>*<name>nCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>zTo</name> = <name>z</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pTo</name>-&gt;<name>z</name></expr></argument>, <argument><expr><name>pTo</name>-&gt;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z</name><index>[<expr><name>pTo</name>-&gt;<name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>z</name> += <name>pTo</name>-&gt;<name>n</name>+1</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>pNextTo</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>nCol</name> = <name>nCol</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pFromCol</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pFKey</name>-&gt;<name><name>aCol</name><index>[<expr>0</expr>]</index></name>.<name>iFrom</name> = <name>p</name>-&gt;<name>nCol</name>-1</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>p</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>p</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pFromCol</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>pFKey</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iFrom</name> = <name>j</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>j</name>&gt;=<name>p</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
          <argument><expr>"unknown column \"%s\" in foreign key definition"</expr></argument>, 
          <argument><expr><name>pFromCol</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>fk_end</name>;</goto>
      }</block></then></if>
    }</block></for>
  }</block></else></if>
  <if>if<condition>( <expr><name>pToCol</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pToCol</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pFKey</name>-&gt;<name><name>aCol</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zCol</name> = <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>pToCol</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name> += <name>n</name>+1</expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>isDeferred</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>deleteConf</name> = (<name>u8</name>)(<name>flags</name> &amp; 0xff)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>updateConf</name> = (<name>u8</name>)((<name>flags</name> &gt;&gt; 8 ) &amp; 0xff)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>insertConf</name> = (<name>u8</name>)((<name>flags</name> &gt;&gt; 16 ) &amp; 0xff)</expr>;</expr_stmt>

  <comment type="block">/* Link the foreign key to the table as the last step.
  */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>pFKey</name> = <name>pFKey</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name> = 0</expr>;</expr_stmt>

<label><name>fk_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_OMIT_FOREIGN_KEY) */</comment>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pFromCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED
** clause is seen as part of a foreign key definition.  The isDeferred
** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.
** The behavior of the most recently created foreign key is adjusted
** accordingly.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DeferForeignKey</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>isDeferred</name></decl></param>)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FOREIGN_KEY</name></cpp:ifndef>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FKey</name> *</type><name>pFKey</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>(<name>pTab</name> = <name>pParse</name>-&gt;<name>pNewTable</name>)==0 || (<name>pFKey</name> = <name>pTab</name>-&gt;<name>pFKey</name>)==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isDeferred</name>==0 || <name>isDeferred</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pFKey</name>-&gt;<name>isDeferred</name> = (<name>u8</name>)<name>isDeferred</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** Generate code that will erase and refill index *pIdx.  This is
** used to initialize a newly created index or to recompute the
** content of an index in response to a REINDEX command.
**
** if memRootPage is not negative, it means that the index is newly
** created.  The register specified by memRootPage contains the
** root page number of the index.  If memRootPage is negative, then
** the index already exists and must be cleared before being refilled and
** the root page number of the index is taken from pIndex-&gt;tnum.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>sqlite3RefillIndex</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Index</name> *</type><name>pIndex</name></decl></param>, <param><decl><type><name>int</name></type> <name>memRootPage</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pIndex</name>-&gt;<name>pTable</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The table that is indexed */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iTab</name> =<init> <expr><name>pParse</name>-&gt;<name>nTab</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* Btree cursor used for pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iIdx</name> =<init> <expr><name>pParse</name>-&gt;<name>nTab</name>+1</expr></init></decl>;</decl_stmt>     <comment type="block">/* Btree cursor used for pIndex */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>addr1</name></decl>;</decl_stmt>                     <comment type="block">/* Address of top of loop */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tnum</name></decl>;</decl_stmt>                      <comment type="block">/* Root page of index */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>                       <comment type="block">/* Generate code into this virtual machine */</comment>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKey</name></decl>;</decl_stmt>                 <comment type="block">/* KeyInfo for index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regIdxKey</name></decl>;</decl_stmt>                 <comment type="block">/* Registers containing the index key */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>regRecord</name></decl>;</decl_stmt>                 <comment type="block">/* Register holding assemblied index record */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_REINDEX</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>,
      <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument> )</argument_list></call></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Require a write-lock on the table to perform this operation */</comment>
  <expr_stmt><expr><call><name>sqlite3TableLock</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>memRootPage</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>tnum</name> = <name>memRootPage</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>tnum</name> = <name>pIndex</name>-&gt;<name>tnum</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Clear</name></expr></argument>, <argument><expr><name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pKey</name> = <call><name>sqlite3IndexKeyinfo</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_OpenWrite</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, 
                    <argument><expr>(<name>char</name> *)<name>pKey</name></expr></argument>, <argument><expr><name>P4_KEYINFO_HANDOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>memRootPage</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeChangeP5</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3OpenTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>OP_OpenRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>addr1</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Rewind</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regRecord</name> = <call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>regIdxKey</name> = <call><name>sqlite3GenerateIndexKey</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIndex</name>-&gt;<name>onError</name>!=<name>OE_None</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j1</name>, <name>j2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>regRowid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>regRowid</name> = <name>regIdxKey</name> + <name>pIndex</name>-&gt;<name>nColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsNull</name></expr></argument>, <argument><expr><name>regIdxKey</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>nColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j2</name> = <call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IsUnique</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>,
                           <argument><expr>0</expr></argument>, <argument><expr><name>regRowid</name></expr></argument>, <argument><expr><call><name>SQLITE_INT_TO_PTR</name><argument_list>(<argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_INT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Halt</name></expr></argument>, <argument><expr><name>SQLITE_CONSTRAINT</name></expr></argument>, <argument><expr><name>OE_Abort</name></expr></argument>, <argument><expr>0</expr></argument>,
                    <argument><expr>"indexed columns are not unique"</expr></argument>, <argument><expr><name>P4_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_IdxInsert</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>regRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Next</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>, <argument><expr><name>addr1</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>addr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Close</name></expr></argument>, <argument><expr><name>iIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Create a new index for an SQL table.  pName1.pName2 is the name of the index 
** and pTblList is the name of the table that is to be indexed.  Both will 
** be NULL for a primary key or an index that is created to satisfy a
** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse-&gt;pNewTable
** as the table to be indexed.  pParse-&gt;pNewTable is a table that is
** currently being constructed by a CREATE TABLE statement.
**
** pList is a list of columns to be indexed.  pList will be NULL if this
** is a primary key or unique-constraint on the most recent column added
** to the table currently under construction.  
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CreateIndex</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,     <comment type="block">/* All information about this parse */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,     <comment type="block">/* First part of index name. May be NULL */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,     <comment type="block">/* Second part of index name. May be NULL */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pTblName</name></decl></param>, <comment type="block">/* Table to index. Use pParse-&gt;pNewTable if 0 */</comment>
  <param><decl><type><name>ExprList</name> *</type><name>pList</name></decl></param>,   <comment type="block">/* A list of columns to be indexed */</comment>
  <param><decl><type><name>int</name></type> <name>onError</name></decl></param>,       <comment type="block">/* OE_Abort, OE_Ignore, OE_Replace, or OE_None */</comment>
  <param><decl><type><name>Token</name> *</type><name>pStart</name></decl></param>,     <comment type="block">/* The CREATE token that begins this statement */</comment>
  <param><decl><type><name>Token</name> *</type><name>pEnd</name></decl></param>,       <comment type="block">/* The ")" that closes the CREATE INDEX statement */</comment>
  <param><decl><type><name>int</name></type> <name>sortOrder</name></decl></param>,     <comment type="block">/* Sort order of primary key when pList==NULL */</comment>
  <param><decl><type><name>int</name></type> <name>ifNotExist</name></decl></param>     <comment type="block">/* Omit error if index already exists */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Table to be indexed */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* The index to be created */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Name of the index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>           <comment type="block">/* Number of characters in zName */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name></type> <name>nullId</name></decl>;</decl_stmt>        <comment type="block">/* Fake token for an empty ID list */</comment>
  <decl_stmt><decl><type><name>DbFixer</name></type> <name>sFix</name></decl>;</decl_stmt>        <comment type="block">/* For assigning database names to pTable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sortOrderMask</name></decl>;</decl_stmt>   <comment type="block">/* 1 to honor DESC in index.  0 to ignore. */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>             <comment type="block">/* The specific table containing the indexed database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>             <comment type="block">/* Index of the database that is being written */</comment>
  <decl_stmt><decl><type><name>Token</name> *</type><name>pName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Unqualified name of the index to create */</comment>
  <decl_stmt><decl><type>struct <name>ExprList_item</name> *</type><name>pListItem</name></decl>;</decl_stmt> <comment type="block">/* For looping over pList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nExtra</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zExtra</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name> || <name>IN_DECLARE_VTAB</name></expr> )</condition><then><block>{
    <goto>goto <name>exit_create_index</name>;</goto>
  }</block></then></if>

  <comment type="block">/*
  ** Find the table that is to be indexed.  Return early if not found.
  */</comment>
  <if>if<condition>( <expr><name>pTblName</name>!=0</expr> )</condition><then><block>{

    <comment type="block">/* Use the two-part index name to determine the database 
    ** to search for the table. 'Fix' the table name to this db
    ** before looking up the table.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName1</name> &amp;&amp; <name>pName2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>&amp;<name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TEMPDB</name></cpp:ifndef>
    <comment type="block">/* If the index name was unqualified, check if the the table
    ** is a temp table. If so, set the database to 1. Do not do this
    ** if initialising a database schema.
    */</comment>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3SrcListLookup</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pName2</name> &amp;&amp; <name>pName2</name>-&gt;<name>n</name>==0 &amp;&amp; <name>pTab</name> &amp;&amp; <name>pTab</name>-&gt;<name>pSchema</name>==<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>iDb</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if<condition>( <expr><call><name>sqlite3FixInit</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>"index"</expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call> &amp;&amp;
        <call><name>sqlite3FixSrcList</name><argument_list>(<argument><expr>&amp;<name>sFix</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr>
    )</condition><then><block>{
      <comment type="block">/* Because the parser constructs pTblName from a single identifier,
      ** sqlite3FixSrcList can never fail. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3LocateTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pTblName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>, 
        <argument><expr><name>pTblName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pTab</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>==<name>pTab</name>-&gt;<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>pTab</name></expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pDb</name> = &amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pTab</name>==0 || <name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
  <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>"sqlite_"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %s may not be indexed"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  }</block></then></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIEW</name></cpp:ifndef>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"views may not be indexed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <if>if<condition>( <expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"virtual tables may not be indexed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_create_index</name>;</goto>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/*
  ** Find the name of the index.  Make sure there is not already another
  ** index or table with the same name.  
  **
  ** Exception:  If we are reading the names of permanent indices from the
  ** sqlite_master table (because some other process changed the schema) and
  ** one of the index names collides with the name of a temporary table or
  ** index, then we will continue to process this index.
  **
  ** If pName==0 it means that we are
  ** dealing with a primary key or UNIQUE constraint.  We have to invent our
  ** own name.
  */</comment>
  <if>if<condition>( <expr><name>pName</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
    <if>if<condition>( <expr><name>zName</name>==0</expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
    <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3CheckObjectName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
      <if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"there is already a table named %s"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>exit_create_index</name>;</goto>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>!=0</expr> )</condition><then><block>{
      <if>if<condition>( <expr>!<name>ifNotExist</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"index %s already exists"</expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pLoop</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>pLoop</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>, <expr><name>n</name>=1</expr>;</init> <condition><expr><name>pLoop</name></expr>;</condition> <incr><expr><name>pLoop</name>=<name>pLoop</name>-&gt;<name>pNext</name></expr>, <expr><name>n</name>++</expr></incr>)<block>{}</block></for>
    <expr_stmt><expr><name>zName</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_autoindex_%s_%d"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zName</name>==0</expr> )</condition><then><block>{
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
  }</block></else></if>

  <comment type="block">/* Check for authorization to create an index.
  */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>pDb</name>-&gt;<name>zName</name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_INSERT</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>i</name> = <name>SQLITE_CREATE_INDEX</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>iDb</name>==1</expr> )</condition><then> <expr_stmt><expr><name>i</name> = <name>SQLITE_CREATE_TEMP_INDEX</name></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If pList==0, it means this routine was called to make a primary
  ** key out of the last column added to the table under construction.
  ** So create a fake list to simulate this.
  */</comment>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>nullId</name>.<name>z</name> = (<name>u8</name>*)<name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>pTab</name>-&gt;<name>nCol</name>-1</expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nullId</name>.<name>n</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr>(<name>char</name>*)<name>nullId</name>.<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pList</name> = <call><name>sqlite3ExprListAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>nullId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>
    <expr_stmt><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>sortOrder</name> = (<name>u8</name>)<name>sortOrder</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Figure out how many bytes of space are required to store explicitly
  ** specified collation sequence names.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>Expr</name> *</type><name>pExpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>
    <if>if<condition>( <expr>(<name>pExpr</name> = <name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pExpr</name>)!=0 &amp;&amp; (<name>pColl</name> = <name>pExpr</name>-&gt;<name>pColl</name>)!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>nExtra</name> += (1 + <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pColl</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>

  <comment type="block">/* 
  ** Allocate the index structure. 
  */</comment>
  <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nCol</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
      <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call> +              <comment type="block">/* Index structure  */</comment>
      <call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>*<name>nCol</name> +           <comment type="block">/* Index.aiColumn   */</comment>
      <call><name>sizeof</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call>*(<name>nCol</name>+1) +       <comment type="block">/* Index.aiRowEst   */</comment>
      <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call>*<name>nCol</name> +        <comment type="block">/* Index.azColl     */</comment>
      <call><name>sizeof</name><argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></call>*<name>nCol</name> +            <comment type="block">/* Index.aSortOrder */</comment>
      <name>nName</name> + 1 +                  <comment type="block">/* Index.zName      */</comment>
      <name>nExtra</name></expr></argument>                       <comment type="block">/* Collation sequence names */</comment>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>exit_create_index</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>azColl</name> = (<name>char</name>**)(&amp;<name><name>pIndex</name><index>[<expr>1</expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>aiColumn</name> = (<name>int</name> *)(&amp;<name>pIndex</name>-&gt;<name><name>azColl</name><index>[<expr><name>nCol</name></expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>aiRowEst</name> = (<name>unsigned</name> *)(&amp;<name>pIndex</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>nCol</name></expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>aSortOrder</name> = (<name>u8</name> *)(&amp;<name>pIndex</name>-&gt;<name><name>aiRowEst</name><index>[<expr><name>nCol</name>+1</expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>zName</name> = (<name>char</name> *)(&amp;<name>pIndex</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>nCol</name></expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>zExtra</name> = (<name>char</name> *)(&amp;<name>pIndex</name>-&gt;<name><name>zName</name><index>[<expr><name>nName</name>+1</expr>]</index></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>pTable</name> = <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>nColumn</name> = <name>pList</name>-&gt;<name>nExpr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>onError</name> = (<name>u8</name>)<name>onError</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>autoIndex</name> = (<name>u8</name>)(<name>pName</name>==0)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pIndex</name>-&gt;<name>pSchema</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name></expr>;</expr_stmt>

  <comment type="block">/* Check to see if we should honor DESC requests on index columns
  */</comment>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>file_format</name>&gt;=4</expr> )</condition><then><block>{
    <expr_stmt><expr><name>sortOrderMask</name> = -1</expr>;</expr_stmt>   <comment type="block">/* Honor DESC */</comment>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>sortOrderMask</name> = 0</expr>;</expr_stmt>    <comment type="block">/* Ignore DESC */</comment>
  }</block></else></if>

  <comment type="block">/* Scan the names of the columns of the table to be indexed and
  ** load the column indices into the Index structure.  Report an error
  ** if any column is not found.
  */</comment>
  <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pListItem</name>=<name>pList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nExpr</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pListItem</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zColName</name> =<init> <expr><name>pListItem</name>-&gt;<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Column</name> *</type><name>pTabCol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>requestedSortOrder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zColl</name></decl>;</decl_stmt>                   <comment type="block">/* Collation sequence name */</comment>

    <for>for(<init><expr><name>j</name>=0</expr>, <expr><name>pTabCol</name>=<name>pTab</name>-&gt;<name>aCol</name></expr>;</init> <condition><expr><name>j</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>pTabCol</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>zColName</name></expr></argument>, <argument><expr><name>pTabCol</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <break>break;</break></then></if>
    }</block></for>
    <if>if<condition>( <expr><name>j</name>&gt;=<name>pTab</name>-&gt;<name>nCol</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"table %s has no column named %s"</expr></argument>,
        <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
    <comment type="block">/* TODO:  Add a test to make sure that the same column is not named
    ** more than once within the same index.  Only the first instance of
    ** the column will ever be used by the optimizer.  Note that using the
    ** same column more than once cannot be an error because that would 
    ** break backwards compatibility - it needs to be a warning.
    */</comment>
    <expr_stmt><expr><name>pIndex</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>i</name></expr>]</index></name> = <name>j</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pListItem</name>-&gt;<name>pExpr</name> &amp;&amp; <name>pListItem</name>-&gt;<name>pExpr</name>-&gt;<name>pColl</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pListItem</name>-&gt;<name>pExpr</name>-&gt;<name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zColl</name> = <name>zExtra</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nExtra</name></expr></argument>, <argument><expr><name>zExtra</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pListItem</name>-&gt;<name>pExpr</name>-&gt;<name>pColl</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zExtra</name> += (<call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>)</argument_list></call> + 1)</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>zColl</name> = <name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>j</name></expr>]</index></name>.<name>zColl</name></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>zColl</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zColl</name> = <name>db</name>-&gt;<name>pDfltColl</name>-&gt;<name>zName</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
    <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name> &amp;&amp; !<call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>pIndex</name>-&gt;<name><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name> = <name>zColl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>requestedSortOrder</name> = <name>pListItem</name>-&gt;<name>sortOrder</name> &amp; <name>sortOrderMask</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIndex</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>u8</name>)<name>requestedSortOrder</name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DefaultRowEst</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pTab</name>==<name>pParse</name>-&gt;<name>pNewTable</name></expr> )</condition><then><block>{
    <comment type="block">/* This routine has been called to create an automatic index as a
    ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or
    ** a PRIMARY KEY or UNIQUE clause following the column definitions.
    ** i.e. one of:
    **
    ** CREATE TABLE t(x PRIMARY KEY, y);
    ** CREATE TABLE t(x, y, UNIQUE(x, y));
    **
    ** Either way, check to see if the table already has such an index. If
    ** so, don't bother creating this one. This only applies to
    ** automatically created indices. Users can do as they wish with
    ** explicit indices.
    */</comment>
    <decl_stmt><decl><type><name>Index</name> *</type><name>pIdx</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>pIdx</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIdx</name></expr>;</condition> <incr><expr><name>pIdx</name>=<name>pIdx</name>-&gt;<name>pNext</name></expr></incr>)<block>{
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>onError</name>!=<name>OE_None</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIdx</name>-&gt;<name>autoIndex</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIndex</name>-&gt;<name>onError</name>!=<name>OE_None</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

      <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>nColumn</name>!=<name>pIndex</name>-&gt;<name>nColumn</name></expr> )</condition><then> <continue>continue;</continue></then></if>
      <for>for(<init><expr><name>k</name>=0</expr>;</init> <condition><expr><name>k</name>&lt;<name>pIdx</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z1</name> =<init> <expr><name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name> =<init> <expr><name>pIndex</name>-&gt;<name><name>azColl</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>pIdx</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name>!=<name>pIndex</name>-&gt;<name><name>aiColumn</name><index>[<expr><name>k</name></expr>]</index></name></expr> )</condition><then> <break>break;</break></then></if>
        <if>if<condition>( <expr><name>pIdx</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>k</name></expr>]</index></name>!=<name>pIndex</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>k</name></expr>]</index></name></expr> )</condition><then> <break>break;</break></then></if>
        <if>if<condition>( <expr><name>z1</name>!=<name>z2</name> &amp;&amp; <call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr> )</condition><then> <break>break;</break></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>k</name>==<name>pIdx</name>-&gt;<name>nColumn</name></expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>onError</name>!=<name>pIndex</name>-&gt;<name>onError</name></expr> )</condition><then><block>{
          <comment type="block">/* This constraint creates the same index as a previous
          ** constraint specified somewhere in the CREATE TABLE statement.
          ** However the ON CONFLICT clauses are different. If both this 
          ** constraint and the previous equivalent constraint have explicit
          ** ON CONFLICT clauses this is an error. Otherwise, use the
          ** explicitly specified behaviour for the index.
          */</comment>
          <if>if<condition>( <expr>!(<name>pIdx</name>-&gt;<name>onError</name>==<name>OE_Default</name> || <name>pIndex</name>-&gt;<name>onError</name>==<name>OE_Default</name>)</expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
                <argument><expr>"conflicting ON CONFLICT clauses specified"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>onError</name>==<name>OE_Default</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pIdx</name>-&gt;<name>onError</name> = <name>pIndex</name>-&gt;<name>onError</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
        <goto>goto <name>exit_create_index</name>;</goto>
      }</block></then></if>
    }</block></for>
  }</block></then></if>

  <comment type="block">/* Link the new Index structure to its table and to the other
  ** in-memory database structures. 
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Index</name> *</type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>p</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pIndex</name>-&gt;<name>pSchema</name>-&gt;<name>idxHash</name></expr></argument>, 
                          <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>+1</expr></argument>,
                          <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>p</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>==<name>pIndex</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed */</comment>
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <goto>goto <name>exit_create_index</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>db</name>-&gt;<name>flags</name> |= <name>SQLITE_InternChanges</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pTblName</name>!=0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pIndex</name>-&gt;<name>tnum</name> = <name>db</name>-&gt;<name>init</name>.<name>newTnum</name></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then>

  <comment type="block">/* If the db-&gt;init.busy is 0 then create the index on disk.  This
  ** involves writing the index into the master table and filling in the
  ** index with the current table contents.
  **
  ** The db-&gt;init.busy is 0 when the user first enters a CREATE INDEX 
  ** command.  db-&gt;init.busy is 1 when a database is opened and 
  ** CREATE INDEX statements are read out of the master table.  In
  ** the latter case the index already exists on disk, which is why
  ** we don't want to recreate it.
  **
  ** If pTblName==0 it means this index is generated as a primary key
  ** or UNIQUE constraint of a CREATE TABLE statement.  Since the table
  ** has just been created, it contains no data and the index initialization
  ** step can be skipped.
  */</comment>
  <else>else <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iMem</name> =<init> <expr>++<name>pParse</name>-&gt;<name>nMem</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <goto>goto <name>exit_create_index</name>;</goto></then></if>


    <comment type="block">/* Create the rootpage for the index
    */</comment>
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_CreateIndex</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Gather the complete text of the CREATE INDEX statement into
    ** the zStmt variable
    */</comment>
    <if>if<condition>( <expr><name>pStart</name> &amp;&amp; <name>pEnd</name></expr> )</condition><then><block>{
      <comment type="block">/* A named index with an explicit CREATE INDEX statement */</comment>
      <expr_stmt><expr><name>zStmt</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"CREATE%s INDEX %.*s"</expr></argument>,
        <argument><expr><name>onError</name>==<name>OE_None</name> ? "" : " UNIQUE"</expr></argument>,
        <argument><expr><name>pEnd</name>-&gt;<name>z</name> - <name>pName</name>-&gt;<name>z</name> + 1</expr></argument>,
        <argument><expr><name>pName</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* An automatic index created by a PRIMARY KEY or UNIQUE constraint */</comment>
      <comment type="block">/* zStmt = sqlite3MPrintf(""); */</comment>
      <expr_stmt><expr><name>zStmt</name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Add an entry in sqlite_master for this index
    */</comment>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, 
        <argument><expr>"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);"</expr></argument>,
        <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>,
        <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>,
        <argument><expr><name>iMem</name></expr></argument>,
        <argument><expr><name>zStmt</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fill the index with data and reparse the schema. Code an OP_Expire
    ** to invalidate all pre-compiled statements.
    */</comment>
    <if>if<condition>( <expr><name>pTblName</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr><name>iMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
         <argument><expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"name='%q'"</expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Expire</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if></else></if>

  <comment type="block">/* When adding an index to the list of indices for a table, make
  ** sure all indices labeled OE_Replace come after all those labeled
  ** OE_Ignore.  This is necessary for the correct operation of UPDATE
  ** and INSERT.
  */</comment>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>init</name>.<name>busy</name> || <name>pTblName</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>onError</name>!=<name>OE_Replace</name> || <name>pTab</name>-&gt;<name>pIndex</name>==0
         || <name>pTab</name>-&gt;<name>pIndex</name>-&gt;<name>onError</name>==<name>OE_Replace</name></expr>)</condition><then><block>{
      <expr_stmt><expr><name>pIndex</name>-&gt;<name>pNext</name> = <name>pTab</name>-&gt;<name>pIndex</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>pIndex</name> = <name>pIndex</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>Index</name> *</type><name>pOther</name> =<init> <expr><name>pTab</name>-&gt;<name>pIndex</name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>pOther</name>-&gt;<name>pNext</name> &amp;&amp; <name>pOther</name>-&gt;<name>pNext</name>-&gt;<name>onError</name>!=<name>OE_Replace</name></expr> )</condition><block>{
        <expr_stmt><expr><name>pOther</name> = <name>pOther</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      }</block></while>
      <expr_stmt><expr><name>pIndex</name>-&gt;<name>pNext</name> = <name>pOther</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pOther</name>-&gt;<name>pNext</name> = <name>pIndex</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>pIndex</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Clean up before exiting */</comment>
<label><name>exit_create_index</name>:</label>
  <if>if<condition>( <expr><name>pIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>freeIndex</name><argument_list>(<argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3ExprListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTblName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>

<comment type="block">/*
** Generate code to make sure the file format number is at least minFormat.
** The generated code will increase the file format number if necessary.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3MinimumFileFormat</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>int</name></type> <name>minFormat</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>r1</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>r2</name> =<init> <expr><call><name>sqlite3GetTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j1</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ReadCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Integer</name></expr></argument>, <argument><expr><name>minFormat</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j1</name> = <call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Ge</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp3</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_SetCookie</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeJumpHere</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>j1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ReleaseTempReg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Fill the Index.aiRowEst[] array with default information - information
** to be used when we have not run the ANALYZE command.
**
** aiRowEst[0] is suppose to contain the number of elements in the index.
** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the
** number of rows in the table that match any particular value of the
** first column of the index.  aiRowEst[2] is an estimate of the number
** of rows that match any particular combiniation of the first 2 columns
** of the index.  And so forth.  It must always be the case that
*
**           aiRowEst[N]&lt;=aiRowEst[N-1]
**           aiRowEst[N]&gt;=1
**
** Apart from that, we have little to go on besides intuition as to
** how aiRowEst[] should be initialized.  The numbers generated here
** are based on typical values found in actual indices.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DefaultRowEst</name><parameter_list>(<param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>unsigned</name> *</type><name>a</name> =<init> <expr><name>pIdx</name>-&gt;<name>aiRowEst</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>a</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>a</name><index>[<expr>0</expr>]</index></name> = 1000000</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>pIdx</name>-&gt;<name>nColumn</name></expr>;</init> <condition><expr><name>i</name>&gt;=5</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = 5</expr>;</expr_stmt>
  }</block></for>
  <while>while<condition>( <expr><name>i</name>&gt;=1</expr> )</condition><block>{
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> = 11 - <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><name>pIdx</name>-&gt;<name>onError</name>!=<name>OE_None</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name><name>a</name><index>[<expr><name>pIdx</name>-&gt;<name>nColumn</name></expr>]</index></name> = 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** This routine will drop an existing named index.  This routine
** implements the DROP INDEX statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3DropIndex</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pName</name></decl></param>, <param><decl><type><name>int</name></type> <name>ifExists</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <goto>goto <name>exit_drop_index</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName</name>-&gt;<name>nSrc</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <goto>goto <name>exit_drop_index</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>pIndex</name> = <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pName</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIndex</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr>!<name>ifExists</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such index: %S"</expr></argument>, <argument><expr><name>pName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>checkSchema</name> = 1</expr>;</expr_stmt>
    <goto>goto <name>exit_drop_index</name>;</goto>
  }</block></then></if>
  <if>if<condition>( <expr><name>pIndex</name>-&gt;<name>autoIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"index associated with UNIQUE "
      "or PRIMARY KEY constraint cannot be dropped"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>exit_drop_index</name>;</goto>
  }</block></then></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>code</name> =<init> <expr><name>SQLITE_DROP_INDEX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name> =<init> <expr><name>pIndex</name>-&gt;<name>pTable</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name> =<init> <expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_DELETE</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_drop_index</name>;</goto>
    }</block></then></if>
    <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>iDb</name></expr> )</condition><then> <expr_stmt><expr><name>code</name> = <name>SQLITE_DROP_TEMP_INDEX</name></expr>;</expr_stmt></then></if>
    <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <goto>goto <name>exit_drop_index</name>;</goto>
    }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Generate code to remove the index and from the master table */</comment>
  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
       <argument><expr>"DELETE FROM %Q.%s WHERE name=%Q"</expr></argument>,
       <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"sqlite_stat1"</expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
        <argument><expr>"DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q"</expr></argument>,
        <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>destroyRootPage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>tnum</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_DropIndex</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pIndex</name>-&gt;<name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

<label><name>exit_drop_index</name>:</label>
  <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** pArray is a pointer to an array of objects.  Each object in the
** array is szEntry bytes in size.  This routine allocates a new
** object on the end of the array.
**
** *pnEntry is the number of entries already in use.  *pnAlloc is
** the previously allocated size of the array.  initSize is the
** suggested initial array size allocation.
**
** The index of the new entry is returned in *pIdx.
**
** This routine returns a pointer to the array of objects.  This
** might be the same as the pArray parameter or it might be a different
** pointer if the array was resized.
*/</comment>
<function><type><name>void</name> *</type><name>sqlite3ArrayAllocate</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,      <comment type="block">/* Connection to notify of malloc failures */</comment>
  <param><decl><type><name>void</name> *</type><name>pArray</name></decl></param>,     <comment type="block">/* Array of objects.  Might be reallocated */</comment>
  <param><decl><type><name>int</name></type> <name>szEntry</name></decl></param>,      <comment type="block">/* Size of each object in the array */</comment>
  <param><decl><type><name>int</name></type> <name>initSize</name></decl></param>,     <comment type="block">/* Suggested initial allocation, in elements */</comment>
  <param><decl><type><name>int</name> *</type><name>pnEntry</name></decl></param>,     <comment type="block">/* Number of objects currently in use */</comment>
  <param><decl><type><name>int</name> *</type><name>pnAlloc</name></decl></param>,     <comment type="block">/* Current size of the allocation, in elements */</comment>
  <param><decl><type><name>int</name> *</type><name>pIdx</name></decl></param>         <comment type="block">/* Write the index of a new slot here */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <if>if<condition>( <expr>*<name>pnEntry</name> &gt;= *<name>pnAlloc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>newSize</name> = (*<name>pnAlloc</name>)*2 + <name>initSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>newSize</name>*<name>szEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pIdx</name> = -1</expr>;</expr_stmt>
      <return>return <expr><name>pArray</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>pnAlloc</name> = <call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call>/<name>szEntry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pArray</name> = <name>pNew</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>z</name> = (<name>char</name>*)<name>pArray</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>z</name><index>[<expr>*<name>pnEntry</name> * <name>szEntry</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>szEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pIdx</name> = *<name>pnEntry</name></expr>;</expr_stmt>
  <expr_stmt><expr>++*<name>pnEntry</name></expr>;</expr_stmt>
  <return>return <expr><name>pArray</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Append a new element to the given IdList.  Create a new IdList if
** need be.
**
** A new IdList is returned, or NULL if malloc() fails.
*/</comment>
<function><type><name>IdList</name> *</type><name>sqlite3IdListAppend</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>IdList</name> *</type><name>pList</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pToken</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pList</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>IdList</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>pList</name>-&gt;<name>nAlloc</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pList</name>-&gt;<name>a</name> = <call><name>sqlite3ArrayAllocate</name><argument_list>(
      <argument><expr><name>db</name></expr></argument>,
      <argument><expr><name>pList</name>-&gt;<name>a</name></expr></argument>,
      <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr>5</expr></argument>,
      <argument><expr>&amp;<name>pList</name>-&gt;<name>nId</name></expr></argument>,
      <argument><expr>&amp;<name>pList</name>-&gt;<name>nAlloc</name></expr></argument>,
      <argument><expr>&amp;<name>i</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>i</name>&lt;0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Delete an IdList.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3IdListDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>IdList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nId</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name>-&gt;<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Return the index in pList of the identifier named zId.  Return -1
** if not found.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IdListIndex</name><parameter_list>(<param><decl><type><name>IdList</name> *</type><name>pList</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return <expr>-1</expr>;</return></then></if>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nId</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then> <return>return <expr><name>i</name></expr>;</return></then></if>
  }</block></for>
  <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/*
** Expand the space allocated for the given SrcList object by
** creating nExtra new slots beginning at iStart.  iStart is zero based.
** New slots are zeroed.
**
** For example, suppose a SrcList initially contains two entries: A,B.
** To append 3 new entries onto the end, do this:
**
**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);
**
** After the call above it would contain:  A, B, nil, nil, nil.
** If the iStart argument had been 1 instead of 2, then the result
** would have been:  A, nil, nil, nil, B.  To prepend the new slots,
** the iStart value would be 0.  The result then would
** be: nil, nil, nil, A, B.
**
** If a memory allocation fails the SrcList is unchanged.  The
** db-&gt;mallocFailed flag will be set to true.
*/</comment>
<function><type><name>SrcList</name> *</type><name>sqlite3SrcListEnlarge</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,       <comment type="block">/* Database connection to notify of OOM errors */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pSrc</name></decl></param>,     <comment type="block">/* The SrcList to be enlarged */</comment>
  <param><decl><type><name>int</name></type> <name>nExtra</name></decl></param>,        <comment type="block">/* Number of new slots to add to pSrc-&gt;a[] */</comment>
  <param><decl><type><name>int</name></type> <name>iStart</name></decl></param>         <comment type="block">/* Index in pSrc-&gt;a[] of first new slot */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity checking on calling parameters */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStart</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nExtra</name>&gt;=1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pSrc</name>==0 || <name>iStart</name>&gt;<name>pSrc</name>-&gt;<name>nSrc</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pSrc</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Allocate additional space if needed */</comment>
  <if>if<condition>( <expr><name>pSrc</name>-&gt;<name>nSrc</name>+<name>nExtra</name>&gt;<name>pSrc</name>-&gt;<name>nAlloc</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>SrcList</name> *</type><name>pNew</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> =<init> <expr><name>pSrc</name>-&gt;<name>nSrc</name>+<name>nExtra</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nGot</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSrc</name></expr></argument>,
               <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pSrc</name></expr></argument>)</argument_list></call> + (<name>nAlloc</name>-1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>pSrc</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pSrc</name> = <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nGot</name> = (<call><name>sqlite3DbMallocSize</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call> - <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pSrc</name></expr></argument>)</argument_list></call>)/<call><name>sizeof</name><argument_list>(<argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>+1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pSrc</name>-&gt;<name>nAlloc</name> = (<name>u16</name>)<name>nGot</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Move existing slots that come after the newly inserted slots
  ** out of the way */</comment>
  <for>for(<init><expr><name>i</name>=<name>pSrc</name>-&gt;<name>nSrc</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;=<name>iStart</name></expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
    <expr_stmt><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name>+<name>nExtra</name></expr>]</index></name> = <name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>pSrc</name>-&gt;<name>nSrc</name> += (<name>i16</name>)<name>nExtra</name></expr>;</expr_stmt>

  <comment type="block">/* Zero the newly allocated slots */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*<name>nExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=<name>iStart</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>iStart</name>+<name>nExtra</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <expr_stmt><expr><name>pSrc</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iCursor</name> = -1</expr>;</expr_stmt>
  }</block></for>

  <comment type="block">/* Return a pointer to the enlarged SrcList */</comment>
  <return>return <expr><name>pSrc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Append a new table name to the given SrcList.  Create a new SrcList if
** need be.  A new entry is created in the SrcList even if pToken is NULL.
**
** A SrcList is returned, or NULL if there is an OOM error.  The returned
** SrcList might be the same as the SrcList that was input or it might be
** a new one.  If an OOM error does occurs, then the prior value of pList
** that is input to this routine is automatically freed.
**
** If pDatabase is not null, it means that the table has an optional
** database name prefix.  Like this:  "database.table".  The pDatabase
** points to the table name and the pTable points to the database name.
** The SrcList.a[].zName field is filled with the table name which might
** come from pTable (if pDatabase is NULL) or from pDatabase.  
** SrcList.a[].zDatabase is filled with the database name from pTable,
** or with NULL if no database is specified.
**
** In other words, if call like this:
**
**         sqlite3SrcListAppend(D,A,B,0);
**
** Then B is a table name and the database name is unspecified.  If called
** like this:
**
**         sqlite3SrcListAppend(D,A,B,C);
**
** Then C is the table name and B is the database name.
*/</comment>
<function><type><name>SrcList</name> *</type><name>sqlite3SrcListAppend</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,        <comment type="block">/* Connection to notify of malloc failures */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>pList</name></decl></param>,     <comment type="block">/* Append to this SrcList. NULL creates a new SrcList */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTable</name></decl></param>,      <comment type="block">/* Table to append */</comment>
  <param><decl><type><name>Token</name> *</type><name>pDatabase</name></decl></param>    <comment type="block">/* Database of the table */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pList</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>SrcList</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    <expr_stmt><expr><name>pList</name>-&gt;<name>nAlloc</name> = 1</expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pList</name> = <call><name>sqlite3SrcListEnlarge</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pList</name>-&gt;<name>nSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3SrcListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pItem</name> = &amp;<name>pList</name>-&gt;<name><name>a</name><index>[<expr><name>pList</name>-&gt;<name>nSrc</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pDatabase</name> &amp;&amp; <name>pDatabase</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pDatabase</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDatabase</name> &amp;&amp; <name>pTable</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Token</name> *</type><name>pTemp</name> =<init> <expr><name>pDatabase</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDatabase</name> = <name>pTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTable</name> = <name>pTemp</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>zName</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>zDatabase</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pList</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Assign VdbeCursor index numbers to all tables in a SrcList
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListAssignCursors</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pList</name> || <name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pList</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>iCursor</name>&gt;=0</expr> )</condition><then> <break>break;</break></then></if>
      <expr_stmt><expr><name>pItem</name>-&gt;<name>iCursor</name> = <name>pParse</name>-&gt;<name>nTab</name>++</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>pItem</name>-&gt;<name>pSelect</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3SrcListAssignCursors</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pSelect</name>-&gt;<name>pSrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Delete an entire SrcList including all its substructure.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListDelete</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>pList</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pList</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <for>for(<init><expr><name>pItem</name>=<name>pList</name>-&gt;<name>a</name></expr>, <expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pList</name>-&gt;<name>nSrc</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>pItem</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>zIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>pItem</name>-&gt;<name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pItem</name>-&gt;<name>pUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called by the parser to add a new term to the
** end of a growing FROM clause.  The "p" parameter is the part of
** the FROM clause that has already been constructed.  "p" is NULL
** if this is the first term of the FROM clause.  pTable and pDatabase
** are the name of the table and database named in the FROM clause term.
** pDatabase is NULL if the database name qualifier is missing - the
** usual case.  If the term has a alias, then pAlias points to the
** alias token.  If the term is a subquery, then pSubquery is the
** SELECT statement that the subquery encodes.  The pTable and
** pDatabase parameters are NULL for subqueries.  The pOn and pUsing
** parameters are the content of the ON and USING clauses.
**
** Return a new SrcList which encodes is the FROM with the new
** term added.
*/</comment>
<function><type><name>SrcList</name> *</type><name>sqlite3SrcListAppendFromTerm</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,          <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>SrcList</name> *</type><name>p</name></decl></param>,             <comment type="block">/* The left part of the FROM clause already seen */</comment>
  <param><decl><type><name>Token</name> *</type><name>pTable</name></decl></param>,          <comment type="block">/* Name of the table to add to the FROM clause */</comment>
  <param><decl><type><name>Token</name> *</type><name>pDatabase</name></decl></param>,       <comment type="block">/* Name of the database containing pTable */</comment>
  <param><decl><type><name>Token</name> *</type><name>pAlias</name></decl></param>,          <comment type="block">/* The right-hand side of the AS subexpression */</comment>
  <param><decl><type><name>Select</name> *</type><name>pSubquery</name></decl></param>,      <comment type="block">/* A subquery used in place of a table name */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pOn</name></decl></param>,              <comment type="block">/* The ON clause of a join */</comment>
  <param><decl><type><name>IdList</name> *</type><name>pUsing</name></decl></param>          <comment type="block">/* The USING clause of a join */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> = <call><name>sqlite3SrcListAppend</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><name>pDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0 || <name>p</name>-&gt;<name>nSrc</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ExprDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3IdListDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3SelectDelete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pItem</name> = &amp;<name>p</name>-&gt;<name><name>a</name><index>[<expr><name>p</name>-&gt;<name>nSrc</name>-1</expr>]</index></name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pAlias</name> &amp;&amp; <name>pAlias</name>-&gt;<name>n</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pItem</name>-&gt;<name>zAlias</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>pSelect</name> = <name>pSubquery</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>pOn</name> = <name>pOn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pItem</name>-&gt;<name>pUsing</name> = <name>pUsing</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add an INDEXED BY or NOT INDEXED clause to the most recently added 
** element of the source-list passed as the second argument.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListIndexedBy</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>SrcList</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pIndexedBy</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pIndexedBy</name> &amp;&amp; <name>p</name> &amp;&amp; <name>p</name>-&gt;<name>nSrc</name>&gt;0</expr> )</condition><then><block>{
    <decl_stmt><decl><type>struct <name>SrcList_item</name> *</type><name>pItem</name> =<init> <expr>&amp;<name>p</name>-&gt;<name><name>a</name><index>[<expr><name>p</name>-&gt;<name>nSrc</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pItem</name>-&gt;<name>notIndexed</name>==0 &amp;&amp; <name>pItem</name>-&gt;<name>zIndex</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pIndexedBy</name>-&gt;<name>n</name>==1 &amp;&amp; !<name>pIndexedBy</name>-&gt;<name>z</name></expr> )</condition><then><block>{
      <comment type="block">/* A "NOT INDEXED" clause was supplied. See parse.y 
      ** construct "indexed_opt" for details. */</comment>
      <expr_stmt><expr><name>pItem</name>-&gt;<name>notIndexed</name> = 1</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pItem</name>-&gt;<name>zIndex</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pIndexedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** When building up a FROM clause in the parser, the join operator
** is initially attached to the left operand.  But the code generator
** expects the join operator to be on the right operand.  This routine
** Shifts all join operators from left to right for an entire FROM
** clause.
**
** Example: Suppose the join is like this:
**
**           A natural cross join B
**
** The operator is "natural cross join".  The A and B operands are stored
** in p-&gt;a[0] and p-&gt;a[1], respectively.  The parser initially stores the
** operator with A.  This routine shifts that operator over to B.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3SrcListShiftJoinType</name><parameter_list>(<param><decl><type><name>SrcList</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>p</name> &amp;&amp; <name>p</name>-&gt;<name>a</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=<name>p</name>-&gt;<name>nSrc</name>-1</expr>;</init> <condition><expr><name>i</name>&gt;0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)<block>{
      <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name>.<name>jointype</name> = <name>p</name>-&gt;<name><name>a</name><index>[<expr><name>i</name>-1</expr>]</index></name>.<name>jointype</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>p</name>-&gt;<name><name>a</name><index>[<expr>0</expr>]</index></name>.<name>jointype</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Begin a transaction
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginTransaction</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>==0 || (<name>db</name>=<name>pParse</name>-&gt;<name>db</name>)==0 || <name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_TRANSACTION</name></expr></argument>, <argument><expr>"BEGIN"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>v</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>type</name>!=<name>TK_DEFERRED</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Transaction</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>type</name>==<name>TK_EXCLUSIVE</name>)+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VdbeUsesBtree</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AutoCommit</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Commit a transaction
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CommitTransaction</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>==0 || (<name>db</name>=<name>pParse</name>-&gt;<name>db</name>)==0 || <name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_TRANSACTION</name></expr></argument>, <argument><expr>"COMMIT"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AutoCommit</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Rollback a transaction
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RollbackTransaction</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pParse</name>==0 || (<name>db</name>=<name>pParse</name>-&gt;<name>db</name>)==0 || <name>db</name>-&gt;<name><name>aDb</name><index>[<expr>0</expr>]</index></name>.<name>pBt</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name> || <name>db</name>-&gt;<name>mallocFailed</name></expr> )</condition><then> <return>return;</return></then></if>
  <if>if<condition>( <expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_TRANSACTION</name></expr></argument>, <argument><expr>"ROLLBACK"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then> <return>return;</return></then></if>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_AutoCommit</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** This function is called by the parser when it parses a command to create,
** release or rollback an SQL savepoint. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Savepoint</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name> =<init> <expr><call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>zName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>az</name><index>[]</index></name> =<init> <expr><block>{ <expr>"BEGIN"</expr>, <expr>"RELEASE"</expr>, <expr>"ROLLBACK"</expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>SAVEPOINT_BEGIN</name> &amp;&amp; <name>SAVEPOINT_RELEASE</name>==1 &amp;&amp; <name>SAVEPOINT_ROLLBACK</name>==2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>( <expr>!<name>v</name> || <call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_SAVEPOINT</name></expr></argument>, <argument><expr><name><name>az</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Savepoint</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Make sure the TEMP database is open and available for use.  Return
** the number of errors.  Leave any error messages in the pParse structure.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3OpenTempDatabase</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pBt</name>==0 &amp;&amp; !<name>pParse</name>-&gt;<name>explain</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>static</name> <name>const</name> <name>int</name></type> <name>flags</name> =<init> 
          <expr><name>SQLITE_OPEN_READWRITE</name> |
          <name>SQLITE_OPEN_CREATE</name> |
          <name>SQLITE_OPEN_EXCLUSIVE</name> |
          <name>SQLITE_OPEN_DELETEONCLOSE</name> |
          <name>SQLITE_OPEN_TEMP_DB</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3BtreeFactory</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SQLITE_DEFAULT_CACHE_SIZE</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                                 <argument><expr>&amp;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"unable to open a temporary database "
        "file for storing temporary tables"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name>rc</name> = <name>rc</name></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_InTrans</name>)==0 || <name>db</name>-&gt;<name>autoCommit</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pSchema</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3PagerJournalMode</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pBt</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>db</name>-&gt;<name>dfltJournalMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
** Generate VDBE code that will verify the schema cookie and start
** a read-transaction for all named database files.
**
** It is important that all schema cookies be verified and all
** read transactions be started before anything else happens in
** the VDBE program.  But this routine can be called after much other
** code has been generated.  So here is what we do:
**
** The first time this routine is called, we code an OP_Goto that
** will jump to a subroutine at the end of the program.  Then we
** record every database that needs its schema verified in the
** pParse-&gt;cookieMask field.  Later, after all other code has been
** generated, the subroutine that does the cookie verifications and
** starts the transactions will be coded and the OP_Goto P2 value
** will be made to point to that subroutine.  The generation of the
** cookie verification subroutine code happens in sqlite3FinishCoding().
**
** If iDb&lt;0 then code the OP_Goto only - don't set flag to verify the
** schema on any databases.  This can be used to position the OP_Goto
** early in the code, before we know if any database tables will be used.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3CodeVerifySchema</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>  <comment type="block">/* This only happens if there was a prior error */</comment>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>cookieGoto</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>cookieGoto</name> = <call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Goto</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>+1</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>iDb</name>&gt;=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pBt</name>!=0 || <name>iDb</name>==1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&lt;<name>SQLITE_MAX_ATTACHED</name>+2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mask</name> = 1&lt;&lt;<name>iDb</name></expr>;</expr_stmt>
    <if>if<condition>( <expr>(<name>pParse</name>-&gt;<name>cookieMask</name> &amp; <name>mask</name>)==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name>cookieMask</name> |= <name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pParse</name>-&gt;<name><name>cookieValue</name><index>[<expr><name>iDb</name></expr>]</index></name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>pSchema</name>-&gt;<name>schema_cookie</name></expr>;</expr_stmt>
      <if>if<condition>( <expr>!<name>OMIT_TEMPDB</name> &amp;&amp; <name>iDb</name>==1</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>sqlite3OpenTempDatabase</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Generate VDBE code that prepares for doing an operation that
** might change the database.
**
** This routine starts a new transaction if we are not already within
** a transaction.  If we are already within a transaction, then a checkpoint
** is set if the setStatement parameter is true.  A checkpoint should
** be set for operations that might fail (due to a constraint) part of
** the way through and which will need to undo some writes without having to
** rollback the whole transaction.  For operations where all constraints
** can be checked before any changes are made to the database, it is never
** necessary to undo a write and the checkpoint should not be set.
**
** Only database iDb and the temp database are made writable by this call.
** If iDb==0, then the main and temp databases are made writable.   If
** iDb==1 then only the temp database is made writable.  If iDb&gt;1 then the
** specified auxiliary database and the temp database are made writable.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BeginWriteOperation</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>int</name></type> <name>setStatement</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name> =<init> <expr><call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>v</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>sqlite3CodeVerifySchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>writeMask</name> |= 1&lt;&lt;<name>iDb</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>setStatement</name> &amp;&amp; <name>pParse</name>-&gt;<name>nested</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Statement</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr>(<name>OMIT_TEMPDB</name> || <name>iDb</name>!=1) &amp;&amp; <name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr>1</expr>]</index></name>.<name>pBt</name>!=0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>setStatement</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Check to see if pIndex uses the collating sequence pColl.  Return
** true if it does and false if it does not.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><name>static</name> <name>int</name></type> <name>collationMatch</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>zColl</name></decl></param>, <param><decl><type><name>Index</name> *</type><name>pIndex</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pIndex</name>-&gt;<name>nColumn</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr><name>pIndex</name>-&gt;<name><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>z</name>==<name>zColl</name> || (<name>z</name> &amp;&amp; <name>zColl</name> &amp;&amp; 0==<call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call>)</expr> )</condition><then><block>{
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
  }</block></for>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Recompute all indices of pTab that use the collating sequence pColl.
** If pColl==0 then recompute all indices of pTab.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><name>static</name> <name>void</name></type> <name>reindexTable</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>, <param><decl><type><name>char</name> <name>const</name> *</type><name>zColl</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name></decl>;</decl_stmt>              <comment type="block">/* An index associated with pTab */</comment>

  <for>for(<init><expr><name>pIndex</name>=<name>pTab</name>-&gt;<name>pIndex</name></expr>;</init> <condition><expr><name>pIndex</name></expr>;</condition> <incr><expr><name>pIndex</name>=<name>pIndex</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <if>if<condition>( <expr><name>zColl</name>==0 || <call><name>collationMatch</name><argument_list>(<argument><expr><name>zColl</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>iDb</name> =<init> <expr><call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Recompute all indices of all tables in all databases where the
** indices use the collating sequence pColl.  If pColl==0 then recompute
** all indices everywhere.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><name>static</name> <name>void</name></type> <name>reindexDatabases</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>char</name> <name>const</name> *</type><name>zColl</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Db</name> *</type><name>pDb</name></decl>;</decl_stmt>                    <comment type="block">/* A single database */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* The database index number */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>HashElem</name> *</type><name>k</name></decl>;</decl_stmt>                <comment type="block">/* For looping over tables in pDb */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* A table in the database */</comment>

  <for>for(<init><expr><name>iDb</name>=0</expr>, <expr><name>pDb</name>=<name>db</name>-&gt;<name>aDb</name></expr>;</init> <condition><expr><name>iDb</name>&lt;<name>db</name>-&gt;<name>nDb</name></expr>;</condition> <incr><expr><name>iDb</name>++</expr>, <expr><name>pDb</name>++</expr></incr>)<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>k</name>=<call><name>sqliteHashFirst</name><argument_list>(<argument><expr>&amp;<name>pDb</name>-&gt;<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>)</argument_list></call></expr>;</init>  <condition><expr><name>k</name></expr>;</condition> <incr><expr><name>k</name>=<call><name>sqliteHashNext</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
      <expr_stmt><expr><name>pTab</name> = (<name>Table</name>*)<call><name>sqliteHashData</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>reindexTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Generate code for the REINDEX command.
**
**        REINDEX                            -- 1
**        REINDEX  &lt;collation&gt;               -- 2
**        REINDEX  ?&lt;database&gt;.?&lt;tablename&gt;  -- 3
**        REINDEX  ?&lt;database&gt;.?&lt;indexname&gt;  -- 4
**
** Form 1 causes all indices in all attached databases to be rebuilt.
** Form 2 rebuilds all indices in all databases that use the named
** collating function.  Forms 3 and 4 rebuild the named index or all
** indices associated with the named table.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_REINDEX</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3Reindex</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>CollSeq</name> *</type><name>pColl</name></decl>;</decl_stmt>             <comment type="block">/* Collating sequence to be reindexed, or NULL */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>                    <comment type="block">/* Name of a table or index */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl>;</decl_stmt>            <comment type="block">/* Name of the database */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>                <comment type="block">/* A table in the database */</comment>
  <decl_stmt><decl><type><name>Index</name> *</type><name>pIndex</name></decl>;</decl_stmt>              <comment type="block">/* An index associated with pTab */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>                    <comment type="block">/* The database index number */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>Token</name> *</type><name>pObjName</name></decl>;</decl_stmt>            <comment type="block">/* Name of the table or index to be reindexed */</comment>

  <comment type="block">/* Read the database schema. If an error occurs, leave an error message
  ** and code in pParse and return NULL. */</comment>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3ReadSchema</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

  <if>if<condition>( <expr><name>pName1</name>==0 || <name>pName1</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>reindexDatabases</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then><else>else <if>if<condition>( <expr><name>pName2</name>==0 || <name>pName2</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zColl</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pName1</name>-&gt;<name>z</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zColl</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>zColl</name></expr> )</condition><then> <return>return;</return></then></if>
    <expr_stmt><expr><name>pColl</name> = <call><name>sqlite3FindCollSeq</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>ENC</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pColl</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>zColl</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>reindexDatabases</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3TwoPartName</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>&amp;<name>pObjName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>iDb</name>&lt;0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>z</name> = <call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pObjName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>z</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>zDb</name> = <name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>reindexTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><name>pIndex</name> = <call><name>sqlite3FindIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pIndex</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3BeginWriteOperation</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3RefillIndex</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pIndex</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"unable to identify the object to be reindexed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return a dynamicly allocated KeyInfo structure that can be used
** with OP_OpenRead or OP_OpenWrite to access database index pIdx.
**
** If successful, a pointer to the new structure is returned. In this case
** the caller is responsible for calling sqlite3DbFree(db, ) on the returned 
** pointer. If an error occurs (out of memory or missing collation 
** sequence), NULL is returned and the state of pParse updated to reflect
** the error.
*/</comment>
<function><type><name>KeyInfo</name> *</type><name>sqlite3IndexKeyinfo</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Index</name> *</type><name>pIdx</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> =<init> <expr><name>pIdx</name>-&gt;<name>nColumn</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> =<init> <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>KeyInfo</name></expr></argument>)</argument_list></call> + (<name>nCol</name>-1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>CollSeq</name>*</expr></argument>)</argument_list></call> + <name>nCol</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>KeyInfo</name> *</type><name>pKey</name> =<init> <expr>(<name>KeyInfo</name> *)<call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>pKey</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pKey</name>-&gt;<name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKey</name>-&gt;<name>aSortOrder</name> = (<name>u8</name> *)&amp;(<name>pKey</name>-&gt;<name><name>aColl</name><index>[<expr><name>nCol</name></expr>]</index></name>)</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>&amp;<name>pKey</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>nCol</name></expr>]</index></name>==&amp;(((<name>u8</name> *)<name>pKey</name>)[<name>nBytes</name>])</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zColl</name> =<init> <expr><name>pIdx</name>-&gt;<name><name>azColl</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKey</name>-&gt;<name><name>aColl</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>sqlite3LocateCollSeq</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zColl</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pKey</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name> = <name>pIdx</name>-&gt;<name><name>aSortOrder</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>pKey</name>-&gt;<name>nField</name> = (<name>u16</name>)<name>nCol</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pKey</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>pKey</name></expr>;</return>
}</block></function>
</unit>
