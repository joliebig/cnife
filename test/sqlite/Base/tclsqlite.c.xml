<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="tclsqlite.c" filename=""><comment type="block">/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** A TCL Interface to SQLite.  Append this file to sqlite3.c and
** compile the whole thing to build a TCL-enabled version of SQLite.
**
** $Id: tclsqlite.c,v 1.234 2009/01/14 23:38:03 drh Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Some additional include files are needed if this file is not
** appended to the amalgamation.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Windows needs to know which symbols to export.  Unix does not.
 * BUILD_sqlite should be undefined for Unix.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BUILD_sqlite</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TCL_STORAGE_CLASS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TCL_STORAGE_CLASS</name> <name>DLLEXPORT</name></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* BUILD_sqlite */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>NUM_PREPARED_STMTS</name> 10</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_PREPARED_STMTS</name> 100</cpp:define>

<comment type="block">/*
** If TCL uses UTF-8 and SQLite is configured to use iso8859, then we
** have to do a translation when going between the two.  Set the 
** UTF_TRANSLATION_NEEDED macro to indicate that we need to do
** this translation.  
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCL_UTF_MAX</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <name>UTF_TRANSLATION_NEEDED</name> 1</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** New SQL functions can be created as TCL scripts.  Each such function
** is described by an instance of the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>SqlFunc</name> SqlFunc;</struct></type></typedef>
<struct>struct <name>SqlFunc</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>   <comment type="block">/* The TCL interpret to execute the function */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name></decl>;</decl_stmt>     <comment type="block">/* The Tcl_Obj representation of the script */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>useEvalObjv</name></decl>;</decl_stmt>      <comment type="block">/* True if it is safe to use Tcl_EvalObjv */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>          <comment type="block">/* Name of this function */</comment>
  <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>pNext</name></decl>;</decl_stmt>       <comment type="block">/* Next function on the list of them all */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** New collation sequences function can be created as TCL scripts.  Each such
** function is described by an instance of the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>SqlCollate</name> SqlCollate;</struct></type></typedef>
<struct>struct <name>SqlCollate</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>   <comment type="block">/* The TCL interpret to execute the function */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zScript</name></decl>;</decl_stmt>        <comment type="block">/* The script to be run */</comment>
  <decl_stmt><decl><type><name>SqlCollate</name> *</type><name>pNext</name></decl>;</decl_stmt>    <comment type="block">/* Next function on the list of them all */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>SqlPreparedStmt</name> SqlPreparedStmt;</struct></type></typedef>
<struct>struct <name>SqlPreparedStmt</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>pNext</name></decl>;</decl_stmt>  <comment type="block">/* Next in linked list */</comment>
  <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>pPrev</name></decl>;</decl_stmt>  <comment type="block">/* Previous on the list */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>     <comment type="block">/* The prepared statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSql</name></decl>;</decl_stmt>                <comment type="block">/* chars in zSql[] */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>        <comment type="block">/* Text of the SQL statement */</comment>
</public>}</block>;</struct>

<typedef>typedef <type><struct>struct <name>IncrblobChannel</name> IncrblobChannel;</struct></type></typedef>

<comment type="block">/*
** There is one instance of this structure for each SQLite database
** that has been opened by the SQLite TCL interface.
*/</comment>
<typedef>typedef <type><struct>struct <name>SqliteDb</name> SqliteDb;</struct></type></typedef>
<struct>struct <name>SqliteDb</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>               <comment type="block">/* The "real" database structure. MUST BE FIRST */</comment>
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>        <comment type="block">/* The interpreter used for this database */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zBusy</name></decl>;</decl_stmt>               <comment type="block">/* The busy callback routine */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zCommit</name></decl>;</decl_stmt>             <comment type="block">/* The commit hook callback routine */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zTrace</name></decl>;</decl_stmt>              <comment type="block">/* The trace callback routine */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zProfile</name></decl>;</decl_stmt>            <comment type="block">/* The profile callback routine */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zProgress</name></decl>;</decl_stmt>           <comment type="block">/* The progress callback routine */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zAuth</name></decl>;</decl_stmt>               <comment type="block">/* The authorization callback routine */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>disableAuth</name></decl>;</decl_stmt>           <comment type="block">/* Disable the authorizer if it exists */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zNull</name></decl>;</decl_stmt>               <comment type="block">/* Text to substitute for an SQL NULL value */</comment>
  <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>pFunc</name></decl>;</decl_stmt>            <comment type="block">/* List of SQL functions */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pUpdateHook</name></decl>;</decl_stmt>      <comment type="block">/* Update hook script (if any) */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pRollbackHook</name></decl>;</decl_stmt>    <comment type="block">/* Rollback hook script (if any) */</comment>
  <decl_stmt><decl><type><name>SqlCollate</name> *</type><name>pCollate</name></decl>;</decl_stmt>      <comment type="block">/* List of SQL collation functions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                    <comment type="block">/* Return code of most recent sqlite3_exec() */</comment>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pCollateNeeded</name></decl>;</decl_stmt>   <comment type="block">/* Collation needed script */</comment>
  <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>stmtList</name></decl>;</decl_stmt> <comment type="block">/* List of prepared statements*/</comment>
  <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>stmtLast</name></decl>;</decl_stmt> <comment type="block">/* Last statement in the list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>maxStmt</name></decl>;</decl_stmt>               <comment type="block">/* The next maximum number of stmtList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStmt</name></decl>;</decl_stmt>                 <comment type="block">/* Number of statements in stmtList */</comment>
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>pIncrblob</name></decl>;</decl_stmt><comment type="block">/* Linked list of open incrblob channels */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStep</name>, <name>nSort</name></decl>;</decl_stmt>          <comment type="block">/* Statistics for most recent operation */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTransaction</name></decl>;</decl_stmt>          <comment type="block">/* Number of nested [transaction] methods */</comment>
</public>}</block>;</struct>

<struct>struct <name>IncrblobChannel</name> <block>{<public type="default">
  <decl_stmt><decl><type><name>sqlite3_blob</name> *</type><name>pBlob</name></decl>;</decl_stmt>      <comment type="block">/* sqlite3 blob handle */</comment>
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name></decl>;</decl_stmt>            <comment type="block">/* Associated database connection */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iSeek</name></decl>;</decl_stmt>                <comment type="block">/* Current seek offset */</comment>
  <decl_stmt><decl><type><name>Tcl_Channel</name></type> <name>channel</name></decl>;</decl_stmt>      <comment type="block">/* Channel identifier */</comment>
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>pNext</name></decl>;</decl_stmt>   <comment type="block">/* Linked list of all open incrblob channels */</comment>
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>pPrev</name></decl>;</decl_stmt>   <comment type="block">/* Linked list of all open incrblob channels */</comment>
</public>}</block>;</struct>

<comment type="block">/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>strlen30</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z2</name> =<init> <expr><name>z</name></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr>*<name>z2</name></expr> )</condition><block>{ <expr_stmt><expr><name>z2</name>++</expr>;</expr_stmt> }</block></while>
  <return>return <expr>0x3fffffff &amp; (<name>int</name>)(<name>z2</name> - <name>z</name>)</expr>;</return>
}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifndef>
<comment type="block">/*
** Close all incrblob channels opened using database connection pDb.
** This is called when shutting down the database connection.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>closeIncrblobChannels</name><parameter_list>(<param><decl><type><name>SqliteDb</name> *</type><name>pDb</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>pNext</name></decl>;</decl_stmt>

  <for>for(<init><expr><name>p</name>=<name>pDb</name>-&gt;<name>pIncrblob</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>pNext</name></expr></incr>)<block>{
    <expr_stmt><expr><name>pNext</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>

    <comment type="block">/* Note: Calling unregister here call Tcl_Close on the incrblob channel, 
    ** which deletes the IncrblobChannel structure at *p. So do not
    ** call Tcl_Free() here.
    */</comment>
    <expr_stmt><expr><call><name>Tcl_UnregisterChannel</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<comment type="block">/*
** Close an incremental blob channel.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>incrblobClose</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name> =<init> <expr>(<name>IncrblobChannel</name> *)<name>instanceData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><call><name>sqlite3_blob_close</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>pDb</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Remove the channel from the SqliteDb.pIncrblob list. */</comment>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>p</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pDb</name>-&gt;<name>pIncrblob</name>==<name>p</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pDb</name>-&gt;<name>pIncrblob</name> = <name>p</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Free the IncrblobChannel structure */</comment>
  <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Read data from an incremental blob channel.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>incrblobInput</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, 
  <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>bufSize</name></decl></param>,
  <param><decl><type><name>int</name> *</type><name>errorCodePtr</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name> =<init> <expr>(<name>IncrblobChannel</name> *)<name>instanceData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nRead</name> =<init> <expr><name>bufSize</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* Number of bytes to read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>                   <comment type="block">/* Total size of the blob */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                      <comment type="block">/* sqlite error code */</comment>

  <expr_stmt><expr><name>nBlob</name> = <call><name>sqlite3_blob_bytes</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>iSeek</name>+<name>nRead</name>)&gt;<name>nBlob</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>nRead</name> = <name>nBlob</name>-<name>p</name>-&gt;<name>iSeek</name></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>nRead</name>&lt;=0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_blob_read</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>buf</name></expr></argument>, <argument><expr><name>nRead</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iSeek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>errorCodePtr</name> = <name>rc</name></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> += <name>nRead</name></expr>;</expr_stmt>
  <return>return <expr><name>nRead</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Write data to an incremental blob channel.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>incrblobOutput</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, 
  <param><decl><type><name>CONST</name> <name>char</name> *</type><name>buf</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>toWrite</name></decl></param>,
  <param><decl><type><name>int</name> *</type><name>errorCodePtr</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name> =<init> <expr>(<name>IncrblobChannel</name> *)<name>instanceData</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nWrite</name> =<init> <expr><name>toWrite</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Number of bytes to write */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name></decl>;</decl_stmt>                   <comment type="block">/* Total size of the blob */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                      <comment type="block">/* sqlite error code */</comment>

  <expr_stmt><expr><name>nBlob</name> = <call><name>sqlite3_blob_bytes</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr>(<name>p</name>-&gt;<name>iSeek</name>+<name>nWrite</name>)&gt;<name>nBlob</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>errorCodePtr</name> = <name>EINVAL</name></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><name>nWrite</name>&lt;=0</expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_blob_write</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>buf</name></expr></argument>, <argument><expr><name>nWrite</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>iSeek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>errorCodePtr</name> = <name>EIO</name></expr>;</expr_stmt>
    <return>return <expr>-1</expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> += <name>nWrite</name></expr>;</expr_stmt>
  <return>return <expr><name>nWrite</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Seek an incremental blob channel.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>incrblobSeek</name><parameter_list>(
  <param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, 
  <param><decl><type><name>long</name></type> <name>offset</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>seekMode</name></decl></param>,
  <param><decl><type><name>int</name> *</type><name>errorCodePtr</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name> =<init> <expr>(<name>IncrblobChannel</name> *)<name>instanceData</name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name>seekMode</name></expr> )</condition><block>{
    <case>case <expr><name>SEEK_SET</name></expr>:
      <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> = <name>offset</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SEEK_CUR</name></expr>:
      <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> += <name>offset</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>SEEK_END</name></expr>:
      <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> = <call><name>sqlite3_blob_bytes</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>pBlob</name></expr></argument>)</argument_list></call> + <name>offset</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default: <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!"Bad seekMode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>

  <return>return <expr><name>p</name>-&gt;<name>iSeek</name></expr>;</return>
}</block></function>


<function><type><name>static</name> <name>void</name></type> <name>incrblobWatch</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list><block>{ 
  <comment type="block">/* NO-OP */</comment> 
}</block></function>
<function><type><name>static</name> <name>int</name></type> <name>incrblobHandle</name><parameter_list>(<param><decl><type><name>ClientData</name></type> <name>instanceData</name></decl></param>, <param><decl><type><name>int</name></type> <name>dir</name></decl></param>, <param><decl><type><name>ClientData</name> *</type><name>hPtr</name></decl></param>)</parameter_list><block>{
  <return>return <expr><name>TCL_ERROR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><name>static</name> <name>Tcl_ChannelType</name></type> <name>IncrblobChannelType</name> =<init> <expr><block>{
  <expr>"incrblob"</expr>,                        <comment type="block">/* typeName                             */</comment>
  <expr><name>TCL_CHANNEL_VERSION_2</name></expr>,             <comment type="block">/* version                              */</comment>
  <expr><name>incrblobClose</name></expr>,                     <comment type="block">/* closeProc                            */</comment>
  <expr><name>incrblobInput</name></expr>,                     <comment type="block">/* inputProc                            */</comment>
  <expr><name>incrblobOutput</name></expr>,                    <comment type="block">/* outputProc                           */</comment>
  <expr><name>incrblobSeek</name></expr>,                      <comment type="block">/* seekProc                             */</comment>
  <expr>0</expr>,                                 <comment type="block">/* setOptionProc                        */</comment>
  <expr>0</expr>,                                 <comment type="block">/* getOptionProc                        */</comment>
  <expr><name>incrblobWatch</name></expr>,                     <comment type="block">/* watchProc (this is a no-op)          */</comment>
  <expr><name>incrblobHandle</name></expr>,                    <comment type="block">/* getHandleProc (always returns error) */</comment>
  <expr>0</expr>,                                 <comment type="block">/* close2Proc                           */</comment>
  <expr>0</expr>,                                 <comment type="block">/* blockModeProc                        */</comment>
  <expr>0</expr>,                                 <comment type="block">/* flushProc                            */</comment>
  <expr>0</expr>,                                 <comment type="block">/* handlerProc                          */</comment>
  <expr>0</expr>,                                 <comment type="block">/* wideSeekProc                         */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Create a new incrblob channel.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>createIncrblobChannel</name><parameter_list>(
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, 
  <param><decl><type><name>SqliteDb</name> *</type><name>pDb</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zTable</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zColumn</name></decl></param>, 
  <param><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>isReadonly</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>IncrblobChannel</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pDb</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_blob</name> *</type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><name>TCL_READABLE</name>|(<name>isReadonly</name> ? 0 : <name>TCL_WRITABLE</name>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* This variable is used to name the channels: "incrblob_[incr count]" */</comment>
  <decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>count</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zChannel</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_blob_open</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zColumn</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>, <argument><expr>!<name>isReadonly</name></expr></argument>, <argument><expr>&amp;<name>pBlob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>p</name> = (<name>IncrblobChannel</name> *)<call><name>Tcl_Alloc</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>IncrblobChannel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>iSeek</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pBlob</name> = <name>pBlob</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zChannel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zChannel</name></expr></argument>, <argument><expr>"incrblob_%d"</expr></argument>, <argument><expr>++<name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>channel</name> = <call><name>Tcl_CreateChannel</name><argument_list>(<argument><expr>&amp;<name>IncrblobChannelType</name></expr></argument>, <argument><expr><name>zChannel</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_RegisterChannel</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>channel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Link the new channel into the SqliteDb.pIncrblob list. */</comment>
  <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name> = <name>pDb</name>-&gt;<name>pIncrblob</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>p</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>p</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>pDb</name>-&gt;<name>pIncrblob</name> = <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>pDb</name> = <name>pDb</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>Tcl_GetChannelName</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>channel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* else clause for "#ifndef SQLITE_OMIT_INCRBLOB" */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <name>closeIncrblobChannels</name>(pDb)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Look at the script prefix in pCmd.  We will be executing this script
** after first appending one or more arguments.  This routine analyzes
** the script to see if it is safe to use Tcl_EvalObjv() on the script
** rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much
** faster.
**
** Scripts that are safe to use with Tcl_EvalObjv() consists of a
** command name followed by zero or more arguments with no [...] or $
** or {...} or ; to be seen anywhere.  Most callback scripts consist
** of just a single procedure name and they meet this requirement.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>safeToUseEvalObjv</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>Tcl_Obj</name> *</type><name>pCmd</name></decl></param>)</parameter_list><block>{
  <comment type="block">/* We could try to do something with Tcl_Parse().  But we will instead
  ** just do a search for forbidden characters.  If any of the forbidden
  ** characters appear in pCmd, we will report the string as unsafe.
  */</comment>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>z</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>n</name>-- &gt; 0</expr> )</condition><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> =<init> <expr>*(<name>z</name>++)</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>c</name>=='$' || <name>c</name>=='[' || <name>c</name>==';'</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  }</block></while>
  <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
** Find an SqlFunc structure with the given name.  Or create a new
** one if an existing one cannot be found.  Return a pointer to the
** structure.
*/</comment>
<function><type><name>static</name> <name>SqlFunc</name> *</type><name>findSqlFunc</name><parameter_list>(<param><decl><type><name>SqliteDb</name> *</type><name>pDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>p</name>, *<name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pNew</name> = (<name>SqlFunc</name>*)<call><name>Tcl_Alloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call> + <call><name>strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zName</name> = (<name>char</name>*)&amp;<name><name>pNew</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{ <expr_stmt><expr><name>pNew</name>-&gt;<name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>tolower</name><argument_list>(<argument><expr><name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for>
  <expr_stmt><expr><name>pNew</name>-&gt;<name><name>zName</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>p</name>=<name>pDb</name>-&gt;<name>pFunc</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name>=<name>p</name>-&gt;<name>pNext</name></expr></incr>)<block>{ 
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pNew</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>interp</name> = <name>pDb</name>-&gt;<name>interp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pScript</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pNext</name> = <name>pDb</name>-&gt;<name>pFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name>-&gt;<name>pFunc</name> = <name>pNew</name></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Finalize and free a list of prepared statements
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>flushStmtCache</name><parameter_list>( <param><decl><type><name>SqliteDb</name> *</type><name>pDb</name></decl></param> )</parameter_list><block>{
  <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>pPreStmt</name></decl>;</decl_stmt>

  <while>while<condition>(  <expr><name>pDb</name>-&gt;<name>stmtList</name></expr> )</condition><block>{
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>stmtList</name>-&gt;<name>pStmt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pPreStmt</name> = <name>pDb</name>-&gt;<name>stmtList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtList</name> = <name>pDb</name>-&gt;<name>stmtList</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>( <argument><expr>(<name>char</name>*)<name>pPreStmt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><name>pDb</name>-&gt;<name>nStmt</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtLast</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** TCL calls this procedure when an sqlite3 database command is
** deleted.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>DbDeleteCmd</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>db</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>flushStmtCache</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>closeIncrblobChannels</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pDb</name>-&gt;<name>pFunc</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>pFunc</name> =<init> <expr><name>pDb</name>-&gt;<name>pFunc</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pFunc</name> = <name>pFunc</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pFunc</name>-&gt;<name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <while>while<condition>( <expr><name>pDb</name>-&gt;<name>pCollate</name></expr> )</condition><block>{
    <decl_stmt><decl><type><name>SqlCollate</name> *</type><name>pCollate</name> =<init> <expr><name>pDb</name>-&gt;<name>pCollate</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pCollate</name> = <name>pCollate</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pCollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zBusy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zBusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zTrace</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProfile</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zProfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zAuth</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zAuth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zNull</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pUpdateHook</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pUpdateHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pRollbackHook</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pRollbackHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called when a database file is locked while trying
** to execute SQL.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>DbBusyHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>, <param><decl><type><name>int</name></type> <name>nTries</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zVal</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zVal</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>nTries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_VarEval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zBusy</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr>(<name>char</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name> || <call><name>atoi</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>0</expr>;</return>
  }</block></then></if>
  <return>return <expr>1</expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
<comment type="block">/*
** This routine is invoked as the 'progress callback' for the database.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>DbProgressHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>zProgress</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name> || <call><name>atoi</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** This routine is called by the SQLite trace handler whenever a new
** block of SQL is executed.  The TCL script in pDb-&gt;zTrace is executed.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>DbTraceHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>str</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zTrace</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** This routine is called by the SQLite profile handler after a statement
** SQL has executed.  The TCL script in pDb-&gt;zProfile is evaluated.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>DbProfileHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zSql</name></decl></param>, <param><decl><type><name>sqlite_uint64</name></type> <name>tm</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zTm</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zTm</name></expr></argument>)</argument_list></call>-1</expr></argument>, <argument><expr><name>zTm</name></expr></argument>, <argument><expr>"%lld"</expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zProfile</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is called when a transaction is committed.  The
** TCL script in pDb-&gt;zCommit is executed.  If it returns non-zero or
** if it throws an exception, the transaction is rolled back instead
** of being committed.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>DbCommitHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_Eval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>!=<name>TCL_OK</name> || <call><name>atoi</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr>1</expr>;</return>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>static</name> <name>void</name></type> <name>DbRollbackHandler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>clientData</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>clientData</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pRollbackHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>TCL_OK</name>!=<call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>pRollbackHook</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_BackgroundError</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>static</name> <name>void</name></type> <name>DbUpdateHandler</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>p</name></decl></param>, 
  <param><decl><type><name>int</name></type> <name>op</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name></decl></param>, 
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zTbl</name></decl></param>, 
  <param><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pCmd</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>pUpdateHook</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name>==<name>SQLITE_INSERT</name> || <name>op</name>==<name>SQLITE_UPDATE</name> || <name>op</name>==<name>SQLITE_DELETE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pCmd</name> = <call><name>Tcl_DuplicateObj</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pUpdateHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(
    <argument><expr>( (<name>op</name>==<name>SQLITE_INSERT</name>)?"INSERT":(<name>op</name>==<name>SQLITE_UPDATE</name>)?"UPDATE":"DELETE")</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zTbl</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>TCL_EVAL_DIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>static</name> <name>void</name></type> <name>tclCollateNeeded</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>pCtx</name></decl></param>,
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>enc</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name> *)<name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name> =<init> <expr><call><name>Tcl_DuplicateObj</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pScript</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pScript</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** This routine is called to evaluate an SQL collation function implemented
** using TCL script.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>tclSqlCollate</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>pCtx</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nA</name></decl></param>,
  <param><decl><type><name>const</name> <name>void</name> *</type><name>zA</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>nB</name></decl></param>,
  <param><decl><type><name>const</name> <name>void</name> *</type><name>zB</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqlCollate</name> *</type><name>p</name> =<init> <expr>(<name>SqlCollate</name> *)<name>pCtx</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pCmd</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pCmd</name> = <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>zScript</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zA</name></expr></argument>, <argument><expr><name>nA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zB</name></expr></argument>, <argument><expr><name>nB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>TCL_EVAL_DIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<call><name>atoi</name><argument_list>(<argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<comment type="block">/*
** This routine is called to evaluate an SQL function implemented
** using TCL script.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>tclSqlFunc</name><parameter_list>(<param><decl><type><name>sqlite3_context</name> *</type><name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>sqlite3_value</name>**</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>p</name> =<init> <expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pCmd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <if>if<condition>( <expr><name>argc</name>==0</expr> )</condition><then><block>{
    <comment type="block">/* If there are no arguments to the function, call Tcl_EvalObjEx on the
    ** script object directly.  This allows the TCL compiler to generate
    ** bytecode for the command on the first invocation and thus make
    ** subsequent invocations much faster. */</comment>
    <expr_stmt><expr><name>pCmd</name> = <name>p</name>-&gt;<name>pScript</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <comment type="block">/* If there are arguments to the function, make a shallow copy of the
    ** script object, lappend the arguments, then evaluate the copy.
    **
    ** By "shallow" copy, we mean a only the outer list Tcl_Obj is duplicated.
    ** The new Tcl_Obj contains pointers to the original list elements. 
    ** That way, when Tcl_EvalObjv() is run and shimmers the first element
    ** of the list to tclCmdNameType, that alternate representation will
    ** be preserved and reused on the next invocation.
    */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>aArg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><call><name>Tcl_ListObjGetElements</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>pScript</name></expr></argument>, <argument><expr>&amp;<name>nArg</name></expr></argument>, <argument><expr>&amp;<name>aArg</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <return>return;</return>
    }</block></then></if>     
    <expr_stmt><expr><name>pCmd</name> = <call><name>Tcl_NewListObj</name><argument_list>(<argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>aArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>sqlite3_value</name> *</type><name>pIn</name> =<init> <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pVal</name></decl>;</decl_stmt>
            
      <comment type="block">/* Set pVal to contain the i'th column of this row. */</comment>
      <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
        <case>case <expr><name>SQLITE_BLOB</name></expr>: <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>bytes</name> =<init> <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewByteArrayObj</name><argument_list>(<argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
        </case><case>case <expr><name>SQLITE_INTEGER</name></expr>: <block>{
          <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>v</name> =<init> <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>v</name>&gt;=-2147483647 &amp;&amp; <name>v</name>&lt;=2147483647</expr> )</condition><then><block>{
            <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
          <break>break;</break>
        }</block>
        </case><case>case <expr><name>SQLITE_FLOAT</name></expr>: <block>{
          <decl_stmt><decl><type><name>double</name></type> <name>r</name> =<init> <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewDoubleObj</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
        </case><case>case <expr><name>SQLITE_NULL</name></expr>: <block>{
          <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
        </case><default>default: <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>bytes</name> =<init> <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr>(<name>char</name> *)<call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
      </default>}</block></switch>
      <expr_stmt><expr><name>rc</name> = <call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return;</return>
      }</block></then></if>
    }</block></for>
    <if>if<condition>( <expr>!<name>p</name>-&gt;<name>useEvalObjv</name></expr> )</condition><then><block>{
      <comment type="block">/* Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd
      ** is a list without a string representation.  To prevent this from
      ** happening, make sure pCmd has a valid string representation */</comment>
      <expr_stmt><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>rc</name> = <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><name>pCmd</name></expr></argument>, <argument><expr><name>TCL_EVAL_DIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>rc</name> &amp;&amp; <name>rc</name>!=<name>TCL_RETURN</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  }</block></then><else>else<block>{
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pVar</name> =<init> <expr><call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zType</name> =<init> <expr><name>pVar</name>-&gt;<name>typePtr</name> ? <name>pVar</name>-&gt;<name>typePtr</name>-&gt;<name>name</name> : ""</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name> =<init> <expr><name><name>zType</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>c</name>=='b' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"bytearray"</expr></argument>)</argument_list></call>==0 &amp;&amp; <name>pVar</name>-&gt;<name>bytes</name>==0</expr> )</condition><then><block>{
      <comment type="block">/* Only return a BLOB type if the Tcl variable is a bytearray and
      ** has no string representation. */</comment>
      <expr_stmt><expr><name>data</name> = <call><name>Tcl_GetByteArrayFromObj</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='b' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"boolean"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='d' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"double"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>Tcl_GetDoubleFromObj</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr>(<name>c</name>=='w' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"wideInt"</expr></argument>)</argument_list></call>==0) ||
          (<name>c</name>=='i' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"int"</expr></argument>)</argument_list></call>==0)</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>v</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if>
  }</block></else></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
<comment type="block">/*
** This is the authentication function.  It appends the authentication
** type code and the two arguments to zCmd[] then invokes the result
** on the interpreter.  The reply is examined to determine if the
** authentication fails or succeeds.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>auth_callback</name><parameter_list>(
  <param><decl><type><name>void</name> *</type><name>pArg</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>code</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg1</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg2</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg3</name></decl></param>,
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zArg4</name></decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zCode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zReply</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>pArg</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pDb</name>-&gt;<name>disableAuth</name></expr> )</condition><then> <return>return <expr><name>SQLITE_OK</name></expr>;</return></then></if>

  <switch>switch<condition>( <expr><name>code</name></expr> )</condition><block>{
    <case>case <expr><name>SQLITE_COPY</name></expr>              : <expr_stmt><expr><name>zCode</name>="SQLITE_COPY"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_INDEX</name></expr>      : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_INDEX"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TABLE</name></expr>      : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TEMP_INDEX</name></expr> : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TEMP_INDEX"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TEMP_TABLE</name></expr> : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TEMP_TABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TEMP_TRIGGER</name></expr>: <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TEMP_TRIGGER"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TEMP_VIEW</name></expr>  : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TEMP_VIEW"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_TRIGGER</name></expr>    : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_TRIGGER"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_VIEW</name></expr>       : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_VIEW"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DELETE</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_DELETE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_INDEX</name></expr>        : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_INDEX"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TABLE</name></expr>        : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TEMP_INDEX</name></expr>   : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TEMP_INDEX"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TEMP_TABLE</name></expr>   : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TEMP_TABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TEMP_TRIGGER</name></expr> : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TEMP_TRIGGER"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TEMP_VIEW</name></expr>    : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TEMP_VIEW"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_TRIGGER</name></expr>      : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_TRIGGER"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_VIEW</name></expr>         : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_VIEW"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_INSERT</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_INSERT"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_PRAGMA</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_PRAGMA"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_READ</name></expr>              : <expr_stmt><expr><name>zCode</name>="SQLITE_READ"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_SELECT</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_SELECT"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_TRANSACTION</name></expr>       : <expr_stmt><expr><name>zCode</name>="SQLITE_TRANSACTION"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_UPDATE</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_UPDATE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_ATTACH</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_ATTACH"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DETACH</name></expr>            : <expr_stmt><expr><name>zCode</name>="SQLITE_DETACH"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_ALTER_TABLE</name></expr>       : <expr_stmt><expr><name>zCode</name>="SQLITE_ALTER_TABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_REINDEX</name></expr>           : <expr_stmt><expr><name>zCode</name>="SQLITE_REINDEX"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_ANALYZE</name></expr>           : <expr_stmt><expr><name>zCode</name>="SQLITE_ANALYZE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_CREATE_VTABLE</name></expr>     : <expr_stmt><expr><name>zCode</name>="SQLITE_CREATE_VTABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_DROP_VTABLE</name></expr>       : <expr_stmt><expr><name>zCode</name>="SQLITE_DROP_VTABLE"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_FUNCTION</name></expr>          : <expr_stmt><expr><name>zCode</name>="SQLITE_FUNCTION"</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>SQLITE_SAVEPOINT</name></expr>         : <expr_stmt><expr><name>zCode</name>="SQLITE_SAVEPOINT"</expr>;</expr_stmt> <break>break;</break>
    </case><default>default                       : <expr_stmt><expr><name>zCode</name>="????"</expr>;</expr_stmt> <break>break;</break>
  </default>}</block></switch>
  <expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppend</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zAuth</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zArg1</name> ? <name>zArg1</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zArg2</name> ? <name>zArg2</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zArg3</name> ? <name>zArg3</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringAppendElement</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>zArg4</name> ? <name>zArg4</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>Tcl_GlobalEval</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zReply</name> = <call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zReply</name></expr></argument>,<argument><expr>"SQLITE_OK"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zReply</name></expr></argument>,<argument><expr>"SQLITE_DENY"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_DENY</name></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zReply</name></expr></argument>,<argument><expr>"SQLITE_IGNORE"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_IGNORE</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = 999</expr>;</expr_stmt>
  }</block></else></if></else></if></else></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_AUTHORIZATION */</comment>

<comment type="block">/*
** zText is a pointer to text obtained via an sqlite3_result_text()
** or similar interface. This routine returns a Tcl string object, 
** reference count set to 0, containing the text. If a translation
** between iso8859 and UTF-8 is required, it is preformed.
*/</comment>
<function><type><name>static</name> <name>Tcl_Obj</name> *</type><name>dbTextToObj</name><parameter_list>(<param><decl><type><name>char</name> <name>const</name> *</type><name>zText</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pVal</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UTF_TRANSLATION_NEEDED</name></cpp:ifdef>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>dCol</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringInit</name><argument_list>(<argument><expr>&amp;<name>dCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_ExternalToUtfDString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>dCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><call><name>Tcl_DStringValue</name><argument_list>(<argument><expr>&amp;<name>dCol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>dCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zText</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>pVal</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** The interface is like "readline" but no command-line editing
** is done.
**
** copied from shell.c from '.import' command
*/</comment>
<function><type><name>static</name> <name>char</name> *</type><name>local_getline</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>zPrompt</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>in</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>zLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nLine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eol</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>nLine</name> = 100</expr>;</expr_stmt>
  <expr_stmt><expr><name>zLine</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nLine</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zLine</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
  <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>eol</name> = 0</expr>;</expr_stmt>
  <while>while<condition>( <expr>!<name>eol</name></expr> )</condition><block>{
    <if>if<condition>( <expr><name>n</name>+100&gt;<name>nLine</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>nLine</name> = <name>nLine</name>*2 + 100</expr>;</expr_stmt>
      <expr_stmt><expr><name>zLine</name> = <call><name>realloc</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>nLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zLine</name>==0</expr> )</condition><then> <return>return <expr>0</expr>;</return></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>fgets</name><argument_list>(<argument><expr>&amp;<name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>nLine</name> - <name>n</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>n</name>==0</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>eol</name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    }</block></then></if>
    <while>while<condition>( <expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name></expr> )</condition><block>{ <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt> }</block></while>
    <if>if<condition>( <expr><name>n</name>&gt;0 &amp;&amp; <name><name>zLine</name><index>[<expr><name>n</name>-1</expr>]</index></name>=='\n'</expr> )</condition><then><block>{
      <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zLine</name><index>[<expr><name>n</name></expr>]</index></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>eol</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
  }</block></while>
  <expr_stmt><expr><name>zLine</name> = <call><name>realloc</name><argument_list>( <argument><expr><name>zLine</name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zLine</name></expr>;</return>
}</block></function>


<comment type="block">/*
** Figure out the column names for the data returned by the statement
** passed as the second argument.
**
** If parameter papColName is not NULL, then *papColName is set to point
** at an array allocated using Tcl_Alloc(). It is the callers responsibility
** to free this array using Tcl_Free(), and to decrement the reference
** count of each Tcl_Obj* member of the array.
**
** The return value of this function is the number of columns of data
** returned by pStmt (and hence the size of the *papColName array).
**
** If pArray is not NULL, then it contains the name of a Tcl array
** variable. The "*" member of this array is set to a list containing
** the names of the columns returned by the statement, in order from
** left to right. e.g. if the names of the returned columns are a, b and
** c, it does the equivalent of the tcl command:
**
**     set ${pArray}(*) {a b c}
*/</comment>
<function><type><name>static</name> <name>int</name></type>
<name>computeColumnNames</name><parameter_list>(
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, 
  <param><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl></param>,              <comment type="block">/* SQL statement */</comment>
  <param><decl><type><name>Tcl_Obj</name> ***</type><name>papColName</name></decl></param>,            <comment type="block">/* OUT: Array of column names */</comment>
  <param><decl><type><name>Tcl_Obj</name> *</type><name>pArray</name></decl></param>                   <comment type="block">/* Name of array variable (may be null) */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>

  <comment type="block">/* Compute column names */</comment>
  <expr_stmt><expr><name>nCol</name> = <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>papColName</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>apColName</name> =<init> <expr>(<name>Tcl_Obj</name>**)<call><name>Tcl_Alloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Tcl_Obj</name>*</expr></argument>)</argument_list></call>*<name>nCol</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>dbTextToObj</name><argument_list>(<argument><expr><call><name>sqlite3_column_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* If results are being stored in an array variable, then create
    ** the array(*) entry for that array
    */</comment>
    <if>if<condition>( <expr><name>pArray</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pColList</name> =<init> <expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pStar</name> =<init> <expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr>"*"</expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pColList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pColList</name></expr></argument>, <argument><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pStar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_ObjSetVar2</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name>pStar</name></expr></argument>, <argument><expr><name>pColList</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pColList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pStar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>papColName</name> = <name>apColName</name></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>nCol</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The "sqlite" command below creates a new Tcl command for each
** connection it opens to an SQLite database.  This routine is invoked
** whenever one of those connection-specific commands is executed
** in Tcl.  For example, if you run Tcl code like this:
**
**       sqlite3 db1  "my_database"
**       db1 close
**
** The first command opens a connection to the "my_database" database
** and calls that connection "db1".  The second command causes this
** subroutine to be invoked.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>DbObjCmd</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>, <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,<param><decl><type><name>Tcl_Obj</name> *<name>const</name>*</type><name>objv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>pDb</name> =<init> <expr>(<name>SqliteDb</name>*)<name>cd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>choice</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>TCL_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>DB_strs</name><index>[]</index></name> =<init> <expr><block>{
    <expr>"authorizer"</expr>,         <expr>"busy"</expr>,              <expr>"cache"</expr>,
    <expr>"changes"</expr>,            <expr>"close"</expr>,             <expr>"collate"</expr>,
    <expr>"collation_needed"</expr>,   <expr>"commit_hook"</expr>,       <expr>"complete"</expr>,
    <expr>"copy"</expr>,               <expr>"enable_load_extension"</expr>,<expr>"errorcode"</expr>,
    <expr>"eval"</expr>,               <expr>"exists"</expr>,            <expr>"function"</expr>,
    <expr>"incrblob"</expr>,           <expr>"interrupt"</expr>,         <expr>"last_insert_rowid"</expr>,
    <expr>"nullvalue"</expr>,          <expr>"onecolumn"</expr>,         <expr>"profile"</expr>,
    <expr>"progress"</expr>,           <expr>"rekey"</expr>,             <expr>"rollback_hook"</expr>,
    <expr>"status"</expr>,             <expr>"timeout"</expr>,           <expr>"total_changes"</expr>,
    <expr>"trace"</expr>,              <expr>"transaction"</expr>,       <expr>"update_hook"</expr>,
    <expr>"version"</expr>,            <expr>0</expr>                    
  }</block></expr></init></decl>;</decl_stmt>
  <enum>enum <name>DB_enum</name> <block>{
    <expr><name>DB_AUTHORIZER</name></expr>,        <expr><name>DB_BUSY</name></expr>,             <expr><name>DB_CACHE</name></expr>,
    <expr><name>DB_CHANGES</name></expr>,           <expr><name>DB_CLOSE</name></expr>,            <expr><name>DB_COLLATE</name></expr>,
    <expr><name>DB_COLLATION_NEEDED</name></expr>,  <expr><name>DB_COMMIT_HOOK</name></expr>,      <expr><name>DB_COMPLETE</name></expr>,
    <expr><name>DB_COPY</name></expr>,              <expr><name>DB_ENABLE_LOAD_EXTENSION</name></expr>,<expr><name>DB_ERRORCODE</name></expr>,
    <expr><name>DB_EVAL</name></expr>,              <expr><name>DB_EXISTS</name></expr>,           <expr><name>DB_FUNCTION</name></expr>,
    <expr><name>DB_INCRBLOB</name></expr>,          <expr><name>DB_INTERRUPT</name></expr>,        <expr><name>DB_LAST_INSERT_ROWID</name></expr>,
    <expr><name>DB_NULLVALUE</name></expr>,         <expr><name>DB_ONECOLUMN</name></expr>,        <expr><name>DB_PROFILE</name></expr>,
    <expr><name>DB_PROGRESS</name></expr>,          <expr><name>DB_REKEY</name></expr>,            <expr><name>DB_ROLLBACK_HOOK</name></expr>,
    <expr><name>DB_STATUS</name></expr>,            <expr><name>DB_TIMEOUT</name></expr>,          <expr><name>DB_TOTAL_CHANGES</name></expr>,
    <expr><name>DB_TRACE</name></expr>,             <expr><name>DB_TRANSACTION</name></expr>,      <expr><name>DB_UPDATE_HOOK</name></expr>, 
    <expr><name>DB_VERSION</name></expr>
  }</block>;</enum>
  <comment type="block">/* don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler */</comment>

  <if>if<condition>( <expr><name>objc</name>&lt;2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SUBCOMMAND ..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr><call><name>Tcl_GetIndexFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>DB_strs</name></expr></argument>, <argument><expr>"option"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>choice</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>

  <switch>switch<condition>( <expr>(enum <name>DB_enum</name>)<name>choice</name></expr> )</condition><block>{

  <comment type="block">/*    $db authorizer ?CALLBACK?
  **
  ** Invoke the given callback to authorize each SQL operation as it is
  ** compiled.  5 arguments are appended to the callback before it is
  ** invoked:
  **
  **   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
  **   (2) First descriptive name (depends on authorization type)
  **   (3) Second descriptive name
  **   (4) Name of the database (ex: "main", "temp")
  **   (5) Name of trigger that is doing the access
  **
  ** The callback should return on of the following strings: SQLITE_OK,
  ** SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
  **
  ** If this method is invoked with no arguments, the current authorization
  ** callback string is returned.
  */</comment>
  <case>case <expr><name>DB_AUTHORIZER</name></expr>: <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifdef>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"authorization not available in this build"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>( <expr><name>objc</name>&gt;3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?CALLBACK?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zAuth</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zAuth</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zAuth</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zAuth</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zAuth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zAuth</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zAuth</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zAuth</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zAuth</name></expr></argument>, <argument><expr><name>zAuth</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zAuth</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zAuth</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>auth_callback</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_set_authorizer</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db busy ?CALLBACK?
  **
  ** Invoke the given callback if an SQL statement attempts to open
  ** a locked database file.
  */</comment>
  </case><case>case <expr><name>DB_BUSY</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>&gt;3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"CALLBACK"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zBusy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zBusy</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zBusy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zBusy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zBusy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zBusy</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zBusy</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zBusy</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zBusy</name></expr></argument>, <argument><expr><name>zBusy</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zBusy</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zBusy</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>DbBusyHandler</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_busy_handler</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*     $db cache flush
  **     $db cache size n
  **
  ** Flush the prepared statement cache, or set the maximum number of
  ** cached statements.
  */</comment>
  </case><case>case <expr><name>DB_CACHE</name></expr>: <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>subCmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <if>if<condition>( <expr><name>objc</name>&lt;=2</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"cache option ?arg?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>subCmd</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>( <argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>*<name>subCmd</name>=='f' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>subCmd</name></expr></argument>,<argument><expr>"flush"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"flush"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>flushStmtCache</name><argument_list>( <argument><expr><name>pDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else <if>if<condition>( <expr>*<name>subCmd</name>=='s' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>subCmd</name></expr></argument>,<argument><expr>"size"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>objc</name>!=4</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"size n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then><else>else<block>{
        <if>if<condition>( <expr><name>TCL_ERROR</name>==<call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>( <argument><expr><name>interp</name></expr></argument>, <argument><expr>"cannot convert \""</expr></argument>, 
               <argument><expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"\" to integer"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>TCL_ERROR</name></expr>;</return>
        }</block></then><else>else<block>{
          <if>if<condition>( <expr><name>n</name>&lt;0</expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>flushStmtCache</name><argument_list>( <argument><expr><name>pDb</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
          }</block></then><else>else <if>if<condition>( <expr><name>n</name>&gt;<name>MAX_PREPARED_STMTS</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>n</name> = <name>MAX_PREPARED_STMTS</name></expr>;</expr_stmt>
          }</block></then></if></else></if>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>maxStmt</name> = <name>n</name></expr>;</expr_stmt>
        }</block></else></if>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>( <argument><expr><name>interp</name></expr></argument>, <argument><expr>"bad option \""</expr></argument>, 
          <argument><expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"\": must be flush or size"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*     $db changes
  **
  ** Return the number of rows that were modified, inserted, or deleted by
  ** the most recent INSERT, UPDATE or DELETE statement, not including 
  ** any changes made by trigger programs.
  */</comment>
  </case><case>case <expr><name>DB_CHANGES</name></expr>: <block>{
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pResult</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=2</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pResult</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetIntObj</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><call><name>sqlite3_changes</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db close
  **
  ** Shutdown the database
  */</comment>
  </case><case>case <expr><name>DB_CLOSE</name></expr>: <block>{
    <expr_stmt><expr><call><name>Tcl_DeleteCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db collate NAME SCRIPT
  **
  ** Create a new SQL collation function called NAME.  Whenever
  ** that function is called, invoke SCRIPT to evaluate the function.
  */</comment>
  </case><case>case <expr><name>DB_COLLATE</name></expr>: <block>{
    <decl_stmt><decl><type><name>SqlCollate</name> *</type><name>pCollate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zScript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nScript</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=4</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"NAME SCRIPT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zName</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zScript</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCollate</name> = (<name>SqlCollate</name>*)<call><name>Tcl_Alloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pCollate</name></expr></argument>)</argument_list></call> + <name>nScript</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pCollate</name>==0</expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><name>pCollate</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCollate</name>-&gt;<name>pNext</name> = <name>pDb</name>-&gt;<name>pCollate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pCollate</name>-&gt;<name>zScript</name> = (<name>char</name>*)&amp;<name><name>pCollate</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pCollate</name> = <name>pCollate</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pCollate</name>-&gt;<name>zScript</name></expr></argument>, <argument><expr><name>zScript</name></expr></argument>, <argument><expr><name>nScript</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3_create_collation</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, 
        <argument><expr><name>pCollate</name></expr></argument>, <argument><expr><name>tclSqlCollate</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db collation_needed SCRIPT
  **
  ** Create a new SQL collation function called NAME.  Whenever
  ** that function is called, invoke SCRIPT to evaluate the function.
  */</comment>
  </case><case>case <expr><name>DB_COLLATION_NEEDED</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SCRIPT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>pCollateNeeded</name> = <call><name>Tcl_DuplicateObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>pCollateNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_collation_needed</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>tclCollateNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db commit_hook ?CALLBACK?
  **
  ** Invoke the given callback just before committing every SQL transaction.
  ** If the callback throws an exception or returns non-zero, then the
  ** transaction is aborted.  If CALLBACK is an empty string, the callback
  ** is disabled.
  */</comment>
  </case><case>case <expr><name>DB_COMMIT_HOOK</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>&gt;3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?CALLBACK?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zCommit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zCommit</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zCommit</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zCommit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zCommit</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zCommit</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zCommit</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zCommit</name></expr></argument>, <argument><expr><name>zCommit</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zCommit</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zCommit</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_commit_hook</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>DbCommitHandler</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_commit_hook</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db complete SQL
  **
  ** Return TRUE if SQL is a complete SQL statement.  Return FALSE if
  ** additional lines of input are needed.  This is similar to the
  ** built-in "info complete" command of Tcl.
  */</comment>
  </case><case>case <expr><name>DB_COMPLETE</name></expr>: <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPLETE</name></cpp:ifndef>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>isComplete</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SQL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>isComplete</name> = <call><name>sqlite3_complete</name><argument_list>( <argument><expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pResult</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetBooleanObj</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>isComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
  **
  ** Copy data into table from filename, optionally using SEPARATOR
  ** as column separators.  If a column contains a null string, or the
  ** value of NULLINDICATOR, a NULL is inserted for the column.
  ** conflict-algorithm is one of the sqlite conflict algorithms:
  **    rollback, abort, fail, ignore, replace
  ** On success, return the number of lines processed, not necessarily same
  ** as 'db changes' due to conflict-algorithm selected.
  **
  ** This code is basically an implementation/enhancement of
  ** the sqlite3 shell.c ".import" command.
  **
  ** This command usage is equivalent to the sqlite2.x COPY statement,
  ** which imports file data into a table using the PostgreSQL COPY file format:
  **   $db copy $conflit_algo $table_name $filename \t \\N
  */</comment>
  </case><case>case <expr><name>DB_COPY</name></expr>: <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zTable</name></decl>;</decl_stmt>               <comment type="block">/* Insert data into this table */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zFile</name></decl>;</decl_stmt>                <comment type="block">/* The file from which to extract data */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zConflict</name></decl>;</decl_stmt>            <comment type="block">/* The conflict algorithm to use */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>        <comment type="block">/* A statement */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nCol</name></decl>;</decl_stmt>                   <comment type="block">/* Number of columns in the table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in an SQL string */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>                   <comment type="block">/* Loop counters */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nSep</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes in zSep[] */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nNull</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bytes in zNull[] */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zSql</name></decl>;</decl_stmt>                 <comment type="block">/* An SQL statement */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zLine</name></decl>;</decl_stmt>                <comment type="block">/* A single line of input from the file */</comment>
    <decl_stmt><decl><type><name>char</name> **</type><name>azCol</name></decl>;</decl_stmt>               <comment type="block">/* zLine[] broken up into columns */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>zCommit</name></decl>;</decl_stmt>              <comment type="block">/* How to commit changes */</comment>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>in</name></decl>;</decl_stmt>                   <comment type="block">/* The input file */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lineno</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>             <comment type="block">/* Line number of input file */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zLineNum</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* Line number print buffer */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pResult</name></decl>;</decl_stmt>           <comment type="block">/* interp result */</comment>

    <decl_stmt><decl><type><name>char</name> *</type><name>zSep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zNull</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>&lt;5 || <name>objc</name>&gt;7</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, 
         <argument><expr>"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>objc</name>&gt;=6</expr> )</condition><then><block>{
      <expr_stmt><expr><name>zSep</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>5</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>zSep</name> = "\t"</expr>;</expr_stmt>
    }</block></else></if>
    <if>if<condition>( <expr><name>objc</name>&gt;=7</expr> )</condition><then><block>{
      <expr_stmt><expr><name>zNull</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>6</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>zNull</name> = ""</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>zConflict</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTable</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zFile</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nSep</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nNull</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nSep</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"Error: non-null separator required for copy"</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zConflict</name></expr></argument>, <argument><expr>"rollback"</expr></argument>)</argument_list></call> != 0 &amp;&amp;
       <call><name>strcmp</name><argument_list>(<argument><expr><name>zConflict</name></expr></argument>, <argument><expr>"abort"</expr></argument>   )</argument_list></call> != 0 &amp;&amp;
       <call><name>strcmp</name><argument_list>(<argument><expr><name>zConflict</name></expr></argument>, <argument><expr>"fail"</expr></argument>    )</argument_list></call> != 0 &amp;&amp;
       <call><name>strcmp</name><argument_list>(<argument><expr><name>zConflict</name></expr></argument>, <argument><expr>"ignore"</expr></argument>  )</argument_list></call> != 0 &amp;&amp;
       <call><name>strcmp</name><argument_list>(<argument><expr><name>zConflict</name></expr></argument>, <argument><expr>"replace"</expr></argument> )</argument_list></call> != 0</expr> )</condition><then> <block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: \""</expr></argument>, <argument><expr><name>zConflict</name></expr></argument>, 
            <argument><expr>"\", conflict-algorithm must be one of: rollback, "
            "abort, fail, ignore, or replace"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zSql</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"SELECT * FROM '%q'"</expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: no such table: "</expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>nByte</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: "</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nCol</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>nCol</name> = <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>nCol</name>==0</expr> )</condition><then> <block>{
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zSql</name> = <call><name>malloc</name><argument_list>( <argument><expr><name>nByte</name> + 50 + <name>nCol</name>*2</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>zSql</name>==0</expr> )</condition><then> <block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: can't malloc()"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name>+50</expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>"INSERT OR %q INTO '%q' VALUES(?"</expr></argument>,
         <argument><expr><name>zConflict</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = ','</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = '?'</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name>++</expr>]</index></name> = ')'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zSql</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: "</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>in</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>in</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: cannot open file: "</expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>azCol</name> = <call><name>malloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>*(<name>nCol</name>+1)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>azCol</name>==0</expr> )</condition><then> <block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"Error: can't malloc()"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"BEGIN"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCommit</name> = "COMMIT"</expr>;</expr_stmt>
    <while>while<condition>( <expr>(<name>zLine</name> = <call><name>local_getline</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call>)!=0</expr> )</condition><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>z</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>lineno</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>azCol</name><index>[<expr>0</expr>]</index></name> = <name>zLine</name></expr>;</expr_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>, <expr><name>z</name>=<name>zLine</name></expr>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>z</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr>*<name>z</name>==<name><name>zSep</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>nSep</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
          <expr_stmt><expr>*<name>z</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
          <if>if<condition>( <expr><name>i</name>&lt;<name>nCol</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>z</name><index>[<expr><name>nSep</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>z</name> += <name>nSep</name>-1</expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></for>
      <if>if<condition>( <expr><name>i</name>+1!=<name>nCol</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nErr</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>)</argument_list></call> + 200</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>zErr</name> = <call><name>malloc</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>zErr</name></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nErr</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>,
             <argument><expr>"Error: %s line %d: expected %d columns of data but found %d"</expr></argument>,
             <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>nCol</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>zCommit</name> = "ROLLBACK"</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <comment type="block">/* check for null data, if so, bind as null */</comment>
        <if>if<condition>( <expr>(<name>nNull</name>&gt;0 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zNull</name></expr></argument>)</argument_list></call>==0)
          || <call><name>strlen30</name><argument_list>(<argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>==0</expr> 
        )</condition><then><block>{
          <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr><name><name>azCol</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></for>
      <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"Error: "</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zCommit</name> = "ROLLBACK"</expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></while>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>azCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zCommit</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name><name>zCommit</name><index>[<expr>0</expr>]</index></name> == 'C'</expr> )</condition><then><block>{
      <comment type="block">/* success, set result as number of lines processed */</comment>
      <expr_stmt><expr><name>pResult</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_SetIntObj</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>TCL_OK</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <comment type="block">/* failure, append lineno where failed */</comment>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zLineNum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zLineNum</name></expr></argument>,<argument><expr>"%d"</expr></argument>,<argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>", failed while processing line: "</expr></argument>,<argument><expr><name>zLineNum</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
    }</block></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **    $db enable_load_extension BOOLEAN
  **
  ** Turn the extension loading feature on or off.  It if off by
  ** default.
  */</comment>
  </case><case>case <expr><name>DB_ENABLE_LOAD_EXTENSION</name></expr>: <block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
    <decl_stmt><decl><type><name>int</name></type> <name>onoff</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"BOOLEAN"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>onoff</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3_enable_load_extension</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>onoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"extension loading is turned off at compile-time"</expr></argument>,
                     <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block>

  <comment type="block">/*
  **    $db errorcode
  **
  ** Return the numeric error code that was returned by the most recent
  ** call to sqlite3_exec().
  */</comment>
  </case><case>case <expr><name>DB_ERRORCODE</name></expr>: <block>{
    <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>
   
  <comment type="block">/*
  **    $db eval $sql ?array? ?{  ...code... }?
  **    $db onecolumn $sql
  **
  ** The SQL statement in $sql is evaluated.  For each row, the values are
  ** placed in elements of the array named "array" and ...code... is executed.
  ** If "array" and "code" are omitted, then no callback is every invoked.
  ** If "array" is an empty string, then the values are placed in variables
  ** that have the same name as the fields extracted by the query.
  **
  ** The onecolumn method is the equivalent of:
  **     lindex [$db eval $sql] 0
  */</comment>
  </case><case>case <expr><name>DB_ONECOLUMN</name></expr>:
  </case><case>case <expr><name>DB_EVAL</name></expr>:
  </case><case>case <expr><name>DB_EXISTS</name></expr>: <block>{
    <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zSql</name></decl>;</decl_stmt>      <comment type="block">/* Next SQL statement to execute */</comment>
    <decl_stmt><decl><type><name>char</name> <name>const</name> *</type><name>zLeft</name></decl>;</decl_stmt>     <comment type="block">/* What is left after first stmt in zSql */</comment>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> *</type><name>pStmt</name></decl>;</decl_stmt>   <comment type="block">/* Compiled SQL statment */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pArray</name></decl>;</decl_stmt>       <comment type="block">/* Name of array into which results are written */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name></decl>;</decl_stmt>      <comment type="block">/* Script to run for each result set */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>apParm</name></decl>;</decl_stmt>      <comment type="block">/* Parameters that need a Tcl_DecrRefCount() */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nParm</name></decl>;</decl_stmt>             <comment type="block">/* Number of entries used in apParm[] */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name><name>aParm</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Static space for apParm[] in the common case */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pRet</name></decl>;</decl_stmt>         <comment type="block">/* Value to be returned */</comment>
    <decl_stmt><decl><type><name>SqlPreparedStmt</name> *</type><name>pPreStmt</name></decl>;</decl_stmt>  <comment type="block">/* Pointer to a prepared statement */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

    <if>if<condition>( <expr><name>choice</name>==<name>DB_EVAL</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>objc</name>&lt;3 || <name>objc</name>&gt;5</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SQL ?ARRAY-NAME? ?SCRIPT?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then></if>
      <expr_stmt><expr><name>pRet</name> = <call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"SQL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then></if>
      <if>if<condition>( <expr><name>choice</name>==<name>DB_EXISTS</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pRet</name> = <call><name>Tcl_NewBooleanObj</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pRet</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>
    <if>if<condition>( <expr><name>objc</name>==3</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pArray</name> = <name>pScript</name> = 0</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==4</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pArray</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>pScript</name> = <name><name>objv</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pArray</name> = <name><name>objv</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name>pArray</name></expr></argument>)</argument_list></call>[0]==0</expr> )</condition><then> <expr_stmt><expr><name>pArray</name> = 0</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>pScript</name> = <name><name>objv</name><index>[<expr>4</expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSql</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>rc</name>==<name>TCL_OK</name> &amp;&amp; <name><name>zSql</name><index>[<expr>0</expr>]</index></name></expr> )</condition><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Loop counter */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nVar</name></decl>;</decl_stmt>                  <comment type="block">/* Number of bind parameters in the pStmt */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nCol</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>             <comment type="block">/* Number of columns in the result set */</comment>
      <decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>apColName</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>   <comment type="block">/* Array of column names */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>                   <comment type="block">/* String length of zSql */</comment>
  
      <comment type="block">/* Try to find a SQL statement that has already been compiled and
      ** which matches the next sequence of SQL.
      */</comment>
      <expr_stmt><expr><name>pStmt</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> = <call><name>strlen30</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>pPreStmt</name> = <name>pDb</name>-&gt;<name>stmtList</name></expr>;</init> <condition><expr><name>pPreStmt</name></expr>;</condition> <incr><expr><name>pPreStmt</name>=<name>pPreStmt</name>-&gt;<name>pNext</name></expr></incr>)<block>{
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pPreStmt</name>-&gt;<name>nSql</name></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>len</name>&gt;=<name>n</name> 
            &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>pPreStmt</name>-&gt;<name>zSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call>==0
            &amp;&amp; (<name><name>zSql</name><index>[<expr><name>n</name></expr>]</index></name>==0 || <name><name>zSql</name><index>[<expr><name>n</name>-1</expr>]</index></name>==';')</expr>
        )</condition><then><block>{
          <expr_stmt><expr><name>pStmt</name> = <name>pPreStmt</name>-&gt;<name>pStmt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>zLeft</name> = &amp;<name><name>zSql</name><index>[<expr><name>pPreStmt</name>-&gt;<name>nSql</name></expr>]</index></name></expr>;</expr_stmt>

          <comment type="block">/* When a prepared statement is found, unlink it from the
          ** cache list.  It will later be added back to the beginning
          ** of the cache list in order to implement LRU replacement.
          */</comment>
          <if>if<condition>( <expr><name>pPreStmt</name>-&gt;<name>pPrev</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>pPrev</name>-&gt;<name>pNext</name> = <name>pPreStmt</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtList</name> = <name>pPreStmt</name>-&gt;<name>pNext</name></expr>;</expr_stmt>
          }</block></else></if>
          <if>if<condition>( <expr><name>pPreStmt</name>-&gt;<name>pNext</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>pNext</name>-&gt;<name>pPrev</name> = <name>pPreStmt</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtLast</name> = <name>pPreStmt</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
          }</block></else></if>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>nStmt</name>--</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
  
      <comment type="block">/* If no prepared statement was found.  Compile the SQL text
      */</comment>
      <if>if<condition>( <expr><name>pStmt</name>==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>pStmt</name></expr></argument>, <argument><expr>&amp;<name>zLeft</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>dbTextToObj</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
        <if>if<condition>( <expr><name>pStmt</name>==0</expr> )</condition><then><block>{
          <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
            <comment type="block">/* A compile-time error in the statement
            */</comment>
            <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>dbTextToObj</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then><else>else<block>{
            <comment type="block">/* The statement was a no-op.  Continue to the next statement
            ** in the SQL string.
            */</comment>
            <expr_stmt><expr><name>zSql</name> = <name>zLeft</name></expr>;</expr_stmt>
            <continue>continue;</continue>
          }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPreStmt</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="block">/* Bind values to parameters that begin with $ or :
      */</comment>  
      <expr_stmt><expr><name>nVar</name> = <call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nParm</name> = 0</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>nVar</name>&gt;<call><name>sizeof</name><argument_list>(<argument><expr><name>aParm</name></expr></argument>)</argument_list></call>/<call><name>sizeof</name><argument_list>(<argument><expr><name><name>aParm</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <expr_stmt><expr><name>apParm</name> = (<name>Tcl_Obj</name>**)<call><name>Tcl_Alloc</name><argument_list>(<argument><expr><name>nVar</name>*<call><name>sizeof</name><argument_list>(<argument><expr><name><name>apParm</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>apParm</name> = <name>aParm</name></expr>;</expr_stmt>
      }</block></else></if>
      <for>for(<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;=<name>nVar</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zVar</name> =<init> <expr><call><name>sqlite3_bind_parameter_name</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if<condition>( <expr><name>zVar</name>!=0 &amp;&amp; (<name><name>zVar</name><index>[<expr>0</expr>]</index></name>=='$' || <name><name>zVar</name><index>[<expr>0</expr>]</index></name>==':' || <name><name>zVar</name><index>[<expr>0</expr>]</index></name>=='@')</expr> )</condition><then><block>{
          <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pVar</name> =<init> <expr><call><name>Tcl_GetVar2Ex</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>&amp;<name><name>zVar</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if<condition>( <expr><name>pVar</name></expr> )</condition><then><block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>u8</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> *</type><name>zType</name> =<init> <expr><name>pVar</name>-&gt;<name>typePtr</name> ? <name>pVar</name>-&gt;<name>typePtr</name>-&gt;<name>name</name> : ""</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>c</name> =<init> <expr><name><name>zType</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if<condition>( <expr><name><name>zVar</name><index>[<expr>0</expr>]</index></name>=='@' ||
               (<name>c</name>=='b' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"bytearray"</expr></argument>)</argument_list></call>==0 &amp;&amp; <name>pVar</name>-&gt;<name>bytes</name>==0)</expr> )</condition><then><block>{
              <comment type="block">/* Load a BLOB type if the Tcl variable is a bytearray and
              ** it has no string representation or the host
              ** parameter name begins with "@". */</comment>
              <expr_stmt><expr><name>data</name> = <call><name>Tcl_GetByteArrayFromObj</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>apParm</name><index>[<expr><name>nParm</name>++</expr>]</index></name> = <name>pVar</name></expr>;</expr_stmt>
            }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='b' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"boolean"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
              <expr_stmt><expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else <if>if<condition>( <expr><name>c</name>=='d' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"double"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
              <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>Tcl_GetDoubleFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_bind_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else <if>if<condition>( <expr>(<name>c</name>=='w' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"wideInt"</expr></argument>)</argument_list></call>==0) ||
                  (<name>c</name>=='i' &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>zType</name></expr></argument>,<argument><expr>"int"</expr></argument>)</argument_list></call>==0)</expr> )</condition><then><block>{
              <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>v</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><name>data</name> = (<name>unsigned</name> <name>char</name> *)<call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>apParm</name><index>[<expr><name>nParm</name>++</expr>]</index></name> = <name>pVar</name></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if></else></if>
          }</block></then><else>else<block>{
            <expr_stmt><expr><call><name>sqlite3_bind_null</name><argument_list>( <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then></if>
      }</block></for>

      <comment type="block">/* Execute the SQL
      */</comment>
      <while>while<condition>( <expr><name>rc</name>==<name>TCL_OK</name> &amp;&amp; <name>pStmt</name> &amp;&amp; <name>SQLITE_ROW</name>==<call><name>sqlite3_step</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr> )</condition><block>{

	<comment type="block">/* Compute column names. This must be done after the first successful
	** call to sqlite3_step(), in case the query is recompiled and the
        ** number or names of the returned columns changes. 
        */</comment>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>pArray</name>||<name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nCol</name> &lt; 0</expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>Tcl_Obj</name> ***</type><name>ap</name> =<init> <expr>(<name>pScript</name>?&amp;<name>apColName</name>:0)</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>nCol</name> = <call><name>computeColumnNames</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pVal</name></decl>;</decl_stmt>
          
          <comment type="block">/* Set pVal to contain the i'th column of this row. */</comment>
          <switch>switch<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block>{
            <case>case <expr><name>SQLITE_BLOB</name></expr>: <block>{
              <decl_stmt><decl><type><name>int</name></type> <name>bytes</name> =<init> <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zBlob</name> =<init> <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if>if<condition>( <expr>!<name>zBlob</name></expr> )</condition><then> <expr_stmt><expr><name>bytes</name> = 0</expr>;</expr_stmt></then></if>
              <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewByteArrayObj</name><argument_list>(<argument><expr>(<name>u8</name>*)<name>zBlob</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name>SQLITE_INTEGER</name></expr>: <block>{
              <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>v</name> =<init> <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if>if<condition>( <expr><name>v</name>&gt;=-2147483647 &amp;&amp; <name>v</name>&lt;=2147483647</expr> )</condition><then><block>{
                <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then><else>else<block>{
                <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewWideIntObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></else></if>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name>SQLITE_FLOAT</name></expr>: <block>{
              <decl_stmt><decl><type><name>double</name></type> <name>r</name> =<init> <expr><call><name>sqlite3_column_double</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>pVal</name> = <call><name>Tcl_NewDoubleObj</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
            </case><case>case <expr><name>SQLITE_NULL</name></expr>: <block>{
              <expr_stmt><expr><name>pVal</name> = <call><name>dbTextToObj</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
            </case><default>default: <block>{
              <expr_stmt><expr><name>pVal</name> = <call><name>dbTextToObj</name><argument_list>(<argument><expr>(<name>char</name> *)<call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block>
          </default>}</block></switch>
  
          <if>if<condition>( <expr><name>pScript</name></expr> )</condition><then><block>{
            <if>if<condition>( <expr><name>pArray</name>==0</expr> )</condition><then><block>{
              <expr_stmt><expr><call><name>Tcl_ObjSetVar2</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then><else>else<block>{
              <expr_stmt><expr><call><name>Tcl_ObjSetVar2</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>, <argument><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          }</block></then><else>else <if>if<condition>( <expr><name>choice</name>==<name>DB_ONECOLUMN</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pRet</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>( <expr><name>pRet</name>==0</expr> )</condition><then><block>{
              <expr_stmt><expr><name>pRet</name> = <name>pVal</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>rc</name> = <name>TCL_BREAK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> = <name>nCol</name></expr>;</expr_stmt>
          }</block></then><else>else <if>if<condition>( <expr><name>choice</name>==<name>DB_EXISTS</name></expr> )</condition><then><block>{
            <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pRet</name> = <call><name>Tcl_NewBooleanObj</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <name>TCL_BREAK</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> = <name>nCol</name></expr>;</expr_stmt>
          }</block></then><else>else<block>{
            <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if></else></if></else></if>
        }</block></for>
  
        <if>if<condition>( <expr><name>pScript</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>pDb</name>-&gt;<name>nStep</name> = <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, 
                                  <argument><expr><name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>nSort</name> = <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,
                                  <argument><expr><name>SQLITE_STMTSTATUS_SORT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> = <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pScript</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>rc</name>==<name>TCL_CONTINUE</name></expr> )</condition><then><block>{
            <expr_stmt><expr><name>rc</name> = <name>TCL_OK</name></expr>;</expr_stmt>
          }</block></then></if>
        }</block></then></if>
      }</block></while>
      <if>if<condition>( <expr><name>rc</name>==<name>TCL_BREAK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>rc</name> = <name>TCL_OK</name></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="block">/* Free the column name objects */</comment>
      <if>if<condition>( <expr><name>pScript</name></expr> )</condition><then><block>{
        <comment type="block">/* If the query returned no rows, but an array variable was 
        ** specified, call computeColumnNames() now to populate the 
        ** arrayname(*) variable.
        */</comment>
        <if>if <condition>(<expr><name>pArray</name> &amp;&amp; <name>nCol</name> &lt; 0</expr>)</condition><then> <block>{
          <decl_stmt><decl><type><name>Tcl_Obj</name> ***</type><name>ap</name> =<init> <expr>(<name>pScript</name>?&amp;<name>apColName</name>:0)</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>nCol</name> = <call><name>computeColumnNames</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>, <argument><expr><name>pArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nCol</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>apColName</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>apColName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="block">/* Free the bound string and blob parameters */</comment>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nParm</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>apParm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
      <if>if<condition>( <expr><name>apParm</name>!=<name>aParm</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>apParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <comment type="block">/* Reset the statement.  If the result code is SQLITE_SCHEMA, then
      ** flush the statement cache and try the statement again.
      */</comment>
      <expr_stmt><expr><name>rc2</name> = <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name>-&gt;<name>nStep</name> = <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, 
                                  <argument><expr><name>SQLITE_STMTSTATUS_FULLSCAN_STEP</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDb</name>-&gt;<name>nSort</name> = <call><name>sqlite3_stmt_status</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,
                                  <argument><expr><name>SQLITE_STMTSTATUS_SORT</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>SQLITE_OK</name>!=<name>rc2</name></expr> )</condition><then><block>{
        <comment type="block">/* If a run-time error occurs, report the error and stop reading
        ** the SQL
        */</comment>
        <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>dbTextToObj</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pPreStmt</name></expr> )</condition><then> <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pPreStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <break>break;</break>
      }</block></then><else>else <if>if<condition>( <expr><name>pDb</name>-&gt;<name>maxStmt</name>&lt;=0</expr> )</condition><then><block>{
        <comment type="block">/* If the cache is turned off, deallocated the statement */</comment>
        <if>if<condition>( <expr><name>pPreStmt</name></expr> )</condition><then> <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pPreStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <comment type="block">/* Everything worked and the cache is operational.
        ** Create a new SqlPreparedStmt structure if we need one.
        ** (If we already have one we can just reuse it.)
        */</comment>
        <if>if<condition>( <expr><name>pPreStmt</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><name>len</name> = <name>zLeft</name> - <name>zSql</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPreStmt</name> = (<name>SqlPreparedStmt</name>*)<call><name>Tcl_Alloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pPreStmt</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>( <expr><name>pPreStmt</name>==0</expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
          <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>pStmt</name> = <name>pStmt</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>nSql</name> = <name>len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>zSql</name> = <call><name>sqlite3_sql</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>strlen30</name><argument_list>(<argument><expr><name>pPreStmt</name>-&gt;<name>zSql</name></expr></argument>)</argument_list></call>==<name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==<call><name>memcmp</name><argument_list>(<argument><expr><name>pPreStmt</name>-&gt;<name>zSql</name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Add the prepared statement to the beginning of the cache list
        */</comment>
        <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>pNext</name> = <name>pDb</name>-&gt;<name>stmtList</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pPreStmt</name>-&gt;<name>pPrev</name> = 0</expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pDb</name>-&gt;<name>stmtList</name></expr> )</condition><then><block>{
         <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtList</name>-&gt;<name>pPrev</name> = <name>pPreStmt</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtList</name> = <name>pPreStmt</name></expr>;</expr_stmt>
        <if>if<condition>( <expr><name>pDb</name>-&gt;<name>stmtLast</name>==0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>nStmt</name>==0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtLast</name> = <name>pPreStmt</name></expr>;</expr_stmt>
        }</block></then><else>else<block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDb</name>-&gt;<name>nStmt</name>&gt;0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>pDb</name>-&gt;<name>nStmt</name>++</expr>;</expr_stmt>
   
        <comment type="block">/* If we have too many statement in cache, remove the surplus from the
        ** end of the cache list.
        */</comment>
        <while>while<condition>( <expr><name>pDb</name>-&gt;<name>nStmt</name>&gt;<name>pDb</name>-&gt;<name>maxStmt</name></expr> )</condition><block>{
          <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>stmtLast</name>-&gt;<name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtLast</name> = <name>pDb</name>-&gt;<name>stmtLast</name>-&gt;<name>pPrev</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>pDb</name>-&gt;<name>stmtLast</name>-&gt;<name>pNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>stmtLast</name>-&gt;<name>pNext</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>pDb</name>-&gt;<name>nStmt</name>--</expr>;</expr_stmt>
        }</block></while>
      }</block></else></if></else></if>

      <comment type="block">/* Proceed to the next statement */</comment>
      <expr_stmt><expr><name>zSql</name> = <name>zLeft</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>pRet</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>rc</name>==<name>TCL_OK</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>rc</name>==<name>TCL_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_ResetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db function NAME [-argcount N] SCRIPT
  **
  ** Create a new SQL function called NAME.  Whenever that function is
  ** called, invoke SCRIPT to evaluate the function.
  */</comment>
  </case><case>case <expr><name>DB_FUNCTION</name></expr>: <block>{
    <decl_stmt><decl><type><name>SqlFunc</name> *</type><name>pFunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>==6</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><call><name>strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>n</name>&gt;2 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>"-argcount"</expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
        <if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>4</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nArg</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
        <if>if<condition>( <expr><name>nArg</name>&lt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"number of arguments must be non-negative"</expr></argument>,
                           <argument><expr>(<name>char</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>TCL_ERROR</name></expr>;</return>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>pScript</name> = <name><name>objv</name><index>[<expr>5</expr>]</index></name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>!=4</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"NAME [-argcount N] SCRIPT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>pScript</name> = <name><name>objv</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if></else></if>
    <expr_stmt><expr><name>zName</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFunc</name> = <call><name>findSqlFunc</name><argument_list>(<argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pFunc</name>==0</expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
    <if>if<condition>( <expr><name>pFunc</name>-&gt;<name>pScript</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr><name>pFunc</name>-&gt;<name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pFunc</name>-&gt;<name>pScript</name> = <name>pScript</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr><name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pFunc</name>-&gt;<name>useEvalObjv</name> = <call><name>safeToUseEvalObjv</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pScript</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>,
        <argument><expr><name>pFunc</name></expr></argument>, <argument><expr><name>tclSqlFunc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
  */</comment>
  </case><case>case <expr><name>DB_INCRBLOB</name></expr>: <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_INCRBLOB</name></cpp:ifdef>
    <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"incrblob not available in this build"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zDb</name> =<init> <expr>"main"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zTable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zColumn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl>;</decl_stmt>

    <comment type="block">/* Check for the -readonly option */</comment>
    <if>if<condition>( <expr><name>objc</name>&gt;3 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"-readonly"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>isReadonly</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if<condition>( <expr><name>objc</name>!=(5+<name>isReadonly</name>) &amp;&amp; <name>objc</name>!=(6+<name>isReadonly</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?-readonly? ?DB? TABLE COLUMN ROWID"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>

    <if>if<condition>( <expr><name>objc</name>==(6+<name>isReadonly</name>)</expr> )</condition><then><block>{
      <expr_stmt><expr><name>zDb</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zTable</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>objc</name>-3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zColumn</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>objc</name>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>Tcl_GetWideIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>objc</name>-1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>( <expr><name>rc</name>==<name>TCL_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>createIncrblobChannel</name><argument_list>(
          <argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zTable</name></expr></argument>, <argument><expr><name>zColumn</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>, <argument><expr><name>isReadonly</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db interrupt
  **
  ** Interrupt the execution of the inner-most SQL interpreter.  This
  ** causes the SQL statement to return an error of SQLITE_INTERRUPT.
  */</comment>
  </case><case>case <expr><name>DB_INTERRUPT</name></expr>: <block>{
    <expr_stmt><expr><call><name>sqlite3_interrupt</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db nullvalue ?STRING?
  **
  ** Change text used when a NULL comes back from the database. If ?STRING?
  ** is not present, then the current string used for NULL is returned.
  ** If STRING is present, then STRING is returned.
  **
  */</comment>
  </case><case>case <expr><name>DB_NULLVALUE</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>!=2 &amp;&amp; <name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"NULLVALUE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><name>objc</name>==3</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>zNull</name> =<init> <expr><call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zNull</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>( <expr><name>zNull</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zNull</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zNull</name></expr></argument>, <argument><expr><name>zNull</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pDb</name>-&gt;<name><name>zNull</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zNull</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>dbTextToObj</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db last_insert_rowid 
  **
  ** Return an integer which is the ROWID for the most recent insert.
  */</comment>
  </case><case>case <expr><name>DB_LAST_INSERT_ROWID</name></expr>: <block>{
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pResult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tcl_WideInt</name></type> <name>rowid</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=2</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>rowid</name> = <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pResult</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetWideIntObj</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  ** The DB_ONECOLUMN method is implemented together with DB_EVAL.
  */</comment>

  <comment type="block">/*    $db progress ?N CALLBACK?
  ** 
  ** Invoke the given callback every N virtual machine opcodes while executing
  ** queries.
  */</comment>
  </case><case>case <expr><name>DB_PROGRESS</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProgress</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zProgress</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==4</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zProgress</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>N</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>TCL_OK</name>!=<call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>N</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then></if><empty_stmt>;</empty_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProgress</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zProgress</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>3</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zProgress</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zProgress</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zProgress</name></expr></argument>, <argument><expr><name>zProgress</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zProgress</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_PROGRESS_CALLBACK</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProgress</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_progress_handler</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>DbProgressHandler</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_progress_handler</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"N CALLBACK"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db profile ?CALLBACK?
  **
  ** Make arrangements to invoke the CALLBACK routine after each SQL statement
  ** that has run.  The text of the SQL and the amount of elapse time are
  ** appended to CALLBACK before the script is run.
  */</comment>
  </case><case>case <expr><name>DB_PROFILE</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>&gt;3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?CALLBACK?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProfile</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zProfile</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zProfile</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProfile</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zProfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zProfile</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zProfile</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zProfile</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zProfile</name></expr></argument>, <argument><expr><name>zProfile</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zProfile</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zProfile</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_profile</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>DbProfileHandler</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_profile</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db rekey KEY
  **
  ** Change the encryption key on the currently open database.
  */</comment>
  </case><case>case <expr><name>DB_REKEY</name></expr>: <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>pKey</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"KEY"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pKey</name> = <call><name>Tcl_GetByteArrayFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_rekey</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>
  }</block>

  <comment type="block">/*
  **     $db status (step|sort)
  **
  ** Display SQLITE_STMTSTATUS_FULLSCAN_STEP or 
  ** SQLITE_STMTSTATUS_SORT for the most recent eval.
  */</comment>
  </case><case>case <expr><name>DB_STATUS</name></expr>: <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zOp</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"(step|sort)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>zOp</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>, <argument><expr>"step"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>v</name> = <name>pDb</name>-&gt;<name>nStep</name></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zOp</name></expr></argument>, <argument><expr>"sort"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>v</name> = <name>pDb</name>-&gt;<name>nSort</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"bad argument: should be step or sort"</expr></argument>, 
            <argument><expr>(<name>char</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></else></if></else></if>
    <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>
  
  <comment type="block">/*
  **     $db timeout MILLESECONDS
  **
  ** Delay for the number of milliseconds specified when a file is locked.
  */</comment>
  </case><case>case <expr><name>DB_TIMEOUT</name></expr>: <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ms</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"MILLISECONDS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>Tcl_GetIntFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>ms</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
    <expr_stmt><expr><call><name>sqlite3_busy_timeout</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>
  
  <comment type="block">/*
  **     $db total_changes
  **
  ** Return the number of rows that were modified, inserted, or deleted 
  ** since the database handle was created.
  */</comment>
  </case><case>case <expr><name>DB_TOTAL_CHANGES</name></expr>: <block>{
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pResult</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=2</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pResult</name> = <call><name>Tcl_GetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetIntObj</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><call><name>sqlite3_total_changes</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db trace ?CALLBACK?
  **
  ** Make arrangements to invoke the CALLBACK routine for each SQL statement
  ** that is executed.  The text of the SQL is appended to CALLBACK before
  ** it is executed.
  */</comment>
  </case><case>case <expr><name>DB_TRACE</name></expr>: <block>{
    <if>if<condition>( <expr><name>objc</name>&gt;3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?CALLBACK?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then><else>else <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zTrace</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pDb</name>-&gt;<name>zTrace</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then><else>else<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zTrace</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zTrace</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>zTrace</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>zTrace</name> &amp;&amp; <name>len</name>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zTrace</name> = <call><name>Tcl_Alloc</name><argument_list>( <argument><expr><name>len</name> + 1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>zTrace</name></expr></argument>, <argument><expr><name>zTrace</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>zTrace</name> = 0</expr>;</expr_stmt>
      }</block></else></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>zTrace</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>pDb</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_trace</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>DbTraceHandler</name></expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><call><name>sqlite3_trace</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if></else></if>
    <break>break;</break>
  }</block>

  <comment type="block">/*    $db transaction [-deferred|-immediate|-exclusive] SCRIPT
  **
  ** Start a new transaction (if we are not already in the midst of a
  ** transaction) and execute the TCL script SCRIPT.  After SCRIPT
  ** completes, either commit the transaction or roll it back if SCRIPT
  ** throws an exception.  Or if no new transation was started, do nothing.
  ** pass the exception on up the stack.
  **
  ** This command was inspired by Dave Thomas's talk on Ruby at the
  ** 2005 O'Reilly Open Source Convention (OSCON).
  */</comment>
  </case><case>case <expr><name>DB_TRANSACTION</name></expr>: <block>{
    <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pScript</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zBegin</name> =<init> <expr>"SAVEPOINT _tcl_transaction"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zEnd</name></decl>;</decl_stmt>
    <if>if<condition>( <expr><name>objc</name>!=3 &amp;&amp; <name>objc</name>!=4</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"[TYPE] SCRIPT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>

    <if>if<condition>( <expr><name>pDb</name>-&gt;<name>nTransaction</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>zBegin</name> = "SAVEPOINT _tcl_transaction"</expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><name>pDb</name>-&gt;<name>nTransaction</name>==0 &amp;&amp; <name>objc</name>==4</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>static</name> <name>const</name> <name>char</name> *</type><name><name>TTYPE_strs</name><index>[]</index></name> =<init> <expr><block>{
        <expr>"deferred"</expr>,   <expr>"exclusive"</expr>,  <expr>"immediate"</expr>, <expr>0</expr>
      }</block></expr></init></decl>;</decl_stmt>
      <enum>enum <name>TTYPE_enum</name> <block>{
        <expr><name>TTYPE_DEFERRED</name></expr>, <expr><name>TTYPE_EXCLUSIVE</name></expr>, <expr><name>TTYPE_IMMEDIATE</name></expr>
      }</block></enum><empty_stmt>;</empty_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>ttype</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetIndexFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>TTYPE_strs</name></expr></argument>, <argument><expr>"transaction type"</expr></argument>,
                              <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>ttype</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
        <return>return <expr><name>TCL_ERROR</name></expr>;</return>
      }</block></then></if>
      <switch>switch<condition>( <expr>(enum <name>TTYPE_enum</name>)<name>ttype</name></expr> )</condition><block>{
        <case>case <expr><name>TTYPE_DEFERRED</name></expr>:    <comment type="block">/* no-op */</comment><empty_stmt>;</empty_stmt>                 <break>break;</break>
        </case><case>case <expr><name>TTYPE_EXCLUSIVE</name></expr>:   <expr_stmt><expr><name>zBegin</name> = "BEGIN EXCLUSIVE"</expr>;</expr_stmt>  <break>break;</break>
        </case><case>case <expr><name>TTYPE_IMMEDIATE</name></expr>:   <expr_stmt><expr><name>zBegin</name> = "BEGIN IMMEDIATE"</expr>;</expr_stmt>  <break>break;</break>
      </case>}</block></switch>
    }</block></then></if></else></if>
    <expr_stmt><expr><name>pScript</name> = <name><name>objv</name><index>[<expr><name>objc</name>-1</expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pDb</name>-&gt;<name>disableAuth</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zBegin</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>disableAuth</name>--</expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>pDb</name>-&gt;<name>nTransaction</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>Tcl_EvalObjEx</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pScript</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>nTransaction</name>--</expr>;</expr_stmt>

    <if>if<condition>( <expr><name>rc</name>!=<name>TCL_ERROR</name></expr> )</condition><then><block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>nTransaction</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zEnd</name> = "RELEASE _tcl_transaction"</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zEnd</name> = "COMMIT"</expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <if>if<condition>( <expr><name>pDb</name>-&gt;<name>nTransaction</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>zEnd</name> = "ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction"</expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>zEnd</name> = "ROLLBACK"</expr>;</expr_stmt>
      }</block></else></if>
    }</block></else></if>

    <expr_stmt><expr><name>pDb</name>-&gt;<name>disableAuth</name>++</expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr> )</condition><then><block>{
      <comment type="block">/* This is a tricky scenario to handle. The most likely cause of an
      ** error is that the exec() above was an attempt to commit the 
      ** top-level transaction that returned SQLITE_BUSY. Or, less likely,
      ** that an IO-error has occured. In either case, throw a Tcl exception
      ** and try to rollback the transaction.
      **
      ** But it could also be that the user executed one or more BEGIN, 
      ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
      ** this method's logic. Not clear how this would be best handled.
      */</comment>
      <if>if<condition>( <expr><name>rc</name>!=<name>TCL_ERROR</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <name>TCL_ERROR</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>"ROLLBACK"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>pDb</name>-&gt;<name>disableAuth</name>--</expr>;</expr_stmt>

    <break>break;</break>
  }</block>

  <comment type="block">/*
  **    $db update_hook ?script?
  **    $db rollback_hook ?script?
  */</comment>
  </case><case>case <expr><name>DB_UPDATE_HOOK</name></expr>: 
  </case><case>case <expr><name>DB_ROLLBACK_HOOK</name></expr>: <block>{

    <comment type="block">/* set ppHook to point at pUpdateHook or pRollbackHook, depending on 
    ** whether [$db update_hook] or [$db rollback_hook] was invoked.
    */</comment>
    <decl_stmt><decl><type><name>Tcl_Obj</name> **</type><name>ppHook</name></decl>;</decl_stmt> 
    <if>if<condition>( <expr><name>choice</name>==<name>DB_UPDATE_HOOK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>ppHook</name> = &amp;<name>pDb</name>-&gt;<name>pUpdateHook</name></expr>;</expr_stmt>
    }</block></then><else>else<block>{
      <expr_stmt><expr><name>ppHook</name> = &amp;<name>pDb</name>-&gt;<name>pRollbackHook</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if<condition>( <expr><name>objc</name>!=2 &amp;&amp; <name>objc</name>!=3</expr> )</condition><then><block>{
       <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>objv</name></expr></argument>, <argument><expr>"?SCRIPT?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr>*<name>ppHook</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>*<name>ppHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><name>objc</name>==3</expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>Tcl_DecrRefCount</name><argument_list>(<argument><expr>*<name>ppHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>ppHook</name> = 0</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <if>if<condition>( <expr><name>objc</name>==3</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!(*<name>ppHook</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetCharLength</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call>&gt;0</expr> )</condition><then><block>{
        <expr_stmt><expr>*<name>ppHook</name> = <name><name>objv</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Tcl_IncrRefCount</name><argument_list>(<argument><expr>*<name>ppHook</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>sqlite3_update_hook</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>, <argument><expr>(<name>pDb</name>-&gt;<name>pUpdateHook</name>?<name>DbUpdateHandler</name>:0)</expr></argument>, <argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_rollback_hook</name><argument_list>(<argument><expr><name>pDb</name>-&gt;<name>db</name></expr></argument>,<argument><expr>(<name>pDb</name>-&gt;<name>pRollbackHook</name>?<name>DbRollbackHandler</name>:0)</expr></argument>,<argument><expr><name>pDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <break>break;</break>
  }</block>

  <comment type="block">/*    $db version
  **
  ** Return the version string for this database.
  */</comment>
  </case><case>case <expr><name>DB_VERSION</name></expr>: <block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>(<name>char</name> *)<call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  }</block>


  </case>}</block></switch> <comment type="block">/* End of the SWITCH statement */</comment>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
**   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?
**                           ?-create BOOLEAN? ?-nomutex BOOLEAN?
**
** This is the main Tcl command.  When the "sqlite" Tcl command is
** invoked, this routine runs to process that command.
**
** The first argument, DBNAME, is an arbitrary name for a new
** database connection.  This command creates a new command named
** DBNAME that is used to control that connection.  The database
** connection is deleted when the DBNAME command is deleted.
**
** The second argument is the name of the database file.
**
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>DbMain</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>cd</name></decl></param>, <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,<param><decl><type><name>Tcl_Obj</name> *<name>const</name>*</type><name>objv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>SqliteDb</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>pKey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nKey</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErrMsg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zVfs</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> =<init> <expr><name>SQLITE_OPEN_READWRITE</name> | <name>SQLITE_OPEN_CREATE</name> | <name>SQLITE_OPEN_NOMUTEX</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_DString</name></type> <name>translatedFilename</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>objc</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><name>zArg</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr>"-version"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr><name>sqlite3_version</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_OK</name></expr>;</return>
    }</block></then></if>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr>"-has-codec"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"1"</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"0"</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <return>return <expr><name>TCL_OK</name></expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <for>for(<init><expr><name>i</name>=3</expr>;</init> <condition><expr><name>i</name>+1&lt;<name>objc</name></expr>;</condition> <incr><expr><name>i</name>+=2</expr></incr>)<block>{
    <expr_stmt><expr><name>zArg</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>,<argument><expr>"-key"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>pKey</name> = <call><name>Tcl_GetByteArrayFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr>"-vfs"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>zVfs</name> = <call><name>Tcl_GetString</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr>"-readonly"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
      <if>if<condition>( <expr><name>b</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>flags</name> &amp;= ~(<name>SQLITE_OPEN_READWRITE</name>|<name>SQLITE_OPEN_CREATE</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_READWRITE</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr>"-create"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
      <if>if<condition>( <expr><name>b</name> &amp;&amp; (<name>flags</name> &amp; <name>SQLITE_OPEN_READONLY</name>)==0</expr> )</condition><then><block>{
        <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_CREATE</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_CREATE</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr>"-nomutex"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
      <if>if<condition>( <expr><name>b</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_NOMUTEX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_FULLMUTEX</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_NOMUTEX</name></expr>;</expr_stmt>
      }</block></else></if>
   }</block></then><else>else <if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zArg</name></expr></argument>, <argument><expr>"-fullmutex"</expr></argument>)</argument_list></call>==0</expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
      <if>if<condition>( <expr><call><name>Tcl_GetBooleanFromObj</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr> )</condition><then> <return>return <expr><name>TCL_ERROR</name></expr>;</return></then></if>
      <if>if<condition>( <expr><name>b</name></expr> )</condition><then><block>{
        <expr_stmt><expr><name>flags</name> |= <name>SQLITE_OPEN_FULLMUTEX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_NOMUTEX</name></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>flags</name> &amp;= ~<name>SQLITE_OPEN_FULLMUTEX</name></expr>;</expr_stmt>
      }</block></else></if>
    }</block></then><else>else<block>{
      <expr_stmt><expr><call><name>Tcl_AppendResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"unknown option: "</expr></argument>, <argument><expr><name>zArg</name></expr></argument>, <argument><expr>(<name>char</name>*)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TCL_ERROR</name></expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if>
  }</block></for>
  <if>if<condition>( <expr><name>objc</name>&lt;3 || (<name>objc</name>&amp;1)!=1</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_WrongNumArgs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>objv</name></expr></argument>, 
      <argument><expr>"HANDLE FILENAME ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN?"
      " ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN?"
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
      " ?-key CODECKEY?"</expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>zErrMsg</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = (<name>SqliteDb</name>*)<call><name>Tcl_Alloc</name><argument_list>( <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>p</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"malloc failed"</expr></argument>, <argument><expr><name>TCL_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFile</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zFile</name> = <call><name>Tcl_TranslateFileName</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr>&amp;<name>translatedFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_open_v2</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr>&amp;<name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>zVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_DStringFree</name><argument_list>(<argument><expr>&amp;<name>translatedFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<call><name>sqlite3_errcode</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <expr_stmt><expr><name>zErrMsg</name> = <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>db</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_HAS_CODEC</name></cpp:ifdef>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3_key</name><argument_list>(<argument><expr><name>p</name>-&gt;<name>db</name></expr></argument>, <argument><expr><name>pKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>db</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_SetResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><name>TCL_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_Free</name><argument_list>(<argument><expr>(<name>char</name>*)<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>TCL_ERROR</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><name>p</name>-&gt;<name>maxStmt</name> = <name>NUM_PREPARED_STMTS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name>-&gt;<name>interp</name> = <name>interp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zArg</name> = <call><name>Tcl_GetStringFromObj</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>, <argument><expr><name>DbObjCmd</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>p</name></expr></argument>, <argument><expr><name>DbDeleteCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Provide a dummy Tcl_InitStubs if we are using this as a static
** library.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_TCL_STUBS</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive>  <name>Tcl_InitStubs</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>Tcl_InitStubs</name>(a,b,c)</cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Make sure we have a PACKAGE_VERSION macro defined.  This will be
** defined automatically by the TEA makefile.  But other makefiles
** do not define it.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PACKAGE_VERSION</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <name>PACKAGE_VERSION</name> <name>SQLITE_VERSION</name></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Initialize this module.
**
** This Tcl module contains only a single new Tcl command named "sqlite".
** (Hence there is no namespace.  There is no point in using a namespace
** if the extension only supplies one new name!)  The "sqlite" command is
** used to open a new SQLite database.  See the DbMain() routine above
** for additional information.
*/</comment>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite3_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>Tcl_InitStubs</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"8.4"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlite3"</expr></argument>, <argument><expr>(<name>Tcl_ObjCmdProc</name>*)<name>DbMain</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_PkgProvide</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlite3"</expr></argument>, <argument><expr><name>PACKAGE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_CreateObjCommand</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlite"</expr></argument>, <argument><expr>(<name>Tcl_ObjCmdProc</name>*)<name>DbMain</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Tcl_PkgProvide</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"sqlite"</expr></argument>, <argument><expr><name>PACKAGE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite3_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><call><name>Sqlite3_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite3_SafeInit</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite3_SafeInit</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite3_Unload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite3_Unload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite3_SafeUnload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite3_SafeUnload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_3_SUFFIX_ONLY</name></cpp:ifndef>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><call><name>Sqlite3_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><call><name>Sqlite3_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite_SafeInit</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite_SafeInit</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite_Unload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite_Unload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Sqlite_SafeUnload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return> }</block></function>
<function><type><name>EXTERN</name> <name>int</name></type> <name>Tclsqlite_SafeUnload</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list><block>{ <return>return <expr><name>TCL_OK</name></expr>;</return>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCLSH</name></cpp:ifdef>
<comment type="block">/*****************************************************************************
** The code that follows is used to build standalone TCL interpreters
** that are statically linked with SQLite.  
*/</comment>

<comment type="block">/*
** If the macro TCLSH is one, then put in code this for the
** "main" routine that will initialize Tcl and take input from
** standard input, or if a file is named on the command line
** the TCL interpreter reads and evaluates that file.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TCLSH</name>==1</expr></cpp:if>
<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>zMainloop</name><index>[]</index></name> =<init>
  <expr>"set line {}\n"
  "while {![eof stdin]} {\n"
    "if {$line!=\"\"} {\n"
      "puts -nonewline \"&gt; \"\n"
    "} else {\n"
      "puts -nonewline \"% \"\n"
    "}\n"
    "flush stdout\n"
    "append line [gets stdin]\n"
    "if {[info complete $line]} {\n"
      "if {[catch {uplevel #0 $line} result]} {\n"
        "puts stderr \"Error: $result\"\n"
      "} elseif {$result!=\"\"} {\n"
        "puts $result\n"
      "}\n"
      "set line {}\n"
    "} else {\n"
      "append line \\n\n"
    "}\n"
  "}\n"</expr></init></decl>
;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If the macro TCLSH is two, then get the main loop code out of
** the separate file "spaceanal_tcl.h".
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TCLSH</name>==2</expr></cpp:if>
<decl_stmt><decl><type><name>static</name> <name>char</name></type> <name><name>zMainloop</name><index>[]</index></name> =<init/></decl> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"spaceanal_tcl.h"</cpp:file></cpp:include>
;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>TCLSH_MAIN</name> main</cpp:define>   <comment type="block">/* Needed to fake out mktclapp */</comment>
<function><type><name>int</name></type> <name>TCLSH_MAIN</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Tcl_FindExecutable</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>interp</name> = <call><name>Tcl_CreateInterp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Sqlite3_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <block>{
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Md5_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqliteconfig_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest1_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest2_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest3_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest4_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest5_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest6_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest7_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest8_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest9_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetestasync_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest_autoext_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest_func_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest_hexio_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest_malloc_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetest_mutex_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetestschema_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetestsse_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>Sqlitetesttclvar_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>SqlitetestThread_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>SqlitetestOnefile_Init</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>extern</name> <name>int</name></type> <name>SqlitetestOsinst_Init</name><parameter_list>(<param><decl><type><name>Tcl_Interp</name>*</type></decl></param>)</parameter_list>;</function_decl>

    <expr_stmt><expr><call><name>Md5_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqliteconfig_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest1_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest2_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest3_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest4_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest5_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest6_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest7_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest8_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest9_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetestasync_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest_autoext_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest_func_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest_hexio_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest_malloc_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetest_mutex_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetestschema_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Sqlitetesttclvar_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SqlitetestThread_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SqlitetestOnefile_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SqlitetestOsinst_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SSE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>Sqlitetestsse_Init</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>( <expr><name>argc</name>&gt;=2 || <name>TCLSH</name>==2</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>zArgc</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>zArgc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zArgc</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>argc</name>-(3-<name>TCLSH</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"argc"</expr></argument>, <argument><expr><name>zArgc</name></expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"argv0"</expr></argument>,<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>,<argument><expr>"argv"</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name>=3-<name>TCLSH</name></expr>;</init> <condition><expr><name>i</name>&lt;<name>argc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>Tcl_SetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"argv"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
          <argument><expr><name>TCL_GLOBAL_ONLY</name> | <name>TCL_LIST_ELEMENT</name> | <name>TCL_APPEND_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if<condition>( <expr><name>TCLSH</name>==1 &amp;&amp; <call><name>Tcl_EvalFile</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>!=<name>TCL_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zInfo</name> =<init> <expr><call><name>Tcl_GetVar</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr>"errorInfo"</expr></argument>, <argument><expr><name>TCL_GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr><name>zInfo</name>==0</expr> )</condition><then> <expr_stmt><expr><name>zInfo</name> = <call><name>Tcl_GetStringResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"%s: %s\n"</expr></argument>, <argument><expr>*<name>argv</name></expr></argument>, <argument><expr><name>zInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>1</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>argc</name>&lt;=1 || <name>TCLSH</name>==2</expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>Tcl_GlobalEval</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>zMainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TCLSH */</comment>
</unit>
