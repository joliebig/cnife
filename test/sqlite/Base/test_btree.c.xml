<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="test_btree.c" filename=""><comment type="block">/*
** 2007 May 05
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Code for testing the btree.c module in SQLite.  This code
** is not included in the SQLite library.  It is used for automated
** testing of the SQLite library.
**
** $Id: test_btree.c,v 1.8 2008/09/29 11:49:48 danielk1977 Exp $
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"btreeInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcl.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Usage: sqlite3_shared_cache_report
**
** Return a list of file that are shared and the number of
** references to each file.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeSharedCacheReport</name><parameter_list>(
  <param><decl><type><name>void</name> *</type> <name>clientData</name></decl></param>,
  <param><decl><type><name>Tcl_Interp</name> *</type><name>interp</name></decl></param>,
  <param><decl><type><name>int</name></type> <name>objc</name></decl></param>,
  <param><decl><type><name>Tcl_Obj</name> *<name>CONST</name></type> <name><name>objv</name><index>[]</index></name></decl></param>
)</parameter_list><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_SHARED_CACHE</name></cpp:ifndef>
  <decl_stmt><decl><type><name>extern</name> <name>BtShared</name> *</type><name>sqlite3SharedCacheList</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Tcl_Obj</name> *</type><name>pRet</name> =<init> <expr><call><name>Tcl_NewObj</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>pBt</name>=<call><name>GLOBAL</name><argument_list>(<argument><expr><name>BtShared</name>*</expr></argument>,<argument><expr><name>sqlite3SharedCacheList</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>pBt</name></expr>;</condition> <incr><expr><name>pBt</name>=<name>pBt</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFile</name> =<init> <expr><call><name>sqlite3PagerFilename</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>pPager</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><call><name>Tcl_NewStringObj</name><argument_list>(<argument><expr><name>zFile</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Tcl_ListObjAppendElement</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>, <argument><expr><call><name>Tcl_NewIntObj</name><argument_list>(<argument><expr><name>pBt</name>-&gt;<name>nRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><call><name>Tcl_SetObjResult</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>pRet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TCL_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Print debugging information about all cursors to standard output.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3BtreeCursorList</name><parameter_list>(<param><decl><type><name>Btree</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <decl_stmt><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BtShared</name> *</type><name>pBt</name> =<init> <expr><name>p</name>-&gt;<name>pBt</name></expr></init></decl>;</decl_stmt>
  <for>for(<init><expr><name>pCur</name>=<name>pBt</name>-&gt;<name>pCursor</name></expr>;</init> <condition><expr><name>pCur</name></expr>;</condition> <incr><expr><name>pCur</name>=<name>pCur</name>-&gt;<name>pNext</name></expr></incr>)<block>{
    <decl_stmt><decl><type><name>MemPage</name> *</type><name>pPage</name> =<init> <expr><name>pCur</name>-&gt;<name><name>apPage</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zMode</name> =<init> <expr><name>pCur</name>-&gt;<name>wrFlag</name> ? "rw" : "ro"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3DebugPrintf</name><argument_list>(<argument><expr>"CURSOR %p rooted at %4d(%s) currently at %d.%d%s\n"</expr></argument>,
       <argument><expr><name>pCur</name></expr></argument>, <argument><expr><name>pCur</name>-&gt;<name>pgnoRoot</name></expr></argument>, <argument><expr><name>zMode</name></expr></argument>,
       <argument><expr><name>pPage</name> ? <name>pPage</name>-&gt;<name>pgno</name> : 0</expr></argument>, <argument><expr><name>pCur</name>-&gt;<name><name>aiIdx</name><index>[<expr><name>pCur</name>-&gt;<name>iPage</name></expr>]</index></name></expr></argument>,
       <argument><expr>(<name>pCur</name>-&gt;<name>eState</name>==<name>CURSOR_VALID</name>) ? "" : " eof"</expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<comment type="block">/*
** Fill aResult[] with information about the entry and page that the
** cursor is pointing to.
** 
**   aResult[0] =  The page number
**   aResult[1] =  The entry number
**   aResult[2] =  Total number of entries on this page
**   aResult[3] =  Cell size (local payload + header)
**   aResult[4] =  Number of free bytes on this page
**   aResult[5] =  Number of free blocks on the page
**   aResult[6] =  Total payload size (local + overflow)
**   aResult[7] =  Header size in bytes
**   aResult[8] =  Local payload size
**   aResult[9] =  Parent page number
**   aResult[10]=  Page number of the first overflow page
**
** This routine is used for testing and debugging only.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3BtreeCursorInfo</name><parameter_list>(<param><decl><type><name>BtCursor</name> *</type><name>pCur</name></decl></param>, <param><decl><type><name>int</name> *</type><name>aResult</name></decl></param>, <param><decl><type><name>int</name></type> <name>upCnt</name></decl></param>)</parameter_list><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  int cnt, idx;
  MemPage *pPage = pCur-&gt;apPage[pCur-&gt;iPage];
  BtCursor tmpCur;
  int rc;

  if( pCur-&gt;eState==CURSOR_REQUIRESEEK ){
    rc = sqlite3BtreeRestoreCursorPosition(pCur);
    if( rc!=SQLITE_OK ){
      return rc;
    }
  }

  assert( pPage-&gt;isInit );
  sqlite3BtreeGetTempCursor(pCur, &amp;tmpCur);
  while( upCnt-- ){
    sqlite3BtreeMoveToParent(&amp;tmpCur);
  }
  pPage = tmpCur.pPage;
  aResult[0] = sqlite3PagerPagenumber(pPage-&gt;pDbPage);
  assert( aResult[0]==pPage-&gt;pgno );
  aResult[1] = tmpCur.idx;
  aResult[2] = pPage-&gt;nCell;
  if( tmpCur.idx&gt;=0 &amp;&amp; tmpCur.idx&lt;pPage-&gt;nCell ){
    sqlite3BtreeParseCell(tmpCur.pPage, tmpCur.idx, &amp;tmpCur.info);
    aResult[3] = tmpCur.info.nSize;
    aResult[6] = tmpCur.info.nData;
    aResult[7] = tmpCur.info.nHeader;
    aResult[8] = tmpCur.info.nLocal;
  }else{
    aResult[3] = 0;
    aResult[6] = 0;
    aResult[7] = 0;
    aResult[8] = 0;
  }
  aResult[4] = pPage-&gt;nFree;
  cnt = 0;
  idx = get2byte(&amp;pPage-&gt;aData[pPage-&gt;hdrOffset+1]);
  while( idx&gt;0 &amp;&amp; idx&lt;pPage-&gt;pBt-&gt;usableSize ){
    cnt++;
    idx = get2byte(&amp;pPage-&gt;aData[idx]);
  }
  aResult[5] = cnt;
  if( pPage-&gt;pParent==0 || sqlite3BtreeIsRootPage(pPage) ){
    aResult[9] = 0;
  }else{
    aResult[9] = pPage-&gt;pParent-&gt;pgno;
  }
  if( tmpCur.info.iOverflow ){
    aResult[10] = get4byte(&amp;tmpCur.info.pCell[tmpCur.info.iOverflow]);
  }else{
    aResult[10] = 0;
  }
  sqlite3BtreeReleaseTempCursor(&amp;tmpCur);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>
</unit>
