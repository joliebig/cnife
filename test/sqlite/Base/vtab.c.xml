<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="vtab.c" filename=""><comment type="block">/*
** 2006 June 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to help implement virtual tables.
**
** $Id: vtab.c,v 1.81 2008/12/10 19:26:24 drh Exp $
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<function><type><name>static</name> <name>int</name></type> <name>createModule</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,                    <comment type="block">/* Database in which module is registered */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,              <comment type="block">/* Name assigned to this module */</comment>
  <param><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl></param>,  <comment type="block">/* The definition of the module */</comment>
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>,                     <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xDestroy</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>        <comment type="block">/* Module destructor function */</comment>
)</parameter_list> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name>, <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Module</name> *</type><name>pMod</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> = (<name>Module</name> *)<call><name>sqlite3DbMallocRaw</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Module</name></expr></argument>)</argument_list></call> + <name>nName</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMod</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>Module</name> *</type><name>pDel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zCopy</name> =<init> <expr>(<name>char</name> *)(&amp;<name><name>pMod</name><index>[<expr>1</expr>]</index></name>)</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMod</name>-&gt;<name>zName</name> = <name>zCopy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMod</name>-&gt;<name>pModule</name> = <name>pModule</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMod</name>-&gt;<name>pAux</name> = <name>pAux</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pMod</name>-&gt;<name>xDestroy</name> = <name>xDestroy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pDel</name> = (<name>Module</name> *)<call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aModule</name></expr></argument>, <argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr>(<name>void</name>*)<name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pDel</name> &amp;&amp; <name>pDel</name>-&gt;<name>xDestroy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pDel</name>-&gt;<call><name>xDestroy</name><argument_list>(<argument><expr><name>pDel</name>-&gt;<name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pDel</name>==<name>pMod</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3ResetInternalSchema</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then><else>else <if>if<condition>( <expr><name>xDestroy</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if></else></if>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>


<comment type="block">/*
** External API function used to create a new virtual-table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_module</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,                    <comment type="block">/* Database in which module is registered */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,              <comment type="block">/* Name assigned to this module */</comment>
  <param><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl></param>,  <comment type="block">/* The definition of the module */</comment>
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>                      <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
)</parameter_list><block>{
  <return>return <expr><call><name>createModule</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pModule</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** External API function used to create a new virtual-table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_module_v2</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,                    <comment type="block">/* Database in which module is registered */</comment>
  <param><decl><type><name>const</name> <name>char</name> *</type><name>zName</name></decl></param>,              <comment type="block">/* Name assigned to this module */</comment>
  <param><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl></param>,  <comment type="block">/* The definition of the module */</comment>
  <param><decl><type><name>void</name> *</type><name>pAux</name></decl></param>,                     <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
  <param><function_decl><type><name>void</name></type> (*<name>xDestroy</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>        <comment type="block">/* Module destructor function */</comment>
)</parameter_list><block>{
  <return>return <expr><call><name>createModule</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pModule</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** Lock the virtual table so that it cannot be disconnected.
** Locks nest.  Every lock should have a corresponding unlock.
** If an unlock is omitted, resources leaks will occur.  
**
** If a disconnect is attempted while a virtual table is locked,
** the disconnect is deferred until all locks have been removed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabLock</name><parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>nRef</name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** Unlock a virtual table.  When the last lock is removed,
** disconnect the virtual table.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabUnlock</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>pVtab</name>-&gt;<name>nRef</name>--</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pVtab</name>-&gt;<name>nRef</name>==0</expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>db</name>-&gt;<name>magic</name>==<name>SQLITE_MAGIC_BUSY</name></expr> )</condition><then><block>{
      <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>pModule</name>-&gt;<call><name>xDisconnect</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>pModule</name>-&gt;<call><name>xDisconnect</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Clear any and all virtual-table information from the Table record.
** This routine is called, for example, just before deleting the Table
** record.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabClear</name><parameter_list>(<param><decl><type><name>Table</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>p</name>-&gt;<name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>p</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pVtab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name>-&gt;<name>pMod</name> &amp;&amp; <name>p</name>-&gt;<name>pMod</name>-&gt;<name>pModule</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name>-&gt;<name>pVtab</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
  <if>if<condition>( <expr><name>p</name>-&gt;<name>azModuleArg</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>p</name>-&gt;<name>nModuleArg</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name><name>azModuleArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name>-&gt;<name>azModuleArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Add a new module argument to pTable-&gt;azModuleArg[].
** The string is not copied - the pointer is stored.  The
** string will be freed automatically when the table is
** deleted.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>addModuleArgument</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTable</name></decl></param>, <param><decl><type><name>char</name> *</type><name>zArg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr><name>pTable</name>-&gt;<name>nModuleArg</name>++</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> =<init> <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call>*(1+<name>pTable</name>-&gt;<name>nModuleArg</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> **</type><name>azModuleArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>azModuleArg</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>azModuleArg</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>azModuleArg</name>==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;<name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name><name>azModuleArg</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>azModuleArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTable</name>-&gt;<name>nModuleArg</name> = 0</expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name><name>azModuleArg</name><index>[<expr><name>i</name></expr>]</index></name> = <name>zArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>azModuleArg</name><index>[<expr><name>i</name>+1</expr>]</index></name> = 0</expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>azModuleArg</name> = <name>azModuleArg</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE
** statement.  The module name has been parsed, but the optional list
** of parameters that follow the module name are still pending.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabBeginParse</name><parameter_list>(
  <param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>,        <comment type="block">/* Parsing context */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName1</name></decl></param>,        <comment type="block">/* Name of new table, or database name */</comment>
  <param><decl><type><name>Token</name> *</type><name>pName2</name></decl></param>,        <comment type="block">/* Name of new table or NULL */</comment>
  <param><decl><type><name>Token</name> *</type><name>pModuleName</name></decl></param>    <comment type="block">/* Name of the module for the virtual table */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* The database the table is being created in */</comment>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTable</name></decl>;</decl_stmt>        <comment type="block">/* The new virtual table */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>

  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>flags</name> &amp; <name>SQLITE_SharedCache</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"Cannot use virtual tables in shared-cache mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>sqlite3StartTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTable</name>==0 || <name>pParse</name>-&gt;<name>nErr</name></expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>0==<name>pTable</name>-&gt;<name>pIndex</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name>&gt;=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pTable</name>-&gt;<name>tabFlags</name> |= <name>TF_Virtual</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name>-&gt;<name>nModuleArg</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pModuleName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>sNameToken</name>.<name>n</name> = (<name>int</name>)(&amp;<name>pModuleName</name>-&gt;<name><name>z</name><index>[<expr><name>pModuleName</name>-&gt;<name>n</name></expr>]</index></name> - <name>pName1</name>-&gt;<name>z</name>)</expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Creating a virtual table invokes the authorization callback twice.
  ** The first invocation, to obtain permission to INSERT a row into the
  ** sqlite_master table, has already been made by sqlite3StartTable().
  ** The second call, to obtain permission to create the table, is made now.
  */</comment>
  <if>if<condition>( <expr><name>pTable</name>-&gt;<name>azModuleArg</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CREATE_VTABLE</name></expr></argument>, <argument><expr><name>pTable</name>-&gt;<name>zName</name></expr></argument>, 
            <argument><expr><name>pTable</name>-&gt;<name><name>azModuleArg</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/*
** This routine takes the module argument that has been accumulating
** in pParse-&gt;zArg[] and appends it to the list of arguments on the
** virtual table currently under construction in pParse-&gt;pTable.
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>addArgumentToVtab</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>sArg</name>.<name>z</name> &amp;&amp; <name>pParse</name>-&gt;<name>pNewTable</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>z</name> =<init> <expr>(<name>const</name> <name>char</name>*)<name>pParse</name>-&gt;<name>sArg</name>.<name>z</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr><name>pParse</name>-&gt;<name>sArg</name>.<name>n</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParse</name>-&gt;<name>pNewTable</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** The parser calls this routine after the CREATE VIRTUAL TABLE statement
** has been completely parsed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabFinishParse</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>pEnd</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>        <comment type="block">/* The table being constructed */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name></decl>;</decl_stmt>        <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>zModule</name></decl>;</decl_stmt>      <comment type="block">/* The module name of the table: USING modulename */</comment>
  <decl_stmt><decl><type><name>Module</name> *</type><name>pMod</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>addArgumentToVtab</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>sArg</name>.<name>z</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Lookup the module name. */</comment>
  <expr_stmt><expr><name>pTab</name> = <name>pParse</name>-&gt;<name>pNewTable</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>nModuleArg</name>&lt;1</expr> )</condition><then> <return>return;</return></then></if>
  <expr_stmt><expr><name>zModule</name> = <name>pTab</name>-&gt;<name><name>azModuleArg</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> = (<name>Module</name>*)<call><name>sqlite3HashFind</name><argument_list>(<argument><expr>&amp;<name>db</name>-&gt;<name>aModule</name></expr></argument>, <argument><expr><name>zModule</name></expr></argument>,
                                  <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name>-&gt;<name>pMod</name> = <name>pMod</name></expr>;</expr_stmt>
  
  <comment type="block">/* If the CREATE VIRTUAL TABLE statement is being entered for the
  ** first time (in other words if the virtual table is actually being
  ** created now instead of just being read out of sqlite_master) then
  ** do additional initialization work and store the statement text
  ** in the sqlite_master table.
  */</comment>
  <if>if<condition>( <expr>!<name>db</name>-&gt;<name>init</name>.<name>busy</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>zWhere</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> *</type><name>v</name></decl>;</decl_stmt>

    <comment type="block">/* Compute the complete text of the CREATE VIRTUAL TABLE statement */</comment>
    <if>if<condition>( <expr><name>pEnd</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>pParse</name>-&gt;<name>sNameToken</name>.<name>n</name> = (<name>int</name>)(<name>pEnd</name>-&gt;<name>z</name> - <name>pParse</name>-&gt;<name>sNameToken</name>.<name>z</name>) + <name>pEnd</name>-&gt;<name>n</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>zStmt</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"CREATE VIRTUAL TABLE %T"</expr></argument>, <argument><expr>&amp;<name>pParse</name>-&gt;<name>sNameToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* A slot for the record has already been allocated in the 
    ** SQLITE_MASTER table.  We just need to update that slot with all
    ** the information we've collected.  
    **
    ** The VM register number pParse-&gt;regRowid holds the rowid of an
    ** entry in the sqlite_master table tht was created for this vtab
    ** by sqlite3StartTable().
    */</comment>
    <expr_stmt><expr><name>iDb</name> = <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr>"UPDATE %Q.%s "
         "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "
       "WHERE rowid=#%d"</expr></argument>,
      <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>,
      <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>,
      <argument><expr><name>zStmt</name></expr></argument>,
      <argument><expr><name>pParse</name>-&gt;<name>regRowid</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> = <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Expire</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zWhere</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"name='%q'"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_ParseSchema</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zWhere</name></expr></argument>, <argument><expr><name>P4_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp4</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VCreate</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, 
                         <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>

  <comment type="block">/* If we are rereading the sqlite_master table create the in-memory
  ** record of the table. If the module has already been registered,
  ** also call the xConnect method here.
  */</comment>
  <else>else <block>{
    <decl_stmt><decl><type><name>Table</name> *</type><name>pOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Schema</name> *</type><name>pSchema</name> =<init> <expr><name>pTab</name>-&gt;<name>pSchema</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zName</name> =<init> <expr><name>pTab</name>-&gt;<name>zName</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nName</name> =<init> <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pOld</name> = <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr>&amp;<name>pSchema</name>-&gt;<name>tblHash</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pOld</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name>==<name>pOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed inside HashInsert() */</comment>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>pSchema</name>-&gt;<name>db</name> = <name>pParse</name>-&gt;<name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pParse</name>-&gt;<name>pNewTable</name> = 0</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** The parser calls this routine when it sees the first token
** of an argument to the module name in a CREATE VIRTUAL TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabArgInit</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>addArgumentToVtab</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>sArg</name>.<name>z</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>sArg</name>.<name>n</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
** The parser calls this routine for each token after the first token
** in an argument to the module name in a CREATE VIRTUAL TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabArgExtend</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Token</name> *</type><name>p</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Token</name> *</type><name>pArg</name> =<init> <expr>&amp;<name>pParse</name>-&gt;<name>sArg</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>pArg</name>-&gt;<name>z</name>==0</expr> )</condition><then><block>{
    <expr_stmt><expr><name>pArg</name>-&gt;<name>z</name> = <name>p</name>-&gt;<name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pArg</name>-&gt;<name>n</name> = <name>p</name>-&gt;<name>n</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pArg</name>-&gt;<name>z</name> &lt; <name>p</name>-&gt;<name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pArg</name>-&gt;<name>n</name> = (<name>int</name>)(&amp;<name>p</name>-&gt;<name><name>z</name><index>[<expr><name>p</name>-&gt;<name>n</name></expr>]</index></name> - <name>pArg</name>-&gt;<name>z</name>)</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<comment type="block">/*
** Invoke a virtual table constructor (either xCreate or xConnect). The
** pointer to the function to invoke is passed as the fourth parameter
** to this procedure.
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>vtabCallConstructor</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, 
  <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>,
  <param><decl><type><name>Module</name> *</type><name>pMod</name></decl></param>,
  <param><function_decl><type><name>int</name></type> (*<name>xConstruct</name>)<parameter_list>(<param><decl><type><name>sqlite3</name>*</type></decl></param>,<param><decl><type><name>void</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>char</name>*<name>const</name>*</type></decl></param>,<param><decl><type><name>sqlite3_vtab</name>**</type></decl></param>,<param><decl><type><name>char</name>**</type></decl></param>)</parameter_list>,
  <param><decl><type><name>char</name> **</type><name>pzErr</name></decl></param></function_decl></param>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *<name>const</name>*</type><name>azArg</name> =<init> <expr>(<name>const</name> <name>char</name> *<name>const</name>*)<name>pTab</name>-&gt;<name>azModuleArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> =<init> <expr><name>pTab</name>-&gt;<name>nModuleArg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zModuleName</name> =<init> <expr><call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>zModuleName</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>!<name>db</name>-&gt;<name>pVTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xConstruct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>db</name>-&gt;<name>pVTab</name> = <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>xConstruct</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name>-&gt;<name>pAux</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr>&amp;<name>pVtab</name></expr></argument>, <argument><expr>&amp;<name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc2</name> = <call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pVtab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>pModule</name> = <name>pMod</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pVtab</name>-&gt;<name>nRef</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>pVtab</name> = <name>pVtab</name></expr>;</expr_stmt>
  }</block></then></if>

  <if>if<condition>( <expr><name>SQLITE_OK</name>!=<name>rc</name></expr> )</condition><then><block>{
    <if>if<condition>( <expr><name>zErr</name>==0</expr> )</condition><then><block>{
      <expr_stmt><expr>*<name>pzErr</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"vtable constructor failed: %s"</expr></argument>, <argument><expr><name>zModuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then><else>else <block>{
      <expr_stmt><expr>*<name>pzErr</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then><else>else <if>if<condition>( <expr><name>db</name>-&gt;<name>pVTab</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zFormat</name> =<init> <expr>"vtable constructor did not declare schema: %s"</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>pzErr</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then></if></else></if> 
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>rc2</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>db</name>-&gt;<name>pVTab</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zModuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If everything went according to plan, loop through the columns
  ** of the table to see if any of them contain the token "hidden".
  ** If so, set the Column.isHidden flag and remove the token from
  ** the type string.
  */</comment>
  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
    <for>for(<init><expr><name>iCol</name>=0</expr>;</init> <condition><expr><name>iCol</name>&lt;<name>pTab</name>-&gt;<name>nCol</name></expr>;</condition> <incr><expr><name>iCol</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>zType</name> =<init> <expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>zType</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nType</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
      <if>if<condition>( <expr>!<name>zType</name></expr> )</condition><then> <continue>continue;</continue></then></if>
      <expr_stmt><expr><name>nType</name> = <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>"hidden"</expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> || (<name><name>zType</name><index>[<expr>6</expr>]</index></name> &amp;&amp; <name><name>zType</name><index>[<expr>6</expr>]</index></name>!=' ')</expr> )</condition><then><block>{
        <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>nType</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
          <if>if<condition>( <expr>(0==<call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr>" hidden"</expr></argument>, <argument><expr>&amp;<name><name>zType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call>)
           &amp;&amp; (<name><name>zType</name><index>[<expr><name>i</name>+7</expr>]</index></name>=='\0' || <name><name>zType</name><index>[<expr><name>i</name>+7</expr>]</index></name>==' ')</expr>
          )</condition><then><block>{
            <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
      }</block></then></if>
      <if>if<condition>( <expr><name>i</name>&lt;<name>nType</name></expr> )</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nDel</name> =<init> <expr>6 + (<name><name>zType</name><index>[<expr><name>i</name>+6</expr>]</index></name> ? 1 : 0)</expr></init></decl>;</decl_stmt>
        <for>for(<init><expr><name>j</name>=<name>i</name></expr>;</init> <condition><expr>(<name>j</name>+<name>nDel</name>)&lt;=<name>nType</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)<block>{
          <expr_stmt><expr><name><name>zType</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>zType</name><index>[<expr><name>j</name>+<name>nDel</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <if>if<condition>( <expr><name><name>zType</name><index>[<expr><name>i</name></expr>]</index></name>=='\0' &amp;&amp; <name>i</name>&gt;0</expr> )</condition><then><block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zType</name><index>[<expr><name>i</name>-1</expr>]</index></name>==' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zType</name><index>[<expr><name>i</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>pTab</name>-&gt;<name><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name>.<name>isHidden</name> = 1</expr>;</expr_stmt>
      }</block></then></if>
    }</block></for>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is invoked by the parser to call the xConnect() method
** of the virtual table pTab. If an error occurs, an error code is returned 
** and an error left in pParse.
**
** This call is a no-op if table pTab is not a virtual table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallConnect</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Module</name> *</type><name>pMod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>( <expr>!<name>pTab</name> || (<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Virtual</name>)==0 || <name>pTab</name>-&gt;<name>pVtab</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if>

  <expr_stmt><expr><name>pMod</name> = <name>pTab</name>-&gt;<name>pMod</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pMod</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zModule</name> =<init> <expr><name>pTab</name>-&gt;<name><name>azModuleArg</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"no such module: %s"</expr></argument>, <argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> *</type><name>db</name> =<init> <expr><name>pParse</name>-&gt;<name>db</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>vtabCallConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>, <argument><expr><name>pMod</name>-&gt;<name>pModule</name>-&gt;<name>xConnect</name></expr></argument>, <argument><expr>&amp;<name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>!=<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Add the virtual table pVtab to the array sqlite3.aVTrans[].
*/</comment>
<function><type><name>static</name> <name>int</name></type> <name>addToVTrans</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>const</name> <name>int</name></type> <name>ARRAY_INCR</name> =<init> <expr>5</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Grow the sqlite3.aVTrans array if required */</comment>
  <if>if<condition>( <expr>(<name>db</name>-&gt;<name>nVTrans</name>%<name>ARRAY_INCR</name>)==0</expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>sqlite3_vtab</name> **</type><name>aVTrans</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> =<init> <expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3_vtab</name> *</expr></argument>)</argument_list></call> * (<name>db</name>-&gt;<name>nVTrans</name> + <name>ARRAY_INCR</name>)</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>aVTrans</name> = <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>db</name>-&gt;<name>aVTrans</name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr>!<name>aVTrans</name></expr> )</condition><then><block>{
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>aVTrans</name><index>[<expr><name>db</name>-&gt;<name>nVTrans</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>sqlite3_vtab</name> *</expr></argument>)</argument_list></call>*<name>ARRAY_INCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>aVTrans</name> = <name>aVTrans</name></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* Add pVtab to the end of sqlite3.aVTrans */</comment>
  <expr_stmt><expr><name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>db</name>-&gt;<name>nVTrans</name>++</expr>]</index></name> = <name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is invoked by the vdbe to call the xCreate method
** of the virtual table named zTab in database iDb. 
**
** If an error occurs, *pzErr is set to point an an English language
** description of the error and an SQLITE_XXX error code is returned.
** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallCreate</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pzErr</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Module</name> *</type><name>pMod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>zModule</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pTab</name> &amp;&amp; (<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Virtual</name>)!=0 &amp;&amp; !<name>pTab</name>-&gt;<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> = <name>pTab</name>-&gt;<name>pMod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zModule</name> = <name>pTab</name>-&gt;<name><name>azModuleArg</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

  <comment type="block">/* If the module has been registered and includes a Create method, 
  ** invoke it now. If the module has not been registered, return an 
  ** error. Otherwise, do nothing.
  */</comment>
  <if>if<condition>( <expr>!<name>pMod</name></expr> )</condition><then><block>{
    <expr_stmt><expr>*<name>pzErr</name> = <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>"no such module: %s"</expr></argument>, <argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>rc</name> = <call><name>vtabCallConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>, <argument><expr><name>pMod</name>-&gt;<name>pModule</name>-&gt;<name>xCreate</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>pTab</name>-&gt;<name>pVtab</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>addToVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name>-&gt;<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is used to set the schema of a virtual table.  It is only
** valid to call this function from within the xCreate() or xConnect() of a
** virtual table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_declare_vtab</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zCreateTable</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>Parse</name></type> <name>sParse</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zErr</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> = <name>db</name>-&gt;<name>pVTab</name></expr>;</expr_stmt>
  <if>if<condition>( <expr>!<name>pTab</name></expr> )</condition><then><block>{
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Virtual</name>)!=0 &amp;&amp; <name>pTab</name>-&gt;<name>nCol</name>==0 &amp;&amp; <name>pTab</name>-&gt;<name>aCol</name>==0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sParse</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>Parse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sParse</name>.<name>declareVtab</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name>sParse</name>.<name>db</name> = <name>db</name></expr>;</expr_stmt>

  <if>if<condition>( 
      <expr><name>SQLITE_OK</name> == <call><name>sqlite3RunParser</name><argument_list>(<argument><expr>&amp;<name>sParse</name></expr></argument>, <argument><expr><name>zCreateTable</name></expr></argument>, <argument><expr>&amp;<name>zErr</name></expr></argument>)</argument_list></call> &amp;&amp; 
      <name>sParse</name>.<name>pNewTable</name> &amp;&amp; 
      !<name>sParse</name>.<name>pNewTable</name>-&gt;<name>pSelect</name> &amp;&amp; 
      (<name>sParse</name>.<name>pNewTable</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Virtual</name>)==0</expr>
  )</condition><then><block>{
    <expr_stmt><expr><name>pTab</name>-&gt;<name>aCol</name> = <name>sParse</name>.<name>pNewTable</name>-&gt;<name>aCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTab</name>-&gt;<name>nCol</name> = <name>sParse</name>.<name>pNewTable</name>-&gt;<name>nCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sParse</name>.<name>pNewTable</name>-&gt;<name>nCol</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sParse</name>.<name>pNewTable</name>-&gt;<name>aCol</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>pVTab</name> = 0</expr>;</expr_stmt>
  }</block></then> <else>else <block>{
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  }</block></else></if>
  <expr_stmt><expr><name>sParse</name>.<name>declareVtab</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr>(<name>sqlite3_stmt</name>*)<name>sParse</name>.<name>pVdbe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>sParse</name>.<name>pNewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sParse</name>.<name>pNewTable</name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr>(<name>rc</name>&amp;0xff)==<name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>db</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function is invoked by the vdbe to call the xDestroy method
** of the virtual table named zTab in database iDb. This occurs
** when a DROP TABLE is mentioned.
**
** This call is a no-op if zTab is not a virtual table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallDestroy</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>iDb</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>zTab</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTab</name> = <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name>.<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>-&gt;<name>pVtab</name></expr> )</condition><then><block>{
    <function_decl><type><name>int</name></type> (*<name>xDestroy</name>)<parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type><name>pVTab</name></decl></param>)</parameter_list> <specifier/>= <specifier>pTab</specifier>-&gt;<specifier>pMod</specifier>-&gt;<specifier>pModule</specifier>-&gt;<specifier>xDestroy</specifier>;</function_decl>
    <expr_stmt><expr><name>rc</name> = <call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name>==<name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>xDestroy</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>xDestroy</name><argument_list>(<argument><expr><name>pTab</name>-&gt;<name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>(<name>void</name>)<call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nVTrans</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
        <if>if<condition>( <expr><name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name>==<name>pTab</name>-&gt;<name>pVtab</name></expr> )</condition><then><block>{
          <expr_stmt><expr><name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name> = <name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr>--<name>db</name>-&gt;<name>nVTrans</name></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      }</block></for>
      <expr_stmt><expr><name>pTab</name>-&gt;<name>pVtab</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>

  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** This function invokes either the xRollback or xCommit method
** of each of the virtual tables in the sqlite3.aVTrans array. The method
** called is identified by the second argument, "offset", which is
** the offset of the method to call in the sqlite3_module structure.
**
** The array is cleared after invoking the callbacks. 
*/</comment>
<function><type><name>static</name> <name>void</name></type> <name>callFinaliser</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if>if<condition>( <expr><name>db</name>-&gt;<name>aVTrans</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>db</name>-&gt;<name>nVTrans</name> &amp;&amp; <name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <function_decl><type><name>int</name></type> (*<name>x</name>)<parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type></decl></param>)</parameter_list>;</function_decl>
      <expr_stmt><expr><name>x</name> = *(<call><name>int</name> <argument_list>(<argument><expr>**</expr></argument>)</argument_list></call>(<name>sqlite3_vtab</name> *))((<name>char</name> *)<name>pVtab</name>-&gt;<name>pModule</name> + <name>offset</name>)</expr>;</expr_stmt>
      <if>if<condition>( <expr><name>x</name></expr> )</condition><then> <expr_stmt><expr><call><name>x</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>db</name>-&gt;<name>aVTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>nVTrans</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>db</name>-&gt;<name>aVTrans</name> = 0</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="block">/*
** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans
** array. Return the error code for the first error that occurs, or
** SQLITE_OK if all xSync operations are successful.
**
** Set *pzErrmsg to point to a buffer that should be released using 
** sqlite3DbFree() containing an error message, if one is available.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabSync</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pzErrmsg</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rcsafety</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> **</type><name>aVTrans</name> =<init> <expr><name>db</name>-&gt;<name>aVTrans</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> = <call><name>sqlite3SafetyOff</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name>-&gt;<name>aVTrans</name> = 0</expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>rc</name>==<name>SQLITE_OK</name> &amp;&amp; <name>i</name>&lt;<name>db</name>-&gt;<name>nVTrans</name> &amp;&amp; <name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name> =<init> <expr><name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <function_decl><type><name>int</name></type> (*<name>x</name>)<parameter_list>(<param><decl><type><name>sqlite3_vtab</name> *</type></decl></param>)</parameter_list>;</function_decl>
    <expr_stmt><expr><name>x</name> = <name>pVtab</name>-&gt;<name>pModule</name>-&gt;<name>xSync</name></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>x</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>x</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>*<name>pzErrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pzErrmsg</name> = <name>pVtab</name>-&gt;<name>zErrMsg</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <expr_stmt><expr><name>db</name>-&gt;<name>aVTrans</name> = <name>aVTrans</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rcsafety</name> = <call><name>sqlite3SafetyOn</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>rc</name> = <name>rcsafety</name></expr>;</expr_stmt>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Invoke the xRollback method of all virtual tables in the 
** sqlite3.aVTrans array. Then clear the array itself.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabRollback</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>callFinaliser</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>sqlite3_module</name></expr></argument>,<argument><expr><name>xRollback</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Invoke the xCommit method of all virtual tables in the 
** sqlite3.aVTrans array. Then clear the array itself.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCommit</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><call><name>callFinaliser</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>sqlite3_module</name></expr></argument>,<argument><expr><name>xCommit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
** If the virtual table pVtab supports the transaction interface
** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is
** not currently open, invoke the xBegin method now.
**
** If the xBegin call is successful, place the sqlite3_vtab pointer
** in the sqlite3.aVTrans array.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabBegin</name><parameter_list>(<param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>, <param><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>const</name> <name>sqlite3_module</name> *</type><name>pModule</name></decl>;</decl_stmt>

  <comment type="block">/* Special case: If db-&gt;aVTrans is NULL and db-&gt;nVTrans is greater
  ** than zero, then this function is being called from within a
  ** virtual module xSync() callback. It is illegal to write to 
  ** virtual module tables in this case, so return SQLITE_LOCKED.
  */</comment>
  <if>if<condition>( <expr><call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
  }</block></then></if>
  <if>if<condition>( <expr>!<name>pVtab</name></expr> )</condition><then><block>{
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  }</block></then></if> 
  <expr_stmt><expr><name>pModule</name> = <name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>

  <if>if<condition>( <expr><name>pModule</name>-&gt;<name>xBegin</name></expr> )</condition><then><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


    <comment type="block">/* If pVtab is already in the aVTrans array, return early */</comment>
    <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr>(<name>i</name>&lt;<name>db</name>-&gt;<name>nVTrans</name>) &amp;&amp; 0!=<name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
      <if>if<condition>( <expr><name>db</name>-&gt;<name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name>==<name>pVtab</name></expr> )</condition><then><block>{
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      }</block></then></if>
    }</block></for>

    <comment type="block">/* Invoke the xBegin method */</comment>
    <expr_stmt><expr><name>rc</name> = <name>pModule</name>-&gt;<call><name>xBegin</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>rc</name>==<name>SQLITE_OK</name></expr> )</condition><then><block>{
      <expr_stmt><expr><name>rc</name> = <call><name>addToVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/*
** The first parameter (pDef) is a function implementation.  The
** second parameter (pExpr) is the first argument to this function.
** If pExpr is a column in a virtual table, then let the virtual
** table implementation have an opportunity to overload the function.
**
** This routine is used to allow virtual table implementations to
** overload MATCH, LIKE, GLOB, and REGEXP operators.
**
** Return either the pDef argument (indicating no change) or a 
** new FuncDef structure that is marked as ephemeral using the
** SQLITE_FUNC_EPHEM flag.
*/</comment>
<function><type><name>FuncDef</name> *</type><name>sqlite3VtabOverloadFunction</name><parameter_list>(
  <param><decl><type><name>sqlite3</name> *</type><name>db</name></decl></param>,    <comment type="block">/* Database connection for reporting malloc problems */</comment>
  <param><decl><type><name>FuncDef</name> *</type><name>pDef</name></decl></param>,  <comment type="block">/* Function to possibly overload */</comment>
  <param><decl><type><name>int</name></type> <name>nArg</name></decl></param>,       <comment type="block">/* Number of arguments to the function */</comment>
  <param><decl><type><name>Expr</name> *</type><name>pExpr</name></decl></param>     <comment type="block">/* First argument to the function */</comment>
)</parameter_list><block>{
  <decl_stmt><decl><type><name>Table</name> *</type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> *</type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_module</name> *</type><name>pMod</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (*<name>xFunc</name>)<parameter_list>(<param><decl><type><name>sqlite3_context</name>*</type></decl></param>,<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>sqlite3_value</name>**</type></decl></param>)</parameter_list> <specifier>= 0</specifier>;</function_decl>
  <decl_stmt><decl><type><name>void</name> *</type><name>pArg</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> *</type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>zLowerName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>z</name></decl>;</decl_stmt>


  <comment type="block">/* Check to see the left operand is a column in a virtual table */</comment>
  <if>if<condition>( <expr><name>pExpr</name>==0</expr> )</condition><then> <return>return <expr><name>pDef</name></expr>;</return></then></if>
  <if>if<condition>( <expr><name>pExpr</name>-&gt;<name>op</name>!=<name>TK_COLUMN</name></expr> )</condition><then> <return>return <expr><name>pDef</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pTab</name> = <name>pExpr</name>-&gt;<name>pTab</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pTab</name>==0</expr> )</condition><then> <return>return <expr><name>pDef</name></expr>;</return></then></if>
  <if>if<condition>( <expr>(<name>pTab</name>-&gt;<name>tabFlags</name> &amp; <name>TF_Virtual</name>)==0</expr> )</condition><then> <return>return <expr><name>pDef</name></expr>;</return></then></if>
  <expr_stmt><expr><name>pVtab</name> = <name>pTab</name>-&gt;<name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name>-&gt;<name>pModule</name>!=0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> = (<name>sqlite3_module</name> *)<name>pVtab</name>-&gt;<name>pModule</name></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pMod</name>-&gt;<name>xFindFunction</name>==0</expr> )</condition><then> <return>return <expr><name>pDef</name></expr>;</return></then></if>
 
  <comment type="block">/* Call the xFindFunction method on the virtual table implementation
  ** to see if the implementation wants to overload this function 
  */</comment>
  <expr_stmt><expr><name>zLowerName</name> = <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDef</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>zLowerName</name></expr> )</condition><then><block>{
    <for>for(<init><expr><name>z</name>=(<name>unsigned</name> <name>char</name>*)<name>zLowerName</name></expr>;</init> <condition><expr>*<name>z</name></expr>;</condition> <incr><expr><name>z</name>++</expr></incr>)<block>{
      <expr_stmt><expr>*<name>z</name> = <name><name>sqlite3UpperToLower</name><index>[<expr>*<name>z</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>rc</name> = <name>pMod</name>-&gt;<call><name>xFindFunction</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>zLowerName</name></expr></argument>, <argument><expr>&amp;<name>xFunc</name></expr></argument>, <argument><expr>&amp;<name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zLowerName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>( <expr><name>pVtab</name>-&gt;<name>zErrMsg</name></expr> )</condition><then><block>{
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVtab</name>-&gt;<name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pVtab</name>-&gt;<name>zErrMsg</name> = 0</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
  <if>if<condition>( <expr><name>rc</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>pDef</name></expr>;</return>
  }</block></then></if>

  <comment type="block">/* Create a new ephemeral function definition for the overloaded
  ** function */</comment>
  <expr_stmt><expr><name>pNew</name> = <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pNew</name></expr></argument>)</argument_list></call>
                             + <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pDef</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pNew</name>==0</expr> )</condition><then><block>{
    <return>return <expr><name>pDef</name></expr>;</return>
  }</block></then></if>
  <expr_stmt><expr>*<name>pNew</name> = *<name>pDef</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>zName</name> = (<name>char</name> *)&amp;<name><name>pNew</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><name>pDef</name>-&gt;<name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>pDef</name>-&gt;<name>zName</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>xFunc</name> = <name>xFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>pUserData</name> = <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name>-&gt;<name>flags</name> |= <name>SQLITE_FUNC_EPHEM</name></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
}</block></function>

<comment type="block">/*
** Make sure virtual table pTab is contained in the pParse-&gt;apVirtualLock[]
** array so that an OP_VBegin will get generated for it.  Add pTab to the
** array if it is missing.  If pTab is already in the array, this routine
** is a no-op.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabMakeWritable</name><parameter_list>(<param><decl><type><name>Parse</name> *</type><name>pParse</name></decl></param>, <param><decl><type><name>Table</name> *</type><name>pTab</name></decl></param>)</parameter_list><block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>pParse</name>-&gt;<name>nVtabLock</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<block>{
    <if>if<condition>( <expr><name>pTab</name>==<name>pParse</name>-&gt;<name><name>apVtabLock</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><then> <return>return;</return></then></if>
  }</block></for>
  <expr_stmt><expr><name>n</name> = (<name>pParse</name>-&gt;<name>nVtabLock</name>+1)*<call><name>sizeof</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name><name>apVtabLock</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pParse</name>-&gt;<name>apVtabLock</name> = <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name>pParse</name>-&gt;<name>apVtabLock</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>( <expr><name>pParse</name>-&gt;<name>apVtabLock</name></expr> )</condition><then><block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name><name>apVtabLock</name><index>[<expr><name>pParse</name>-&gt;<name>nVtabLock</name>++</expr>]</index></name> = <name>pTab</name></expr>;</expr_stmt>
  }</block></then><else>else<block>{
    <expr_stmt><expr><name>pParse</name>-&gt;<name>db</name>-&gt;<name>mallocFailed</name> = 1</expr>;</expr_stmt>
  }</block></else></if>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
