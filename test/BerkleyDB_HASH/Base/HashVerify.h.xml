<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="HashVerify.h"><comment type="block">/*-
* See the file LICENSE for redistribution information.
*
* Copyright (c) 1999-2005
*	Sleepycat Software.  All rights reserved.
*
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_config.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_SYSTEM_INCLUDES</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_shash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_verify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BtreeMacros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashVerify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashFunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbVrfy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbVrfyutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"MpFget.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"MpFput.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbOvflVrfy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbVrfy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbRet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BTreeVerify.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BTreeCompare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbErr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbLog2.h"</cpp:file></cpp:include>




<class>class <name>CHashVerify</name>
<block>{<private type="default">
</private><public>public:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_HASH</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_VERIFY</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<function><type><name>static</name> <name>int</name></type> <name>ham_vrfy_meta</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>m</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>
	<function><type><name>static</name> <name>int</name></type> <name>ham_vrfy</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>h</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_vrfy_item</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>h</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>
	<function><type><name>static</name> <name>int</name></type> <name>ham_vrfy_structure</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>meta_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>meta_pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_vrfy_bucket</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>m</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>bucket</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_vrfy_hashing</name>(DB *<name>dbp</name>, <name>u_int32_t</name> <name>nentries</name>, <name>HMETA</name> *<name>m</name>, <name>u_int32_t</name> <name>thisbucket</name>, <name>db_pgno_t</name> <name>pgno</name>, <name>u_int32_t</name> <name>flags</name>, <name>u_int32_t</name> (*<name>hfunc</name>) <specifier>__P</specifier><parameter_list>(<param/></parameter_list>(<specifier>DB</specifier> *, <specifier>const</specifier> <specifier>void</specifier> *, <specifier>u_int32_t</specifier>)</decl></decl_stmt></public>)</block></class>)
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>nentries</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>thisbucket</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>hfunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_salvage</name>(DB *<name>dbp</name>, <name>VRFY_DBINFO</name> *<name>vdp</name>, <name>db_pgno_t</name> <name>pgno</name>, <name>PAGE</name> *<name>h</name>, <name>void</name> *<name>handle</name>, <name>int</name> (*<name>callback</name>) <specifier>__P</specifier><parameter_list>(<param/></parameter_list>(<specifier>void</specifier> *, <specifier>const</specifier> <specifier>void</specifier> *)</decl></decl_stmt>), <decl_stmt><decl><type><name>u_int32_t</name></type> <name>flags</name>)
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></decl></decl_stmt>
	<function><type><name>static</name> <name>int</name></type> <name>ham_meta2pgset</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>hmeta</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>DB</name> *</type><name>pgset</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>hmeta</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_dups_unsorted</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>u_int8_t</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="line">//#ifndef HAVE_HASH</comment>

	<comment type="block">/*
	* __ham_salvage --
	*	Safely dump out anything that looks like a key on an alleged
	*	hash page.
	*
	* PUBLIC: int __ham_salvage __P((DB *, VRFY_DBINFO *, db_pgno_t, PAGE *,
	* PUBLIC:     void *, int (*)(void *, const void *), u_int32_t));
	*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_salvage</name></name><argument_list>(<argument><expr><name>DB</name> *<name>dbp</name></expr></argument>, <argument><expr><name>VRFY_DBINFO</name> *<name>vdp</name></expr></argument>, <argument><expr><name>db_pgno_t</name> <name>pgno</name></expr></argument>, <argument><expr><name>PAGE</name> *<name>h</name></expr></argument>, <argument><expr><name>void</name> *<name>handle</name></expr></argument>, <argument><expr><macro><name>int</name> <argument_list>(<argument>*callback</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(void *, const void *)</argument>)</argument_list></macro></expr></argument>, <argument><expr><name>u_int32_t</name> <name>flags</name></expr></argument>)</argument_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>dbt</name>, <name>unkdbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>dpgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>err_ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>himark</name>, <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name>, *<name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>dlen</name>, <name>len</name>, <name>tlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DBT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbt</name>.<name>flags</name> = <name>DB_DBT_REALLOC</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>unkdbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DBT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>unkdbt</name>.<name>size</name> = (<name>u_int32_t</name>)<call><name>strlen</name><argument_list>(<argument><expr>"UNKNOWN"</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>unkdbt</name>.<name>data</name> = (<name>void</name>*)"UNKNOWN"</expr>;</expr_stmt>

		<expr_stmt><expr><name>err_ret</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		* Allocate a buffer for overflow items.  Start at one page;
		* __db_safe_goff will realloc as needed.
		*/</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>himark</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init><condition>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<comment type="block">/* If we're not aggressive, break when we hit NUM_ENT(h). */</comment>
			<if>if <condition>(<expr>!<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_AGGRESSIVE</name></expr></argument>)</argument_list></call> &amp;&amp; <name>i</name> &gt;= <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>

			<comment type="block">/* Verify the current item. */</comment>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbVrfy</name>::<name>db_vrfy_inpitem</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><name>h</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>himark</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If this returned a fatality, it's time to break. */</comment>
			<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_FATAL</name></expr>)</condition><then>
				<break>break;</break></then></if>

			<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
				<comment type="block">/* Set len to total entry length. */</comment>
				<expr_stmt><expr><name>len</name> = <call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hk</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>len</name> == 0 || <name>len</name> &gt; <name>dbp</name>-&gt;<name>pgsize</name> ||
					<call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>hk</name> + <name>len</name> - (<name>u_int8_t</name> *)<name>h</name></expr></argument>)</argument_list></call> &gt;
					<name>dbp</name>-&gt;<name>pgsize</name></expr>)</condition><then> <block>{
						<comment type="block">/* Item is unsafely large; skip it. */</comment>
						<expr_stmt><expr><name>err_ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
						<continue>continue;</continue>
				}</block></then></if>
				<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<default>default:
	<if>if <condition>(<expr>!<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_AGGRESSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<break>break;</break></then></if>
	<expr_stmt><expr><name>err_ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
	<break>break;</break>
</default><case>case <expr><name>H_KEYDATA</name></expr>:
	<comment type="block">/* Update len to size of item. */</comment>
	<expr_stmt><expr><name>len</name> = <call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>keydata</name>:</label>			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbt</name>.<name>size</name> = <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbt</name>.<name>data</name> = <name>buf</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_prdbt</name></name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>,
		<argument><expr>0</expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
	<if>if <condition>(<expr><name>len</name> &lt; <name>HOFFPAGE_SIZE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err_ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
		<continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dpgno</name></expr></argument>,
		<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>dpgno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOvflVrfy</name>::<name>db_safe_goff</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>,
		<argument><expr><name>dpgno</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_prdbt</name></name><argument_list>(<argument><expr>&amp;<name>unkdbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>" "</expr></argument>,
				<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	}</block></then></if>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_prdbt</name></name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>,
		<argument><expr>0</expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_OFFDUP</name></expr>:
	<if>if <condition>(<expr><name>len</name> &lt; <name>HOFFDUP_SIZE</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err_ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
		<continue>continue;</continue>
	}</block></then></if>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dpgno</name></expr></argument>,
		<argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>dpgno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* UNKNOWN iff pgno is bad or we're a key. */</comment>
	<if>if <condition>(<expr>!<call><name>IS_VALID_PGNO</name><argument_list>(<argument><expr><name>dpgno</name></expr></argument>)</argument_list></call> || (<name>i</name> % 2 == 0)</expr>)</condition><then> <block>{
		<if>if <condition>(<expr>(<name>ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_prdbt</name></name><argument_list>(<argument><expr>&amp;<name>unkdbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>" "</expr></argument>,
			<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt></then></if>
	}</block></then> <else>else <if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfy</name>::<name>db_salvage_duptree</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
		<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>dpgno</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>,
		<argument><expr><name>flags</name> | <name>SA_SKIPFIRSTKEY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt></then></if></else></if>
	<break>break;</break>
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<expr_stmt><expr><name>len</name> = <call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	* We're a key;  printing dups will seriously
	* foul the output.  If we're being aggressive,
	* pretend this is a key and let the app.
	* programmer sort out the mess.
	*/</comment>
	<if>if <condition>(<expr><name>i</name> % 2 == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_AGGRESSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<goto>goto <name>keydata</name>;</goto></then></if>
		<break>break;</break>
	}</block></then></if>

	<comment type="block">/*
	* Check if too small to have any data.
	* But first, we have to update the len to
	* reflect the size of the data not the
	* size of the on-page entry.
	*/</comment>
	<if>if <condition>(<expr><name>len</name> &lt;
		<call><name>HKEYDATA_SIZE</name><argument_list>(<argument><expr>2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>err_ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
			<continue>continue;</continue>
	}</block></then></if>

	<comment type="block">/* Loop until we hit the total length. */</comment>
	<for>for (<init><expr><name>tlen</name> = 0</expr>;</init> <condition><expr><name>tlen</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call> &lt; <name>len</name></expr>;</condition>
		<incr><expr><name>tlen</name> += <name>dlen</name></expr></incr>) <block>{
			<expr_stmt><expr><name>p</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> + <name>tlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlen</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			* If dlen is too long, print all the
			* rest of the dup set in a chunk.
			*/</comment>
			<if>if <condition>(<expr><name>dlen</name> + <name>tlen</name> &gt; <name>len</name></expr>)</condition><then>
				<expr_stmt><expr><name>dlen</name> = <name>len</name> - <name>tlen</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dbt</name>.<name>size</name> = <name>dlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dbt</name>.<name>data</name> = <name>buf</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_prdbt</name></name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>" "</expr></argument>,
				<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<expr_stmt><expr><name>err_ret</name> = <name>ret</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>tlen</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<break>break;</break>
				</case>}</block></switch>
			}</block></then></if>
		}</block></for>

		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_salvage_markdone</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>t_ret</name>)</expr>;</return></then></if>
		<return>return <expr>((<name>ret</name> == 0 &amp;&amp; <name>err_ret</name> != 0) ? <name>err_ret</name> : <name>ret</name>)</expr>;</return>
	}</block></decl></decl_stmt>


	<comment type="block">/*
	* __ham_vrfy_hashing --
	*	Verify that all items on a given hash page hash correctly.
	*
	* PUBLIC: int __ham_vrfy_hashing __P((DB *,
	* PUBLIC:     u_int32_t, HMETA *, u_int32_t, db_pgno_t, u_int32_t,
	* PUBLIC:     u_int32_t (*) __P((DB *, const void *, u_int32_t))));
	*/</comment>
	<decl_stmt><decl><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy_hashing</name></name><argument_list>(<argument><expr><name>DB</name> *<name>dbp</name></expr></argument>, <argument><expr><name>u_int32_t</name> <name>nentries</name></expr></argument>, <argument><expr><name>HMETA</name> *<name>m</name></expr></argument>, <argument><expr><name>u_int32_t</name> <name>thisbucket</name></expr></argument>, <argument><expr><name>db_pgno_t</name> <name>pgno</name></expr></argument>, <argument><expr><name>u_int32_t</name> <name>flags</name></expr></argument>, <argument><expr><macro><name>u_int32_t</name> <argument_list>(<argument>*hfunc</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(DB *, const void *, u_int32_t)</argument>)</argument_list></macro></expr></argument>)</argument_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name>, <name>isbad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hval</name>, <name>bucket</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = <name>isbad</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DBT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr><name>DB_DBT_REALLOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nentries</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
			<comment type="block">/*
			* We've already verified the page integrity and that of any
			* overflow chains linked off it;  it is therefore safe to use
			* __db_ret.  It's also not all that much slower, since we have
			* to copy every hash item to deal with alignment anyway;  we
			* can tweak this a bit if this proves to be a bottleneck,
			* but for now, take the easy route.
			*/</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbRet</name>::<name>db_ret</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><name>hval</name> = <call><name>hfunc</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbt</name>.<name>data</name></expr></argument>, <argument><expr><name>dbt</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bucket</name> = <name>hval</name> &amp; <name>m</name>-&gt;<name>high_mask</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>bucket</name> &gt; <name>m</name>-&gt;<name>max_bucket</name></expr>)</condition><then>
				<expr_stmt><expr><name>bucket</name> = <name>bucket</name> &amp; <name>m</name>-&gt;<name>low_mask</name></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr><name>bucket</name> != <name>thisbucket</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: item %lu hashes incorrectly",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>

<label><name>err</name>:</label>	<if>if <condition>(<expr><name>dbt</name>.<name>data</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_ufree</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>dbt</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>t_ret</name>)</expr>;</return></then></if>

		<return>return <expr>((<name>ret</name> == 0 &amp;&amp; <name>isbad</name> == 1) ? <name>DB_VERIFY_BAD</name> : <name>ret</name>)</expr>;</return>
	}</block></decl></decl_stmt>


	<comment type="block">/*
	* __ham_vrfy_structure --
	*	Verify the structure of a hash database.
	*
	* PUBLIC: int __ham_vrfy_structure __P((DB *, VRFY_DBINFO *, db_pgno_t,
	* PUBLIC:     u_int32_t));
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy_structure</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>meta_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>pgset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HMETA</name> *</type><name>m</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_PAGEINFO</name> *</type><name>pip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>isbad</name>, <name>p</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>bucket</name>, <name>spares_entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgset</name> = <name>vdp</name>-&gt;<name>pgset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>h</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = <name>isbad</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_get</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>meta_pgno</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr><name>p</name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: Hash meta page referenced twice",
				(<name>u_long</name>)<name>meta_pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>DB_VERIFY_BAD</name>)</expr>;</return>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_inc</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>meta_pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/* Get the meta page;  we'll need it frequently. */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>meta_pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/* Loop through bucket by bucket. */</comment>
		<for>for (<init><expr><name>bucket</name> = 0</expr>;</init> <condition><expr><name>bucket</name> &lt;= <name>m</name>-&gt;<name>max_bucket</name></expr>;</condition> <incr><expr><name>bucket</name>++</expr></incr>)
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name>ham_vrfy_bucket</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
						<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
					<else>else
						<goto>goto <name>err</name>;</goto></else></if>
			}</block></then></if></for>

			<comment type="block">/*
			* There may be unused hash pages corresponding to buckets
			* that have been allocated but not yet used.  These may be
			* part of the current doubling above max_bucket, or they may
			* correspond to buckets that were used in a transaction
			* that then aborted.
			*
			* Loop through them, as far as the spares array defines them,
			* and make sure they're all empty.
			*
			* Note that this should be safe, since we've already verified
			* that the spares array is sane.
			*/</comment>
			<for>for (<init><expr><name>bucket</name> = <name>m</name>-&gt;<name>max_bucket</name> + 1</expr>;</init> <condition><expr><name>spares_entry</name> = <call><name><name>CDbLog2</name>::<name>db_log2</name></name><argument_list>(<argument><expr><name>bucket</name> + 1</expr></argument>)</argument_list></call></expr>,
				<expr><name>spares_entry</name> &lt; <name>NCACHED</name> &amp;&amp; <name>m</name>-&gt;<name><name>spares</name><index>[<expr><name>spares_entry</name></expr>]</index></name> != 0</expr>;</condition> <incr><expr><name>bucket</name>++</expr></incr>) <block>{
					<expr_stmt><expr><name>pgno</name> = <call><name>BS_TO_PAGE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>m</name>-&gt;<name>spares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>

					<comment type="block">/* It's okay if these pages are totally zeroed;  unmark it. */</comment>
					<expr_stmt><expr><call><name>F_CLR</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_IS_ALLZEROES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* It's also OK if this page is simply invalid. */</comment>
					<if>if <condition>(<expr><name>pip</name>-&gt;<name>type</name> == <name>P_INVALID</name></expr>)</condition><then> <block>{
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
							<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
							<goto>goto <name>err</name>;</goto></then></if>
						<continue>continue;</continue>
					}</block></then></if>

					<if>if <condition>(<expr><name>pip</name>-&gt;<name>type</name> != <name>P_HASH</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
							"Page %lu: hash bucket %lu maps to non-hash page",
							(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>bucket</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
					}</block></then> <else>else <if>if <condition>(<expr><name>pip</name>-&gt;<name>entries</name> != 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
							"Page %lu: non-empty page in unused hash bucket %lu",
							(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>bucket</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
					}</block></then> <else>else <block>{
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_get</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
							<goto>goto <name>err</name>;</goto></then></if>
						<if>if <condition>(<expr><name>p</name> != 0</expr>)</condition><then> <block>{
							<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
								"Page %lu: above max_bucket referenced",
								(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
						}</block></then> <else>else <block>{
							<if>if <condition>(<expr>(<name>ret</name> =
								<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_inc</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<goto>goto <name>err</name>;</goto></then></if>
							<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
								<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<goto>goto <name>err</name>;</goto></then></if>
							<continue>continue;</continue>
						}</block></else></if>
					}</block></else></if></else></if>

					<comment type="block">/* If we got here, it's an error. */</comment>
					<expr_stmt><expr>(<name>void</name>)<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
			}</block></for>

<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>t_ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr><name>h</name> != <name>NULL</name> &amp;&amp; (<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>t_ret</name>)</expr>;</return></then></if>
		<return>return <expr>((<name>isbad</name> == 1 &amp;&amp; <name>ret</name> == 0) ? <name>DB_VERIFY_BAD</name>: <name>ret</name>)</expr>;</return>
	}</block></function>


	<comment type="block">/*
	* __ham_vrfy_meta --
	*	Verify the hash-specific part of a metadata page.
	*
	*	Note that unlike btree, we don't save things off, because we
	*	will need most everything again to verify each page and the
	*	amount of state here is significant.
	*
	* PUBLIC: int __ham_vrfy_meta __P((DB *, VRFY_DBINFO *, HMETA *,
	* PUBLIC:     db_pgno_t, u_int32_t));
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy_meta</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>m</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH</name> *</type><name>hashp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_PAGEINFO</name> *</type><name>pip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>ret</name>, <name>t_ret</name>, <name>isbad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>pwr</name>, <name>mbucket</name></decl>;</decl_stmt>
		<macro><name>u_int32_t</name> <argument_list>(<argument>*hfunc</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(DB *, const void *, u_int32_t)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>isbad</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>hashp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>HASH</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>h_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>hashp</name> != <name>NULL</name> &amp;&amp; <name>hashp</name>-&gt;<name>h_hash</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>hfunc</name> = <name>hashp</name>-&gt;<name>h_hash</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>hfunc</name> = <name><name>CHashFunc</name>::<name>ham_func5</name></name></expr>;</expr_stmt></else></if>

		<comment type="block">/*
		* If we haven't already checked the common fields in pagezero,
		* check them.
		*/</comment>
		<if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_INCOMPLETE</name></expr></argument>)</argument_list></call> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbVrfy</name>::<name>db_vrfy_meta</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr>&amp;<name>m</name>-&gt;<name>dbmeta</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
				<else>else
					<goto>goto <name>err</name>;</goto></else></if>
		}</block></then></if>

		<comment type="block">/* h_charkey */</comment>
		<if>if <condition>(<expr>!<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_NOORDERCHK</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<if>if <condition>(<expr><name>m</name>-&gt;<name>h_charkey</name> != <call><name>hfunc</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>CHARKEY</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>CHARKEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: database has custom hash function; reverify with DB_NOORDERCHK set",
					(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				* Return immediately;  this is probably a sign of user
				* error rather than database corruption, so we want to
				* avoid extraneous errors.
			 */</comment>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			}</block></then></if></then></if>

			<comment type="block">/* max_bucket must be less than the last pgno. */</comment>
			<if>if <condition>(<expr><name>m</name>-&gt;<name>max_bucket</name> &gt; <name>vdp</name>-&gt;<name>last_pgno</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: Impossible max_bucket %lu on meta page",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>m</name>-&gt;<name>max_bucket</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				* Most other fields depend somehow on max_bucket, so
				* we just return--there will be lots of extraneous
				* errors.
				*/</comment>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			}</block></then></if>

			<comment type="block">/*
			* max_bucket, high_mask and low_mask: high_mask must be one
			* less than the next power of two above max_bucket, and
			* low_mask must be one less than the power of two below it.
			*/</comment>
			<expr_stmt><expr><name>pwr</name> = (<name>m</name>-&gt;<name>max_bucket</name> == 0) ? 1 : 1 &lt;&lt; <call><name><name>CDbLog2</name>::<name>db_log2</name></name><argument_list>(<argument><expr><name>m</name>-&gt;<name>max_bucket</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>m</name>-&gt;<name>high_mask</name> != <name>pwr</name> - 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: incorrect high_mask %lu, should be %lu",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>m</name>-&gt;<name>high_mask</name>, (<name>u_long</name>)<name>pwr</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><name>pwr</name> &gt;&gt;= 1</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>m</name>-&gt;<name>low_mask</name> != <name>pwr</name> - 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: incorrect low_mask %lu, should be %lu",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>m</name>-&gt;<name>low_mask</name>, (<name>u_long</name>)<name>pwr</name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/* ffactor: no check possible. */</comment>
			<expr_stmt><expr><name>pip</name>-&gt;<name>h_ffactor</name> = <name>m</name>-&gt;<name>ffactor</name></expr>;</expr_stmt>

			<comment type="block">/*
			* nelem: just make sure it's not astronomical for now. This is the
			* same check that hash_upgrade does, since there was a bug in 2.X
			* which could make nelem go "negative".
			*/</comment>
			<if>if <condition>(<expr><name>m</name>-&gt;<name>nelem</name> &gt; 0x80000000</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: suspiciously high nelem of %lu",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>m</name>-&gt;<name>nelem</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>pip</name>-&gt;<name>h_nelem</name> = 0</expr>;</expr_stmt>
			}</block></then> <else>else
				<expr_stmt><expr><name>pip</name>-&gt;<name>h_nelem</name> = <name>m</name>-&gt;<name>nelem</name></expr>;</expr_stmt></else></if>

			<comment type="block">/* flags */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr>&amp;<name>m</name>-&gt;<name>dbmeta</name></expr></argument>, <argument><expr><name>DB_HASH_DUP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr>&amp;<name>m</name>-&gt;<name>dbmeta</name></expr></argument>, <argument><expr><name>DB_HASH_DUPSORT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPSORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<comment type="block">/* XXX: Why is the DB_HASH_SUBDB flag necessary? */</comment>

			<comment type="block">/* spares array */</comment>
			<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>m</name>-&gt;<name><name>spares</name><index>[<expr><name>i</name></expr>]</index></name> != 0 &amp;&amp; <name>i</name> &lt; <name>NCACHED</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<comment type="block">/*
				* We set mbucket to the maximum bucket that would use a given
				* spares entry;  we want to ensure that it's always less
				* than last_pgno.
				*/</comment>
				<expr_stmt><expr><name>mbucket</name> = (1 &lt;&lt; <name>i</name>) - 1</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>BS_TO_PAGE</name><argument_list>(<argument><expr><name>mbucket</name></expr></argument>, <argument><expr><name>m</name>-&gt;<name>spares</name></expr></argument>)</argument_list></call> &gt; <name>vdp</name>-&gt;<name>last_pgno</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
						"Page %lu: spares array entry %d is invalid",
						(<name>u_long</name>)<name>pgno</name>, <name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				}</block></then></if>
			}</block></for>

<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_SALVAGE</name></expr></argument>)</argument_list></call> &amp;&amp;
			(<name>t_ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_salvage_markdone</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>((<name>ret</name> == 0 &amp;&amp; <name>isbad</name> == 1) ? <name>DB_VERIFY_BAD</name> : <name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_vrfy --
	*	Verify hash page.
	*
	* PUBLIC: int __ham_vrfy __P((DB *, VRFY_DBINFO *, PAGE *, db_pgno_t,
	* PUBLIC:     u_int32_t));
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>h</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>VRFY_PAGEINFO</name> *</type><name>pip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>ent</name>, <name>himark</name>, <name>inpend</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name> *</type><name>inp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>isbad</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>isbad</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> != <name>P_HASH</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>TYPE_ERR_PRINT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr>"__ham_vrfy"</expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>EINVAL</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		}</block></then></if>

		<comment type="block">/* Verify and save off fields common to all PAGEs. */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfy</name>::<name>db_vrfy_datapage</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
			<else>else
				<goto>goto <name>err</name>;</goto></else></if>
		}</block></then></if>

		<comment type="block">/*
		* Verify inp[].  Each offset from 0 to NUM_ENT(h) must be lower
		* than the previous one, higher than the current end of the inp array,
		* and lower than the page size.
		*
		* In any case, we return immediately if things are bad, as it would
		* be unsafe to proceed.
		*/</comment>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>ent</name> = 0</expr>, <expr><name>himark</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>,
			<expr><name>inpend</name> = <call>(<name>u_int32_t</name>)<argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>inp</name> - (<name>u_int8_t</name> *)<name>h</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ent</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ent</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>inp</name><index>[<expr><name>ent</name></expr>]</index></name> &gt;= <name>himark</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: item %lu is out of order or nonsensical",
					(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>ent</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			}</block></then> <else>else <if>if <condition>(<expr><name>inpend</name> &gt;= <name>himark</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: entries array collided with data",
					(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>

			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>himark</name> = <name><name>inp</name><index>[<expr><name>ent</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>inpend</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_vrfy_item</name><argument_list>(
					<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
			}</block></else></if></else></if></for>

<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name> == 0 &amp;&amp; <name>isbad</name> == 1 ? <name>DB_VERIFY_BAD</name> : <name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_meta2pgset --
	*	Return the set of hash pages corresponding to the given
	*	known-good meta page.
	*
	* PUBLIC: int __ham_meta2pgset __P((DB *, VRFY_DBINFO *, HMETA *, u_int32_t,
	* PUBLIC:     DB *));
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_meta2pgset</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>hmeta</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>DB</name> *</type><name>pgset</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>bucket</name>, <name>totpgs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>val</name></decl>;</decl_stmt>

		<comment type="block">/*
		* We don't really need flags, but leave them for consistency with
		* __bam_meta2pgset.
		*/</comment>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>pgset</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totpgs</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		* Loop through all the buckets, pushing onto pgset the corresponding
		* page(s) for each one.
		*/</comment>
		<for>for (<init><expr><name>bucket</name> = 0</expr>;</init> <condition><expr><name>bucket</name> &lt;= <name>hmeta</name>-&gt;<name>max_bucket</name></expr>;</condition> <incr><expr><name>bucket</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>pgno</name> = <call><name>BS_TO_PAGE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>hmeta</name>-&gt;<name>spares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			* We know the initial pgno is safe because the spares array has
			* been verified.
			*
			* Safely walk the list of pages in this bucket.
			*/</comment>
			<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> == <name>P_HASH</name></expr>)</condition><then> <block>{

					<comment type="block">/*
					* Make sure we don't go past the end of
					* pgset.
					*/</comment>
					<if>if <condition>(<expr>++<name>totpgs</name> &gt; <name>vdp</name>-&gt;<name>last_pgno</name></expr>)</condition><then> <block>{
						<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr>(<name>DB_VERIFY_BAD</name>)</expr>;</return>
					}</block></then></if>
					<if>if <condition>(<expr>(<name>ret</name> =
						<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_inc</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
							<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr>(<name>ret</name>)</expr>;</return>
					}</block></then></if>

					<expr_stmt><expr><name>pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else>else
					<expr_stmt><expr><name>pgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt></else></if>

				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<comment type="block">/* If the new pgno is wonky, go onto the next bucket. */</comment>
				<if>if <condition>(<expr>!<call><name>IS_VALID_PGNO</name><argument_list>(<argument><expr><name>pgno</name></expr></argument>)</argument_list></call> ||
					<name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
					<break>break;</break></then></if>

				<comment type="block">/*
				* If we've touched this page before, we have a cycle;
				* go on to the next bucket.
				*/</comment>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_get</name></name><argument_list>(<argument><expr><name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<if>if <condition>(<expr><name>val</name> != 0</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></for>
		}</block></for>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>


	<comment type="block">/*
	* __ham_vrfy_item --
	*	Given a hash page and an offset, sanity-check the item itself,
	*	and save off any overflow items or off-page dup children as necessary.
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy_item</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>h</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>i</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HOFFPAGE</name></type> <name>hop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HOFFDUP</name></type> <name>hod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_CHILDINFO</name></type> <name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_PAGEINFO</name> *</type><name>pip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>offset</name>, <name>len</name>, <name>dlen</name>, <name>elen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>databuf</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<switch>switch <condition>(<expr><call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H_KEYDATA</name></expr>:
	<comment type="block">/* Nothing to do here--everything but the type field is data */</comment>
	<break>break;</break>
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<comment type="block">/* Are we a datum or a key?  Better be the former. */</comment>
	<if>if <condition>(<expr><name>i</name> % 2 == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
			"Page %lu: hash key stored as duplicate item %lu",
			(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<comment type="block">/*
	* Dups are encoded as a series within a single HKEYDATA,
	* in which each dup is surrounded by a copy of its length
	* on either side (so that the series can be walked in either
	* direction.  We loop through this series and make sure
	* each dup is reasonable.
	*
	* Note that at this point, we've verified item i-1, so
	* it's safe to use LEN_HKEYDATA (which looks at inp[i-1]).
	*/</comment>
	<expr_stmt><expr><name>len</name> = <call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>databuf</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>offset</name> = 0</expr>;</init> <condition><expr><name>offset</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>offset</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dlen</name></expr></argument>, <argument><expr><name>databuf</name> + <name>offset</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure the length is plausible. */</comment>
		<if>if <condition>(<expr><name>offset</name> + <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>dlen</name></expr></argument>)</argument_list></call> &gt; <name>len</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: duplicate item %lu has bad length",
				(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		}</block></then></if>

		<comment type="block">/*
		* Make sure the second copy of the length is the
		* same as the first.
		*/</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>elen</name></expr></argument>,
			<argument><expr><name>databuf</name> + <name>offset</name> + <name>dlen</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>elen</name> != <name>dlen</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: duplicate item %lu has two different lengths",
				(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_NOORDERCHK</name></expr></argument>)</argument_list></call> &amp;&amp;
		<call><name>ham_dups_unsorted</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_DUPS_UNSORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
	<comment type="block">/* Offpage item.  Make sure pgno is sane, save off. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>hop</name></expr></argument>, <argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>HOFFPAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>IS_VALID_PGNO</name><argument_list>(<argument><expr><name>hop</name>.<name>pgno</name></expr></argument>)</argument_list></call> || <name>hop</name>.<name>pgno</name> == <name>pip</name>-&gt;<name>pgno</name> ||
		<name>hop</name>.<name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: offpage item %lu has bad pgno %lu",
				(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>, (<name>u_long</name>)<name>hop</name>.<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>VRFY_CHILDINFO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>child</name>.<name>pgno</name> = <name>hop</name>.<name>pgno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>child</name>.<name>type</name> = <name>V_OVERFLOW</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>child</name>.<name>tlen</name> = <name>hop</name>.<name>tlen</name></expr>;</expr_stmt> <comment type="block">/* This will get checked later. */</comment>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_childput</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>&amp;<name>child</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_OFFDUP</name></expr>:
	<comment type="block">/* Offpage duplicate item.  Same drill. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>hod</name></expr></argument>, <argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>HOFFDUP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<call><name>IS_VALID_PGNO</name><argument_list>(<argument><expr><name>hod</name>.<name>pgno</name></expr></argument>)</argument_list></call> || <name>hod</name>.<name>pgno</name> == <name>pip</name>-&gt;<name>pgno</name> ||
		<name>hod</name>.<name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: offpage item %lu has bad page number",
				(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
	}</block></then></if>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>VRFY_CHILDINFO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>child</name>.<name>pgno</name> = <name>hod</name>.<name>pgno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>child</name>.<name>type</name> = <name>V_DUPLICATE</name></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_childput</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>&amp;<name>child</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>
	<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
		"Page %lu: item %lu has bad type",
		(<name>u_long</name>)<name>pip</name>-&gt;<name>pgno</name>, (<name>u_long</name>)<name>i</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>DB_VERIFY_BAD</name></expr>;</expr_stmt>
	<break>break;</break>
		</default>}</block></switch>

<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_vrfy_bucket --
	*	Verify a given bucket.
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_vrfy_bucket</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>VRFY_DBINFO</name> *</type><name>vdp</name></decl></param>, <param><decl><type><name>HMETA</name> *</type><name>m</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>bucket</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH</name> *</type><name>hashp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_CHILDINFO</name> *</type><name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VRFY_PAGEINFO</name> *</type><name>mip</name>, *<name>pip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name>, <name>isbad</name>, <name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name>, <name>next_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>cc</name></decl>;</decl_stmt>
		<macro><name>u_int32_t</name> <argument_list>(<argument>*hfunc</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(DB *, const void *, u_int32_t)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><name>isbad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>pip</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hashp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>HASH</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>h_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hashp</name> != <name>NULL</name> &amp;&amp; <name>hashp</name>-&gt;<name>h_hash</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>hfunc</name> = <name>hashp</name>-&gt;<name>h_hash</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>hfunc</name> = <name><name>CHashFunc</name>::<name>ham_func5</name></name></expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>mip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/* Calculate the first pgno for this bucket. */</comment>
		<expr_stmt><expr><name>pgno</name> = <call><name>BS_TO_PAGE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>m</name>-&gt;<name>spares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<comment type="block">/* Make sure we got a plausible page number. */</comment>
		<if>if <condition>(<expr><name>pgno</name> &gt; <name>vdp</name>-&gt;<name>last_pgno</name> || <name>pip</name>-&gt;<name>type</name> != <name>P_HASH</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: impossible first page in bucket %lu",
				(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>bucket</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Unsafe to continue. */</comment>
			<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		}</block></then></if>

		<if>if <condition>(<expr><name>pip</name>-&gt;<name>prev_pgno</name> != <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
				"Page %lu: first page in hash bucket %lu has a prev_pgno",
				(<name>u_long</name>)<name>pgno</name>, (<name>u_long</name>)<name>bucket</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/*
		* Set flags for dups and sorted dups.
		*/</comment>
		<expr_stmt><expr><name>flags</name> |= <call><name>F_ISSET</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call> ? <name>ST_DUPOK</name> : 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>flags</name> |= <call><name>F_ISSET</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPSORT</name></expr></argument>)</argument_list></call> ? <name>ST_DUPSORT</name> : 0</expr>;</expr_stmt>

		<comment type="block">/* Loop until we find a fatal bug, or until we run out of pages. */</comment>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<comment type="block">/* Provide feedback on our progress to the application. */</comment>
			<if>if <condition>(<expr>!<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_SALVAGE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><call><name><name>CDbVrfy</name>::<name>db_vrfy_struct_feedback</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_get</name></name><argument_list>(<argument><expr><name>vdp</name>-&gt;<name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<if>if <condition>(<expr><name>p</name> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
					"Page %lu: hash page referenced twice",
					(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				<comment type="block">/* Unsafe to continue. */</comment>
				<goto>goto <name>err</name>;</goto>
			}</block></then> <else>else <if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_pgset_inc</name></name><argument_list>(<argument><expr><name>vdp</name>-&gt;<name>pgset</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if></else></if>

			<comment type="block">/*
			* Hash pages that nothing has ever hashed to may never
			* have actually come into existence, and may appear to be
			* entirely zeroed.  This is acceptable, and since there's
			* no real way for us to know whether this has actually
			* occurred, we clear the "wholly zeroed" flag on every
			* hash page.  A wholly zeroed page, by nature, will appear
			* to have no flags set and zero entries, so should
			* otherwise verify correctly.
			*/</comment>
			<expr_stmt><expr><call><name>F_CLR</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_IS_ALLZEROES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If we have dups, our meta page had better know about it. */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call> &amp;&amp;
				!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
						"Page %lu: duplicates present in non-duplicate database",
						(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/*
			* If the database has sorted dups, this page had better
			* not have unsorted ones.
			*/</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>VRFY_HAS_DUPSORT</name></expr></argument>)</argument_list></call> &amp;&amp;
				<call><name>F_ISSET</name><argument_list>(<argument><expr><name>pip</name></expr></argument>, <argument><expr><name>VRFY_DUPS_UNSORTED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
						"Page %lu: unsorted dups in sorted-dup database",
						(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/* Walk overflow chains and offpage dup trees. */</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_childcursor</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr>&amp;<name>cc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<for>for (<init><expr><name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_ccset</name></name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>pip</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>&amp;<name>child</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ret</name> == 0</expr>;</condition>
				<incr><expr><name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_ccnext</name></name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr>&amp;<name>child</name></expr></argument>)</argument_list></call></expr></incr>)
				<if>if <condition>(<expr><name>child</name>-&gt;<name>type</name> == <name>V_OVERFLOW</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOvflVrfy</name>::<name>db_vrfy_ovfl_structure</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>,
						<argument><expr><name>child</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>child</name>-&gt;<name>tlen</name></expr></argument>,
						<argument><expr><name>flags</name> | <name>ST_OVFL_LEAF</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
								<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
							<else>else
								<goto>goto <name>err</name>;</goto></else></if>
					}</block></then></if>
				}</block></then> <else>else <if>if <condition>(<expr><name>child</name>-&gt;<name>type</name> == <name>V_DUPLICATE</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfy</name>::<name>db_vrfy_duptype</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
						<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>child</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
							<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
							<continue>continue;</continue>
					}</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CBTreeVerify</name>::<name>bam_vrfy_subtree</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>,
						<argument><expr><name>child</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						<argument><expr><name>flags</name> | <name>ST_RECNUM</name> | <name>ST_DUPSET</name> | <name>ST_TOPLEVEL</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
								<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
							<else>else
								<goto>goto <name>err</name>;</goto></else></if>
					}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				}</block></then></if></else></if></for>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_ccclose</name></name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
				<expr_stmt><expr><name>cc</name> = <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* If it's safe to check that things hash properly, do so. */</comment>
				<if>if <condition>(<expr><name>isbad</name> == 0 &amp;&amp; !<call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_NOORDERCHK</name></expr></argument>)</argument_list></call> &amp;&amp;
					(<name>ret</name> = <call><name>ham_vrfy_hashing</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pip</name>-&gt;<name>entries</name></expr></argument>,
					<argument><expr><name>m</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hfunc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
						<if>if <condition>(<expr><name>ret</name> == <name>DB_VERIFY_BAD</name></expr>)</condition><then>
							<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt></then>
						<else>else
							<goto>goto <name>err</name>;</goto></else></if>
				}</block></then></if>

				<expr_stmt><expr><name>next_pgno</name> = <name>pip</name>-&gt;<name>next_pgno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>pip</name> = <name>NULL</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>

				<if>if <condition>(<expr><name>next_pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
					<break>break;</break></then></if>		<comment type="block">/* End of the bucket. */</comment>

				<comment type="block">/* We already checked this, but just in case... */</comment>
				<if>if <condition>(<expr>!<call><name>IS_VALID_PGNO</name><argument_list>(<argument><expr><name>next_pgno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
						"Page %lu: hash page has bad next_pgno",
						(<name>u_long</name>)<name>pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				}</block></then></if>

				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_getpageinfo</name></name><argument_list>(<argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>next_pgno</name></expr></argument>, <argument><expr>&amp;<name>pip</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>

				<if>if <condition>(<expr><name>pip</name>-&gt;<name>prev_pgno</name> != <name>pgno</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>EPRINT</name><argument_list>(<argument><expr>(<name>dbp</name>-&gt;<name>dbenv</name>,
						"Page %lu: hash page has bad prev_pgno",
						(<name>u_long</name>)<name>next_pgno</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isbad</name> = 1</expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>pgno</name> = <name>next_pgno</name></expr>;</expr_stmt>
		}</block></for>

<label><name>err</name>:</label>	<if>if <condition>(<expr><name>cc</name> != <name>NULL</name> &amp;&amp; ((<name>t_ret</name> = <call><name><name>CDbVrfyutil</name>::<name>db_vrfy_ccclose</name></name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call>) != 0) &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>mip</name> != <name>NULL</name> &amp;&amp; ((<name>t_ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>mip</name></expr></argument>)</argument_list></call>) != 0) &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>pip</name> != <name>NULL</name> &amp;&amp; ((<name>t_ret</name> =
			<call><name><name>CDbVrfyutil</name>::<name>db_vrfy_putpageinfo</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>vdp</name></expr></argument>, <argument><expr><name>pip</name></expr></argument>)</argument_list></call>) != 0) &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>((<name>ret</name> == 0 &amp;&amp; <name>isbad</name> == 1) ? <name>DB_VERIFY_BAD</name> : <name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_dups_unsorted --
	*	Takes a known-safe hash duplicate set and its total length.
	*	Returns 1 if there are out-of-order duplicates in this set,
	*	0 if there are not.
	*/</comment>
	<function><type><name>int</name></type> <name><name>CHashVerify</name>::<name>ham_dups_unsorted</name></name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>u_int8_t</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>a</name>, <name>b</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>offset</name>, <name>dlen</name></decl>;</decl_stmt>
		<macro><name>int</name> <argument_list>(<argument>*func</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(DB *, const DBT *, const DBT *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DBT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DBT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>func</name> = (<name>dbp</name>-&gt;<name>dup_compare</name> == <name>NULL</name>) ? <name><name>CBTreeCompare</name>::<name>bam_defcmp</name></name> : <name>dbp</name>-&gt;<name>dup_compare</name></expr>;</expr_stmt>

		<comment type="block">/*
		* Loop through the dup set until we hit the end or we find
		* a pair of dups that's out of order.  b is always the current
		* dup, a the one before it.
		*/</comment>
		<for>for (<init><expr><name>offset</name> = 0</expr>;</init> <condition><expr><name>offset</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>offset</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dlen</name></expr></argument>, <argument><expr><name>buf</name> + <name>offset</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b</name>.<name>data</name> = <name>buf</name> + <name>offset</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b</name>.<name>size</name> = <name>dlen</name></expr>;</expr_stmt>

			<if>if <condition>(<expr><name>a</name>.<name>data</name> != <name>NULL</name> &amp;&amp; <call><name>func</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
				<return>return <expr>(1)</expr>;</return></then></if>

			<expr_stmt><expr><name>a</name>.<name>data</name> = <name>b</name>.<name>data</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>a</name>.<name>size</name> = <name>b</name>.<name>size</name></expr>;</expr_stmt>
		}</block></for>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">//#ifndef HAVE_HASH #else</comment>

};
</unit>
