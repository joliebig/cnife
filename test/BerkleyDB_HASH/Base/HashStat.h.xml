<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="HashStat.h" language="C++"><comment type="block">/*-
* See the file LICENSE for redistribution information.
*
* Copyright (c) 1996-2005
*	Sleepycat Software.  All rights reserved.
*
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_config.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_SYSTEM_INCLUDES</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_shash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BtreeMacros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashStat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashMeta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashPage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"MpFget.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"MpFput.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbMethod.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbPr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"EnvStat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbCam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbReclaim.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BTreeStatistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BTreeTraverse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbErr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbLog2.h"</cpp:file></cpp:include>


<comment type="block">/* Hash statistics structure. */</comment>
<struct>struct <name>__db_h_stat</name> <block>{<public type="default">
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_magic</name></decl>;</decl_stmt>		<comment type="block">/* Magic number. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_version</name></decl>;</decl_stmt>		<comment type="block">/* Version number. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_metaflags</name></decl>;</decl_stmt>	<comment type="block">/* Metadata flags. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_nkeys</name></decl>;</decl_stmt>		<comment type="block">/* Number of unique keys. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_ndata</name></decl>;</decl_stmt>		<comment type="block">/* Number of data items. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_pagesize</name></decl>;</decl_stmt>	<comment type="block">/* Page size. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_ffactor</name></decl>;</decl_stmt>		<comment type="block">/* Fill factor specified at create. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_buckets</name></decl>;</decl_stmt>		<comment type="block">/* Number of hash buckets. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_free</name></decl>;</decl_stmt>		<comment type="block">/* Pages on the free list. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_bfree</name></decl>;</decl_stmt>		<comment type="block">/* Bytes free on bucket pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_bigpages</name></decl>;</decl_stmt>	<comment type="block">/* Number of big key/data pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_big_bfree</name></decl>;</decl_stmt>	<comment type="block">/* Bytes free on big item pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_overflows</name></decl>;</decl_stmt>	<comment type="block">/* Number of overflow pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_ovfl_free</name></decl>;</decl_stmt>	<comment type="block">/* Bytes free on ovfl pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_dup</name></decl>;</decl_stmt>		<comment type="block">/* Number of dup pages. */</comment>
	<decl_stmt><decl><type><name>u_int32_t</name></type> <name>hash_dup_free</name></decl>;</decl_stmt>	<comment type="block">/* Bytes free on duplicate pages. */</comment>
</public>}</block>;</struct>


<class>class <name>CHashStat</name>
<block>{<private type="default">
</private><public>public:
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_HASH</name></cpp:ifndef>
	<function><type><name>static</name> <name>void</name></type> <name>ham_print_cursor</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr>(<name>void</name>)<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_stat</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>void</name> *</type><name>spp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>spp</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_stat_print</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHash</name>::<name>db_no_hash_am</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>


	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_stat_callback</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>pagep</name></decl></param>, <param><decl><type><name>void</name> *</type><name>cookie</name></decl></param>, <param><decl><type><name>int</name> *</type><name>putp</name></decl></param>)</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_traverse</name><argument_list>(<argument><expr><name>DBC</name> *<name>dbc</name></expr></argument>, <argument><expr><name>db_lockmode_t</name> <name>mode</name></expr></argument>, <argument><expr><call><name>int</name> <argument_list>(<argument><expr>*<name>callback</name></expr></argument>)</argument_list></call> <call><name>__P</name><argument_list>(<argument><expr>(<name>DB</name> *, <name>PAGE</name> *, <name>void</name> *, <name>int</name> *)</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> *<name>cookie</name></expr></argument>, <argument><expr><name>int</name> <name>look_past_max</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="line">//#ifndef HAVE_HASH</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_STATISTICS</name></cpp:ifdef>
	<comment type="block">/*
	* __ham_print_cursor --
	*	Display the current cursor.
	*
	* PUBLIC: void __ham_print_cursor __P((DBC *));
	*/</comment>
	<function><type><name>static</name> <name>void</name></type> <name>ham_print_cursor</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>static</name> <name>const</name> <name>FN</name></type> <name><name>fn</name><index>[]</index></name> =<init> <expr><block>{
			<expr><block>{ <expr><name>H_CONTINUE</name></expr>,	<expr>"H_CONTINUE"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_DELETED</name></expr>,	<expr>"H_DELETED"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_DIRTY</name></expr>,	<expr>"H_DIRTY"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_DUPONLY</name></expr>,	<expr>"H_DUPONLY"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_EXPAND</name></expr>,	<expr>"H_EXPAND"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_ISDUP</name></expr>,	<expr>"H_ISDUP"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_NEXT_NODUP</name></expr>,	<expr>"H_NEXT_NODUP"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_NOMORE</name></expr>,	<expr>"H_NOMORE"</expr> }</block></expr>,
			<expr><block>{ <expr><name>H_OK</name></expr>,		<expr>"H_OK"</expr> }</block></expr>,
			<expr><block>{ <expr>0</expr>,		<expr><name>NULL</name></expr> }</block></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>cp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Bucket traversing"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Bucket locked"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>lbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Duplicate set offset"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>dup_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Current duplicate length"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Total duplicate set length"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>dup_tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Bytes needed for add"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>seek_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Page on which we can insert"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>seek_found_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STAT_ULONG</name><argument_list>(<argument><expr>"Order"</expr></argument>, <argument><expr><name>cp</name>-&gt;<name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CDbPr</name>::<name>db_prflags</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cp</name>-&gt;<name>flags</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"\tInternal Flags"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>

	<comment type="block">/*
	* __ham_stat --
	*	Gather/print the hash statistics
	*
	* PUBLIC: int __ham_stat __P((DBC *, void *, u_int32_t));
	*/</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_stat</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>void</name> *</type><name>spp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_HASH_STAT</name> *</type><name>sp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name> = <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<comment type="block">/* Allocate and clear the structure. */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_umalloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>sp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>sp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>sp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Copy the fields that we have. */</comment>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_nkeys</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>key_count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ndata</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>record_count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_pagesize</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_buckets</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_magic</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>magic</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_version</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>version</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_metaflags</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>flags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ffactor</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>ffactor</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>flags</name> == <name>DB_FAST_STAT</name> || <name>flags</name> == <name>DB_CACHED_COUNTS</name></expr>)</condition><then>
			<goto>goto <name>done</name>;</goto></then></if>

		<comment type="block">/* Walk the free list, counting pages. */</comment>
		<for>for (<init><expr><name>sp</name>-&gt;<name>hash_free</name> = 0</expr>, <expr><name>pgno</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>free</name></expr>;</init>
			<condition><expr><name>pgno</name> != <name>PGNO_INVALID</name></expr>;</condition><incr/>) <block>{
				<expr_stmt><expr>++<name>sp</name>-&gt;<name>hash_free</name></expr>;</expr_stmt>

				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>

				<expr_stmt><expr><name>pgno</name> = <name>h</name>-&gt;<name>next_pgno</name></expr>;</expr_stmt>
				<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>

		<comment type="block">/* Now traverse the rest of the table. */</comment>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_nkeys</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ndata</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_traverse</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr><name>DB_LOCK_READ</name></expr></argument>, <argument><expr><name>ham_stat_callback</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_RDONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_dirty_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>key_count</name> = <name>sp</name>-&gt;<name>hash_nkeys</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>record_count</name> = <name>sp</name>-&gt;<name>hash_ndata</name></expr>;</expr_stmt>
		}</block></then></if>

<label><name>done</name>:</label>	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<expr_stmt><expr>*(<name>DB_HASH_STAT</name> **)<name>spp</name> = <name>sp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>

<label><name>err</name>:</label>	<if>if <condition>(<expr><name>sp</name> != <name>NULL</name></expr>)</condition><then>
			<constructor_decl><name>COsAlloc::os_ufree</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>sp</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>

		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>hdr</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_stat_print --
	*	Display hash statistics.
	*
	* PUBLIC: int __ham_stat_print __P((DBC *, u_int32_t));
	*/</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_stat_print</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>static</name> <name>const</name> <name>FN</name></type> <name><name>fn</name><index>[]</index></name> =<init> <expr><block>{
			<expr><block>{ <expr><name>DB_HASH_DUP</name></expr>,		<expr>"duplicates"</expr> }</block></expr>,
			<expr><block>{ <expr><name>DB_HASH_SUBDB</name></expr>,	<expr>"multiple-databases"</expr> }</block></expr>,
			<expr><block>{ <expr><name>DB_HASH_DUPSORT</name></expr>,	<expr>"sorted duplicates"</expr> }</block></expr>,
			<expr><block>{ <expr>0</expr>,			<expr><name>NULL</name></expr> }</block></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_HASH_STAT</name> *</type><name>sp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>lorder</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashStat</name>::<name>ham_stat</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>sp</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_STAT_ALL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_msg</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><call><name>DB_GLOBAL</name><argument_list>(<argument><expr><name>db_line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_msg</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Default Hash database information:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_msg</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"%lx\tHash magic number"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_msg</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"%lu\tHash version number"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr>(<name>void</name>)<call><name><name>CDbMethod</name>::<name>db_get_lorder</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr>&amp;<name>lorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>lorder</name></expr>)</condition> <block>{
<case>case <expr>1234</expr>:
	<expr_stmt><expr><name>s</name> = "Little-endian"</expr>;</expr_stmt>
	<break>break;</break>
</case><case>case <expr>4321</expr>:
	<expr_stmt><expr><name>s</name> = "Big-endian"</expr>;</expr_stmt>
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><name>s</name> = "Unrecognized byte order"</expr>;</expr_stmt>
	<break>break;</break>
		</default>}</block></switch>
		<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_msg</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"%s\tByte order"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CDbPr</name>::<name>db_prflags</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_metaflags</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"\tFlags"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Underlying database page size"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_pagesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Specified fill factor"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_ffactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of keys in the database"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of data items in the database"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_ndata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Number of hash buckets"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl_pct</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Number of bytes free on bucket pages"</expr></argument>,
			<argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_bfree</name></expr></argument>, <argument><expr><call><name>DB_PCT_PG</name><argument_list>(
			<argument><expr><name>sp</name>-&gt;<name>hash_bfree</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_buckets</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_pagesize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"ff"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of overflow pages"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_bigpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl_pct</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Number of bytes free in overflow pages"</expr></argument>,
			<argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_big_bfree</name></expr></argument>, <argument><expr><call><name>DB_PCT_PG</name><argument_list>(
			<argument><expr><name>sp</name>-&gt;<name>hash_big_bfree</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_bigpages</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_pagesize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"ff"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of bucket overflow pages"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_overflows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl_pct</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of bytes free in bucket overflow pages"</expr></argument>,
			<argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_ovfl_free</name></expr></argument>, <argument><expr><call><name>DB_PCT_PG</name><argument_list>(
			<argument><expr><name>sp</name>-&gt;<name>hash_ovfl_free</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_overflows</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_pagesize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"ff"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Number of duplicate pages"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl_pct</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr>"Number of bytes free in duplicate pages"</expr></argument>,
			<argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_dup_free</name></expr></argument>, <argument><expr><call><name>DB_PCT_PG</name><argument_list>(
			<argument><expr><name>sp</name>-&gt;<name>hash_dup_free</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_dup</name></expr></argument>, <argument><expr><name>sp</name>-&gt;<name>hash_pagesize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"ff"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>CEnvStat</name>::<name>db_dl</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>"Number of pages on the free list"</expr></argument>, <argument><expr>(<name>u_long</name>)<name>sp</name>-&gt;<name>hash_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<constructor_decl><name>COsAlloc::os_ufree</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>sp</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>


	<function><type><name>static</name> <name>int</name></type> <name>ham_stat_callback</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>pagep</name></decl></param>, <param><decl><type><name>void</name> *</type><name>cookie</name></decl></param>, <param><decl><type><name>int</name> *</type><name>putp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB_HASH_STAT</name> *</type><name>sp</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
		<decl_stmt><decl><type><name>DB_BTREE_STAT</name></type> <name>bstat</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>indx</name>, <name>len</name>, <name>off</name>, <name>tlen</name>, <name>top</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr>*<name>putp</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>DB_HASH_STAT</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>pagep</name>-&gt;<name>type</name></expr>)</condition> <block>{
<case>case <expr><name>P_INVALID</name></expr>:
	<comment type="block">/*
	* Hash pages may be wholly zeroed;  this is not a bug.
	* Obviously such pages have no data, so we can just proceed.
	*/</comment>
	<break>break;</break>
</case><case>case <expr><name>P_HASH</name></expr>:
	<comment type="block">/*
	* We count the buckets and the overflow pages
	* separately and tally their bytes separately
	* as well.  We need to figure out if this page
	* is a bucket.
	*/</comment>
	<if>if <condition>(<expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name></expr>)</condition><then>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_bfree</name> += <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
	<else>else <block>{
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_overflows</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ovfl_free</name> += <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>top</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Correct for on-page duplicates and deleted items. */</comment>
	<for>for (<init><expr><name>indx</name> = 0</expr>;</init> <condition><expr><name>indx</name> &lt; <name>top</name></expr>;</condition> <incr><expr><name>indx</name> += <name>P_INDX</name></expr></incr>) <block>{
		<switch>switch <condition>(<expr>*<call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H_OFFDUP</name></expr>:
	<break>break;</break>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
</case><case>case <expr><name>H_KEYDATA</name></expr>:
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ndata</name>++</expr>;</expr_stmt>
	<break>break;</break>
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<expr_stmt><expr><name>tlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>off</name> = 0</expr>;</init> <condition><expr><name>off</name> &lt; <name>tlen</name></expr>;</condition>
		<incr><expr><name>off</name> += <name>len</name> + 2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
			<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ndata</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>,
				<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call>
				+ <name>off</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<break>break;</break>
</case><default>default:
	<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
		</default>}</block></switch>
	}</block></for>
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_nkeys</name> += <call><name>H_NUMPAIRS</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
</case><case>case <expr><name>P_IBTREE</name></expr>:
</case><case>case <expr><name>P_IRECNO</name></expr>:
</case><case>case <expr><name>P_LBTREE</name></expr>:
</case><case>case <expr><name>P_LRECNO</name></expr>:
</case><case>case <expr><name>P_LDUP</name></expr>:
	<comment type="block">/*
	* These are all btree pages; get a correct
	* cookie and call them.  Then add appropriate
	* fields into our stat structure.
	*/</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>bstat</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>bstat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CBTreeStatistic</name>::<name>bam_stat_callback</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr>&amp;<name>bstat</name></expr></argument>, <argument><expr><name>putp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_dup</name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_dup_free</name> += <name>bstat</name>.<name>bt_leaf_pgfree</name> +
		<name>bstat</name>.<name>bt_dup_pgfree</name> + <name>bstat</name>.<name>bt_int_pgfree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_ndata</name> += <name>bstat</name>.<name>bt_ndata</name></expr>;</expr_stmt>
	<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>P_OVERFLOW</name></expr>:
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_bigpages</name>++</expr>;</expr_stmt>
	<expr_stmt><expr><name>sp</name>-&gt;<name>hash_big_bfree</name> += <call><name>P_OVFLSPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
</case><default>default:
	<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
		</default>}</block></switch>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !HAVE_STATISTICS */</comment>

	<function><type><name>int</name></type> <name><name>CHashStat</name>::<name>ham_stat</name></name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>void</name> *</type><name>spp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>spp</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr>(<call><name><name>CEnvStat</name>::<name>db_stat_not_built</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	* __ham_traverse
	*	 Traverse an entire hash table.  We use the callback so that we
	* can use this both for stat collection and for deallocation.
	*
	* PUBLIC: int __ham_traverse __P((DBC *, db_lockmode_t,
	* PUBLIC:     int (*)(DB *, PAGE *, void *, int *), void *, int));
	*/</comment>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_traverse</name><argument_list>(<argument><expr><name>DBC</name> *<name>dbc</name></expr></argument>, <argument><expr><name>db_lockmode_t</name> <name>mode</name></expr></argument>, <argument><expr><call><name>int</name> <argument_list>(<argument><expr>*<name>callback</name></expr></argument>)</argument_list></call> <call><name>__P</name><argument_list>(<argument><expr>(<name>DB</name> *, <name>PAGE</name> *, <name>void</name> *, <name>int</name> *)</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> *<name>cookie</name></expr></argument>, <argument><expr><name>int</name> <name>look_past_max</name></expr></argument>)</argument_list>
	<block>{
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> message("CHashStat::ham_traverse")</cpp:pragma>
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>opd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HKEYDATA</name> *</type><name>hk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name>, <name>opgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>did_put</name>, <name>i</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>bucket</name>, <name>spares_entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opd</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		* In a perfect world, we could simply read each page in the file
		* and look at its page type to tally the information necessary.
		* Unfortunately, the bucket locking that hash tables do to make
		* locking easy, makes this a pain in the butt.  We have to traverse
		* duplicate, overflow and big pages from the bucket so that we
		* don't access anything that isn't properly locked.
		*
		*/</comment>
		<for>for (<init><expr><name>bucket</name> = 0</expr>;</init><condition>;</condition> <incr><expr><name>bucket</name>++</expr></incr>) <block>{
			<comment type="block">/*
			* We put the loop exit condition check here, because
			* it made for a really vile extended ?: that made SCO's
			* compiler drop core.
		 *
		 * If look_past_max is not set, we can stop at max_bucket;
		 * if it is set, we need to include pages that are part of
		 * the current doubling but beyond the highest bucket we've
		 * split into, as well as pages from a "future" doubling
		 * that may have been created within an aborted
		 * transaction.  To do this, keep looping (and incrementing
		 * bucket) until the corresponding spares array entries
		 * cease to be defined.
		 */</comment>
			<if>if <condition>(<expr><name>look_past_max</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>spares_entry</name> = <call><name><name>CDbLog2</name>::<name>db_log2</name></name><argument_list>(<argument><expr><name>bucket</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>spares_entry</name> &gt;= <name>NCACHED</name> ||
					<name>hcp</name>-&gt;<name>hdr</name>-&gt;<name><name>spares</name><index>[<expr><name>spares_entry</name></expr>]</index></name> == 0</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><name>bucket</name> &gt; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></else></if>

			<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = <name>bucket</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_get_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ret</name> == 0</expr>;</condition>
				<incr><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_next_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></incr>) <block>{

					<comment type="block">/*
					* If we are cleaning up pages past the max_bucket,
					* then they may be on the free list and have their
					* next pointers set, but they should be ignored.  In
					* fact, we really ought to just skip anybody who is
					* not a valid page.
					*/</comment>
					<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> == <name>P_INVALID</name></expr>)</condition><then>
						<break>break;</break></then></if>
					<expr_stmt><expr><name>pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					* Go through each item on the page checking for
					* duplicates (in which case we have to count the
					* duplicate pages) or big key/data items (in which
					* case we have to count those pages).
					*/</comment>
					<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
						<expr_stmt><expr><name>hk</name> = (<name>HKEYDATA</name> *)<call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
<case>case <expr><name>H_OFFDUP</name></expr>:
	<block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>opgno</name></expr></argument>, <argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbCam</name>::<name>db_c_newopd</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>opd</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<function_decl><type><name>CBTreeTraverse</name></type> <name>traverse</name><parameter_list>(<param><decl><type>*</type><name>opd</name></decl></param>, <param><decl><type><name>callback</name></type></decl></param>)</parameter_list>;</function_decl>
		<if>if <condition>(<expr>(<name>ret</name> = <name>traverse</name>.<call><name>bam_traverse</name><argument_list>(<argument><expr><name>DB_LOCK_READ</name></expr></argument>, <argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbCam</name>::<name>db_c_close</name></name><argument_list>(<argument><expr><name>opd</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>opd</name> = <name>NULL</name></expr>;</expr_stmt>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
	<comment type="block">/*
	* We are about to get a big page
	* which will use the same spot that
	* the current page uses, so we need
	* to restore the current page before
	* looking at it again.
	*/</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>opgno</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbReclaim</name>::<name>db_traverse_big</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
		<argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_KEYDATA</name></expr>:
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>EINVAL</name></expr>;</expr_stmt>
	<goto>goto <name>err</name>;</goto>

						</default>}</block></switch>
					}</block></for>

					<comment type="block">/* Call the callback on main pages. */</comment>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name>callback</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
						<argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cookie</name></expr></argument>, <argument><expr>&amp;<name>did_put</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>

					<if>if <condition>(<expr><name>did_put</name></expr>)</condition><then>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
					<if>if <condition>(<expr><name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
						<break>break;</break></then></if>
			}</block></for>
			<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>

		}</block></for>
<label><name>err</name>:</label>	<if>if <condition>(<expr><name>opd</name> != <name>NULL</name> &amp;&amp;
			(<name>t_ret</name> = <call><name><name>CDbCam</name>::<name>db_c_close</name></name><argument_list>(<argument><expr><name>opd</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="line">//#ifndef HAVE_HASH #else</comment>

</public>}</block>;</class>



</unit>