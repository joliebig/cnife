<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="HashAuto.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_config.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_SYSTEM_INCLUDES</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Crypto.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"db_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashAuto.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"HashRec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"LogPut.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbDispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Txn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DbregUtil.h"</cpp:file></cpp:include>


<class>class <name>CHashAuto</name>
<block>{<private type="default">
</private><public>public:

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_HASH</name></cpp:ifndef>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_init_recover</name>(DB_ENV *<name>dbenv</name>, <name>int</name> (***<name>dtabp</name>)__P((DB_ENV *</decl>, DBT *, DB_LSN *, db_recops, void *</decl_stmt></public>)</block></class>), <decl_stmt><decl><type><name>size_t</name> *</type><name>dtabsizep</name>)
	<block>{
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>dtabsizep</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></decl></decl_stmt>

	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_insdel_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>data</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_insdel_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_insdel_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_newpage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>prev_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>prevlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_newpage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_newpage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_splitdata_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>pageimage</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_splitdata_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_splitdata_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_replace_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>off</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>olditem</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>newitem</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>makedup</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_replace_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_replace_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_copypage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>nnext_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nnextlsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>page</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_copypage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_copypage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_metagroup_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>bucket</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mmpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>mmetalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>metalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>newalloc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_metagroup_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_metagroup_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>meta_lsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>start_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>num</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>free</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_groupalloc_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_curadj_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>dup_off</name></decl></param>, <param><decl><type><name>int</name></type> <name>add</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_dup</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>order</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_curadj_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_curadj_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_chgpg_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_ham_mode</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>old_pgno</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>old_indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>new_indx</name></decl></param>)</parameter_list>;</function_decl>
	<function_decl><type><name>static</name> <name>int</name></type> <name>ham_chgpg_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_chgpg_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">//#ifndef HAVE_HASH</comment>

	<comment type="block">/*
	* PUBLIC: int __ham_init_recover __P((DB_ENV *, int (***)(DB_ENV *,
	* PUBLIC:     DBT *, DB_LSN *, db_recops, void *), size_t *));
	*/</comment>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_init_recover</name>(DB_ENV *<name>dbenv</name>, <name>int</name> (***<name>dtabp</name>)__P((DB_ENV *</decl>, DBT *, DB_LSN *, db_recops, void *</decl_stmt>)), <decl_stmt><decl><type><name>size_t</name> *</type><name>dtabsizep</name>)
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_insdel_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_insdel</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_newpage_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_newpage</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_splitdata_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_splitdata</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_replace_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_replace</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_copypage_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_copypage</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_metagroup_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_metagroup</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_groupalloc_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_groupalloc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_curadj_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_curadj</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_chgpg_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_chgpg</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<return>return <expr>(0)</expr>;</return>
	}</block></decl></decl_stmt>

	<comment type="block">/*
	* PUBLIC: int __ham_insdel_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, u_int32_t, DB_LSN *,
	* PUBLIC:     const DBT *, const DBT *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_insdel_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>data</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_insdel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>key</name> == <name>NULL</name> ? 0 : <name>key</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>data</name> == <name>NULL</name> ? 0 : <name>data</name>-&gt;<name>size</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>ndx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>key</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>key</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>data</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>data</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>data</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_insdel_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_insdel_read __P((DB_ENV *, void *, __ham_insdel_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_insdel_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_insdel_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_insdel_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_insdel_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>ndx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>key</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>key</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>key</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>key</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>data</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>data</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>data</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>data</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_newpage_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *,
	* PUBLIC:     db_pgno_t, DB_LSN *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_newpage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>prev_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>prevlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_newpage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>prev_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>prevlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>prevlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>next_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_newpage_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_newpage_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_newpage_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_newpage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_newpage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_newpage_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_newpage_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>prev_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prevlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>prevlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>next_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_splitdata_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, const DBT *, DB_LSN *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_splitdata_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>pageimage</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_splitdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>pageimage</name> == <name>NULL</name> ? 0 : <name>pageimage</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pageimage</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>pageimage</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pageimage</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>pageimage</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_splitdata_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_splitdata_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_splitdata_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_splitdata_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_splitdata_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_splitdata_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_splitdata_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pageimage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pageimage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pageimage</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pageimage</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>pageimage</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_replace_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, u_int32_t, DB_LSN *, int32_t, const DBT *,
	* PUBLIC:     const DBT *, u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_replace_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>off</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>olditem</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>newitem</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>makedup</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_replace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>olditem</name> == <name>NULL</name> ? 0 : <name>olditem</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>newitem</name> == <name>NULL</name> ? 0 : <name>newitem</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>ndx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>olditem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>olditem</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>olditem</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>olditem</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>newitem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>newitem</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>newitem</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>newitem</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>makedup</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_replace_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_replace_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_replace_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_replace_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_replace_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_replace_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_replace_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>ndx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>off</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>olditem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>olditem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>olditem</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>olditem</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>olditem</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>newitem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>newitem</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>newitem</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>newitem</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>makedup</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_copypage_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *, db_pgno_t,
	* PUBLIC:     DB_LSN *, const DBT *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_copypage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>nnext_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nnextlsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>page</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_copypage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>page</name> == <name>NULL</name> ? 0 : <name>page</name>-&gt;<name>size</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>next_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>nnext_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nnextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nnextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>page</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>page</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>page</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>page</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_copypage_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_copypage_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_copypage_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_copypage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_copypage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_copypage_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_copypage_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>next_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>nnext_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>page</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>page</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>page</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_metagroup_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *,
	* PUBLIC:     db_pgno_t, DB_LSN *, u_int32_t, db_pgno_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_metagroup_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>bucket</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mmpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>mmetalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>metalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>newalloc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_metagroup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>bucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mmpgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>mmetalsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>mmetalsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mpgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>metalsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>metalsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>newalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>last_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_metagroup_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_metagroup_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_metagroup_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_metagroup_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_metagroup_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_metagroup_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_metagroup_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>bucket</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mmpgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mpgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>metalsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>metalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>newalloc</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>last_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_groupalloc_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, DB_LSN *, db_pgno_t, u_int32_t, db_pgno_t,
	* PUBLIC:     db_pgno_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>meta_lsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>start_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>num</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>free</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_groupalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>meta_lsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>meta_lsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>start_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>num</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>free</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>last_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_groupalloc_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_groupalloc_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_groupalloc_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_groupalloc_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_groupalloc_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_groupalloc_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>start_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>num</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>free</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>last_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_curadj_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, u_int32_t, u_int32_t, u_int32_t, int, int,
	* PUBLIC:     u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_curadj_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>dup_off</name></decl></param>, <param><decl><type><name>int</name></type> <name>add</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_dup</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>order</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_curadj</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dup_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>add</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>is_dup</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>order</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_curadj_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_curadj_read __P((DB_ENV *, void *, __ham_curadj_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_curadj_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_curadj_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_curadj_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_curadj_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>len</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>dup_off</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>add</name> = (<name>int</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>is_dup</name> = (<name>int</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>order</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_chgpg_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_ham_mode, db_pgno_t, db_pgno_t, u_int32_t,
	* PUBLIC:     u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_chgpg_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_ham_mode</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>old_pgno</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>old_indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>new_indx</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_chgpg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<expr_stmt><expr><call><name>DB_SET_TXN_LSNP</name><argument_list>(<argument><expr><name>txnid</name></expr></argument>, <argument><expr>&amp;<name>rlsnp</name></expr></argument>, <argument><expr>&amp;<name>lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>logrec</name>.<name>data</name> = <name>lr</name>-&gt;<name>data</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>old_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>old_indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call>(<name>u_int32_t</name>)<argument_list>(<argument><expr><name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call> &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
			<comment type="block">/*
			* Set the debug bit if we are going to log non-durable
			* transactions so they will be ignored by recovery.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lr</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rectype</name> |= <name>DB_debug_FLAG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>rlsnp</name></expr></argument>, <argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr>*<name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_DIAGNOSTIC</name></cpp:ifdef>
		<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CHashAutop</name>::<name>ham_chgpg_print</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>, <argument><expr><name>DB_TXN_PRINT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIAGNOSTIC</name></cpp:ifdef>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_chgpg_read __P((DB_ENV *, void *, __ham_chgpg_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_chgpg_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_chgpg_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_chgpg_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_chgpg_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name><name>static_cast</name><argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mode</name> = (<name>db_ham_mode</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>old_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>old_indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//#ifndef HAVE_HASH #else</comment>




};
</unit>
