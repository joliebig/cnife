<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHash</name>
<block>{
<comment>//---refactored functions</comment>
<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashHookFunction1</name><parameterlist>(<param><decl><type><name>HASH_CURSOR</name> *&amp;</type> <name>hcp</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>tmp_val</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>nondup_size</name></decl></param>, <param><decl><type><name>db_indx_t</name>&amp;</type> <name>newsize</name></decl></param>, <param><decl><type><name>DB</name> *&amp;</type> <name>dbp</name></decl></param>, <param><decl><type><name>void</name> *&amp;</type> <name>newrec</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>tmp_val2</name></decl></param>, <param><decl><type><name>u_int8_t</name> *&amp;</type> <name>p</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>len</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>myval</name></decl></param>, <param><decl><type><name>u_int8_t</name> *&amp;</type> <name>hk</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>nval</name></decl></param>, <param><decl><type><name>DBC</name> *&amp;</type> <name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>flags</name></decl></param>)</parameterlist>
	<block>{
	
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/*
			 * This is an overwrite of a duplicate. We should never
			 * be off-page at this point.
			 */</comment>
			<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>opd</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* On page dups */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>nval</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/*
				 * We're going to have to get the current item, then
				 * construct the record, do any padding and do a
				 * replace.
				 */</comment>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>tmp_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> =
					<call><name>ham_dup_return</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>DB_CURRENT</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<comment type="block">/* Figure out new size. */</comment>
				<expr_stmt><expr><name>nondup_size</name> = <name>tmp_val</name>.<name>size</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newsize</name> = <name>nondup_size</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Three cases:
				 * 1. strictly append (may need to allocate space
				 *	for pad bytes; really gross).
				 * 2. overwrite some and append.
				 * 3. strictly overwrite.
				 */</comment>
				<if>if <condition>(<expr><name>nval</name>-&gt;<name>doff</name> &gt; <name>nondup_size</name></expr>)</condition><then>
					<expr_stmt><expr><name>newsize</name> +=
						((<name>nval</name>-&gt;<name>doff</name> - <name>nondup_size</name>) + <name>nval</name>-&gt;<name>size</name>)</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>nval</name>-&gt;<name>doff</name> + <name>nval</name>-&gt;<name>dlen</name> &gt; <name>nondup_size</name></expr>)</condition><then>
					<expr_stmt><expr><name>newsize</name> += <name>nval</name>-&gt;<name>size</name> -
						(<name>nondup_size</name> - <name>nval</name>-&gt;<name>doff</name>)</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>newsize</name> += <name>nval</name>-&gt;<name>size</name> - <name>nval</name>-&gt;<name>dlen</name></expr>;</expr_stmt></else></if></else></if>

				<comment type="block">/*
				 * Make sure that the new size doesn't put us over
				 * the onpage duplicate size in which case we need
				 * to convert to off-page duplicates.
				 */</comment>
				<if>if <condition>(<expr><call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>,
					<argument><expr>(<name>hcp</name>-&gt;<name>dup_tlen</name> - <name>nondup_size</name>) + <name>newsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashDup</name>::<name>ham_dup_convert</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
					<return>return <expr>(<name>hcp</name>-&gt;<name>opd</name>-&gt;<call><name>c_am_put</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>opd</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</return>
				}</block></then></if>

				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
					<argument><expr><call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>newrec</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>tmp_val2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>tmp_val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type>&amp;</type><name>tmp_val2</name></decl></param>, <param><decl><type><name>DB_DBT_PARTIAL</name></type></decl></param>)</parameter_list>;</constructor_decl>

				<comment type="block">/* Construct the record. */</comment>
				<expr_stmt><expr><name>p</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>newrec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Initial size. */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>newsize</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* First part of original record. */</comment>
				<expr_stmt><expr><name>len</name> = <name>nval</name>-&gt;<name>doff</name> &gt; <name>tmp_val</name>.<name>size</name>
					? <name>tmp_val</name>.<name>size</name> : <name>nval</name>-&gt;<name>doff</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tmp_val</name>.<name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>nval</name>-&gt;<name>doff</name> &gt; <name>tmp_val</name>.<name>size</name></expr>)</condition><then> <block>{
					<comment type="block">/* Padding */</comment>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>nval</name>-&gt;<name>doff</name> - <name>tmp_val</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>p</name> += <name>nval</name>-&gt;<name>doff</name> - <name>tmp_val</name>.<name>size</name></expr>;</expr_stmt>
				}</block></then></if>

				<comment type="block">/* New bytes */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nval</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>nval</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += <name>nval</name>-&gt;<name>size</name></expr>;</expr_stmt>

				<comment type="block">/* End of original record (if there is any) */</comment>
				<if>if <condition>(<expr><name>nval</name>-&gt;<name>doff</name> + <name>nval</name>-&gt;<name>dlen</name> &lt; <name>tmp_val</name>.<name>size</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>len</name> = (<name>tmp_val</name>.<name>size</name> - <name>nval</name>-&gt;<name>doff</name>) - <name>nval</name>-&gt;<name>dlen</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>u_int8_t</name> *)<name>tmp_val</name>.<name>data</name> +
						<name>nval</name>-&gt;<name>doff</name> + <name>nval</name>-&gt;<name>dlen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
				}</block></then></if>

				<comment type="block">/* Final size. */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>newsize</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure that the caller isn't corrupting
				 * the sort order.
				 */</comment>
				<if>if <condition>(<expr><name>dbp</name>-&gt;<name>dup_compare</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>tmp_val2</name>.<name>data</name> =
						(<name>u_int8_t</name> *)<name>newrec</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmp_val2</name>.<name>size</name> = <name>newsize</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>dbp</name>-&gt;<call><name>dup_compare</name><argument_list>(
						<argument><expr><name>dbp</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>&amp;<name>tmp_val2</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
						<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>newrec</name></type></decl></param>)</parameter_list>;</constructor_decl>
						<return>return <expr>(<call><name><name>CDbCam</name>::<name>db_duperr</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>)</expr>;</return>
					}</block></then></if>
				}</block></then></if>

				<expr_stmt><expr><name>tmp_val2</name>.<name>data</name> = <name>newrec</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp_val2</name>.<name>size</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp_val2</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp_val2</name>.<name>dlen</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_replpair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>tmp_val2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>newrec</name></type></decl></param>)</parameter_list>;</constructor_decl>

				<comment type="block">/* Update cursor */</comment>
				<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<if>if <condition>(<expr><name>newsize</name> &gt; <name>nondup_size</name></expr>)</condition><then>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> += (<name>newsize</name> - <name>nondup_size</name>)</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> -= (<name>nondup_size</name> - <name>newsize</name>)</expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>newsize</name></expr>;</expr_stmt>
				<return>return <expr>(0)</expr>;</return>
			}</block></then> <else>else <block>{
				<comment type="block">/* Check whether we need to convert to off page. */</comment>
				<if>if <condition>(<expr><call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>,
					<argument><expr>(<name>hcp</name>-&gt;<name>dup_tlen</name> - <name>hcp</name>-&gt;<name>dup_len</name>) + <name>nval</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashDup</name>::<name>ham_dup_convert</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
					<return>return <expr>(<name>hcp</name>-&gt;<name>opd</name>-&gt;<call><name>c_am_put</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>opd</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</return>
				}</block></then></if>

				<comment type="block">/* Make sure we maintain sort order. */</comment>
				<if>if <condition>(<expr><name>dbp</name>-&gt;<name>dup_compare</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>tmp_val2</name>.<name>data</name> =
						<call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
						<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>hcp</name>-&gt;<name>dup_off</name> +
						<call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmp_val2</name>.<name>size</name> = <name>hcp</name>-&gt;<name>dup_len</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>dbp</name>-&gt;<call><name>dup_compare</name><argument_list>(
						<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr>&amp;<name>tmp_val2</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_err</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr>"Existing data sorts differently from put data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr>(<name>EINVAL</name>)</expr>;</return>
					}</block></then></if>
				}</block></then></if>
				<comment type="block">/* Overwriting a complete duplicate. */</comment>
				<if>if <condition>(<expr>(<name>ret</name> =
					<call><name><name>CHashDup</name>::<name>ham_make_dup</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>,
					<argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>ulen</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<comment type="block">/* Now fix what we are replacing. */</comment>
				<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update cursor */</comment>
				<if>if <condition>(<expr><name>nval</name>-&gt;<name>size</name> &gt; <name>hcp</name>-&gt;<name>dup_len</name></expr>)</condition><then>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> += (<name>nval</name>-&gt;<name>size</name> - <name>hcp</name>-&gt;<name>dup_len</name>)</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> -= (<name>hcp</name>-&gt;<name>dup_len</name> - <name>nval</name>-&gt;<name>size</name>)</expr>;</expr_stmt></else></if>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = (<name>db_indx_t</name>)<name>nval</name>-&gt;<name>size</name></expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><name>myval</name> = &amp;<name>tmp_val</name></expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>nval</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Put/overwrite */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type>&amp;</type><name>tmp_val</name></decl></param>, <param><decl><type><name>DB_DBT_PARTIAL</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>tmp_val</name>.<name>dlen</name></expr></argument>,
					<argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
					<argument><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>pagesize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><name>myval</name> = &amp;<name>tmp_val</name></expr>;</expr_stmt>
		}</block></then> <else>else
			<comment type="block">/* Regular partial put */</comment>
			<expr_stmt><expr><name>myval</name> = <name>nval</name></expr>;</expr_stmt></else></if></else></if>
<comment>//--functionbody</comment>
	}</block></function>

}</block></class>;</unit>