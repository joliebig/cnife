<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHashPage</name>
<block>{
<comment>//---refactored functions</comment><public>
public:


	<comment type="block">/*
	* PUBLIC: int __ham_item __P((DBC *, db_lockmode_t, db_pgno_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_err</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr>"Attempt to return a deleted item"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>EINVAL</name>)</expr>;</return>
		}</block></then></if>
		<expr_stmt><expr><call><name>F_CLR</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_OK</name> | <name>H_NOMORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check if we need to get a page for this cursor. */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_get_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

<label><name>recheck</name>:</label>
		<comment type="block">/* Check if we are looking for space in which to insert an item. */</comment>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>seek_size</name> &amp;&amp; <name>hcp</name>-&gt;<name>seek_found_page</name> == <name>PGNO_INVALID</name> &amp;&amp;
			<name>hcp</name>-&gt;<name>seek_size</name> &lt; <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>seek_found_page</name> = <name>hcp</name>-&gt;<name>pgno</name></expr>;</expr_stmt></then></if>

		<comment type="block">/* Check for off-page duplicates. */</comment>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>H_OFFDUP</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgnop</name></expr></argument>,
					<argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<return>return <expr>(0)</expr>;</return>
		}</block></then></if>

		<comment type="block">/* Check if we need to go on to the next page. */</comment>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<comment type="block">/*
			* ISDUP is set, and offset is at the beginning of the datum.
			* We need to grab the length of the datum, then set the datum
			* pointer to be the beginning of the datum.
			*/</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>hcp</name>-&gt;<name>dup_len</name></expr></argument>,
			<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
			<name>hcp</name>-&gt;<name>dup_off</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> &gt;= (<name>db_indx_t</name>)<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/* Fetch next page. */</comment>
			<if>if <condition>(<expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = 0</expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_next_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>next_pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<goto>goto <name>recheck</name>;</goto>
		}</block></then></if>

		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_item_reset __P((DBC *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_reset</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name>ham_item_init</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_item_init __P((DBC *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_init</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<comment type="block">/*
		* If this cursor still holds any locks, we must release them if
		* we are not running with transactions.
		*/</comment>
		<expr_stmt><expr><name>ret</name> = <call><name>__TLPUT</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* The following fields must *not* be initialized here because they
		* may have meaning across inits.
		*	hlock, hdr, split_buf, stats
		*/</comment>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = <name>BUCKET_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>lbucket</name> = <name>BUCKET_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOCK_INIT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>lock_mode</name> = <name>DB_LOCK_NG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>seek_size</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>seek_found_page</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>flags</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Returns the last item in a bucket.
	*
	* PUBLIC: int __ham_item_last __P((DBC *, db_lockmode_t, db_pgno_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_last</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_item_reset</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<return>return <expr>(<call><name>ham_item_prev</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_item_first __P((DBC *, db_lockmode_t, db_pgno_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_first</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_item_reset</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name>ham_item_next</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_item_prev --
	*	Returns a pointer to key/data pair on a page.  In the case of
	*	bigkeys, just returns the page number and index of the bigkey
	*	pointer pair.
	*
	* PUBLIC: int __ham_item_prev __P((DBC *, db_lockmode_t, db_pgno_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_prev</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>

		<comment type="block">/*
		* There are 5 cases for backing up in a hash file.
		* Case 1: In the middle of a page, no duplicates, just dec the index.
		* Case 2: In the middle of a duplicate set, back up one.
		* Case 3: At the beginning of a duplicate set, get out of set and
		*	back up to next key.
		* Case 4: At the beginning of a page; go to previous page.
		* Case 5: At the beginning of a bucket; go to prev bucket.
		*/</comment>
		<expr_stmt><expr><call><name>F_CLR</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_OK</name> | <name>H_NOMORE</name> | <name>H_DELETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_get_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/*
		* First handle the duplicates.  Either you'll get the key here
		* or you'll exit the duplicate set and drop into the code below
		* to handle backing up through keys.
		*/</comment>
		<if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_NEXT_NODUP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> ==
				<name>H_OFFDUP</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgnop</name></expr></argument>,
						<argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<return>return <expr>(0)</expr>;</return>
			}</block></then></if>

			<comment type="block">/* Duplicates are on-page. */</comment>
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>dup_off</name> != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>hcp</name>-&gt;<name>dup_len</name></expr></argument>, <argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(
					<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
					+ <name>hcp</name>-&gt;<name>dup_off</name> - <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> -=
					<call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<call><name>ham_item</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>)</expr>;</return>
			}</block></then></if>
		}</block></then></if>

		<comment type="block">/*
		* If we get here, we are not in a duplicate set, and just need
		* to back up the cursor.  There are still three cases:
		* midpage, beginning of page, beginning of bucket.
		*/</comment>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DUPONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<return>return <expr>(0)</expr>;</return>
		}</block></then> <else>else
			<comment type="block">/*
			* We are no longer in a dup set;  flag this so the dup code
			* will reinitialize should we stumble upon another one.
			*/</comment>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == 0</expr>)</condition><then> <block>{		<comment type="block">/* Beginning of page. */</comment>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
				<comment type="block">/* Beginning of bucket. */</comment>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return>
			}</block></then> <else>else <if>if <condition>(<expr>(<name>ret</name> =
				<call><name>ham_next_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then>
			<else>else
				<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
		}</block></then></if>

		<comment type="block">/*
		* Either we've got the cursor set up to be decremented, or we
		* have to find the end of a bucket.
		*/</comment>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == <name>NDX_INVALID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</init>
				<condition><expr><name>next_pgno</name> != <name>PGNO_INVALID</name></expr>;</condition>
				<incr><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_next_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>next_pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>

			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == 0</expr>)</condition><then> <block>{
				<comment type="block">/* Bucket was empty. */</comment>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return>
			}</block></then></if>
		}</block></then></if>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> -= 2</expr>;</expr_stmt>

		<return>return <expr>(<call><name>ham_item</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Sets the cursor to the next key/data pair on a page.
	*
	* PUBLIC: int __ham_item_next __P((DBC *, db_lockmode_t, db_pgno_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_item_next</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_get_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/*
		* Deleted on-page duplicates are a weird case. If we delete the last
		* one, then our cursor is at the very end of a duplicate set and
		* we actually need to go on to the next key.
		*/</comment>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> != <name>NDX_INVALID</name> &amp;&amp;
				<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call> &amp;&amp;
				<call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
				== <name>H_DUPLICATE</name> &amp;&amp; <name>hcp</name>-&gt;<name>dup_tlen</name> == <name>hcp</name>-&gt;<name>dup_off</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DUPONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
						<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
						<return>return <expr>(0)</expr>;</return>
					}</block></then> <else>else <block>{
						<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
					}</block></else></if>
			}</block></then> <else>else <if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DUPONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<return>return <expr>(0)</expr>;</return>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call> &amp;&amp;
				<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_NEXT_NODUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
			}</block></then></if></else></if></else></if>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
		}</block></then> <else>else <if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == <name>NDX_INVALID</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = 0</expr>;</expr_stmt>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
		}</block></then> <else>else <if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_NEXT_NODUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
		}</block></then> <else>else <if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call> &amp;&amp; <name>hcp</name>-&gt;<name>dup_tlen</name> != 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>dup_off</name> + <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call> &gt;=
				<name>hcp</name>-&gt;<name>dup_tlen</name> &amp;&amp; <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DUPONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<return>return <expr>(0)</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>dup_off</name> &gt;= <name>hcp</name>-&gt;<name>dup_tlen</name></expr>)</condition><then> <block>{
				<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then> <else>else <if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DUPONLY</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NOMORE</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<return>return <expr>(0)</expr>;</return>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if></else></if></else></if></else></if></else></if>

		<return>return <expr>(<call><name>ham_item</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: void __ham_putitem __P((DB *, PAGE *p, const DBT *, int));
	*
	* This is a little bit sleazy in that we're overloading the meaning
	* of the H_OFFPAGE type here.  When we recover deletes, we have the
	* entire entry instead of having only the DBT, so we'll pass type
	* H_OFFPAGE to mean, "copy the whole entry" as opposed to constructing
	* an H_KEYDATA around it.
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_putitem</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>u_int16_t</name></type> <name>n</name>, <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name> *</type><name>inp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Put the item element on the page. */</comment>
		<if>if <condition>(<expr><name>type</name> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>off</name> = <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> - <name>dbt</name>-&gt;<name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name><name>inp</name><index>[<expr><name>n</name></expr>]</index></name> = <name>off</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>off</name> = <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> - <call><name>HKEYDATA_SIZE</name><argument_list>(<argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name><name>inp</name><index>[<expr><name>n</name></expr>]</index></name> = <name>off</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUT_HKEYDATA</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<comment type="block">/* Adjust page info. */</comment>
		<expr_stmt><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> += 1</expr>;</expr_stmt>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: void __ham_reputpair  __P((DB *, PAGE *,
	* PUBLIC:    u_int32_t, const DBT *, const DBT *));
	*
	* This is a special case to restore a key/data pair to its original
	* location during recovery.  We are guaranteed that the pair fits
	* on the page and is not the last pair on the page (because if it's
	* the last pair, the normal insert works).
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_reputpair</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>data</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name>, *<name>inp</name>, <name>movebytes</name>, <name>newbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>psize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>from</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>psize</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* First shuffle the existing items up on the page.  */</comment>
		<expr_stmt><expr><name>movebytes</name> = (<name>db_indx_t</name>)(
			(<name>ndx</name> == 0 ? <name>psize</name> : <name><name>inp</name><index>[<expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name> - 2</expr></argument>)</argument_list></call></expr>]</index></name>) - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>newbytes</name> = <name>key</name>-&gt;<name>size</name> + <name>data</name>-&gt;<name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>from</name> = (<name>u_int8_t</name> *)<name>p</name> + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>from</name> - <name>newbytes</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>movebytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* Adjust the indices and move them up 2 spaces. Note that we
		* have to check the exit condition inside the loop just in case
		* we are dealing with index 0 (db_indx_t's are unsigned).
		*/</comment>
		<for>for (<init><expr><name>i</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>--</expr></incr> ) <block>{
			<expr_stmt><expr><name><name>inp</name><index>[<expr><name>i</name> + 2</expr>]</index></name> = <name><name>inp</name><index>[<expr><name>i</name></expr>]</index></name> - <name>newbytes</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>i</name> == <call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>
		}</block></for>

		<comment type="block">/* Put the key and data on the page. */</comment>
		<expr_stmt><expr><name><name>inp</name><index>[<expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>]</index></name> = (<name>db_indx_t</name>)(
			(<name>ndx</name> == 0 ? <name>psize</name> : <name><name>inp</name><index>[<expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name> - 2</expr></argument>)</argument_list></call></expr>]</index></name>) - <name>key</name>-&gt;<name>size</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inp</name><index>[<expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name><name>inp</name><index>[<expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>]</index></name> - <name>data</name>-&gt;<name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Adjust page info. */</comment>
		<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> -= <name>newbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> += 2</expr>;</expr_stmt>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_del_pair __P((DBC *, int));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_del_pair</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>int</name></type> <name>reclaim_page</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>data_dbt</name>, <name>key_dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>new_lsn</name>, *<name>n_lsn</name>, <name>tmp_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>n_pagep</name>, *<name>nn_pagep</name>, *<name>p</name>, *<name>p_pagep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_ham_mode</name></type> <name>op</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>ndx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>chg_pgno</name>, <name>pgno</name>, <name>tmp_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>order</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_pagep</name> = <name>p_pagep</name> = <name>nn_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndx</name> = <name>hcp</name>-&gt;<name>indx</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> == <name>NULL</name> &amp;&amp; (<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(
			<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>p</name> = <call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* We optimize for the normal case which is when neither the key nor
		* the data are large.  In this case, we write a single log record
		* and do the delete.  If either is large, we'll call __big_delete
		* to remove the big item and then update the page to remove the
		* entry referring to the big item.
		*/</comment>
		<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_doff</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
			<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H_OFFPAGE</name></expr>:
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>,
		<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_doff</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
</case><case>case <expr><name>H_OFFDUP</name></expr>:
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<comment type="block">/*
	* If we delete a pair that is/was a duplicate, then
	* we had better clear the flag so that we update the
	* cursor appropriately.
	*/</comment>
	<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
	<break>break;</break>
</case><default>default:
	<comment type="block">/* No-op */</comment>
	<break>break;</break>
		</default>}</block></switch></then></if>

		<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/* Now log the delete off this page. */</comment>
		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>key_dbt</name>.<name>data</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_dbt</name>.<name>size</name> = <call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_dbt</name>.<name>data</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_dbt</name>.<name>size</name> =
				<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_insdel_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DELPAIR</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>u_int32_t</name>)<name>ndx</name></expr></argument>,
				<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>key_dbt</name></expr></argument>, <argument><expr>&amp;<name>data_dbt</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<comment type="block">/* Move lsn onto page. */</comment>
		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>

		<comment type="block">/* Do the delete. */</comment>
		<constructor_decl><name>ham_dpair</name><parameter_list>(<param><decl><type><name>dbp</name></type></decl></param>, <param><decl><type><name>p</name></type></decl></param>, <param><decl><type><name>ndx</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<comment type="block">/*
		* Mark item deleted so that we don't try to return it, and
		* so that we update the cursor correctly on the next call
		* to next.
		*/</comment>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<comment type="block">/*
		* Update cursors that are on the page where the delete happend.
		*/</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHash</name>::<name>ham_c_update</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/*
		* If we are locking, we will not maintain this, because it is
		* a hot spot.
		*
		* XXX
		* Perhaps we can retain incremental numbers and apply them later.
		*/</comment>
		<if>if <condition>(<expr>!<call><name>STD_LOCKING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>--<name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>nelem</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_dirty_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>

		<comment type="block">/*
		* If we need to reclaim the page, then check if the page is empty.
		* There are two cases.  If it's empty and it's not the first page
		* in the bucket (i.e., the bucket page) then we can simply remove
		* it. If it is the first chain in the bucket, then we need to copy
		* the second page into it and remove the second page.
		* If its the only page in the bucket we leave it alone.
		*/</comment>
		<if>if <condition>(<expr>!<name>reclaim_page</name> ||
			<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> != 0 ||
			(<call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name> &amp;&amp; <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name>)</expr>)</condition><then>
			<return>return <expr>(<call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>

		<if>if <condition>(<expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<comment type="block">/*
			* First page in chain is empty and we know that there
			* are more pages in the chain.
			*/</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>n_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

			<if>if <condition>(<expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call> != <name>PGNO_INVALID</name> &amp;&amp; (<name>ret</name> =
				<call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>nn_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>key_dbt</name>.<name>data</name> = <name>n_pagep</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>key_dbt</name>.<name>size</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_copypage_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
					<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>nn_pagep</name> == <name>NULL</name> ? <name>NULL</name> : &amp;<call><name>LSN</name><argument_list>(<argument><expr><name>nn_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr>&amp;<name>key_dbt</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
			}</block></then> <else>else
				<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

			<comment type="block">/* Move lsn onto page. */</comment>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call> != <name>PGNO_INVALID</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>nn_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr><name>nn_pagep</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>nn_pagep</name></expr></argument>)</argument_list></call> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> =
					<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>nn_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>nn_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
						<goto>goto <name>err</name>;</goto>
				}</block></then></if>
			}</block></then></if>

			<expr_stmt><expr><name>tmp_pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp_lsn</name> = <call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>tmp_pgno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>tmp_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>PGNO_INVALID</name></expr>;</expr_stmt>

			<comment type="block">/*
			* Update cursors to reflect the fact that records
			* on the second page have moved to the first page.
			*/</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_c_delpg</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DB_HAM_DELFIRSTPG</name></expr></argument>, <argument><expr>&amp;<name>order</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<comment type="block">/*
			* Update the cursor to reflect its new position.
			*/</comment>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_free</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>n_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			}</block></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>p_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<if>if <condition>(<expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> =
					<call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>n_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
				<expr_stmt><expr><name>n_lsn</name> = &amp;<call><name>LSN</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>n_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>n_lsn</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></else></if>

			<expr_stmt><expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>n_pagep</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_newpage_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>,
					<argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DELOVFL</name></expr></argument>, <argument><expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n_lsn</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
			}</block></then> <else>else
				<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

			<comment type="block">/* Move lsn onto page. */</comment>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>
			<if>if <condition>(<expr><name>n_pagep</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>n_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>

			<if>if <condition>(<expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
				<comment type="block">/*
				* There is no next page; put the cursor on the
				* previous page as if we'd deleted the last item
				* on that page, with index after the last valid
				* entry.
			 *
			 * The deleted flag was set up above.
			 */</comment>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>op</name> = <name>DB_HAM_DELLASTPG</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<comment type="block">/*
				* There is a next page, so put the cursor at
				* the beginning of it.
			 */</comment>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>op</name> = <name>DB_HAM_DELMIDPG</name></expr>;</expr_stmt>
			}</block></else></if>

			<comment type="block">/*
			* Since we are about to delete the cursor page and we have
			* just moved the cursor, we need to make sure that the
			* old page pointer isn't left hanging around in the cursor.
			*/</comment>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chg_pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_free</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>t_ret</name> =
				<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>p_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>n_pagep</name> != <name>NULL</name> &amp;&amp; (<name>t_ret</name> =
				<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>n_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_c_delpg</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
				<argument><expr><name>chg_pgno</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>&amp;<name>order</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt>
		}</block></else></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>

<label><name>err</name>:</label>	<comment type="block">/* Clean up any pages. */</comment>
		<if>if <condition>(<expr><name>n_pagep</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>n_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>nn_pagep</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>nn_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>p_pagep</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>p_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_replpair --
	*	Given the key data indicated by the cursor, replace part/all of it
	*	according to the fields in the dbt.
	*
	* PUBLIC: int __ham_replpair __P((DBC *, DBT *, u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_replpair</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>make_dup</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>old_dbt</name>, <name>tdata</name>, <name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type>	<name>new_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>change</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>dup_flag</name>, <name>len</name>, <name>memsize</name>, <name>newlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>beyond_eor</name>, <name>is_big</name>, <name>is_plus</name>, <name>ret</name>, <name>type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>beg</name>, *<name>dest</name>, *<name>end</name>, *<name>hk</name>, *<name>src</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>memp</name></decl>;</decl_stmt>

		<comment type="block">/*
		* Items that were already offpage (ISBIG) were handled before
		* we get in here.  So, we need only handle cases where the old
		* key is on a regular page.  That leaves us 6 cases:
		* 1. Original data onpage; new data is smaller
		* 2. Original data onpage; new data is the same size
		* 3. Original data onpage; new data is bigger, but not ISBIG,
		*    fits on page
		* 4. Original data onpage; new data is bigger, but not ISBIG,
		*    does not fit on page
		* 5. Original data onpage; New data is an off-page item.
		* 6. Original data was offpage; new item is smaller.
		*
		* Cases 1-3 are essentially the same (and should be the common case).
		* We handle 4-6 as delete and add.
		*/</comment>
		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<comment type="block">/*
		* We need to compute the number of bytes that we are adding or
		* removing from the entry.  Normally, we can simply substract
		* the number of bytes we are replacing (dbt-&gt;dlen) from the
		* number of bytes we are inserting (dbt-&gt;size).  However, if
		* we are doing a partial put off the end of a record, then this
		* formula doesn't work, because we are essentially adding
		* new bytes.
		*/</comment>
		<if>if <condition>(<expr><name>dbt</name>-&gt;<name>size</name> &gt; <name>dbt</name>-&gt;<name>dlen</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>change</name> = <name>dbt</name>-&gt;<name>size</name> - <name>dbt</name>-&gt;<name>dlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_plus</name> = 1</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>change</name> = <name>dbt</name>-&gt;<name>dlen</name> - <name>dbt</name>-&gt;<name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_plus</name> = 0</expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_big</name> = <call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_big</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>len</name> = <call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
			<argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<expr_stmt><expr><name>beyond_eor</name> = <name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name> &gt; <name>len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>beyond_eor</name></expr>)</condition><then> <block>{
			<comment type="block">/*
			* The change is beyond the end of record.  If change
			* is a positive number, we can simply add the extension
			* to it.  However, if change is negative, then we need
			* to figure out if the extension is larger than the
			* negative change.
			*/</comment>
			<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
				<expr_stmt><expr><name>change</name> += <name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name> - <name>len</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr><name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name> - <name>len</name> &gt; <name>change</name></expr>)</condition><then> <block>{
				<comment type="block">/* Extension bigger than change */</comment>
				<expr_stmt><expr><name>is_plus</name> = 1</expr>;</expr_stmt>
				<expr_stmt><expr><name>change</name> = (<name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name> - <name>len</name>) - <name>change</name></expr>;</expr_stmt>
			}</block></then> <else>else <comment type="block">/* Extension is smaller than change. */</comment>
				<expr_stmt><expr><name>change</name> -= (<name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name> - <name>len</name>)</expr>;</expr_stmt></else></if></else></if>
		}</block></then></if>

		<expr_stmt><expr><name>newlen</name> = (<name>is_plus</name> ? <name>len</name> + <name>change</name> : <name>len</name> - <name>change</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call> ||
			(<name>is_plus</name> &amp;&amp; <name>change</name> &gt; <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>) ||
			<name>beyond_eor</name> || <name>is_big</name></expr>)</condition><then> <block>{
				<comment type="block">/* 
				* If we are in cases 4 or 5 then is_plus will be true.
				* If we don't have a transaction then we cannot roll back,
				* make sure there is enough room for the new page.
				*/</comment>
				<if>if <condition>(<expr><name>is_plus</name> &amp;&amp; <name>dbc</name>-&gt;<name>txn</name> == <name>NULL</name> &amp;&amp;
					<name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>maxpgno</name> != 0 &amp;&amp;
					<name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>maxpgno</name> == <name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>last_pgno</name></expr>)</condition><then>
					<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_space_err</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>
				<comment type="block">/*
				* Cases 4-6 -- two subcases.
				* A. This is not really a partial operation, but an overwrite.
				*    Simple del and add works.
				* B. This is a partial and we need to construct the data that
				*    we are really inserting (yuck).
				* In both cases, we need to grab the key off the page (in
				* some cases we could do this outside of this routine; for
				* cleanliness we do it here.  If you happen to be on a big
				* key, this could be a performance hit).
				*/</comment>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> =
					<call><name><name>CDbRet</name>::<name>db_ret</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rkey</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rkey</name>.<name>ulen</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<comment type="block">/* Preserve duplicate info. */</comment>
				<expr_stmt><expr><name>dup_flag</name> = <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>dbt</name>-&gt;<name>doff</name> == 0 &amp;&amp; <name>dbt</name>-&gt;<name>dlen</name> == <name>len</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>ret</name> = <call><name>ham_del_pair</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
						<expr_stmt><expr><name>ret</name> = <call><name>ham_add_el</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
						<argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr><name>dbt</name></expr></argument>, <argument><expr><name>dup_flag</name> ? <name>H_DUPLICATE</name> : <name>H_KEYDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></then> <else>else <block>{					<comment type="block">/* Case B */</comment>
					<expr_stmt><expr><name>type</name> = <call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> != <name>H_OFFPAGE</name> ?
						<call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> : <name>H_KEYDATA</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>tdata</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>memp</name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>memsize</name> = 0</expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbRet</name>::<name>db_ret</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>tdata</name></expr></argument>, <argument><expr>&amp;<name>memp</name></expr></argument>, <argument><expr>&amp;<name>memsize</name></expr></argument>)</argument_list></call>)
						!= 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>

					<comment type="block">/* Now we can delete the item. */</comment>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_del_pair</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
						<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>memp</name></type></decl></param>)</parameter_list>;</constructor_decl>
						<goto>goto <name>err</name>;</goto>
					}</block></then></if>

					<comment type="block">/* Now shift old data around to make room for new. */</comment>
					<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then> <block>{
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_realloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
							<argument><expr><name>tdata</name>.<name>size</name> + <name>change</name></expr></argument>, <argument><expr>&amp;<name>tdata</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
							<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
						<expr_stmt><expr><name>memp</name> = <name>tdata</name>.<name>data</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>memsize</name> = <name>tdata</name>.<name>size</name> + <name>change</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>tdata</name>.<name>data</name> + <name>tdata</name>.<name>size</name></expr></argument>,
							<argument><expr>0</expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then></if>
					<expr_stmt><expr><name>end</name> = (<name>u_int8_t</name> *)<name>tdata</name>.<name>data</name> + <name>tdata</name>.<name>size</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>src</name> = (<name>u_int8_t</name> *)<name>tdata</name>.<name>data</name> + <name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>src</name> &lt; <name>end</name> &amp;&amp; <name>tdata</name>.<name>size</name> &gt; <name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>len</name> = <name>tdata</name>.<name>size</name> - (<name>dbt</name>-&gt;<name>doff</name> + <name>dbt</name>-&gt;<name>dlen</name>)</expr>;</expr_stmt>
						<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
							<expr_stmt><expr><name>dest</name> = <name>src</name> + <name>change</name></expr>;</expr_stmt></then>
						<else>else
							<expr_stmt><expr><name>dest</name> = <name>src</name> - <name>change</name></expr>;</expr_stmt></else></if>
						<constructor_decl><name>memmove</name><parameter_list>(<param><decl><type><name>dest</name></type></decl></param>, <param><decl><type><name>src</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>;</constructor_decl>
					}</block></then></if>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>tdata</name>.<name>data</name> + <name>dbt</name>-&gt;<name>doff</name></expr></argument>,
						<argument><expr><name>dbt</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
						<expr_stmt><expr><name>tdata</name>.<name>size</name> += <name>change</name></expr>;</expr_stmt></then>
					<else>else
						<expr_stmt><expr><name>tdata</name>.<name>size</name> -= <name>change</name></expr>;</expr_stmt></else></if>

					<comment type="block">/* Now add the pair. */</comment>
					<expr_stmt><expr><name>ret</name> = <call><name>ham_add_el</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr>&amp;<name>tdata</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>memp</name></type></decl></param>)</parameter_list>;</constructor_decl>
				}</block></else></if>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>dup_flag</name></type></decl></param>)</parameter_list>;</constructor_decl>
<label><name>err</name>:</label>		<return>return <expr>(<name>ret</name>)</expr>;</return>
		}</block></then></if>

		<comment type="block">/*
		* Set up pointer into existing data. Do it before the log
		* message so we can use it inside of the log setup.
		*/</comment>
		<expr_stmt><expr><name>beg</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>beg</name> += <name>dbt</name>-&gt;<name>doff</name></expr>;</expr_stmt>

		<comment type="block">/*
		* If we are going to have to move bytes at all, figure out
		* all the parameters here.  Then log the call before moving
		* anything around.
		*/</comment>
		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>old_dbt</name>.<name>data</name> = <name>beg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_dbt</name>.<name>size</name> = <name>dbt</name>-&gt;<name>dlen</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_replace_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>(<name>u_int32_t</name>)<call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>(<name>int32_t</name>)<name>dbt</name>-&gt;<name>doff</name></expr></argument>, <argument><expr>&amp;<name>old_dbt</name></expr></argument>, <argument><expr><name>dbt</name></expr></argument>, <argument><expr><name>make_dup</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>

		<expr_stmt><expr><call><name>ham_onpage_replace</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>u_int32_t</name>)<call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr>(<name>int32_t</name>)<name>dbt</name>-&gt;<name>doff</name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><name>is_plus</name></expr></argument>, <argument><expr><name>dbt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Replace data on a page with new data, possibly growing or shrinking what's
	* there.  This is called on two different occasions. On one (from replpair)
	* we are interested in changing only the data.  On the other (from recovery)
	* we are replacing the entire data (header and all) with a new element.  In
	* the latter case, the off argument is negative.
	* pagep: the page that we're changing
	* ndx: page index of the element that is growing/shrinking.
	* off: Offset at which we are beginning the replacement.
	* change: the number of bytes (+ or -) that the element is growing/shrinking.
	* dbt: the new data that gets written at beg.
	*
	* PUBLIC: void __ham_onpage_replace __P((DB *, PAGE *, u_int32_t,
	* PUBLIC:     int32_t, u_int32_t,  int, DBT *));
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_onpage_replace</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>pagep</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>off</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>change</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_plus</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name>, *<name>inp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32_t</name></type> <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>pgsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>src</name>, *<name>dest</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>zero_me</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pgsize</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>change</name> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero_me</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>src</name> = (<name>u_int8_t</name> *)(<name>pagep</name>) + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>off</name> &lt; 0</expr>)</condition><then>
				<expr_stmt><expr><name>len</name> = <name><name>inp</name><index>[<expr><name>ndx</name></expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>(<name>u_int32_t</name>)<name>off</name> &gt;=
				<call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>pgsize</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>len</name> = (<name>int32_t</name>)(<call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
						+ <call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>pgsize</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call> - <name>src</name>)</expr>;</expr_stmt>
					<expr_stmt><expr><name>zero_me</name> = 1</expr>;</expr_stmt>
			}</block></then> <else>else
				<expr_stmt><expr><name>len</name> = (<name>int32_t</name>)(
				(<call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>off</name>) -
				<name>src</name>)</expr>;</expr_stmt></else></if></else></if>
			<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
				<expr_stmt><expr><name>dest</name> = <name>src</name> - <name>change</name></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>dest</name> = <name>src</name> + <name>change</name></expr>;</expr_stmt></else></if>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr>(<name>size_t</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>zero_me</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dest</name> + <name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

			<comment type="block">/* Now update the indices. */</comment>
			<for>for (<init><expr><name>i</name> = <name>ndx</name></expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
					<expr_stmt><expr><name><name>inp</name><index>[<expr><name>i</name></expr>]</index></name> -= <name>change</name></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name><name>inp</name><index>[<expr><name>i</name></expr>]</index></name> += <name>change</name></expr>;</expr_stmt></else></if>
			}</block></for>
			<if>if <condition>(<expr><name>is_plus</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> -= <name>change</name></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> += <name>change</name></expr>;</expr_stmt></else></if>
		}</block></then></if>
		<if>if <condition>(<expr><name>off</name> &gt;= 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>off</name></expr></argument>,
			<argument><expr><name>dbt</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>dbt</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_split_page __P((DBC *, u_int32_t, u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_split_page</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>obucket</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>nbucket</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> **</type><name>carray</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>key</name>, <name>page_dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LOCK</name></type> <name>block</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>new_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name>, *<name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> **</type><name>pp</name>, *<name>old_pagep</name>, *<name>temp_pagep</name>, *<name>new_pagep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>bucket_pgno</name>, <name>npgno</name>, <name>next_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>big_len</name>, <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>found</name>, <name>i</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>big_buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carray</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>temp_pagep</name> = <name>old_pagep</name> = <name>new_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
		<constructor_decl><name>LOCK_INIT</name><parameter_list>(<param><decl><type><name>block</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>bucket_pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>obucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_lget</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr>0</expr></argument>, <argument><expr><name>bucket_pgno</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>block</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
			<argument><expr>&amp;<name>bucket_pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>old_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<comment type="block">/* Properly initialize the new bucket page. */</comment>
		<expr_stmt><expr><name>npgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>npgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>new_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<expr_stmt><expr><call><name>P_INIT</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>,
			<argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>npgno</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>P_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>temp_pagep</name> = <name>hcp</name>-&gt;<name>split_buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><name>old_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>page_dbt</name>.<name>size</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>page_dbt</name>.<name>data</name> = <name>old_pagep</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_splitdata_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SPLITOLD</name></expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>page_dbt</name></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>

		<expr_stmt><expr><call><name>P_INIT</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>,
			<argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>P_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>big_len</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>big_buf</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>key</name>.<name>flags</name> = 0</expr>;</expr_stmt>
		<while>while <condition>(<expr><name>temp_pagep</name> != <name>NULL</name></expr>)</condition> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHash</name>::<name>ham_get_clist</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NDX_INVALID</name></expr></argument>, <argument><expr>&amp;<name>carray</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; (<name>db_indx_t</name>)<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name> += 2</expr></incr>) <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbRet</name>::<name>db_ret</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>,
					<argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>big_buf</name></expr></argument>, <argument><expr>&amp;<name>big_len</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>

				<if>if <condition>(<expr><call><name><name>CHash</name>::<name>ham_call_hash</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>key</name>.<name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name>.<name>size</name></expr></argument>)</argument_list></call> == <name>obucket</name></expr>)</condition><then>
					<expr_stmt><expr><name>pp</name> = &amp;<name>old_pagep</name></expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name>pp</name> = &amp;<name>new_pagep</name></expr>;</expr_stmt></else></if>

				<comment type="block">/*
				* Figure out how many bytes we need on the new
				* page to store the key/data pair.
			 */</comment>
				<expr_stmt><expr><name>len</name> = <call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
					<argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
					<argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
					2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr><call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr>*<name>pp</name></expr></argument>)</argument_list></call> &lt; <name>len</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>page_dbt</name>.<name>size</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>page_dbt</name>.<name>data</name> = *<name>pp</name></expr>;</expr_stmt>
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_splitdata_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
							<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
							<argument><expr><name>SPLITNEW</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>page_dbt</name></expr></argument>,
							<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
							<goto>goto <name>err</name>;</goto></then></if>
					}</block></then> <else>else
						<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>
					<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> =
						<call><name>ham_add_ovflpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>*<name>pp</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>
				}</block></then></if>

				<comment type="block">/* Check if we need to update a cursor. */</comment>
				<if>if <condition>(<expr><name>carray</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>found</name> = 0</expr>;</expr_stmt>
					<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>carray</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
						<expr_stmt><expr><name>cp</name> =
							(<name>HASH_CURSOR</name> *)<name><name>carray</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>internal</name></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>cp</name>-&gt;<name>pgno</name> == <call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call> &amp;&amp;
							<name>cp</name>-&gt;<name>indx</name> == <name>n</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>cp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>cp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt>
						}</block></then></if>
					}</block></for>
					<if>if <condition>(<expr><name>found</name> &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call> &amp;&amp;
						<call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<if>if <condition>(<expr>(<name>ret</name> =
								<call><name><name>CHashAuto</name>::<name>ham_chgpg_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
								<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
								<argument><expr><name>DB_HAM_SPLIT</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<goto>goto <name>err</name>;</goto></then></if>
					}</block></then></if>
				}</block></then></if>
				<expr_stmt><expr><call><name>ham_copy_item</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ham_copy_item</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Clear temp_page; if it's a link overflow page, free it. */</comment>
			<if>if <condition>(<expr><call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call> != <name>bucket_pgno</name> &amp;&amp; (<name>ret</name> =
				<call><name><name>CDbMeta</name>::<name>db_free</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>temp_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
			}</block></then></if>

			<if>if <condition>(<expr><name>next_pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
				<expr_stmt><expr><name>temp_pagep</name> = <name>NULL</name></expr>;</expr_stmt></then>
			<else>else <if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(
				<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>next_pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>temp_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if></else></if>

			<if>if <condition>(<expr><name>temp_pagep</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>page_dbt</name>.<name>size</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>page_dbt</name>.<name>data</name> = <name>temp_pagep</name></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_splitdata_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
						<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
						<argument><expr><name>SPLITOLD</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr>&amp;<name>page_dbt</name></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>
				}</block></then> <else>else
					<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>
				<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>
			}</block></then></if>

			<if>if <condition>(<expr><name>carray</name> != <name>NULL</name></expr>)</condition><then>	<comment type="block">/* We never knew its size. */</comment>
				<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>carray</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>
			<expr_stmt><expr><name>carray</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></while>
		<if>if <condition>(<expr><name>big_buf</name> != <name>NULL</name></expr>)</condition><then>
			<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>big_buf</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>

		<comment type="block">/*
		* If the original bucket spanned multiple pages, then we've got
		* a pointer to a page that used to be on the bucket chain.  It
		* should be deleted.
		*/</comment>
		<if>if <condition>(<expr><name>temp_pagep</name> != <name>NULL</name> &amp;&amp; <call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call> != <name>bucket_pgno</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_free</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>temp_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
		}</block></then></if>

		<comment type="block">/*
		* Write new buckets out.
		*/</comment>
		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>page_dbt</name>.<name>size</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>page_dbt</name>.<name>data</name> = <name>old_pagep</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_splitdata_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>,
				<argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SPLITNEW</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>page_dbt</name></expr></argument>,
				<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page_dbt</name>.<name>data</name> = <name>new_pagep</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_splitdata_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
				<argument><expr><name>SPLITNEW</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>page_dbt</name></expr></argument>,
				<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr><call><name>LSN</name><argument_list>(<argument><expr><name>old_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr><call><name>LSN</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>old_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>t_ret</name> =
			<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>new_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>0</expr>)</condition><then> <block>{
<label><name>err</name>:</label>		<if>if <condition>(<expr><name>old_pagep</name> != <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>old_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>new_pagep</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>P_INIT</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
					<argument><expr><name>npgno</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>P_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>new_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<if>if <condition>(<expr><name>temp_pagep</name> != <name>NULL</name> &amp;&amp; <call><name>PGNO</name><argument_list>(<argument><expr><name>temp_pagep</name></expr></argument>)</argument_list></call> != <name>bucket_pgno</name></expr>)</condition><then>
				<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>temp_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name>__TLPUT</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>carray</name> != <name>NULL</name></expr>)</condition><then>		<comment type="block">/* We never knew its size. */</comment>
			<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>carray</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Add the given pair to the page.  The page in question may already be
	* held (i.e. it was already gotten).  If it is, then the page is passed
	* in via the pagep parameter.  On return, pagep will contain the page
	* to which we just added something.  This allows us to link overflow
	* pages and return the new page having correctly put the last page.
	*
	* PUBLIC: int __ham_add_el __P((DBC *, const DBT *, const DBT *, int));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_add_el</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>const</name> <name>DBT</name> *</type><name>pkey</name>, *<name>pdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>key_dbt</name>, <name>data_dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>new_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HOFFPAGE</name></type> <name>doff</name>, <name>koff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name>, <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>data_size</name>, <name>key_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>pages</name>, <name>pagespace</name>, <name>pairsize</name>, <name>rectype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>do_expand</name>, <name>is_keybig</name>, <name>is_databig</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>key_type</name>, <name>data_type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>do_expand</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>pgno</name> = <name>hcp</name>-&gt;<name>seek_found_page</name> != <name>PGNO_INVALID</name> ?
			<name>hcp</name>-&gt;<name>seek_found_page</name> : <name>hcp</name>-&gt;<name>pgno</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> == <name>NULL</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>key_size</name> = <call><name>HKEYDATA_PSIZE</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_size</name> = <call><name>HKEYDATA_PSIZE</name><argument_list>(<argument><expr><name>val</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_keybig</name> = <call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_databig</name> = <call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>val</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>is_keybig</name></expr>)</condition><then>
			<expr_stmt><expr><name>key_size</name> = <name>HOFFPAGE_PSIZE</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>is_databig</name></expr>)</condition><then>
			<expr_stmt><expr><name>data_size</name> = <name>HOFFPAGE_PSIZE</name></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>pairsize</name> = <name>key_size</name> + <name>data_size</name></expr>;</expr_stmt>

		<comment type="block">/* Advance to first page in chain with room for item. */</comment>
		<while>while <condition>(<expr><call><name>H_NUMPAIRS</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> != <name>PGNO_INVALID</name></expr>)</condition> <block>{
			<comment type="block">/*
			* This may not be the end of the chain, but the pair may fit
			* anyway.  Check if it's a bigpair that fits or a regular
			* pair that fits.
			*/</comment>
			<if>if <condition>(<expr><call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> &gt;= <name>pairsize</name></expr>)</condition><then>
				<break>break;</break></then></if>
			<expr_stmt><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_next_cpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>next_pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></while>

		<comment type="block">/*
		* Check if we need to allocate a new page.
		*/</comment>
		<if>if <condition>(<expr><call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> &lt; <name>pairsize</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>do_expand</name> = 1</expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_add_ovflpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
				<argument><expr>(<name>PAGE</name> *)<name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>PAGE</name> **)&amp;<name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/*
		* If we don't have a transaction then make sure we will not
		* run out of file space before updating the key or data.
		*/</comment>
		<if>if <condition>(<expr><name>dbc</name>-&gt;<name>txn</name> == <name>NULL</name> &amp;&amp;
			<name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>maxpgno</name> != 0 &amp;&amp; (<name>is_keybig</name> || <name>is_databig</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>pagespace</name> = <call><name>P_MAXSPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pages</name> = 0</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>is_databig</name></expr>)</condition><then> 
					<expr_stmt><expr><name>pages</name> = ((<name>data_size</name> - 1) / <name>pagespace</name>) + 1</expr>;</expr_stmt></then></if>
				<if>if <condition>(<expr><name>is_keybig</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>pages</name> += ((<name>key</name>-&gt;<name>size</name> - 1) / <name>pagespace</name>) + 1</expr>;</expr_stmt>
					<if>if <condition>(<expr><name>pages</name> &gt;
						(<name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>maxpgno</name> - <name>dbp</name>-&gt;<name>mpf</name>-&gt;<name>mfp</name>-&gt;<name>last_pgno</name>)</expr>)</condition><then>
						<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_space_err</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>
				}</block></then></if>
		}</block></then></if>

		<comment type="block">/*
		* Update cursor.
		*/</comment>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<if>if <condition>(<expr><name>is_keybig</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>koff</name>.<name>type</name> = <name>H_OFFPAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>koff</name>.<name><name>unused</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>koff</name>.<name><name>unused</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>koff</name>.<name><name>unused</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_poff</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>koff</name>.<name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<expr_stmt><expr><name>koff</name>.<name>tlen</name> = <name>key</name>-&gt;<name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_dbt</name>.<name>data</name> = &amp;<name>koff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_dbt</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>koff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pkey</name> = &amp;<name>key_dbt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_type</name> = <name>H_OFFPAGE</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>pkey</name> = <name>key</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>key_type</name> = <name>H_KEYDATA</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>is_databig</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>doff</name>.<name>type</name> = <name>H_OFFPAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>doff</name>.<name><name>unused</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>doff</name>.<name><name>unused</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>doff</name>.<name><name>unused</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_poff</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>&amp;<name>doff</name>.<name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<expr_stmt><expr><name>doff</name>.<name>tlen</name> = <name>val</name>-&gt;<name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_dbt</name>.<name>data</name> = &amp;<name>doff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_dbt</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>doff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pdata</name> = &amp;<name>data_dbt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_type</name> = <name>H_OFFPAGE</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>pdata</name> = <name>val</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_type</name> = <name>type</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>rectype</name> = <name>PUTPAIR</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>is_databig</name></expr>)</condition><then>
				<expr_stmt><expr><name>rectype</name> |= <name>PAIR_DATAMASK</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>is_keybig</name></expr>)</condition><then>
				<expr_stmt><expr><name>rectype</name> |= <name>PAIR_KEYMASK</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>type</name> == <name>H_DUPLICATE</name></expr>)</condition><then>
				<expr_stmt><expr><name>rectype</name> |= <name>PAIR_DUPMASK</name></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_insdel_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
				<argument><expr><name>rectype</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>u_int32_t</name>)<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>pdata</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<comment type="block">/* Move lsn onto page. */</comment>
		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>

		<expr_stmt><expr><call><name>ham_putitem</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>key_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ham_putitem</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pdata</name></expr></argument>, <argument><expr><name>data_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* For splits, we are going to update item_info's page number
		* field, so that we can easily return to the same page the
		* next time we come in here.  For other operations, this shouldn't
		* matter, since odds are this is the last thing that happens before
		* we return to the user program.
		*/</comment>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* XXX
		* Maybe keep incremental numbers here.
		*/</comment>
		<if>if <condition>(<expr>!<call><name>STD_LOCKING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>nelem</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_dirty_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>

		<if>if <condition>(<expr><name>do_expand</name> || (<name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>ffactor</name> != 0 &amp;&amp;
			(<name>u_int32_t</name>)<call><name>H_NUMPAIRS</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> &gt; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>ffactor</name>)</expr>)</condition><then>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_EXPAND</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Special __putitem call used in splitting -- copies one entry to
	* another.  Works for all types of hash entries (H_OFFPAGE, H_KEYDATA,
	* H_DUPLICATE, H_OFFDUP).  Since we log splits at a high level, we
	* do not need to do any logging here.
	*
	* PUBLIC: void __ham_copy_item __P((DB *, PAGE *, u_int32_t, PAGE *));
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_copy_item</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>src_page</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>src_ndx</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>dest_page</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>pgsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>src</name>, *<name>dest</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name> *</type><name>inp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pgsize</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dest_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		* Copy the key and data entries onto this new page.
		*/</comment>
		<expr_stmt><expr><name>src</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>src_page</name></expr></argument>, <argument><expr><name>src_ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up space on dest. */</comment>
		<expr_stmt><expr><name>len</name> = (<name>u_int32_t</name>)<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>src_page</name></expr></argument>, <argument><expr><name>pgsize</name></expr></argument>, <argument><expr><name>src_ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>dest_page</name></expr></argument>)</argument_list></call> -= <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inp</name><index>[<expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>dest_page</name></expr></argument>)</argument_list></call></expr>]</index></name> = <call><name>HOFFSET</name><argument_list>(<argument><expr><name>dest_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dest</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dest_page</name></expr></argument>, <argument><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>dest_page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>dest_page</name></expr></argument>)</argument_list></call>++</expr>;</expr_stmt>

		<constructor_decl><name>memcpy</name><parameter_list>(<param><decl><type><name>dest</name></type></decl></param>, <param><decl><type><name>src</name></type></decl></param>, <param><decl><type><name>len</name></type></decl></param>)</parameter_list>;</constructor_decl>
	}</block></function>

	<comment type="block">/*
	*
	* Returns:
	*	0 on success -- pp points to new page.
	*	errno on error -- pp not valid.
	*
	* PUBLIC: int __ham_add_ovflpage __P((DBC *, PAGE *, int, PAGE **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_add_ovflpage</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>pagep</name></decl></param>, <param><decl><type><name>int</name></type> <name>release</name></decl></param>, <param><decl><type><name>PAGE</name> **</type><name>pp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>new_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>new_pagep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_new</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>P_HASH</name></expr></argument>, <argument><expr>&amp;<name>new_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_newpage_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>,
				<argument><expr><name>PUTOVFL</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<comment type="block">/* Move lsn onto page. */</comment>
		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> = <call><name>LSN</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> = <call><name>PGNO</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PREV_PGNO</name><argument_list>(<argument><expr><name>new_pagep</name></expr></argument>)</argument_list></call> = <call><name>PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>release</name></expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr>*<name>pp</name> = <name>new_pagep</name></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_get_cpage __P((DBC *, db_lockmode_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_get_cpage</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LOCK</name></type> <name>tmp_lock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		* There are four cases with respect to buckets and locks.
		* 1. If there is no lock held, then if we are locking, we should
		*    get the lock.
		* 2. If there is a lock held, it's for the current bucket, and it's
		*    for the right mode, we don't need to do anything.
		* 3. If there is a lock held for the current bucket but it's not
		*    strong enough, we need to upgrade.
		* 4. If there is a lock, but it's for a different bucket, then we need
		*    to release the existing lock and get a new lock.
		*/</comment>
		<constructor_decl><name>LOCK_INIT</name><parameter_list>(<param><decl><type><name>tmp_lock</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<if>if <condition>(<expr><call><name>STD_LOCKING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>lbucket</name> != <name>hcp</name>-&gt;<name>bucket</name></expr>)</condition><then> <block>{	<comment type="block">/* Case 4 */</comment>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name>__TLPUT</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<expr_stmt><expr><call><name>LOCK_INIT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/*
			* See if we have the right lock.  If we are doing
			* dirty reads we assume the write lock has been downgraded.
			*/</comment>
			<if>if <condition>(<expr>(<call><name>LOCK_ISSET</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call> &amp;&amp;
				((<name>hcp</name>-&gt;<name>lock_mode</name> == <name>DB_LOCK_READ</name> ||
				<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_READ_UNCOMMITTED</name></expr></argument>)</argument_list></call>) &amp;&amp;
				<name>mode</name> == <name>DB_LOCK_WRITE</name>))</expr>)</condition><then> <block>{
					<comment type="block">/* Case 3. */</comment>
					<expr_stmt><expr><name>tmp_lock</name> = <name>hcp</name>-&gt;<name>lock</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LOCK_INIT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/* Acquire the lock. */</comment>
			<if>if <condition>(<expr>!<call><name>LOCK_ISSET</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<comment type="block">/* Cases 1, 3, and 4. */</comment>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_lock_bucket</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if></then></if>

			<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>hcp</name>-&gt;<name>lock_mode</name> = <name>mode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>lbucket</name> = <name>hcp</name>-&gt;<name>bucket</name></expr>;</expr_stmt>
				<comment type="block">/* Case 3: release the original lock. */</comment>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name>__ENV_LPUT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>tmp_lock</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			}</block></then> <else>else <if>if <condition>(<expr><call><name>LOCK_ISSET</name><argument_list>(<argument><expr><name>tmp_lock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>lock</name> = <name>tmp_lock</name></expr>;</expr_stmt></then></if></else></if>
		}</block></then></if>

		<if>if <condition>(<expr><name>ret</name> == 0 &amp;&amp; <name>hcp</name>-&gt;<name>page</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
				<argument><expr>&amp;<name>hcp</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Get a new page at the cursor, putting the last page if necessary.
	* If the flag is set to H_ISDUP, then we are talking about the
	* duplicate page, not the main page.
	*
	* PUBLIC: int __ham_next_cpage __P((DBC *, db_pgno_t, int));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_next_cpage</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>int</name></type> <name>dirty</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name> &amp;&amp; (<name>ret</name> =
			<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dirty</name> ? <name>DB_MPOOL_DIRTY</name> : 0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = 0</expr>;</expr_stmt>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_lock_bucket --
	*	Get the lock on a particular bucket.
	*
	* PUBLIC: int __ham_lock_bucket __P((DBC *, db_lockmode_t));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_lock_bucket</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>gotmeta</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gotmeta</name> = <name>hcp</name>-&gt;<name>hdr</name> == <name>NULL</name> ? 1 : 0</expr>;</expr_stmt>
		<if>if <condition>(<expr><name>gotmeta</name></expr>)</condition><then>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if></then></if>
		<expr_stmt><expr><name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>gotmeta</name></expr>)</condition><then>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if></then></if>

		<expr_stmt><expr><name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_lget</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>lock_mode</name> = <name>mode</name></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_dpair --
	*	Delete a pair on a page, paying no attention to what the pair
	*	represents.  The caller is responsible for freeing up duplicates
	*	or offpage entries that might be referenced by this pair.
	*
	*	Recovery assumes that this may be called without the metadata
	*	page pinned.
	*
	* PUBLIC: void __ham_dpair __P((DB *, PAGE *, u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_dpair</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>indx</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>delta</name>, <name>n</name>, *<name>inp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>dest</name>, *<name>src</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		* Compute "delta", the amount we have to shift all of the
		* offsets.  To find the delta, we just need to calculate
		* the size of the pair of elements we are removing.
		*/</comment>
		<expr_stmt><expr><name>delta</name> = <call><name>H_PAIRSIZE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* The hard case: we want to remove something other than
		* the last item on the page.  We need to shift data and
		* offsets down.
		*/</comment>
		<if>if <condition>(<expr>(<name>db_indx_t</name>)<name>indx</name> != <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> - 2</expr>)</condition><then> <block>{
			<comment type="block">/*
			* Move the data: src is the first occupied byte on
			* the page. (Length is delta.)
			*/</comment>
			<expr_stmt><expr><name>src</name> = (<name>u_int8_t</name> *)<name>p</name> + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			* Destination is delta bytes beyond src.  This might
			* be an overlapping copy, so we have to use memmove.
			*/</comment>
			<expr_stmt><expr><name>dest</name> = <name>src</name> + <name>delta</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>inp</name><index>[<expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Adjust page metadata. */</comment>
		<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <call><name>HOFFSET</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> + <name>delta</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> - 2</expr>;</expr_stmt>

		<comment type="block">/* Adjust the offsets. */</comment>
		<for>for (<init><expr><name>n</name> = (<name>db_indx_t</name>)<name>indx</name></expr>;</init> <condition><expr><name>n</name> &lt; (<name>db_indx_t</name>)(<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
			<expr_stmt><expr><name><name>inp</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>inp</name><index>[<expr><name>n</name> + 2</expr>]</index></name> + <name>delta</name></expr>;</expr_stmt></for>

	}</block></function>

	<comment type="block">/*
	* __ham_c_delpg --
	*
	* Adjust the cursors after we've emptied a page in a bucket, taking
	* care that when we move cursors pointing to deleted items, their
	* orders don't collide with the orders of cursors on the page we move
	* them to (since after this function is called, cursors with the same
	* index on the two pages will be otherwise indistinguishable--they'll
	* all have pgno new_pgno).  There are three cases:
	*
	*	1) The emptied page is the first page in the bucket.  In this
	*	case, we've copied all the items from the second page into the
	*	first page, so the first page is new_pgno and the second page is
	*	old_pgno.  new_pgno is empty, but can have deleted cursors
	*	pointing at indx 0, so we need to be careful of the orders
	*	there.  This is DB_HAM_DELFIRSTPG.
	*
	*	2) The page is somewhere in the middle of a bucket.  Our caller
	*	can just delete such a page, so it's old_pgno.  old_pgno is
	*	empty, but may have deleted cursors pointing at indx 0, so we
	*	need to be careful of indx 0 when we move those cursors to
	*	new_pgno.  This is DB_HAM_DELMIDPG.
	*
	*	3) The page is the last in a bucket.  Again the empty page is
	*	old_pgno, and again it should only have cursors that are deleted
	*	and at indx == 0.  This time, though, there's no next page to
	*	move them to, so we set them to indx == num_ent on the previous
	*	page--and indx == num_ent is the index whose cursors we need to
	*	be careful of.  This is DB_HAM_DELLASTPG.
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_delpg</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>old_pgno</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>num_ent</name></decl></param>, <param><decl><type><name>db_ham_mode</name></type> <name>op</name></decl></param>, <param><decl><type><name>u_int32_t</name> *</type><name>orderp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name>, *<name>ldbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXN</name> *</type><name>my_txn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>found</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>indx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>order</name></decl>;</decl_stmt>

		<comment type="block">/* Which is the worrisome index? */</comment>
		<expr_stmt><expr><name>indx</name> = (<name>op</name> == <name>DB_HAM_DELLASTPG</name>) ? <name>num_ent</name> : 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_txn</name> = <call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call> ? <name>dbc</name>-&gt;<name>txn</name> : <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		* Find the highest order of any cursor our movement
		* may collide with.
		*/</comment>
		<expr_stmt><expr><name>order</name> = 1</expr>;</expr_stmt>
		<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
			<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
					<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
						<if>if <condition>(<expr><name>cp</name> == <name>dbc</name> || <name>cp</name>-&gt;<name>dbtype</name> != <name>DB_HASH</name></expr>)</condition><then>
							<continue>continue;</continue></then></if>
						<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>cp</name>-&gt;<name>internal</name></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>hcp</name>-&gt;<name>pgno</name> == <name>new_pgno</name></expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == <name>indx</name> &amp;&amp;
								<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call> &amp;&amp;
								<name>hcp</name>-&gt;<name>order</name> &gt;= <name>order</name></expr>)</condition><then>
								<expr_stmt><expr><name>order</name> = <name>hcp</name>-&gt;<name>order</name> + 1</expr>;</expr_stmt></then></if>
							<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>op</name> != <name>DB_HAM_DELFIRSTPG</name> ||
								<name>hcp</name>-&gt;<name>indx</name> == <name>NDX_INVALID</name> ||
								(<name>hcp</name>-&gt;<name>indx</name> == 0 &amp;&amp;
								<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
						}</block></then></if>
				}</block></for>
				<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>

		<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
			<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
					<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
						<if>if <condition>(<expr><name>cp</name> == <name>dbc</name> || <name>cp</name>-&gt;<name>dbtype</name> != <name>DB_HASH</name></expr>)</condition><then>
							<continue>continue;</continue></then></if>

						<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>cp</name>-&gt;<name>internal</name></expr>;</expr_stmt>

						<if>if <condition>(<expr><name>hcp</name>-&gt;<name>pgno</name> == <name>old_pgno</name></expr>)</condition><then> <block>{
							<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>DB_HAM_DELFIRSTPG</name></expr>:
	<comment type="block">/*
	* We're moving all items,
	* regardless of index.
	*/</comment>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>new_pgno</name></expr>;</expr_stmt>

	<comment type="block">/*
	* But we have to be careful of
	* the order values.
	*/</comment>
	<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == <name>indx</name></expr>)</condition><then>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt></then></if>
	<break>break;</break>
</case><case>case <expr><name>DB_HAM_DELMIDPG</name></expr>:
	<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>new_pgno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name> == 0 &amp;&amp;
		<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt>
	<break>break;</break>
</case><case>case <expr><name>DB_HAM_DELLASTPG</name></expr>:
	<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>new_pgno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name> == 0 &amp;&amp;
		<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>indx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt>
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_panic</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call>)</expr>;</return>
							</default>}</block></switch>
							<if>if <condition>(<expr><name>my_txn</name> != <name>NULL</name> &amp;&amp; <name>cp</name>-&gt;<name>txn</name> != <name>my_txn</name></expr>)</condition><then>
								<expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt></then></if>
						}</block></then></if>
				}</block></for>
				<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>found</name> != 0 &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_chgpg_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>my_txn</name></expr></argument>, <argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>op</name></expr></argument>,
				<argument><expr><name>old_pgno</name></expr></argument>, <argument><expr><name>new_pgno</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr>*<name>orderp</name> = <name>order</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>
</public>
}</block></class>;</unit>