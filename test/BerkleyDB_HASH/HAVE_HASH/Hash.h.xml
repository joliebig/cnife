<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHash</name>
<block>{
<comment>//---refactored functions</comment><public>
public:
<comment type="line">//#ifndef HAVE_HASH</comment>




	<comment type="block">/*
	* __ham_quick_delete --
	*	This function is called by __db_del when the appropriate conditions
	*	are met, and it performs the delete in the optimized way.
	*
	* PUBLIC: int __ham_quick_delete __P((DBC *));
	*/</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_quick_delete</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		* When performing a DB-&gt;del operation not involving secondary indices
		* and not removing an off-page duplicate tree, we can speed things up
		* substantially by removing the entire duplicate set, if any is
		* present, in one operation, rather than by conjuring up and deleting
		* each of the items individually.  (All are stored in one big HKEYDATA
		* structure.)  We don't bother to distinguish on-page duplicate sets
		* from single, non-dup items;  they're deleted in exactly the same way.
		*
		* The cursor should be set to the first item in the duplicate set, or
		* to the sole key/data pair when the key does not have a duplicate set,
		* before the function is called.
		*
		* We do not need to call CDB_LOCKING_INIT, __db_del calls here with
		* a write cursor.
		*
		* Assert we're initialized, but not to an off-page duplicate.
		* Assert we're not using secondary indices.
		*/</comment>
		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call><name>IS_INITIALIZED</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>internal</name>-&gt;<name>opd</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_SECONDARY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><call><name>LIST_FIRST</name><argument_list>(<argument><expr>&amp;<name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>s_secondaries</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_c_writelock</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_del_pair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>


	<comment type="block">/*
	* __ham_c_count --
	*	Return a count of on-page duplicates.
	*
	* PUBLIC: int __ham_c_count __P((DBC *, db_recno_t *));
	*/</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_count</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_recno_t</name> *</type><name>recnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_recno_t</name></type> <name>recno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>p</name>, *<name>pend</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>recno</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_get_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DB_LOCK_READ</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> &gt;= <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr>*<name>recnop</name> = 0</expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		}</block></then></if>

		<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
		<case>case <expr><name>H_KEYDATA</name></expr>:
		</case><case>case <expr><name>H_OFFPAGE</name></expr>:
			<expr_stmt><expr><name>recno</name> = 1</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>H_DUPLICATE</name></expr>:
			<expr_stmt><expr><name>p</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pend</name> = <name>p</name> +
				<call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>pend</name></expr>;</condition> <incr><expr><name>recno</name>++</expr></incr>) <block>{
				<comment type="block">/* p may be odd, so copy rather than just dereffing */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> += 2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call> + <name>len</name></expr>;</expr_stmt>
			}</block></for>

			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</default>}</block></switch>

		<expr_stmt><expr>*<name>recnop</name> = <name>recno</name></expr>;</expr_stmt>

	<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>


	<comment type="block">/*
	* __ham_c_dup --
	*	Duplicate a hash cursor, such that the new one holds appropriate
	*	locks for the position of the original.
	*
	* PUBLIC: int __ham_c_dup __P((DBC *, DBC *));
	*/</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_dup</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>orig_dbc</name></decl></param>, <param><decl><type><name>DBC</name> *</type><name>new_dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>orig</name>, *<name>new__renamed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>orig</name> = (<name>HASH_CURSOR</name> *)<name>orig_dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new__renamed</name> = (<name>HASH_CURSOR</name> *)<name>new_dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new__renamed</name>-&gt;<name>bucket</name> = <name>orig</name>-&gt;<name>bucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new__renamed</name>-&gt;<name>lbucket</name> = <name>orig</name>-&gt;<name>lbucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new__renamed</name>-&gt;<name>dup_off</name> = <name>orig</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new__renamed</name>-&gt;<name>dup_len</name> = <name>orig</name>-&gt;<name>dup_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new__renamed</name>-&gt;<name>dup_tlen</name> = <name>orig</name>-&gt;<name>dup_tlen</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>new__renamed</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>new__renamed</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>

		<comment type="block">/*
		* If the old cursor held a lock and we're not in transactions, get one
		* for the new one.   The reason that we don't need a new lock if we're
		* in a transaction is because we already hold a lock and will continue
		* to do so until commit, so there is no point in re-acquiring it. We
		* don't know if the old lock was a read or write lock, but it doesn't
		* matter. We'll get a read lock.  We know that this locker already
		* holds a lock of the correct type, so if we need a write lock and
		* request it, we know that we'll get it.
		*/</comment>
		<if>if <condition>(<expr><name>orig_dbc</name>-&gt;<name>txn</name> == <name>NULL</name> &amp;&amp; <call><name>LOCK_ISSET</name><argument_list>(<argument><expr><name>orig</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_lock_bucket</name></name><argument_list>(<argument><expr><name>new_dbc</name></expr></argument>, <argument><expr><name>DB_LOCK_READ</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if></then></if>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>


	<comment type="block">/* ****************** CURSORS ********************************** */</comment>
	<comment type="block">/*
	 * __ham_c_init --
	 *	Initialize the hash-specific portion of a cursor.
	 *
	 * PUBLIC: int __ham_c_init __P((DBC *));
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_init</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>new_curs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_calloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr>1</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>struct <name>cursor_t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>new_curs</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr>&amp;<name>new_curs</name>-&gt;<name>split_buf</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
			<constructor_decl><name>COsAlloc::os_free</name><parameter_list>(<param><decl><type><name>dbenv</name></type></decl></param>, <param><decl><type><name>new_curs</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<return>return <expr>(<name>ret</name>)</expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><name>dbc</name>-&gt;<name>internal</name> = (<name>DBC_INTERNAL</name> *) <name>new_curs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<call><name>InitMethods</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_bulk</name> = <name>ham_bulk</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_close</name> = <name>ham_c_close</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_del</name> = <name>ham_c_del</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_destroy</name> = <name>ham_c_destroy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_get</name> = <name>ham_c_get</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_put</name> = <name>ham_c_put</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbc</name>-&gt;<name>c_am_writelock</name> = <name>ham_c_writelock</name></expr>;</expr_stmt>

		<return>return <expr>(<call><name><name>CHashPage</name>::<name>ham_item_init</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>


	<comment type="block">/*
	 * __ham_c_close --
	 *	Close down the cursor from a single use.
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_close</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>root_pgno</name></decl></param>, <param><decl><type><name>int</name> *</type><name>rmroot</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HKEYDATA</name> *</type><name>dp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_lockmode_t</name></type> <name>lock_mode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>doroot</name>, <name>gotmeta</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>dirty</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>COMPQUIET</name><argument_list>(<argument><expr><name>rmroot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>doroot</name> = <name>gotmeta</name> = <name>ret</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *) <name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<comment type="block">/* Check for off page dups. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
	<comment type="line">// hash without btree has no off page dups</comment>
		<if>if <condition>(<expr><name>dbc</name>-&gt;<name>internal</name>-&gt;<name>opd</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>done</name>;</goto></then></if>
			<expr_stmt><expr><name>gotmeta</name> = 1</expr>;</expr_stmt>
			<expr_stmt><expr><name>lock_mode</name> = <name>DB_LOCK_READ</name></expr>;</expr_stmt>

			<comment type="block">/* To support dirty reads we must reget the write lock. */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_READ_UNCOMMITTED</name></expr></argument>)</argument_list></call> &amp;&amp;
				 <call><name>F_ISSET</name><argument_list>(<argument><expr>(<name>CBTreeCursor</name> *)
				 <name>dbc</name>-&gt;<name>internal</name>-&gt;<name>opd</name>-&gt;<name>internal</name></expr></argument>, <argument><expr><name>C_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>lock_mode</name> = <name>DB_LOCK_WRITE</name></expr>;</expr_stmt></then></if>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_get_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_mode</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>out</name>;</goto></then></if>
			<expr_stmt><expr><name>dp</name> = (<name>HKEYDATA</name> *)<call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If it's not a dup we aborted before we changed it. */</comment>
			<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call> == <name>H_OFFDUP</name></expr>)</condition><then>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>root_pgno</name></expr></argument>,
					<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>root_pgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt></else></if>

			<if>if <condition>(<expr>(<name>ret</name> =
				<name>hcp</name>-&gt;<name>opd</name>-&gt;<call><name>c_am_close</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>opd</name></expr></argument>, <argument><expr><name>root_pgno</name></expr></argument>, <argument><expr>&amp;<name>doroot</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>out</name>;</goto></then></if>
			<if>if <condition>(<expr><name>doroot</name> != 0</expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_del_pair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>out</name>;</goto></then></if>
				<expr_stmt><expr><name>dirty</name> = <name>DB_MPOOL_DIRTY</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<label><name>out</name>:</label>	<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name> &amp;&amp; (<name>t_ret</name> =
			<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dirty</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>gotmeta</name> != 0 &amp;&amp; (<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

	<label><name>done</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_init</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * __ham_c_destroy --
	 *	Cleanup the access method private part of a cursor.
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_destroy</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>hcp</name>-&gt;<name>split_buf</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>split_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>hcp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_del</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>repldbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>out</name>;</goto></then></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_get_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>out</name>;</goto></then></if>

		<comment type="block">/* Off-page duplicates. */</comment>
		<if>if <condition>(<expr><call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>H_OFFDUP</name></expr>)</condition><then>
			<goto>goto <name>out</name>;</goto></then></if>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* On-page duplicate. */</comment>
			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>dup_off</name> == 0 &amp;&amp;
				<call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call> == <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>pagesize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_del_pair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <block>{
				<expr_stmt><expr><name>repldbt</name>.<name>flags</name> = 0</expr>;</expr_stmt>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type>&amp;</type><name>repldbt</name></decl></param>, <param><decl><type><name>DB_DBT_PARTIAL</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>repldbt</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>repldbt</name>.<name>dlen</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>repldbt</name>.<name>size</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>repldbt</name>.<name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
					<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_replpair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>repldbt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> -= <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>ret</name> = <call><name>ham_c_update</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
						<argument><expr><call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
			}</block></else></if>

		}</block></then> <else>else <comment type="block">/* Not a duplicate */</comment>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_del_pair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

	<label><name>out</name>:</label>	<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>ret</name> == 0 ? <name>DB_MPOOL_DIRTY</name> : 0</expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_get</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_lockmode_t</name></type> <name>lock_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>get_key</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>

		<comment type="block">/* Clear OR'd in additional bits so we can check for flag equality. */</comment>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DBC_RMW</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>lock_type</name> = <name>DB_LOCK_WRITE</name></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><name>lock_type</name> = <name>DB_LOCK_READ</name></expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>seek_size</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>get_key</name> = 1</expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> <block>{
		<case>case <expr><name>DB_PREV_NODUP</name></expr>:
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NEXT_NODUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<comment type="block">/* FALLTHROUGH */</comment>
		</case><case>case <expr><name>DB_PREV</name></expr>:
			<if>if <condition>(<expr><call><name>IS_INITIALIZED</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_prev</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<comment type="block">/* FALLTHROUGH */</comment>
		</case><case>case <expr><name>DB_LAST</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_last</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>DB_NEXT_NODUP</name></expr>:
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NEXT_NODUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<comment type="block">/* FALLTHROUGH */</comment>
		</case><case>case <expr><name>DB_NEXT</name></expr>:
			<if>if <condition>(<expr><call><name>IS_INITIALIZED</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>
			<comment type="block">/* FALLTHROUGH */</comment>
		</case><case>case <expr><name>DB_FIRST</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_first</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>DB_NEXT_DUP</name></expr>:
			<comment type="block">/* cgetchk has already determined that the cursor is set. */</comment>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DUPONLY</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>DB_SET</name></expr>:
		</case><case>case <expr><name>DB_SET_RANGE</name></expr>:
		</case><case>case <expr><name>DB_GET_BOTH</name></expr>:
		</case><case>case <expr><name>DB_GET_BOTH_RANGE</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name>ham_lookup</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>get_key</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>DB_GET_BOTHC</name></expr>:
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DUPONLY</name></type></decl></param>)</parameter_list>;</constructor_decl>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>get_key</name> = 0</expr>;</expr_stmt>
			<break>break;</break>
		</case><case>case <expr><name>DB_CURRENT</name></expr>:
			<comment type="block">/* cgetchk has already determined that the cursor is set. */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = <name>DB_KEYEMPTY</name></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			}</block></then></if>

			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbErr</name>::<name>db_unknown_flag</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr>"__ham_c_get"</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</default>}</block></switch>

		<comment type="block">/*
		 * Must always enter this loop to do error handling and
		 * check for big key/data pair.
		 */</comment>
		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<if>if <condition>(<expr><name>ret</name> != 0 &amp;&amp; <name>ret</name> != <name>DB_NOTFOUND</name></expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then>
			<else>else <if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_OK</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>*<name>pgnop</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
					<expr_stmt><expr><name>ret</name> = <call><name>ham_dup_return</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<break>break;</break>
			}</block></then> <else>else <if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_NOMORE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name><name>CDbErr</name>::<name>db_err</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
					<argument><expr>"H_NOMORE returned to __ham_c_get"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> = <name>EINVAL</name></expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if></else></if></else></if>

			<comment type="block">/*
			 * Ran out of entries in a bucket; change buckets.
			 */</comment>
			<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> <block>{
				<case>case <expr><name>DB_LAST</name></expr>:
				</case><case>case <expr><name>DB_PREV</name></expr>:
				</case><case>case <expr><name>DB_PREV_NODUP</name></expr>:
					<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>hcp</name>-&gt;<name>bucket</name> == 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>ret</name> = <name>DB_NOTFOUND</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
						<goto>goto <name>err</name>;</goto>
					}</block></then></if>
					<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name>--</expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
						<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_prev</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
							<argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					<break>break;</break>
				</case><case>case <expr><name>DB_FIRST</name></expr>:
				</case><case>case <expr><name>DB_NEXT</name></expr>:
				</case><case>case <expr><name>DB_NEXT_NODUP</name></expr>:
					<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name>++</expr>;</expr_stmt>
					<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>hcp</name>-&gt;<name>bucket</name> &gt; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>ret</name> = <name>DB_NOTFOUND</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
						<goto>goto <name>err</name>;</goto>
					}</block></then></if>
					<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
						<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
							<argument><expr><name>lock_type</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					<break>break;</break>
				</case><case>case <expr><name>DB_GET_BOTH</name></expr>:
				</case><case>case <expr><name>DB_GET_BOTHC</name></expr>:
				</case><case>case <expr><name>DB_GET_BOTH_RANGE</name></expr>:
				</case><case>case <expr><name>DB_NEXT_DUP</name></expr>:
				</case><case>case <expr><name>DB_SET</name></expr>:
				</case><case>case <expr><name>DB_SET_RANGE</name></expr>:
					<comment type="block">/* Key not found. */</comment>
					<expr_stmt><expr><name>ret</name> = <name>DB_NOTFOUND</name></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</case><case>case <expr><name>DB_CURRENT</name></expr>:
					<comment type="block">/*
					 * This should only happen if you are doing
					 * deletes and reading with concurrent threads
					 * and not doing proper locking.  We return
					 * the same error code as we would if the
					 * cursor were deleted.
					 */</comment>
					<expr_stmt><expr><name>ret</name> = <name>DB_KEYEMPTY</name></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</case><default>default:
					<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</default>}</block></switch>
		}</block></for>

		<if>if <condition>(<expr><name>get_key</name> == 0</expr>)</condition><then>
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>key</name></type></decl></param>, <param><decl><type><name>DB_DBT_ISSET</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>

	<label><name>err</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

		<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DUPONLY</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_NEXT_NODUP</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * __ham_bulk -- Return bulk data from a hash table.
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_bulk</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>pg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>dup_len</name>, <name>dup_off</name>, <name>dup_tlen</name>, <name>indx</name>, *<name>inp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_lockmode_t</name></type> <name>lock_mode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32_t</name> *</type><name>endp</name>, *<name>offp</name>, *<name>saveoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>key_off</name>, <name>key_size</name>, <name>pagesize</name>, <name>size</name>, <name>space</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>dbuf</name>, *<name>dp</name>, *<name>hk</name>, *<name>np</name>, *<name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_dup</name>, <name>is_key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>need_pg</name>, <name>next_key</name>, <name>no_dup</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>key_off</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>dup_len</name> = <name>dup_off</name> = <name>dup_tlen</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pagesize</name> = <name>dbp</name>-&gt;<name>pgsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_key</name> = <call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_MULTIPLE_KEY</name></expr></argument>)</argument_list></call> ? 1 : 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>next_key</name> = <name>is_key</name> &amp;&amp; <call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_OPFLAGS_MASK</name></expr></argument>)</argument_list></call> != <name>DB_NEXT_DUP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>no_dup</name> = <call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_OPFLAGS_MASK</name></expr></argument>)</argument_list></call> == <name>DB_NEXT_NODUP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbuf</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>np</name> = <name>dp</name> = <name>dbuf</name></expr>;</expr_stmt>

		<comment type="block">/* Keep track of space that is left.  There is an termination entry */</comment>
		<expr_stmt><expr><name>space</name> = <name>data</name>-&gt;<name>ulen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>space</name> -= <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build the offset/size table from the end up. */</comment>
		<expr_stmt><expr><name>endp</name> = (<name>int32_t</name> *) ((<name>u_int8_t</name> *)<name>dbuf</name> + <name>data</name>-&gt;<name>ulen</name>)</expr>;</expr_stmt>
		<expr_stmt><expr><name>endp</name>--</expr>;</expr_stmt>
		<expr_stmt><expr><name>offp</name> = <name>endp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>key_size</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>lock_mode</name> = <call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DBC_RMW</name></expr></argument>)</argument_list></call> ? <name>DB_LOCK_WRITE</name>: <name>DB_LOCK_READ</name></expr>;</expr_stmt>

	<label><name>next_pg</name>:</label>
		<expr_stmt><expr><name>need_pg</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>indx</name> = <name>cp</name>-&gt;<name>indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg</name> = <call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>cp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<do>do <block>{
			<if>if <condition>(<expr><name>is_key</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>key_size</name></expr></argument>,
						<argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>,
						<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>size</name> = <name>key_size</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>key_size</name> &gt; <name>space</name></expr>)</condition><then>
						<goto>goto <name>get_key_space</name>;</goto></then></if>
					<if>if <condition>(<expr>(<name>ret</name> = <name>dbc</name>-&gt;<call><name>bulk_overflow</name><argument_list>(<argument><expr><name>key_size</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
					<expr_stmt><expr><name>space</name> -= <name>key_size</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>key_off</name> = (<name>u_int32_t</name>)(<name>np</name> - <name>dbuf</name>)</expr>;</expr_stmt>
					<expr_stmt><expr><name>np</name> += <name>key_size</name></expr>;</expr_stmt>
				}</block></then> <else>else <block>{
					<if>if <condition>(<expr><name>need_pg</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>dp</name> = <name>np</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>size</name> = <name>pagesize</name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>space</name> &lt; <name>size</name></expr>)</condition><then> <block>{
	<label><name>get_key_space</name>:</label>
							<if>if <condition>(<expr><name>offp</name> == <name>endp</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>data</name>-&gt;<name>size</name> = (<name>u_int32_t</name>)
									<call><name>DB_ALIGN</name><argument_list>(<argument><expr><name>size</name> +
									<name>pagesize</name></expr></argument>, <argument><expr>1024</expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<return>return
									<expr>(<name>DB_BUFFER_SMALL</name>)</expr>;</return>
							}</block></then></if>
							<goto>goto <name>back_up</name>;</goto>
						}</block></then></if>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>,
						   <argument><expr>(<name>u_int8_t</name> *)<name>pg</name> + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>need_pg</name> = 0</expr>;</expr_stmt>
						<expr_stmt><expr><name>space</name> -= <name>size</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>np</name> += <name>size</name></expr>;</expr_stmt>
					}</block></then></if>
					<expr_stmt><expr><name>key_size</name> = <call><name>LEN_HKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>key_off</name> = ((<name><name>inp</name><index>[<expr><name>indx</name></expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call>) +
						(<name>u_int32_t</name>)(<name>dp</name> - <name>dbuf</name>)) +
						<call><name>SSZA</name><argument_list>(<argument><expr><name>HKEYDATA</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if>
			}</block></then></if>

			<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<case>case <expr><name>H_DUPLICATE</name></expr>:
			</case><case>case <expr><name>H_KEYDATA</name></expr>:
				<if>if <condition>(<expr><name>need_pg</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>dp</name> = <name>np</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>size</name> = <name>pagesize</name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>space</name> &lt; <name>size</name></expr>)</condition><then> <block>{
	<label><name>back_up</name>:</label>
						<if>if <condition>(<expr><name>indx</name> != 0</expr>)</condition><then> <block>{
							<expr_stmt><expr><name>indx</name> -= 2</expr>;</expr_stmt>
							<comment type="block">/* XXX
							 * It's not clear that this is
							 * the right way to fix this,
							 * but here goes.
							 * If we are backing up onto a
							 * duplicate, then we need to
							 * position ourselves at the
							 * end of the duplicate set.
							 * We probably need to make
							 * this work for H_OFFDUP too.
							 * It might be worth making a
							 * dummy cursor and calling
							 * __ham_item_prev.
							 */</comment>
							<expr_stmt><expr><name>tmp</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> ==
								<name>H_DUPLICATE</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>dup_off</name> = <name>dup_tlen</name> =
									<call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>,
									<argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>indx</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dup_len</name></expr></argument>,
									<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							}</block></then> <else>else  <block>{
								<expr_stmt><expr><name>is_dup</name> = 0</expr>;</expr_stmt>
								<expr_stmt><expr><name>dup_len</name> = 0</expr>;</expr_stmt>
								<expr_stmt><expr><name>dup_off</name> = 0</expr>;</expr_stmt>
								<expr_stmt><expr><name>dup_tlen</name> = 0</expr>;</expr_stmt>
								<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>cp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
							}</block></else></if>
							<goto>goto <name>get_space</name>;</goto>
						}</block></then></if>
						<comment type="block">/* indx == 0 */</comment>
						<expr_stmt><expr><name>cp</name>-&gt;<name>dup_len</name> = <name>dup_len</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>cp</name>-&gt;<name>dup_off</name> = <name>dup_off</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>cp</name>-&gt;<name>dup_tlen</name> = <name>dup_tlen</name></expr>;</expr_stmt>
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_prev</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
							<argument><expr><name>lock_mode</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>ret</name> != <name>DB_NOTFOUND</name></expr>)</condition><then>
								<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
							<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
								<argument><expr><name>cp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
							<expr_stmt><expr><name>cp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
							<if>if <condition>(<expr><name>cp</name>-&gt;<name>bucket</name> == 0</expr>)</condition><then> <block>{
								<expr_stmt><expr><name>cp</name>-&gt;<name>indx</name> = <name>indx</name> =
									<name>NDX_INVALID</name></expr>;</expr_stmt>
								<goto>goto <name>get_space</name>;</goto>
							}</block></then></if>
							<if>if <condition>(<expr>(<name>ret</name> =
								<call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

							<expr_stmt><expr><name>cp</name>-&gt;<name>bucket</name>--</expr>;</expr_stmt>
							<expr_stmt><expr><name>cp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>cp</name></expr></argument>,
								<argument><expr><name>cp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>cp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
							<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(
								<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
							<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_prev</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
								<argument><expr><name>lock_mode</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
								<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
						}</block></then></if>
						<expr_stmt><expr><name>indx</name> = <name>cp</name>-&gt;<name>indx</name></expr>;</expr_stmt>
	<label><name>get_space</name>:</label>
						<comment type="block">/*
						 * See if we put any data in the buffer.
						 */</comment>
						<if>if <condition>(<expr><name>offp</name> &gt;= <name>endp</name> ||
							<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DBC_TRANSIENT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<expr_stmt><expr><name>data</name>-&gt;<name>size</name> = (<name>u_int32_t</name>)
								<call><name>DB_ALIGN</name><argument_list>(<argument><expr><name>size</name> +
								<name>data</name>-&gt;<name>ulen</name> - <name>space</name></expr></argument>, <argument><expr>1024</expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return <expr>(<name>DB_BUFFER_SMALL</name>)</expr>;</return>
						}</block></then></if>
						<comment type="block">/*
						 * Don't continue;  we're all out
						 * of space, even though we're
						 * returning success.
						 */</comment>
						<expr_stmt><expr><name>next_key</name> = 0</expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr>(<name>u_int8_t</name> *)<name>pg</name> + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>need_pg</name> = 0</expr>;</expr_stmt>
					<expr_stmt><expr><name>space</name> -= <name>size</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>np</name> += <name>size</name></expr>;</expr_stmt>
				}</block></then></if>

				<comment type="block">/*
				 * We're about to crack the offset(s) and length(s)
				 * out of an H_KEYDATA or H_DUPLICATE item.
				 * There are three cases:
				 *   1. We were moved into a duplicate set by
				 *	the standard hash cursor code.  Respect
				 *	the dup_off and dup_tlen we were given.
				 *   2. We stumbled upon a duplicate set while
				 *	walking the page on our own.  We need to
				 *	recognize it as a dup and set dup_off and
				 *	dup_tlen.
				 *   3. The current item is not a dup.
				 */</comment>
				<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<comment type="block">/* Case 1 */</comment>
					<expr_stmt><expr><name>is_dup</name> = 1</expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_len</name> = <name>cp</name>-&gt;<name>dup_len</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_off</name> = <name>cp</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_tlen</name> = <name>cp</name>-&gt;<name>dup_tlen</name></expr>;</expr_stmt>
				}</block></then> <else>else <if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_DUPLICATE</name></expr>)</condition><then> <block>{
					<comment type="block">/* Case 2 */</comment>
					<expr_stmt><expr><name>is_dup</name> = 1</expr>;</expr_stmt>
					<comment type="block">/*
					 * If we run out of memory and bail,
					 * make sure the fact we're in a dup set
					 * isn't ignored later.
					 */</comment>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>cp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>dup_off</name> = 0</expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dup_len</name></expr></argument>,
						<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_tlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>, <argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else>else <block>{
					<comment type="block">/* Case 3 */</comment>
					<expr_stmt><expr><name>is_dup</name> = 0</expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_len</name> = 0</expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_off</name> = 0</expr>;</expr_stmt>
					<expr_stmt><expr><name>dup_tlen</name> = 0</expr>;</expr_stmt>
				}</block></else></if></else></if>

				<do>do <block>{
					<expr_stmt><expr><name>space</name> -= (<name>is_key</name> ? 4 : 2) * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>size</name> += (<name>is_key</name> ? 4 : 2) * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * Since space is an unsigned, if we happen
					 * to wrap, then this comparison will turn out
					 * to be true.  XXX Wouldn't it be better to
					 * simply check above that space is greater than
					 * the value we're about to subtract???
					 */</comment>
					<if>if <condition>(<expr><name>space</name> &gt; <name>data</name>-&gt;<name>ulen</name></expr>)</condition><then> <block>{
						<if>if <condition>(<expr>!<name>is_dup</name> || <name>dup_off</name> == 0</expr>)</condition><then>
							<goto>goto <name>back_up</name>;</goto></then></if>
						<expr_stmt><expr><name>dup_off</name> -= (<name>db_indx_t</name>)
							<call><name>DUP_SIZE</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)<name><name>offp</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>get_space</name>;</goto>
					}</block></then></if>
					<if>if <condition>(<expr><name>is_key</name></expr>)</condition><then> <block>{
						<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_off</name></expr>;</expr_stmt>
						<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_size</name></expr>;</expr_stmt>
					}</block></then></if>
					<if>if <condition>(<expr><name>is_dup</name></expr>)</condition><then> <block>{
						<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)(
							((<name><name>inp</name><index>[<expr><name>indx</name> + 1</expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call>) +
							<name>dp</name> - <name>dbuf</name>) + <call><name>SSZA</name><argument_list>(<argument><expr><name>HKEYDATA</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> +
							<name>dup_off</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>dup_len</name></expr></argument>,
							<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> + <name>dup_off</name></expr></argument>,
							<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>dup_off</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr>*<name>offp</name>-- = <name>dup_len</name></expr>;</expr_stmt>
					}</block></then> <else>else <block>{
						<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)(
							((<name><name>inp</name><index>[<expr><name>indx</name> + 1</expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call>) +
							<name>dp</name> - <name>dbuf</name>) + <call><name>SSZA</name><argument_list>(<argument><expr><name>HKEYDATA</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
						<expr_stmt><expr>*<name>offp</name>-- = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>,
							<argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></else></if>
				}</block> while <condition>(<expr><name>is_dup</name> &amp;&amp; <name>dup_off</name> &lt; <name>dup_tlen</name> &amp;&amp; <name>no_dup</name> == 0</expr>)</condition>;</do>
				<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>cp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
			</case><case>case <expr><name>H_OFFDUP</name></expr>:
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>space</name> -= 2 * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>space</name> &gt; <name>data</name>-&gt;<name>ulen</name></expr>)</condition><then>
					<goto>goto <name>back_up</name>;</goto></then></if>

				<if>if <condition>(<expr><name>is_key</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>space</name> -= 2 * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>space</name> &gt; <name>data</name>-&gt;<name>ulen</name></expr>)</condition><then>
						<goto>goto <name>back_up</name>;</goto></then></if>
					<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_off</name></expr>;</expr_stmt>
					<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_size</name></expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>saveoff</name> = <name>offp</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CBTreeCursor</name>::<name>bam_bulk_duplicates</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
					<argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>dbuf</name></expr></argument>, <argument><expr><name>is_key</name> ? <name>offp</name> + 2 : <name>NULL</name></expr></argument>,
					<argument><expr>&amp;<name>offp</name></expr></argument>, <argument><expr>&amp;<name>np</name></expr></argument>, <argument><expr>&amp;<name>space</name></expr></argument>, <argument><expr><name>no_dup</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>ret</name> == <name>DB_BUFFER_SMALL</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>size</name> = <name>space</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>space</name> = 0</expr>;</expr_stmt>
						<if>if <condition>(<expr><name>is_key</name> &amp;&amp; <name>saveoff</name> == <name>offp</name></expr>)</condition><then> <block>{
							<expr_stmt><expr><name>offp</name> += 2</expr>;</expr_stmt>
							<goto>goto <name>back_up</name>;</goto>
						}</block></then></if>
						<goto>goto <name>get_space</name>;</goto>
					}</block></then></if>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
				}</block></then></if>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</case><case>case <expr><name>H_OFFPAGE</name></expr>:
				<expr_stmt><expr><name>space</name> -= (<name>is_key</name> ? 4 : 2) * <call><name>sizeof</name><argument_list>(<argument><expr>*<name>offp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>space</name> &gt; <name>data</name>-&gt;<name>ulen</name></expr>)</condition><then>
					<goto>goto <name>back_up</name>;</goto></then></if>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>size</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>size</name> &gt; <name>space</name></expr>)</condition><then>
					<goto>goto <name>back_up</name>;</goto></then></if>

				<if>if <condition>(<expr>(<name>ret</name> = <name>dbc</name>-&gt;<call><name>bulk_overflow</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<if>if <condition>(<expr><name>is_key</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_off</name></expr>;</expr_stmt>
					<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>key_size</name></expr>;</expr_stmt>
				}</block></then></if>

				<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)(<name>np</name> - <name>dbuf</name>)</expr>;</expr_stmt>
				<expr_stmt><expr>*<name>offp</name>-- = (<name>int32_t</name>)<name>size</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>np</name> += <name>size</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>space</name> -= <name>size</name></expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<comment type="block">/* Do nothing. */</comment>
				<break>break;</break>
			</default>}</block></switch>
		}</block> while <condition>(<expr><name>next_key</name> &amp;&amp; (<name>indx</name> += 2) &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

		<expr_stmt><expr><name>cp</name>-&gt;<name>indx</name> = <name>indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name>-&gt;<name>dup_len</name> = <name>dup_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name>-&gt;<name>dup_off</name> = <name>dup_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name>-&gt;<name>dup_tlen</name> = <name>dup_tlen</name></expr>;</expr_stmt>

		<comment type="block">/* If we are off the page then try to the next page. */</comment>
		<if>if <condition>(<expr><name>ret</name> == 0 &amp;&amp; <name>next_key</name> &amp;&amp; <name>indx</name> &gt;= <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_mode</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then>
				<goto>goto <name>next_pg</name>;</goto></then></if>
			<if>if <condition>(<expr><name>ret</name> != <name>DB_NOTFOUND</name></expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>dbp</name>-&gt;<name>mpf</name></expr></argument>, <argument><expr><name>cp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<expr_stmt><expr><name>cp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

			<expr_stmt><expr><name>cp</name>-&gt;<name>bucket</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>cp</name>-&gt;<name>bucket</name> &gt; <name>cp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>)</condition><then> <block>{
				<comment type="block">/*
				 * Restore cursor to its previous state.  We're past
				 * the last item in the last bucket, so the next
				 * DBC-&gt;c_get(DB_NEXT) will return DB_NOTFOUND.
				 */</comment>
				<expr_stmt><expr><name>cp</name>-&gt;<name>bucket</name>--</expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> = <name>DB_NOTFOUND</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<comment type="block">/*
				 * Start on the next bucket.
				 *
				 * Note that if this new bucket happens to be empty,
				 * but there's another non-empty bucket after it,
				 * we'll return early.  This is a rare case, and we
				 * don't guarantee any particular number of keys
				 * returned on each call, so just let the next call
				 * to bulk get move forward by yet another bucket.
				 */</comment>
				<expr_stmt><expr><name>cp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
				<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>cp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>lock_mode</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>t_ret</name>)</expr>;</return></then></if>
			<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
				<goto>goto <name>next_pg</name>;</goto></then></if>
			<if>if <condition>(<expr><name>ret</name> != <name>DB_NOTFOUND</name></expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>
		<expr_stmt><expr>*<name>offp</name> = -1</expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_put</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>tmp_val</name>, *<name>myval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The compiler doesn't realize that we only use this when ret is
		 * equal to 0 and that if ret is equal to 0, that we must have set
		 * myval.  So, we initialize it here to shut the compiler up.
		 */</comment>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>myval</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call> &amp;&amp;
			<name>flags</name> != <name>DB_KEYFIRST</name> &amp;&amp; <name>flags</name> != <name>DB_KEYLAST</name></expr>)</condition><then>
			<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return></then></if>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_get_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err1</name>;</goto></then></if>

		<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> <block>{
		<case>case <expr><name>DB_KEYLAST</name></expr>:
		</case><case>case <expr><name>DB_KEYFIRST</name></expr>:
		</case><case>case <expr><name>DB_NODUPDATA</name></expr>:
			<expr_stmt><expr><name>nbytes</name> = (<call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call> ? <name>HOFFPAGE_PSIZE</name> :
				<call><name>HKEYDATA_PSIZE</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call>) +
				(<call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call> ? <name>HOFFPAGE_PSIZE</name> :
				<call><name>HKEYDATA_PSIZE</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_lookup</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
				<argument><expr><name>key</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>) == <name>DB_NOTFOUND</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
				<if>if <condition>(<expr><name>hcp</name>-&gt;<name>seek_found_page</name> != <name>PGNO_INVALID</name> &amp;&amp;
					<name>hcp</name>-&gt;<name>seek_found_page</name> != <name>hcp</name>-&gt;<name>pgno</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err2</name>;</goto></then></if>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>hcp</name>-&gt;<name>seek_found_page</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>NDX_INVALID</name></expr>;</expr_stmt>
				}</block></then></if>

				<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call> &amp;&amp; <name>data</name>-&gt;<name>doff</name> != 0</expr>)</condition><then> <block>{
					<comment type="block">/*
					 * A partial put, but the key does not exist
					 * and we are not beginning the write at 0.
					 * We must create a data item padded up to doff
					 * and then write the new bytes represented by
					 * val.
					 */</comment>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_init_dbt</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>,
						<argument><expr><name>data</name>-&gt;<name>size</name> + <name>data</name>-&gt;<name>doff</name></expr></argument>,
						<argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>data</name></expr></argument>,
						<argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>ulen</name></expr></argument>)</argument_list></call>) == 0</expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tmp_val</name>.<name>data</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>data</name>-&gt;<name>doff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>tmp_val</name>.<name>data</name> +
							<name>data</name>-&gt;<name>doff</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>myval</name> = &amp;<name>tmp_val</name></expr>;</expr_stmt>
					}</block></then></if>
				}</block></then> <else>else
					<expr_stmt><expr><name>myval</name> = (<name>DBT</name> *)<name>data</name></expr>;</expr_stmt></else></if>

				<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
					<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_add_el</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>myval</name></expr></argument>, <argument><expr><name>H_KEYDATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				<goto>goto <name>done</name>;</goto>
			}</block></then></if>
			<break>break;</break>
		</case><case>case <expr><name>DB_BEFORE</name></expr>:
		</case><case>case <expr><name>DB_AFTER</name></expr>:
		</case><case>case <expr><name>DB_CURRENT</name></expr>:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</case><default>default:
			<expr_stmt><expr><name>ret</name> = <call><name><name>CDbErr</name>::<name>db_unknown_flag</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr>"__ham_c_put"</expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</default>}</block></switch>

		<if>if <condition>(<expr>*<name>pgnop</name> == <name>PGNO_INVALID</name> &amp;&amp; <name>ret</name> == 0</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>flags</name> == <name>DB_CURRENT</name> ||
				((<name>flags</name> == <name>DB_KEYFIRST</name> ||
				<name>flags</name> == <name>DB_KEYLAST</name> || <name>flags</name> == <name>DB_NODUPDATA</name>) &amp;&amp;
				!(<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_DUP</name></expr></argument>)</argument_list></call> || <call><name>F_ISSET</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>DB_DBT_DUPOK</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <call><name>ham_overwrite</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else
				<expr_stmt><expr><name>ret</name> = <call><name><name>CHashDup</name>::<name>ham_add_dup</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		}</block></then></if>

	<label><name>done</name>:</label>	<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>t_ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		}</block></then></if>

		<if>if <condition>(<expr><name>ret</name> == 0 &amp;&amp; <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_EXPAND</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ret</name> = <call><name>ham_expand_table</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_EXPAND</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<comment type="block">/* If we are out of space, ignore the error. */</comment>
			<if>if <condition>(<expr><name>ret</name> == <name>ENOSPC</name> &amp;&amp; <name>dbc</name>-&gt;<name>txn</name> == <name>NULL</name></expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt></then></if>
		}</block></then></if>

	<label><name>err2</name>:</label>	<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CHashMeta</name>::<name>ham_release_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

	<label><name>err1</name>:</label>	<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/********************************* UTILITIES ************************/</comment>

	<comment type="block">/*
	 * __ham_expand_table --
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_expand_table</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LOCK</name></type> <name>metalock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBMETA</name> *</type><name>mmeta</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>h</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name>, <name>mpgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>dirty_meta</name>, <name>logn</name>, <name>newalloc</name>, <name>new_bucket</name>, <name>old_bucket</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>got_meta</name>, <name>new_double</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashMeta</name>::<name>ham_dirty_meta</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<constructor_decl><name>LOCK_INIT</name><parameter_list>(<param><decl><type><name>metalock</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<expr_stmt><expr><name>mmeta</name> = (<name>DBMETA</name> *) <name>hcp</name>-&gt;<name>hdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpgno</name> = <name>mmeta</name>-&gt;<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>h</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty_meta</name> = <name>newalloc</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>got_meta</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		 * If the split point is about to increase, make sure that we
		 * have enough extra pages.  The calculation here is weird.
		 * We'd like to do this after we've upped max_bucket, but it's
		 * too late then because we've logged the meta-data split.  What
		 * we'll do between then and now is increment max bucket and then
		 * see what the log of one greater than that is; here we have to
		 * look at the log of max + 2.  VERY NASTY STUFF.
		 *
		 * We figure out what we need to do, then we log it, then request
		 * the pages from mpool.  We don't want to fail after extending
		 * the file.
		 *
		 * If the page we are about to split into has already been allocated,
		 * then we simply need to get it to get its LSN.  If it hasn't yet
		 * been allocated, then we know it's LSN (0,0).
		 */</comment>

		<expr_stmt><expr><name>new_bucket</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name> + 1</expr>;</expr_stmt>
		<expr_stmt><expr><name>old_bucket</name> = <name>new_bucket</name> &amp; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>low_mask</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_double</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name> == <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>high_mask</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logn</name> = <call><name><name>CDbLog2</name>::<name>db_log2</name></name><argument_list>(<argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>!<name>new_double</name> || <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name><name>spares</name><index>[<expr><name>logn</name> + 1</expr>]</index></name> != <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<comment type="block">/* Page exists; get it so we can get its LSN */</comment>
			<expr_stmt><expr><name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
			<expr_stmt><expr><name>lsn</name> = <name>h</name>-&gt;<name>lsn</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<comment type="block">/* Get the master meta-data page to do allocation. */</comment>
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_SUBDB</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>mpgno</name> = <name>PGNO_BASE_MD</name></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_lget</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
				   <argument><expr>0</expr></argument>, <argument><expr><name>mpgno</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>metalock</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>mpgno</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>mmeta</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<goto>goto <name>err</name>;</goto></then></if>
				<expr_stmt><expr><name>got_meta</name> = 1</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><name>pgno</name> = <name>mmeta</name>-&gt;<name>last_pgno</name> + 1</expr>;</expr_stmt>
			<constructor_decl><name>ZERO_LSN</name><parameter_list>(<param><decl><type><name>lsn</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>newalloc</name> = 1</expr>;</expr_stmt>
		}</block></else></if>

		<comment type="block">/* Log the meta-data split first. */</comment>
		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<comment type="block">/*
			 * We always log the page number of the first page of
			 * the allocation group.  However, the LSN that we log
			 * is either the LSN on the first page (if we did not
			 * do the actual allocation here) or the LSN on the last
			 * page of the unit (if we did do the allocation here).
			 */</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_metagroup_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>,
				<argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr></argument>, <argument><expr><name>mpgno</name></expr></argument>, <argument><expr>&amp;<name>mmeta</name>-&gt;<name>lsn</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>pgno</name></expr></argument>, <argument><expr>&amp;<name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>lsn</name></expr></argument>,
				<argument><expr><name>pgno</name></expr></argument>, <argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr><name>newalloc</name></expr></argument>, <argument><expr><name>mmeta</name>-&gt;<name>last_pgno</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>lsn</name> = <name>lsn</name></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>new_double</name> &amp;&amp; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name><name>spares</name><index>[<expr><name>logn</name> + 1</expr>]</index></name> == <name>PGNO_INVALID</name></expr>)</condition><then> <block>{
			<comment type="block">/*
			 * We need to begin a new doubling and we have not allocated
			 * any pages yet.  Read the last page in and initialize it to
			 * make the allocation contiguous.  The pgno we calculated
			 * above is the first page allocated. The entry in spares is
			 * that page number minus any buckets already allocated (it
			 * simplifies bucket to page transaction).  After we've set
			 * that, we calculate the last pgno.
			 */</comment>

			<expr_stmt><expr><name>pgno</name> += <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>;</expr_stmt>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr>&amp;<name>pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name><name>spares</name><index>[<expr><name>logn</name> + 1</expr>]</index></name> =
				(<name>pgno</name> - <name>new_bucket</name>) - <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mmeta</name>-&gt;<name>last_pgno</name> = <name>pgno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mmeta</name>-&gt;<name>lsn</name> = <name>lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty_meta</name> = <name>DB_MPOOL_DIRTY</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>P_INIT</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
				<argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>P_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Write out whatever page we ended up modifying. */</comment>
		<expr_stmt><expr><name>h</name>-&gt;<name>lsn</name> = <name>lsn</name></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<expr_stmt><expr><name>h</name> = <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update the meta-data page of this hash database.
		 */</comment>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name> = <name>new_bucket</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>new_double</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>low_mask</name> = <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>high_mask</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>high_mask</name> = <name>new_bucket</name> | <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>low_mask</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/* Relocate records to the new bucket */</comment>
		<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_split_page</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<label><name>err</name>:</label>	<if>if <condition>(<expr><name>got_meta</name></expr>)</condition><then>
			<if>if <condition>(<expr>(<name>t_ret</name> =
				<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>mmeta</name></expr></argument>, <argument><expr><name>dirty_meta</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if></then></if>
		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name>__TLPUT</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>metalock</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>h</name> != <name>NULL</name></expr>)</condition><then>
			<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * PUBLIC: u_int32_t __ham_call_hash __P((DBC *, u_int8_t *, u_int32_t));
	 */</comment>
	<function><type><name>static</name> <name>u_int32_t</name></type> <name>ham_call_hash</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int8_t</name> *</type><name>k</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH</name> *</type><name>hashp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>n</name>, <name>bucket</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>HASH</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>h_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> = (<name>u_int32_t</name>)(<name>hashp</name>-&gt;<call><name>h_hash</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

		<expr_stmt><expr><name>bucket</name> = <name>n</name> &amp; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>high_mask</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>bucket</name> &gt; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>)</condition><then>
			<expr_stmt><expr><name>bucket</name> = <name>bucket</name> &amp; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>low_mask</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>bucket</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * Check for duplicates, and call __db_ret appropriately.  Release
	 * everything held by the cursor.
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_dup_return</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>val</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>pp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name> *</type><name>myval</name>, <name>tmp_val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>ndx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>off</name>, <name>tlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name>, <name>type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>len</name></decl>;</decl_stmt>

		<comment type="block">/* Check for duplicate and return the first one. */</comment>
		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndx</name> = <call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>type</name> = <call><name>HPAGE_TYPE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>myval</name> = <name>val</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * There are 4 cases:
		 * 1. We are not in duplicate, simply return; the upper layer
		 *    will do the right thing.
		 * 2. We are looking at keys and stumbled onto a duplicate.
		 * 3. We are in the middle of a duplicate set. (ISDUP set)
		 * 4. We need to check for particular data match.
		 */</comment>

		<comment type="block">/* We should never get here with off-page dups. */</comment>
		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>type</name> != <name>H_OFFDUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Case 1 */</comment>
		<if>if <condition>(<expr><name>type</name> != <name>H_DUPLICATE</name> &amp;&amp; <name>flags</name> != <name>DB_GET_BOTH</name> &amp;&amp;
			<name>flags</name> != <name>DB_GET_BOTHC</name> &amp;&amp; <name>flags</name> != <name>DB_GET_BOTH_RANGE</name></expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<comment type="block">/*
		 * Here we check for the case where we just stumbled onto a
		 * duplicate.  In this case, we do initialization and then
		 * let the normal duplicate code handle it. (Case 2)
		 */</comment>
		<if>if <condition>(<expr>!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call> &amp;&amp; <name>type</name> == <name>H_DUPLICATE</name></expr>)</condition><then> <block>{
			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>dbmeta</name>.<name>pagesize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>flags</name> == <name>DB_LAST</name> ||
				<name>flags</name> == <name>DB_PREV</name> || <name>flags</name> == <name>DB_PREV_NODUP</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = 0</expr>;</expr_stmt>
				<do>do <block>{
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>,
						<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> + <name>hcp</name>-&gt;<name>dup_off</name></expr></argument>,
						<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block> while <condition>(<expr><name>hcp</name>-&gt;<name>dup_off</name> &lt; <name>hcp</name>-&gt;<name>dup_tlen</name></expr>)</condition>;</do>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> -= <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>,
					<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = 0</expr>;</expr_stmt>
			}</block></else></if>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>len</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/*
		 * If we are retrieving a specific key/data pair, then we
		 * may need to adjust the cursor before returning data.
		 * Case 4
		 */</comment>
		<if>if <condition>(<expr><name>flags</name> == <name>DB_GET_BOTH</name> ||
			<name>flags</name> == <name>DB_GET_BOTHC</name> || <name>flags</name> == <name>DB_GET_BOTH_RANGE</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/*
				 * If we're doing a join, search forward from the
				 * current position, not the beginning of the dup set.
				 */</comment>
				<if>if <condition>(<expr><name>flags</name> == <name>DB_GET_BOTHC</name></expr>)</condition><then>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_CONTINUE</name></type></decl></param>)</parameter_list>;</constructor_decl></then></if>

				<constructor_decl><name>CHashDup::ham_dsearch</name><parameter_list>(<param><decl><type><name>dbc</name></type></decl></param>, <param><decl><type><name>val</name></type></decl></param>, <param><decl><type>&amp;</type><name>off</name></decl></param>, <param><decl><type>&amp;</type><name>cmp</name></decl></param>, <param><decl><type><name>flags</name></type></decl></param>)</parameter_list>;</constructor_decl>

				<comment type="block">/*
				 * This flag is set nowhere else and is safe to
				 * clear unconditionally.
				 */</comment>
				<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_CONTINUE</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = <name>off</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>((<name>HKEYDATA</name> *)<name>hk</name>)-&gt;<name>type</name> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>tlen</name></expr></argument>,
						<argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>,
						<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_moff</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
						<argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>dup_compare</name></expr></argument>, <argument><expr>&amp;<name>cmp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				}</block></then> <else>else <block>{
					<comment type="block">/*
					 * We do not zero tmp_val since the comparison
					 * routines may only look at data and size.
					 */</comment>
					<expr_stmt><expr><name>tmp_val</name>.<name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>tmp_val</name>.<name>size</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
						<argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cmp</name> = <name>dbp</name>-&gt;<name>dup_compare</name> == <name>NULL</name> ?
						<call><name><name>CBTreeCompare</name>::<name>bam_defcmp</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> :
						<name>dbp</name>-&gt;<call><name>dup_compare</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if>
			}</block></else></if>

			<if>if <condition>(<expr><name>cmp</name> != 0</expr>)</condition><then>
				<return>return <expr>(<name>DB_NOTFOUND</name>)</expr>;</return></then></if>
		}</block></then></if>

		<comment type="block">/*
		 * If we're doing a bulk get, we don't want to actually return
		 * the data:  __ham_bulk will take care of cracking out the
		 * duplicates appropriately.
		 *
		 * The rest of this function calculates partial offsets and
		 * handles the actual __db_ret, so just return if
		 * DB_MULTIPLE(_KEY) is set.
		 */</comment>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DBC_MULTIPLE</name> | <name>DBC_MULTIPLE_KEY</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<comment type="block">/*
		 * Now, everything is initialized, grab a duplicate if
		 * necessary.
		 */</comment>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_ISDUP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{	<comment type="block">/* Case 3 */</comment>
			<comment type="block">/*
			 * Copy the DBT in case we are retrieving into user
			 * memory and we need the parameters for it.  If the
			 * user requested a partial, then we need to adjust
			 * the user's parameters to get the partial of the
			 * duplicate which is itself a partial.
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<comment type="block">/*
				 * Take the user's length unless it would go
				 * beyond the end of the duplicate.
				 */</comment>
				<if>if <condition>(<expr><name>tmp_val</name>.<name>doff</name> &gt; <name>hcp</name>-&gt;<name>dup_len</name></expr>)</condition><then>
					<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = 0</expr>;</expr_stmt></then>
				<else>else <if>if <condition>(<expr><name>tmp_val</name>.<name>dlen</name> + <name>tmp_val</name>.<name>doff</name> &gt; <name>hcp</name>-&gt;<name>dup_len</name></expr>)</condition><then>
					<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = <name>hcp</name>-&gt;<name>dup_len</name> - <name>tmp_val</name>.<name>doff</name></expr>;</expr_stmt></then></if></else></if>

			}</block></then> <else>else <block>{
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type>&amp;</type><name>tmp_val</name></decl></param>, <param><decl><type><name>DB_DBT_PARTIAL</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = <name>hcp</name>-&gt;<name>dup_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> = 0</expr>;</expr_stmt>
			}</block></else></if>

			<comment type="block">/*
			 * Set offset to the appropriate place within the
			 * current duplicate -- need to take into account
			 * both the dup_off and the current duplicate's
			 * length.
			 */</comment>
			<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> += <name>hcp</name>-&gt;<name>dup_off</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>myval</name> = &amp;<name>tmp_val</name></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="block">/*
		 * Finally, if we had a duplicate, pp, ndx, and myval should be
		 * set appropriately.
		 */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbRet</name>::<name>db_ret</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name>myval</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>rdata</name>-&gt;<name>data</name></expr></argument>,
			<argument><expr>&amp;<name>dbc</name>-&gt;<name>rdata</name>-&gt;<name>ulen</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/*
		 * In case we sent a temporary off to db_ret, set the real
		 * return values.
		 */</comment>
		<expr_stmt><expr><name>val</name>-&gt;<name>data</name> = <name>myval</name>-&gt;<name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name>-&gt;<name>size</name> = <name>myval</name>-&gt;<name>size</name></expr>;</expr_stmt>

		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>val</name></type></decl></param>, <param><decl><type><name>DB_DBT_ISSET</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashHookFunction1</name><parameterlist>(<param><decl><type><name>HASH_CURSOR</name> *&amp;</type> <name>hcp</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>tmp_val</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>nondup_size</name></decl></param>, <param><decl><type><name>db_indx_t</name>&amp;</type> <name>newsize</name></decl></param>, <param><decl><type><name>DB</name> *&amp;</type> <name>dbp</name></decl></param>, <param><decl><type><name>void</name> *&amp;</type> <name>newrec</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>tmp_val2</name></decl></param>, <param><decl><type><name>u_int8_t</name> *&amp;</type> <name>p</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>len</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>myval</name></decl></param>, <param><decl><type><name>u_int8_t</name> *&amp;</type> <name>hk</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>nval</name></decl></param>, <param><decl><type><name>DBC</name> *&amp;</type> <name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>flags</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_overwrite</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>nval</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name> *</type><name>myval</name>, <name>tmp_val</name>, <name>tmp_val2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> *</type><name>newrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name>, *<name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>len</name>, <name>nondup_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>newsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashHookFunction1</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>tmp_val</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>nondup_size</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>newrec</name></expr></argument>, <argument><expr><name>tmp_val2</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>myval</name></expr></argument>, <argument><expr><name>hk</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<call><name><name>CHashPage</name>::<name>ham_replpair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>myval</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * Given a key and a cursor, sets the cursor to the page/ndx on which
	 * the key resides.  If the key is found, the cursor H_OK flag is set
	 * and the pagep, bndx, pgno (dpagep, dndx, dpgno) fields are set.
	 * If the key is not found, the H_OK flag is not set.  If the sought
	 * field is non-0, the pagep, bndx, pgno (dpagep, dndx, dpgno) fields
	 * are set indicating where an add might take place.  If it is 0,
	 * non of the cursor pointer field are valid.
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_lookup</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>sought</name></decl></param>, <param><decl><type><name>db_lockmode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>tlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>match</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name>, *<name>dk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * Set up cursor so that we're looking for space to add an item
		 * as we cycle through the pages looking for the key.
		 */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_reset</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>seek_size</name> = <name>sought</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = <call><name>ham_call_hash</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>(<name>u_int8_t</name> *)<name>key</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
			<expr_stmt><expr>*<name>pgnop</name> = <name>PGNO_INVALID</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_item_next</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>pgnop</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

			<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_NOMORE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
				<break>break;</break></then></if>

			<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
			<case>case <expr><name>H_OFFPAGE</name></expr>:
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>tlen</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_TLEN</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>tlen</name> == <name>key</name>-&gt;<name>size</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>pgno</name></expr></argument>,
						<argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbOverflow</name>::<name>db_moff</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
						<argument><expr><name>key</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>match</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
					<if>if <condition>(<expr><name>match</name> == 0</expr>)</condition><then>
						<goto>goto <name>found_key</name>;</goto></then></if>
				}</block></then></if>
				<break>break;</break>
			</case><case>case <expr><name>H_KEYDATA</name></expr>:
				<if>if <condition>(<expr><name>key</name>-&gt;<name>size</name> ==
					<call><name>LEN_HKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call> &amp;&amp;
					<call><name>memcmp</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>data</name></expr></argument>,
					<argument><expr><call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
					<comment type="block">/* Found the key, check for data type. */</comment>
	<label><name>found_key</name>:</label>			<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_OK</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<expr_stmt><expr><name>dk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>dk</name></expr></argument>)</argument_list></call> == <name>H_OFFDUP</name></expr>)</condition><then>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgnop</name></expr></argument>, <argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					<return>return <expr>(0)</expr>;</return>
				}</block></then></if>
				<break>break;</break>
			</case><case>case <expr><name>H_DUPLICATE</name></expr>:
			</case><case>case <expr><name>H_OFFDUP</name></expr>:
				<comment type="block">/*
				 * These are errors because keys are never
				 * duplicated, only data items are.
				 */</comment>
				<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
			</case><default>default:
				<return>return <expr>(<call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</return>
			</default>}</block></switch>
		}</block></for>

		<comment type="block">/*
		 * Item was not found.
		 */</comment>

		<if>if <condition>(<expr><name>sought</name> != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * __ham_init_dbt --
	 *	Initialize a dbt using some possibly already allocated storage
	 *	for items.
	 *
	 * PUBLIC: int __ham_init_dbt __P((DB_ENV *,
	 * PUBLIC:     DBT *, u_int32_t, void **, u_int32_t *));
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_init_dbt</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>void</name> **</type><name>bufp</name></decl></param>, <param><decl><type><name>u_int32_t</name> *</type><name>sizep</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dbt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>dbt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>*<name>sizep</name> &lt; <name>size</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_realloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>bufp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>sizep</name> = 0</expr>;</expr_stmt>
				<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
			<expr_stmt><expr>*<name>sizep</name> = <name>size</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>dbt</name>-&gt;<name>data</name> = *<name>bufp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbt</name>-&gt;<name>size</name> = <name>size</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * Adjust the cursor after an insert or delete.  The cursor passed is
	 * the one that was operated upon; we just need to check any of the
	 * others.
	 *
	 * len indicates the length of the item added/deleted
	 * add indicates if the item indicated by the cursor has just been
	 * added (add == 1) or deleted (add == 0).
	 * dup indicates if the addition occurred into a duplicate set.
	 *
	 * PUBLIC: int __ham_c_update
	 * PUBLIC:    __P((DBC *, u_int32_t, int, int));
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_c_update</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>add</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_dup</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name>, *<name>ldbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXN</name> *</type><name>my_txn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name>, *<name>lcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>found</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>order</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Adjustment will only be logged if this is a subtransaction.
		 * Only subtransactions can abort and effect their parent
		 * transactions cursors.
		 */</comment>

		<expr_stmt><expr><name>my_txn</name> = <call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call> ? <name>dbc</name>-&gt;<name>txn</name> : <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Calculate the order of this deleted record.
		 * This will be one greater than any cursor that is pointing
		 * at this record and already marked as deleted.
		 */</comment>
		<expr_stmt><expr><name>order</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>!<name>add</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>order</name> = 1</expr>;</expr_stmt>
			<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
				<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
				<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
					<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
					<if>if <condition>(<expr><name>cp</name> == <name>dbc</name> || <name>cp</name>-&gt;<name>dbtype</name> != <name>DB_HASH</name></expr>)</condition><then>
						<continue>continue;</continue></then></if>
					<expr_stmt><expr><name>lcp</name> = (<name>HASH_CURSOR</name> *)<name>cp</name>-&gt;<name>internal</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call> &amp;&amp;
						<name>hcp</name>-&gt;<name>pgno</name> == <name>lcp</name>-&gt;<name>pgno</name> &amp;&amp;
						<name>hcp</name>-&gt;<name>indx</name> == <name>lcp</name>-&gt;<name>indx</name> &amp;&amp;
						<name>order</name> &lt;= <name>lcp</name>-&gt;<name>order</name> &amp;&amp;
						(!<name>is_dup</name> || <name>hcp</name>-&gt;<name>dup_off</name> == <name>lcp</name>-&gt;<name>dup_off</name>)</expr>)</condition><then>
						<expr_stmt><expr><name>order</name> = <name>lcp</name>-&gt;<name>order</name> + 1</expr>;</expr_stmt></then></if>
				}</block></for>
				<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>order</name> = <name>order</name></expr>;</expr_stmt>
		}</block></then></if>

		<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
			<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
			<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
				<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<if>if <condition>(<expr><name>cp</name> == <name>dbc</name> || <name>cp</name>-&gt;<name>dbtype</name> != <name>DB_HASH</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>

				<expr_stmt><expr><name>lcp</name> = (<name>HASH_CURSOR</name> *)<name>cp</name>-&gt;<name>internal</name></expr>;</expr_stmt>

				<if>if <condition>(<expr><name>lcp</name>-&gt;<name>pgno</name> != <name>hcp</name>-&gt;<name>pgno</name> || <name>lcp</name>-&gt;<name>indx</name> == <name>NDX_INVALID</name></expr>)</condition><then>
					<continue>continue;</continue></then></if>

				<if>if <condition>(<expr><name>my_txn</name> != <name>NULL</name> &amp;&amp; <name>cp</name>-&gt;<name>txn</name> != <name>my_txn</name></expr>)</condition><then>
					<expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt></then></if>

				<if>if <condition>(<expr>!<name>is_dup</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>add</name></expr>)</condition><then> <block>{
						<comment type="block">/*
						 * This routine is not called to add
						 * non-dup records which are always put
						 * at the end.  It is only called from
						 * recovery in this case and the
						 * cursor will be marked deleted.
						 * We are "undeleting" so unmark all
						 * cursors with the same order.
						 */</comment>
						<if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> == <name>hcp</name>-&gt;<name>indx</name> &amp;&amp;
							<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>lcp</name>-&gt;<name>order</name> == <name>hcp</name>-&gt;<name>order</name></expr>)</condition><then>
								<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>lcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl></then>
							<else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>order</name> &gt;
								<name>hcp</name>-&gt;<name>order</name></expr>)</condition><then> <block>{

							<comment type="block">/*
							 * If we've moved this cursor's
							 * index, split its order
							 * number--i.e., decrement it by
							 * enough so that the lowest
							 * cursor moved has order 1.
							 * cp_arg-&gt;order is the split
							 * point, so decrement by one
							 * less than that.
							 */</comment>
								<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> -=
									(<name>hcp</name>-&gt;<name>order</name> - 1)</expr>;</expr_stmt>
								<expr_stmt><expr><name>lcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt>
							}</block></then></if></else></if>
						}</block></then> <else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> &gt;= <name>hcp</name>-&gt;<name>indx</name></expr>)</condition><then>
							<expr_stmt><expr><name>lcp</name>-&gt;<name>indx</name> += 2</expr>;</expr_stmt></then></if></else></if>

					}</block></then> <else>else <block>{
						<if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> &gt; <name>hcp</name>-&gt;<name>indx</name></expr>)</condition><then> <block>{
							<expr_stmt><expr><name>lcp</name>-&gt;<name>indx</name> -= 2</expr>;</expr_stmt>
							<if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> == <name>hcp</name>-&gt;<name>indx</name> &amp;&amp;
								<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
								<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt></then></if>
						}</block></then> <else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> == <name>hcp</name>-&gt;<name>indx</name> &amp;&amp;
							!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>lcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
							<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>lcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
							<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> = <name>order</name></expr>;</expr_stmt>
						}</block></then></if></else></if>
					}</block></else></if>
				}</block></then> <else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>indx</name> == <name>hcp</name>-&gt;<name>indx</name></expr>)</condition><then> <block>{
					<comment type="block">/*
					 * Handle duplicates.  This routine is
					 * only called for on page dups.
					 * Off page dups are handled by btree/rtree
					 * code.
					 */</comment>
					<if>if <condition>(<expr><name>add</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>lcp</name>-&gt;<name>dup_tlen</name> += <name>len</name></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>lcp</name>-&gt;<name>dup_off</name> == <name>hcp</name>-&gt;<name>dup_off</name> &amp;&amp;
							<call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call> &amp;&amp;
							<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<comment type="block">/* Abort of a delete. */</comment>
							<if>if <condition>(<expr><name>lcp</name>-&gt;<name>order</name> == <name>hcp</name>-&gt;<name>order</name></expr>)</condition><then>
								<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>lcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl></then>
							<else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>order</name> &gt;
								<name>hcp</name>-&gt;<name>order</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> -=
									(<name>hcp</name>-&gt;<name>order</name> -1)</expr>;</expr_stmt>
								<expr_stmt><expr><name>lcp</name>-&gt;<name>dup_off</name> += <name>len</name></expr>;</expr_stmt>
							}</block></then></if></else></if>
						}</block></then> <else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>dup_off</name> &gt;= <name>hcp</name>-&gt;<name>dup_off</name></expr>)</condition><then>
							<expr_stmt><expr><name>lcp</name>-&gt;<name>dup_off</name> += <name>len</name></expr>;</expr_stmt></then></if></else></if>
					}</block></then> <else>else <block>{
						<expr_stmt><expr><name>lcp</name>-&gt;<name>dup_tlen</name> -= <name>len</name></expr>;</expr_stmt>
						<if>if <condition>(<expr><name>lcp</name>-&gt;<name>dup_off</name> &gt; <name>hcp</name>-&gt;<name>dup_off</name></expr>)</condition><then> <block>{
							<expr_stmt><expr><name>lcp</name>-&gt;<name>dup_off</name> -= <name>len</name></expr>;</expr_stmt>
							<if>if <condition>(<expr><name>lcp</name>-&gt;<name>dup_off</name> ==
								<name>hcp</name>-&gt;<name>dup_off</name> &amp;&amp;
								<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
								<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> += <name>order</name></expr>;</expr_stmt></then></if>
						}</block></then> <else>else <if>if <condition>(<expr><name>lcp</name>-&gt;<name>dup_off</name> ==
							<name>hcp</name>-&gt;<name>dup_off</name> &amp;&amp;
							!<call><name>F_ISSET</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
							<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>lcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>
							<expr_stmt><expr><name>lcp</name>-&gt;<name>order</name> = <name>order</name></expr>;</expr_stmt>
						}</block></then></if></else></if>
					}</block></else></if>
				}</block></then></if></else></if>
			}</block></for>
			<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>found</name> != 0 &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_curadj_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>my_txn</name></expr></argument>, <argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>pgno</name></expr></argument>,
				<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>dup_off</name></expr></argument>, <argument><expr><name>add</name></expr></argument>, <argument><expr><name>is_dup</name></expr></argument>, <argument><expr><name>order</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	 * __ham_get_clist --
	 *
	 * Get a list of cursors either on a particular bucket or on a particular
	 * page and index combination.  The former is so that we can update
	 * cursors on a split.  The latter is so we can update cursors when we
	 * move items off page.
	 *
	 * PUBLIC: int __ham_get_clist __P((DB *, db_pgno_t, u_int32_t, DBC ***));
	 */</comment>
	<function><type><name>static</name> <name>int</name></type> <name>ham_get_clist</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>indx</name></decl></param>, <param><decl><type><name>DBC</name> ***</type><name>listp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>ldbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>nalloc</name>, <name>nused</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Assume that finding anything is the exception, so optimize for
		 * the case where there aren't any.
		 */</comment>
		<expr_stmt><expr><name>nalloc</name> = <name>nused</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr>*<name>listp</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
			<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
			<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
				<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>)
				<comment type="block">/*
				 * We match if cp-&gt;pgno matches the specified
				 * pgno, and if either the cp-&gt;indx matches
				 * or we weren't given an index.
				 */</comment>
				<if>if <condition>(<expr><name>cp</name>-&gt;<name>internal</name>-&gt;<name>pgno</name> == <name>pgno</name> &amp;&amp;
					(<name>indx</name> == <name>NDX_INVALID</name> ||
					<name>cp</name>-&gt;<name>internal</name>-&gt;<name>indx</name> == <name>indx</name>)</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>nused</name> &gt;= <name>nalloc</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>nalloc</name> += 10</expr>;</expr_stmt>
						<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_realloc</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
							<argument><expr><name>nalloc</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>HASH_CURSOR</name> *</expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>listp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
							<goto>goto <name>err</name>;</goto></then></if>
					}</block></then></if>
					<expr_stmt><expr>(*<name>listp</name>)[<name>nused</name>++] = <name>cp</name></expr>;</expr_stmt>
				}</block></then></if></for>

			<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>listp</name> != <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>nused</name> &gt;= <name>nalloc</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>nalloc</name>++</expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_realloc</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
					<argument><expr><name>nalloc</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>HASH_CURSOR</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr>(*<name>listp</name>)[<name>nused</name>] = <name>NULL</name></expr>;</expr_stmt>
		}</block></then></if>
		<return>return <expr>(0)</expr>;</return>
	<label><name>err</name>:</label>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_writelock</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB_LOCK</name></type> <name>tmp_lock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * All we need do is acquire the lock and let the off-page
		 * dup tree do its thing.
		 */</comment>
		<if>if <condition>(<expr>!<call><name>STD_LOCKING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
		<if>if <condition>(<expr>(!<call><name>LOCK_ISSET</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>lock</name></expr></argument>)</argument_list></call> || <name>hcp</name>-&gt;<name>lock_mode</name> != <name>DB_LOCK_WRITE</name>)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>tmp_lock</name> = <name>hcp</name>-&gt;<name>lock</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_lock_bucket</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>DB_LOCK_WRITE</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp;
				<name>tmp_lock</name>.<name>mode</name> != <name>DB_LOCK_WWRITE</name></expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <call><name>__LPUT</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>tmp_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

</public>
}</block></class>;</unit>