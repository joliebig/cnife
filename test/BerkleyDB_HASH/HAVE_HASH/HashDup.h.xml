<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHashDup</name>
<block>{
<comment>//---refactored functions</comment><public>
public:


	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashDupHookFunction1</name><parameterlist>(<param><decl><type><name>u_int8_t</name> *&amp;</type> <name>hk</name></decl></param>, <param><decl><type><name>HASH_CURSOR</name> *&amp;</type> <name>hcp</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>new_size</name></decl></param>, <param><decl><type><name>DB</name> *&amp;</type> <name>dbp</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DBC</name> *&amp;</type> <name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *&amp;</type> <name>nval</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>flags</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_add_dup</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>nval</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name> *</type><name>pgnop</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>pval</name>, <name>tmp_val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>add_bytes</name>, <name>new_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cmp</name>, <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>flags</name> != <name>DB_CURRENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>add_bytes</name> = <name>nval</name>-&gt;<name>size</name> +
			(<call><name>F_ISSET</name><argument_list>(<argument><expr><name>nval</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call> ? <name>nval</name>-&gt;<name>doff</name> : 0)</expr>;</expr_stmt>
		<expr_stmt><expr><name>add_bytes</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>add_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_check_move</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>add_bytes</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/*
		* Check if resulting duplicate set is going to need to go
		* onto a separate duplicate page.  If so, convert the
		* duplicate set and add the new one.  After conversion,
		* hcp-&gt;dndx is the first free ndx or the index of the
		* current pointer into the duplicate set.
		*/</comment>
		<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Add the len bytes to the current singleton. */</comment>
		<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> != <name>H_DUPLICATE</name></expr>)</condition><then>
			<expr_stmt><expr><name>add_bytes</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>new_size</name> =
			<call><name>LEN_HKEYDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
			<name>add_bytes</name></expr>;</expr_stmt>

		<comment type="block">/*
		* We convert to off-page duplicates if the item is a big item,
		* the addition of the new item will make the set large, or
		* if there isn't enough room on this page to add the next item.
		*/</comment>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashDupHookFunction1</name><argument_list>(<argument><expr><name>hk</name></expr></argument>, <argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>, <argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There are two separate cases here: on page and off page. */</comment>
		<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> != <name>H_OFFDUP</name></expr>)</condition><then> 
		<block>{
			<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> != <name>H_DUPLICATE</name></expr>)</condition><then> 
			<block>{
				<expr_stmt><expr><name>pval</name>.<name>flags</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>pval</name>.<name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pval</name>.<name>size</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
					<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_make_dup</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>,
					<argument><expr>&amp;<name>pval</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>data</name></expr></argument>,
					<argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>ulen</name></expr></argument>)</argument_list></call>) != 0 || (<name>ret</name> =
					<call><name><name>CHashPage</name>::<name>ham_replpair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> = <name>H_DUPLICATE</name></expr>;</expr_stmt>

				<comment type="block">/*
				* Update the cursor position since we now are in
				* duplicates.
			 */</comment>
				<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = 0</expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>pval</name>.<name>size</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<comment type="block">/* Now make the new entry a duplicate. */</comment>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_make_dup</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>nval</name></expr></argument>,
				<argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>data</name></expr></argument>, <argument><expr>&amp;<name>dbc</name>-&gt;<name>my_rdata</name>.<name>ulen</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

			<expr_stmt><expr><name>tmp_val</name>.<name>dlen</name> = 0</expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> 
			<block>{			<comment type="block">/* On page. */</comment>
			<case>case <expr><name>DB_KEYFIRST</name></expr>:
			</case><case>case <expr><name>DB_KEYLAST</name></expr>:
			</case><case>case <expr><name>DB_NODUPDATA</name></expr>:
				<if>if <condition>(<expr><name>dbp</name>-&gt;<name>dup_compare</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>ham_dsearch</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
						<argument><expr><name>nval</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name>.<name>doff</name></expr></argument>, <argument><expr>&amp;<name>cmp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* dup dups are not supported w/ sorted dups */</comment>
					<if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
						<return>return <expr>(<call><name><name>CDbCam</name>::<name>db_duperr</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>
				}</block></then> <else>else <block>{
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
						<argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>nval</name>-&gt;<name>size</name></expr>;</expr_stmt>
					<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
					<if>if <condition>(<expr><name>flags</name> == <name>DB_KEYFIRST</name></expr>)</condition><then>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = <name>tmp_val</name>.<name>doff</name> = 0</expr>;</expr_stmt></then>
					<else>else
						<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> =
						<name>tmp_val</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_tlen</name></expr>;</expr_stmt></else></if>
				}</block></else></if>
				<break>break;</break>
			</case><case>case <expr><name>DB_BEFORE</name></expr>:
				<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_off</name></expr>;</expr_stmt>
				<break>break;</break>
			</case><case>case <expr><name>DB_AFTER</name></expr>:
				<expr_stmt><expr><name>tmp_val</name>.<name>doff</name> = <name>hcp</name>-&gt;<name>dup_off</name> + <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</case><default>default:
				<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>EINVAL</name>)</expr>;</return>
			</default>}</block></switch>

			<comment type="block">/* Add the duplicate. */</comment>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_replpair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>&amp;<name>tmp_val</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
				<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

			<comment type="block">/* Now, update the cursor if necessary. */</comment>
			<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> <block>{
<case>case <expr><name>DB_AFTER</name></expr>:
	<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>dup_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>nval</name>-&gt;<name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> += (<name>db_indx_t</name>)<call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>nval</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
</case><case>case <expr><name>DB_BEFORE</name></expr>:
</case><case>case <expr><name>DB_KEYFIRST</name></expr>:
</case><case>case <expr><name>DB_KEYLAST</name></expr>:
</case><case>case <expr><name>DB_NODUPDATA</name></expr>:
	<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> += (<name>db_indx_t</name>)<call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>nval</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>nval</name>-&gt;<name>size</name></expr>;</expr_stmt>
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr>(<name>EINVAL</name>)</expr>;</return>
			</default>}</block></switch>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CHash</name>::<name>ham_c_update</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>tmp_val</name>.<name>size</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr>(<name>ret</name>)</expr>;</return>
		}</block></then></if>

		<comment type="block">/*
		* If we get here, then we're on duplicate pages; set pgnop and
		* return so the common code can handle it.
		*/</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pgnop</name></expr></argument>, <argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* Convert an on-page set of duplicates to an offpage set of duplicates.
	*
	* PUBLIC: int __ham_dup_convert __P((DBC *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_dup_convert</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>BOVERFLOW</name></type> <name>bo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> **</type><name>hcs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HOFFPAGE</name></type> <name>ho</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>dp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name>, <name>len</name>, <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>c</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>p</name>, *<name>pend</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<comment type="block">/*
		* Create a new page for the duplicates.
		*/</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbMeta</name>::<name>db_new</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr><name>dbp</name>-&gt;<name>dup_compare</name> == <name>NULL</name> ? <name>P_LRECNO</name> : <name>P_LDUP</name></expr></argument>, <argument><expr>&amp;<name>dp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><call><name>P_INIT</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>,
			<argument><expr><name>dp</name>-&gt;<name>pgno</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>PGNO_INVALID</name></expr></argument>, <argument><expr><name>LEAFLEVEL</name></expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* Get the list of cursors that may need to be updated.
		*/</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHash</name>::<name>ham_get_clist</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
			<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>u_int32_t</name>)<name>hcp</name>-&gt;<name>indx</name></expr></argument>, <argument><expr>&amp;<name>hcs</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>

		<comment type="block">/*
		* Now put the duplicates onto the new page.
		*/</comment>
		<expr_stmt><expr><name>dbt</name>.<name>flags</name> = 0</expr>;</expr_stmt>
		<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H_KEYDATA</name></expr>:
	<comment type="block">/* Simple case, one key on page; move it to dup page. */</comment>
	<expr_stmt><expr><name>dbt</name>.<name>size</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbt</name>.<name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <call><name><name>CDbDup</name>::<name>db_pitem</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
		<argument><expr><name>dp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>BKEYDATA_SIZE</name><argument_list>(<argument><expr><name>dbt</name>.<name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<goto>goto <name>finish</name>;</goto>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
	<comment type="block">/* Simple case, one key on page; move it to dup page. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>ho</name></expr></argument>, <argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>HOFFPAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>bo</name>.<name>unused1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>B_TSET</name><argument_list>(<argument><expr><name>bo</name>.<name>type</name></expr></argument>, <argument><expr><name>ho</name>.<name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>bo</name>.<name>unused2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bo</name>.<name>pgno</name> = <name>ho</name>.<name>pgno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bo</name>.<name>tlen</name> = <name>ho</name>.<name>tlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbt</name>.<name>size</name> = <name>BOVERFLOW_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbt</name>.<name>data</name> = &amp;<name>bo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> = <call><name><name>CDbDup</name>::<name>db_pitem</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>dbt</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finish</name>:</label>		<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<break>break;</break></then></if>

	<comment type="block">/* Update any other cursors. */</comment>
	<if>if <condition>(<expr><name>hcs</name> != <name>NULL</name> &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call> &amp;&amp;
		<call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_chgpg_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>,
				<argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DB_HAM_DUP</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<break>break;</break></then></if>
	}</block></then></if>
	<for>for (<init><expr><name>c</name> = 0</expr>;</init> <condition><expr><name>hcs</name> != <name>NULL</name> &amp;&amp; <name><name>hcs</name><index>[<expr><name>c</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>)
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_dcursor</name><argument_list>(<argument><expr><name><name>hcs</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>,
			<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<break>break;</break></then></if></for>
			}</block></then></if>
			<break>break;</break>
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<expr_stmt><expr><name>p</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pend</name> = <name>p</name> +
		<call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	* We need to maintain the duplicate cursor position.
	* Keep track of where we are in the duplicate set via
	* the offset, and when it matches the one in the cursor,
	* set the off-page duplicate cursor index to the current
	* index.
	*/</comment>
	<for>for (<init><expr><name>off</name> = 0</expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>p</name> &lt; <name>pend</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbt</name>.<name>size</name> = <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbt</name>.<name>data</name> = <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>len</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDup</name>::<name>db_pitem</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>,
			<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>BKEYDATA_SIZE</name><argument_list>(<argument><expr><name>dbt</name>.<name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>dbt</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<break>break;</break></then></if>

		<comment type="block">/* Update any other cursors */</comment>
		<if>if <condition>(<expr><name>hcs</name> != <name>NULL</name> &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call> &amp;&amp;
			<call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_chgpg_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>,
					<argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DB_HAM_DUP</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<break>break;</break></then></if>
		}</block></then></if>
		<for>for (<init><expr><name>c</name> = 0</expr>;</init> <condition><expr><name>hcs</name> != <name>NULL</name> &amp;&amp; <name><name>hcs</name><index>[<expr><name>c</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>)
			<if>if <condition>(<expr>((<name>HASH_CURSOR</name> *)(<name><name>hcs</name><index>[<expr><name>c</name></expr>]</index></name>-&gt;<name>internal</name>))-&gt;<name>dup_off</name>
				== <name>off</name> &amp;&amp; (<name>ret</name> = <call><name>ham_dcursor</name><argument_list>(<argument><expr><name><name>hcs</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if></for>
		<expr_stmt><expr><name>off</name> += <name>len</name> + 2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><name>ret</name> = <call><name><name>CDbErr</name>::<name>db_pgfmt</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
		</default>}</block></switch>

		<comment type="block">/*
		* Now attach this to the source page in place of the old duplicate
		* item.
		*/</comment>
		<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <call><name>ham_move_offpage</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr>(<name>u_int32_t</name>)<call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<label><name>err</name>:</label>	<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>(<name>t_ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(
			<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>ret</name> == 0 ? <name>DB_MPOOL_DIRTY</name> : 0</expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = <name>hcp</name>-&gt;<name>dup_off</name> = <name>hcp</name>-&gt;<name>dup_len</name> = 0</expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr><name>hcs</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name><name>COsAlloc</name>::<name>os_free</name></name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>dbenv</name></expr></argument>, <argument><expr><name>hcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_make_dup
	*
	* Take a regular dbt and make it into a duplicate item with all the partial
	* information set appropriately. If the incoming dbt is a partial, assume
	* we are creating a new entry and make sure that we do any initial padding.
	*
	* PUBLIC: int __ham_make_dup __P((DB_ENV *,
	* PUBLIC:     const DBT *, DBT *d, void **, u_int32_t *));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_make_dup</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>notdup</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>duplicate</name></decl></param>, <param><decl><type><name>void</name> **</type><name>bufp</name></decl></param>, <param><decl><type><name>u_int32_t</name> *</type><name>sizep</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>tsize</name>, <name>item_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>item_size</name> = (<name>db_indx_t</name>)<name>notdup</name>-&gt;<name>size</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>notdup</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>item_size</name> += <name>notdup</name>-&gt;<name>doff</name></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>tsize</name> = <call><name>DUP_SIZE</name><argument_list>(<argument><expr><name>item_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHash</name>::<name>ham_init_dbt</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>duplicate</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>, <argument><expr><name>bufp</name></expr></argument>, <argument><expr><name>sizep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>duplicate</name>-&gt;<name>dlen</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>duplicate</name>-&gt;<name>flags</name> = <name>notdup</name>-&gt;<name>flags</name></expr>;</expr_stmt>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>duplicate</name></type></decl></param>, <param><decl><type><name>DB_DBT_PARTIAL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>p</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>duplicate</name>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>item_size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>notdup</name></expr></argument>, <argument><expr><name>DB_DBT_PARTIAL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>notdup</name>-&gt;<name>doff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> += <name>notdup</name>-&gt;<name>doff</name></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>notdup</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>notdup</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> += <name>notdup</name>-&gt;<name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>item_size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>duplicate</name>-&gt;<name>doff</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>duplicate</name>-&gt;<name>dlen</name> = <name>notdup</name>-&gt;<name>size</name></expr>;</expr_stmt>

		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_check_move --
	*
	* Check if we can do whatever we need to on this page.  If not,
	* then we'll have to move the current element to a new page.
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_check_move</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>add_len</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>k</name>, <name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>new_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PAGE</name> *</type><name>next_pagep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>new_datalen</name>, <name>old_len</name>, <name>rectype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>hk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hk</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* If the item is already off page duplicates or an offpage item,
		* then we know we can do whatever we need to do in-place
		*/</comment>
		<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFDUP</name> || <call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<expr_stmt><expr><name>old_len</name> =
			<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_datalen</name> = (<name>old_len</name> - <call><name>HKEYDATA_SIZE</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) + <name>add_len</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> != <name>H_DUPLICATE</name></expr>)</condition><then>
			<expr_stmt><expr><name>new_datalen</name> += <call><name>DUP_SIZE</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<comment type="block">/*
		* We need to add a new page under two conditions:
		* 1. The addition makes the total data length cross the BIG
		*    threshold and the OFFDUP structure won't fit on this page.
		* 2. The addition does not make the total data cross the
		*    threshold, but the new data won't fit on the page.
		* If neither of these is true, then we can return.
		*/</comment>
		<if>if <condition>(<expr><call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>new_datalen</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>old_len</name> &gt; <name>HOFFDUP_SIZE</name> ||
			<name>HOFFDUP_SIZE</name> - <name>old_len</name> &lt;= <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<if>if <condition>(<expr>!<call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>new_datalen</name></expr></argument>)</argument_list></call> &amp;&amp;
			(<name>new_datalen</name> - <name>old_len</name>) &lt;= <call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<return>return <expr>(0)</expr>;</return></then></if>

		<comment type="block">/*
		* If we get here, then we need to move the item to a new page.
		* Check if there are more pages in the chain.  We now need to
		* update new_datalen to include the size of both the key and
		* the data that we need to move.
		*/</comment>

		<expr_stmt><expr><name>new_datalen</name> = <call><name>ISBIG</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>new_datalen</name></expr></argument>)</argument_list></call> ?
<name>HOFFDUP_SIZE</name> : <call><name>HKEYDATA_SIZE</name><argument_list>(<argument><expr><name>new_datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_datalen</name> +=
			<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>next_pagep</name> = <name>NULL</name></expr>;</expr_stmt>
		<for>for (<init><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>next_pgno</name> != <name>PGNO_INVALID</name></expr>;</condition>
			<incr><expr><name>next_pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<if>if <condition>(<expr><name>next_pagep</name> != <name>NULL</name> &amp;&amp;
					(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFget</name>::<name>memp_fget</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>,
					<argument><expr>&amp;<name>next_pgno</name></expr></argument>, <argument><expr><name>DB_MPOOL_CREATE</name></expr></argument>, <argument><expr>&amp;<name>next_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

				<if>if <condition>(<expr><call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call> &gt;= <name>new_datalen</name></expr>)</condition><then>
					<break>break;</break></then></if>
		}</block></for>

		<comment type="block">/* No more pages, add one. */</comment>
		<if>if <condition>(<expr><name>next_pagep</name> == <name>NULL</name> &amp;&amp; (<name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_add_ovflpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>next_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<comment type="block">/* Add new page at the end of the chain. */</comment>
		<if>if <condition>(<expr><call><name>P_FREESPACE</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call> &lt; <name>new_datalen</name> &amp;&amp; (<name>ret</name> =
			<call><name><name>CHashPage</name>::<name>ham_add_ovflpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>next_pagep</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
				<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr>(<name>ret</name>)</expr>;</return>
		}</block></then></if>

		<comment type="block">/* Copy the item to the new page. */</comment>
		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>rectype</name> = <name>PUTPAIR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>k</name>.<name>flags</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>d</name>.<name>flags</name> = 0</expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(
				<argument><expr><call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>rectype</name> |= <name>PAIR_KEYMASK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>k</name>.<name>data</name> = <call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>k</name>.<name>size</name> = <name>HOFFPAGE_SIZE</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name>k</name>.<name>data</name> =
					<call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>k</name>.<name>size</name> =
					<call><name>LEN_HKEY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call> == <name>H_OFFPAGE</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>rectype</name> |= <name>PAIR_DATAMASK</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name>.<name>data</name> = <call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name>.<name>size</name> = <name>HOFFPAGE_SIZE</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
					<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>H_DUPLICATE</name></expr>)</condition><then>
					<expr_stmt><expr><name>rectype</name> |= <name>PAIR_DUPMASK</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>d</name>.<name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(
					<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name>.<name>size</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>,
					<argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_insdel_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
				<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<name>new_lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>(<name>u_int32_t</name>)<call><name>NUM_ENT</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr>&amp;<name>k</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
					<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr>(<name>ret</name>)</expr>;</return>
			}</block></then></if>
		}</block></then> <else>else
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type><name>new_lsn</name></type></decl></param>)</parameter_list>;</constructor_decl></else></if>

		<comment type="block">/* Move lsn onto page. */</comment>
		<expr_stmt><expr><call><name>LSN</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call> = <name>new_lsn</name></expr>;</expr_stmt>	<comment type="block">/* Structure assignment. */</comment>

		<expr_stmt><expr><call><name><name>CHashPage</name>::<name>ham_copy_item</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>CHashPage</name>::<name>ham_copy_item</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>H_DATAINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* We've just manually inserted a key and set of data onto
		* next_pagep;  however, it's possible that our caller will
		* return without further modifying the new page, for instance
		* if DB_NODUPDATA is set and our new item is a duplicate duplicate.
		* Thus, to be on the safe side, we need to mark the page dirty
		* here. [#2996]
		*
		* Note that __ham_del_pair should dirty the page we're moving
		* the items from, so we need only dirty the new page ourselves.
		*/</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFset</name>::<name>memp_fset</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>next_pagep</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>out</name>;</goto></then></if>

		<comment type="block">/* Update all cursors that used to point to this item. */</comment>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name>ham_c_chgpg</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>H_KEYINDEX</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUM_ENT</name><argument_list>(<argument><expr><name>next_pagep</name></expr></argument>)</argument_list></call> - 2</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>out</name>;</goto></then></if>

		<comment type="block">/* Now delete the pair from the current page. */</comment>
		<expr_stmt><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_del_pair</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* __ham_del_pair decremented nelem.  This is incorrect;  we
		* manually copied the element elsewhere, so the total number
		* of elements hasn't changed.  Increment it again.
		*
		* !!!
		* Note that we still have the metadata page pinned, and
		* __ham_del_pair dirtied it, so we don't need to set the dirty
		* flag again.
		*/</comment>
		<if>if <condition>(<expr>!<call><name>STD_LOCKING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>nelem</name>++</expr>;</expr_stmt></then></if>

<label><name>out</name>:</label>
		<expr_stmt><expr>(<name>void</name>)<call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>DB_MPOOL_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>next_pagep</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <call><name>PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> - 2</expr>;</expr_stmt>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_EXPAND</name></type></decl></param>)</parameter_list>;</constructor_decl>
		<constructor_decl><name>F_CLR</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_DELETED</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_move_offpage --
	*	Replace an onpage set of duplicates with the OFFDUP structure
	*	that references the duplicate page.
	*
	* XXX
	* This is really just a special case of __onpage_replace; we should
	* probably combine them.
	*
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_move_offpage</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>PAGE</name> *</type><name>pagep</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>new_dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>old_dbt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HOFFDUP</name></type> <name>od</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name>, *<name>inp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32_t</name></type> <name>difflen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>src</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>od</name>.<name>type</name> = <name>H_OFFDUP</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>od</name>.<name><name>unused</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>od</name>.<name><name>unused</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UMRW_SET</name><argument_list>(<argument><expr><name>od</name>.<name><name>unused</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>od</name>.<name>pgno</name> = <name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>new_dbt</name>.<name>data</name> = &amp;<name>od</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_dbt</name>.<name>size</name> = <name>HOFFDUP_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_dbt</name>.<name>data</name> = <call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_dbt</name>.<name>size</name> = <call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_replace_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,
				<argument><expr><call><name>PGNO</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(<name>u_int32_t</name>)<name>ndx</name></expr></argument>, <argument><expr>&amp;<call><name>LSN</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>-1</expr></argument>,
				<argument><expr>&amp;<name>old_dbt</name></expr></argument>, <argument><expr>&amp;<name>new_dbt</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else
			<expr_stmt><expr><call><name>LSN_NOT_LOGGED</name><argument_list>(<argument><expr><call><name>LSN</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

		<comment type="block">/*
		* difflen is the difference in the lengths, and so may be negative.
		* We know that the difference between two unsigned lengths from a
		* database page will fit into an int32_t.
		*/</comment>
		<expr_stmt><expr><name>difflen</name> =
			(<name>int32_t</name>)<call><name>LEN_HITEM</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call> -
			(<name>int32_t</name>)<name>HOFFDUP_SIZE</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>difflen</name> != 0</expr>)</condition><then> <block>{
			<comment type="block">/* Copy data. */</comment>
			<expr_stmt><expr><name>inp</name> = <call><name>P_INP</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src</name> = (<name>u_int8_t</name> *)(<name>pagep</name>) + <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>src</name> + <name>difflen</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>inp</name><index>[<expr><name>ndx</name></expr>]</index></name> - <call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HOFFSET</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call> += <name>difflen</name></expr>;</expr_stmt>

			<comment type="block">/* Update index table. */</comment>
			<for>for (<init><expr><name>i</name> = <name>ndx</name></expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>pagep</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
				<expr_stmt><expr><name><name>inp</name><index>[<expr><name>i</name></expr>]</index></name> += <name>difflen</name></expr>;</expr_stmt></for>
		}</block></then></if>

		<comment type="block">/* Now copy the offdup entry onto the page. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>pagep</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>od</name></expr></argument>, <argument><expr><name>HOFFDUP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* __ham_dsearch:
	*	Locate a particular duplicate in a duplicate set.  Make sure that
	*	we exit with the cursor set appropriately.
	*
	* PUBLIC: void __ham_dsearch
	* PUBLIC:     __P((DBC *, DBT *, u_int32_t *, int *, u_int32_t));
	*/</comment>

	<function><type><name>static</name> <name>void</name></type> <name>ham_dsearch</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>u_int32_t</name> *</type><name>offp</name></decl></param>, <param><decl><type><name>int</name> *</type><name>cmpp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBT</name></type> <name>cur</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_indx_t</name></type> <name>i</name>, <name>len</name></decl>;</decl_stmt>
		<macro><name>int</name> <argument_list>(<argument>*func</argument>)</argument_list></macro> <macro><name>__P</name><argument_list>(<argument>(DB *, const DBT *, const DBT *)</argument>)</argument_list></macro>;
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>func</name> = <name>dbp</name>-&gt;<name>dup_compare</name> == <name>NULL</name> ? <name><name>CBTreeCompare</name>::<name>bam_defcmp</name></name> : <name>dbp</name>-&gt;<name>dup_compare</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> = <call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_CONTINUE</name></expr></argument>)</argument_list></call> ? <name>hcp</name>-&gt;<name>dup_off</name>: 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> = <call><name>HKEYDATA_DATA</name><argument_list>(<argument><expr><call><name>H_PAIRDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> + <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_tlen</name> = <call><name>LEN_HDATA</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>pgsize</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> = <name>hcp</name>-&gt;<name>dup_len</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name> &lt; <name>hcp</name>-&gt;<name>dup_tlen</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name>.<name>data</name> = <name>data</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur</name>.<name>size</name> = (<name>u_int32_t</name>)<name>len</name></expr>;</expr_stmt>

			<comment type="block">/*
			* If we find an exact match, we're done.  If in a sorted
			* duplicate set and the item is larger than our test item,
			* we're done.  In the latter case, if permitting partial
			* matches, it's not a failure.
			*/</comment>
			<expr_stmt><expr>*<name>cmpp</name> = <call><name>func</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>dbt</name></expr></argument>, <argument><expr>&amp;<name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>*<name>cmpp</name> == 0</expr>)</condition><then>
				<break>break;</break></then></if>
			<if>if <condition>(<expr>*<name>cmpp</name> &lt; 0 &amp;&amp; <name>dbp</name>-&gt;<name>dup_compare</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr><name>flags</name> == <name>DB_GET_BOTH_RANGE</name></expr>)</condition><then>
					<expr_stmt><expr>*<name>cmpp</name> = 0</expr>;</expr_stmt></then></if>
				<break>break;</break>
			}</block></then></if>

			<expr_stmt><expr><name>i</name> += <name>len</name> + 2 * <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> += <name>len</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>db_indx_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>

		<expr_stmt><expr>*<name>offp</name> = <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_off</name> = <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name>-&gt;<name>dup_len</name> = <name>len</name></expr>;</expr_stmt>
		<constructor_decl><name>F_SET</name><parameter_list>(<param><decl><type><name>hcp</name></type></decl></param>, <param><decl><type><name>H_ISDUP</name></type></decl></param>)</parameter_list>;</constructor_decl>
	}</block></function>

<comment type="block">/*
	* __ham_c_chgpg --
	*	Adjust the cursors after moving an item to a new page.  We only
	*	move cursors that are pointing at this one item and are not
	*	deleted;  since we only touch non-deleted cursors, and since
	*	(by definition) no item existed at the pgno/indx we're moving the
	*	item to, we're guaranteed that all the cursors we affect here or
	*	on abort really do refer to this one item.
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_c_chgpg</name><parameter_list>(<param><decl><type><name>DBC</name> *</type><name>dbc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>old_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>old_index</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>new_index</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name>, *<name>ldbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name></type> <name>lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXN</name> *</type><name>my_txn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>cp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>found</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_txn</name> = <call><name>IS_SUBTRANSACTION</name><argument_list>(<argument><expr><name>dbc</name>-&gt;<name>txn</name></expr></argument>)</argument_list></call> ? <name>dbc</name>-&gt;<name>txn</name> : <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> = 0</expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>ldbp</name> = <call><name><name>DB</name>::<name>dblist_get</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>adj_fileid</name></expr></argument>)</argument_list></call></expr>;</init>
			<condition><expr><name>ldbp</name> != <name>NULL</name> &amp;&amp; <name>ldbp</name>-&gt;<name>adj_fileid</name> == <name>dbp</name>-&gt;<name>adj_fileid</name></expr>;</condition>
			<incr><expr><name>ldbp</name> = <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>ldbp</name></expr></argument>, <argument><expr><name>dblistlinks</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
				<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for (<init><expr><name>cp</name> = <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>ldbp</name>-&gt;<name>active_queue</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> != <name>NULL</name></expr>;</condition>
					<incr><expr><name>cp</name> = <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
						<if>if <condition>(<expr><name>cp</name> == <name>dbc</name> || <name>cp</name>-&gt;<name>dbtype</name> != <name>DB_HASH</name></expr>)</condition><then>
							<continue>continue;</continue></then></if>

						<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>cp</name>-&gt;<name>internal</name></expr>;</expr_stmt>

						<comment type="block">/*
						* If a cursor is deleted, it doesn't refer to this
						* item--it just happens to have the same indx, but
						* it points to a former neighbor.  Don't move it.
						*/</comment>
						<if>if <condition>(<expr><call><name>F_ISSET</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>H_DELETED</name></expr></argument>)</argument_list></call></expr>)</condition><then>
							<continue>continue;</continue></then></if>

						<if>if <condition>(<expr><name>hcp</name>-&gt;<name>pgno</name> == <name>old_pgno</name></expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>hcp</name>-&gt;<name>indx</name> == <name>old_index</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>new_pgno</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>hcp</name>-&gt;<name>indx</name> = <name>new_index</name></expr>;</expr_stmt>
							}</block></then> <else>else
								<continue>continue;</continue></else></if>
							<if>if <condition>(<expr><name>my_txn</name> != <name>NULL</name> &amp;&amp; <name>cp</name>-&gt;<name>txn</name> != <name>my_txn</name></expr>)</condition><then>
								<expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt></then></if>
						}</block></then></if>
				}</block></for>
				<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbp</name>-&gt;<name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dbenv</name>-&gt;<name>mtx_dblist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>found</name> != 0 &amp;&amp; <call><name>DBC_LOGGING</name><argument_list>(<argument><expr><name>dbc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CHashAuto</name>::<name>ham_chgpg_log</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>my_txn</name></expr></argument>, <argument><expr>&amp;<name>lsn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>DB_HAM_CHGPG</name></expr></argument>,
				<argument><expr><name>old_pgno</name></expr></argument>, <argument><expr><name>new_pgno</name></expr></argument>, <argument><expr><name>old_index</name></expr></argument>, <argument><expr><name>new_index</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then></if>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>


	</public>
}</block></class>;</unit>