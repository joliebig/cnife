<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHashAuto</name>
<block>{
<comment>//---refactored functions</comment><public>
public:
<comment type="line">//#ifndef HAVE_HASH</comment>

	<comment type="block">/*
	* PUBLIC: int __ham_init_recover __P((DB_ENV *, int (***)(DB_ENV *,
	* PUBLIC:     DBT *, DB_LSN *, db_recops, void *), size_t *));
	*/</comment>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_init_recover</name><argument_list>(<argument><expr><name>DB_ENV</name> *<name>dbenv</name></expr></argument>, <argument><expr><call><name>int</name> <argument_list>(<argument><expr>***<name>dtabp</name></expr></argument>)</argument_list></call><call><name>__P</name><argument_list>(<argument><expr>(<name>DB_ENV</name> *, <name>DBT</name> *, <name>DB_LSN</name> *, <name>db_recops</name>, <name>void</name> *)</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name> *<name>dtabsizep</name></expr></argument>)</argument_list>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_insdel_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_insdel</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_newpage_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_newpage</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_splitdata_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_splitdata</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_replace_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_replace</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_copypage_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_copypage</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_metagroup_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_metagroup</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_groupalloc_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_groupalloc</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_curadj_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_curadj</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbDispatch</name>::<name>db_add_recovery</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>dtabp</name></expr></argument>, <argument><expr><name>dtabsizep</name></expr></argument>,
			<argument><expr><name><name>CHashRec</name>::<name>ham_chgpg_recover</name></name></expr></argument>, <argument><expr><name>DB___ham_chgpg</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<return>return <expr>(0)</expr>;</return>
	}</block></decl></decl_stmt>

	<comment type="block">/*
	* PUBLIC: int __ham_insdel_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, u_int32_t, DB_LSN *,
	* PUBLIC:     const DBT *, const DBT *));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction6</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><parameterlist>(<param><decl><type><name>DB_TXNLOGREC</name> *&amp;</type> <name>lr</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>rectype</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>rlsnp</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>flags</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><parameterlist>(<param><decl><type><name>DB_TXNLOGREC</name> *&amp;</type> <name>lr</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>rectype</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>rlsnp</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name>&amp;</type> <name>flags</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><parameterlist>(<param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>is_durable</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>, <param><decl><type><name>DB_TXN</name> *&amp;</type> <name>txnid</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><parameterlist>(<param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>int</name>&amp;</type> <name>is_durable</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *&amp;</type> <name>data</name></decl></param>, <param><decl><type><name>DB_TXN</name> *&amp;</type> <name>txnid</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_insdel_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>key</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>data</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_insdel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>key</name> == <name>NULL</name> ? 0 : <name>key</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>data</name> == <name>NULL</name> ? 0 : <name>data</name>-&gt;<name>size</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>ndx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>key</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>key</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>key</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>data</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>data</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>data</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>data</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction6</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_insdel_read __P((DB_ENV *, void *, __ham_insdel_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_insdel_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_insdel_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_insdel_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_insdel_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>ndx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>key</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>key</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>key</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>key</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>data</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>data</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>data</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>data</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_newpage_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *,
	* PUBLIC:     db_pgno_t, DB_LSN *));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction4</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_newpage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>prev_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>prevlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_newpage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>prev_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>prevlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>prevlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>prevlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>next_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction4</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_newpage_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_newpage_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_newpage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_newpage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_newpage_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_newpage_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>prev_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prevlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>prevlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>prevlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>next_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_splitdata_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, const DBT *, DB_LSN *));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_splitdata_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>opcode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>pageimage</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_splitdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>pageimage</name> == <name>NULL</name> ? 0 : <name>pageimage</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>opcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pageimage</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>pageimage</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pageimage</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>pageimage</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>pageimage</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_splitdata_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_splitdata_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_splitdata_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_splitdata_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_splitdata_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_splitdata_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>opcode</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pageimage</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pageimage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pageimage</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pageimage</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>pageimage</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_replace_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, u_int32_t, DB_LSN *, int32_t, const DBT *,
	* PUBLIC:     const DBT *, u_int32_t));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_replace_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>ndx</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>int32_t</name></type> <name>off</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>olditem</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>newitem</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>makedup</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_replace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>olditem</name> == <name>NULL</name> ? 0 : <name>olditem</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>newitem</name> == <name>NULL</name> ? 0 : <name>newitem</name>-&gt;<name>size</name>)
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>ndx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>olditem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>olditem</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>olditem</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>olditem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>olditem</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<if>if <condition>(<expr><name>newitem</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>newitem</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>newitem</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>newitem</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>newitem</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>makedup</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_replace_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_replace_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_replace_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_replace_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_replace_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_replace_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>ndx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>off</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>olditem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>olditem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>olditem</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>olditem</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>olditem</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>newitem</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>newitem</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>newitem</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>newitem</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>makedup</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_copypage_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *, db_pgno_t,
	* PUBLIC:     DB_LSN *, const DBT *));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction9</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_copypage_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>next_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nextlsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>nnext_pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>nnextlsn</name></decl></param>, <param><decl><type><name>const</name> <name>DBT</name> *</type><name>page</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>zero</name>, <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_copypage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call> + (<name>page</name> == <name>NULL</name> ? 0 : <name>page</name>-&gt;<name>size</name>)</expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>next_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>nnext_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>nnextlsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>nnextlsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>nnextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>page</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>zero</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>page</name>-&gt;<name>size</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>page</name>-&gt;<name>data</name></expr></argument>, <argument><expr><name>page</name>-&gt;<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bp</name> += <name>page</name>-&gt;<name>size</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction9</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_copypage_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_copypage_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_copypage_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_copypage_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_copypage_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_copypage_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>next_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>nnext_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>nnextlsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>page</name>.<name>size</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>page</name>.<name>data</name> = <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <name>argp</name>-&gt;<name>page</name>.<name>size</name></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_metagroup_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, u_int32_t, db_pgno_t, DB_LSN *, db_pgno_t, DB_LSN *,
	* PUBLIC:     db_pgno_t, DB_LSN *, u_int32_t, db_pgno_t));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction8</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_metagroup_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>bucket</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mmpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>mmetalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>mpgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>metalsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>pagelsn</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>newalloc</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_metagroup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>bucket</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mmpgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>mmetalsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>mmetalsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>mmetalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mpgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>metalsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>metalsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>metalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>pagelsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>pagelsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>newalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>last_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>lr</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction8</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>is_durable</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_metagroup_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_metagroup_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_metagroup_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_metagroup_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_metagroup_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_metagroup_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>bucket</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mmpgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>mmetalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mpgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>metalsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>metalsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>metalsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>pagelsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>pagelsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>newalloc</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>last_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_groupalloc_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, DB_LSN *, db_pgno_t, u_int32_t, db_pgno_t,
	* PUBLIC:     db_pgno_t));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction7</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><parameterlist>()</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type> <name>meta_lsn</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>start_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>num</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>free</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>last_pgno</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_groupalloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>()</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>meta_lsn</name> != <name>NULL</name></expr>)</condition><then>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>meta_lsn</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
		<else>else
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr>*<name>meta_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>start_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>num</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>free</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>last_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>()</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction7</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>()</argument_list></call></expr>;</expr_stmt><expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_groupalloc_read __P((DB_ENV *, void *,
	* PUBLIC:     __ham_groupalloc_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_groupalloc_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_groupalloc_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_groupalloc_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_groupalloc_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>,  <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>meta_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>start_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>num</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>free</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>last_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_curadj_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_pgno_t, u_int32_t, u_int32_t, u_int32_t, int, int,
	* PUBLIC:     u_int32_t));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction5</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_curadj_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>dup_off</name></decl></param>, <param><decl><type><name>int</name></type> <name>add</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_dup</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>order</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_curadj</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dup_off</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>add</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>is_dup</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>order</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction5</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_curadj_read __P((DB_ENV *, void *, __ham_curadj_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_curadj_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_curadj_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_curadj_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_curadj_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>len</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>dup_off</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>add</name> = (<name>int</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>is_dup</name> = (<name>int</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>order</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_chgpg_log __P((DB *, DB_TXN *, DB_LSN *,
	* PUBLIC:     u_int32_t, db_ham_mode, db_pgno_t, db_pgno_t, u_int32_t,
	* PUBLIC:     u_int32_t));
	*/</comment>

	<function>	<type><name>void</name></type> <name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><parameterlist>(<param><decl><type><name>int</name>&amp;</type> <name>ret</name></decl></param>, <param><decl><type><name>DB_ENV</name> *&amp;</type> <name>dbenv</name></decl></param>, <param><decl><type><name>DBT</name>&amp;</type> <name>logrec</name></decl></param>, <param><decl><type><name>DB_LSN</name> *&amp;</type> <name>ret_lsnp</name></decl></param>)</parameterlist>
	<block>{
	<comment>//--functionbody</comment>
	}</block></function><function><type><name>static</name> <name>int</name></type> <name>ham_chgpg_log</name><parameter_list>(<param><decl><type><name>DB</name> *</type><name>dbp</name></decl></param>, <param><decl><type><name>DB_TXN</name> *</type><name>txnid</name></decl></param>, <param><decl><type><name>DB_LSN</name> *</type><name>ret_lsnp</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>flags</name></decl></param>, <param><decl><type><name>db_ham_mode</name></type> <name>mode</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>old_pgno</name></decl></param>, <param><decl><type><name>db_pgno_t</name></type> <name>new_pgno</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>old_indx</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>new_indx</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>DBT</name></type> <name>logrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_TXNLOGREC</name> *</type><name>lr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_LSN</name> *</type><name>lsnp</name>, <name>null_lsn</name>, *<name>rlsnp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name>, <name>rectype</name>, <name>txn_num</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int</name></type> <name>npad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>is_durable</name>, <name>ret</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbenv</name> = <name>dbp</name>-&gt;<name>dbenv</name></expr>;</expr_stmt>
		<constructor_decl><name>COMPQUIET</name><parameter_list>(<param><decl><type><name>lr</name></type></decl></param>, <param><decl><type><name>NULL</name></type></decl></param>)</parameter_list>;</constructor_decl>

		<expr_stmt><expr><name>rectype</name> = <name>DB___ham_chgpg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npad</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>rlsnp</name> = <name>ret_lsnp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<if>if <condition>(<expr><call><name>LF_ISSET</name><argument_list>(<argument><expr><name>DB_LOG_NOT_DURABLE</name></expr></argument>)</argument_list></call> ||
			<call><name>F_ISSET</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>DB_AM_NOT_DURABLE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>is_durable</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else
			<expr_stmt><expr><name>is_durable</name> = 1</expr>;</expr_stmt></else></if>

		<if>if <condition>(<expr><name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>txn_num</name> = 0</expr>;</expr_stmt>
			<expr_stmt><expr><name>lsnp</name> = &amp;<name>null_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_lsn</name>.<name>file</name> = <name>null_lsn</name>.<name>offset</name> = 0</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>kids</name></expr></argument>)</argument_list></call> != <name>NULL</name> &amp;&amp;
				(<name>ret</name> = <call><name><name>CTxn</name>::<name>txn_activekids</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rectype</name></expr></argument>, <argument><expr><name>txnid</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
			<comment type="block">/*
			* We need to assign begin_lsn while holding region mutex.
			* That assignment is done inside the DbEnv-&gt;log_put call,
			* so pass in the appropriate memory location to be filled
			* in by the log_put code.
			*/</comment>
			<constructor_decl><name>DB_SET_TXN_LSNP</name><parameter_list>(<param><decl><type><name>txnid</name></type></decl></param>, <param><decl><type>&amp;</type><name>rlsnp</name></decl></param>, <param><decl><type>&amp;</type><name>lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
			<expr_stmt><expr><name>txn_num</name> = <name>txnid</name>-&gt;<name>txnid</name></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr><name>dbp</name>-&gt;<name>log_filename</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name> == <name>DB_LOGFILEID_INVALID</name> &amp;&amp;
			(<name>ret</name> = <call><name><name>CDbregUtil</name>::<name>dbreg_lazy_id</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<expr_stmt><expr><name>logrec</name>.<name>size</name> = <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call>
			+ <call><name>sizeof</name><argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><call><name>CRYPTO_ON</name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>npad</name> =
				((<name>DB_CIPHER</name> *)<name>dbenv</name>-&gt;<name>crypto_handle</name>)-&gt;<call><name>adj_size</name><argument_list>(<argument><expr><name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>logrec</name>.<name>size</name> += <name>npad</name></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> =
				<call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name>.<name>size</name></expr></argument>, <argument><expr>&amp;<name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
				<argument><expr><name>logrec</name>.<name>size</name> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXNLOGREC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>lr</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
				<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<if>if <condition>(<expr><name>npad</name> &gt; 0</expr>)</condition><then>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>(<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name> + <name>logrec</name>.<name>size</name> - <name>npad</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>npad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>logrec</name>.<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>rectype</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>rectype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>txn_num</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>txn_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>lsnp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>dbp</name>-&gt;<name>log_filename</name>-&gt;<name>id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>mode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>old_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_pgno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>old_indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>uinttmp</name> = (<name>u_int32_t</name>)<name>new_indx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>(<name>u_int32_t</name>)(<name>bp</name> - (<name>u_int8_t</name> *)<name>logrec</name>.<name>data</name>) &lt;= <name>logrec</name>.<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>is_durable</name> || <name>txnid</name> == <name>NULL</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CLogPut</name>::<name>log_put</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>rlsnp</name></expr></argument>,<argument><expr>(<name>DBT</name> *)&amp;<name>logrec</name></expr></argument>,
				<argument><expr><name>flags</name> | <name>DB_LOG_NOCOPY</name></expr></argument>)</argument_list></call>) == 0 &amp;&amp; <name>txnid</name> != <name>NULL</name></expr>)</condition><then> <block>{
					<expr_stmt><expr>*<name>lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>rlsnp</name> != <name>ret_lsnp</name></expr>)</condition><then>
						<expr_stmt><expr>*<name>ret_lsnp</name> = *<name>rlsnp</name></expr>;</expr_stmt></then></if>
			}</block></then></if>
		}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>STAILQ_INSERT_HEAD</name><argument_list>(<argument><expr>&amp;<name>txnid</name>-&gt;<name>logs</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>F_SET</name><argument_list>(<argument><expr>(<name>TXN_DETAIL</name> *)<name>txnid</name>-&gt;<name>td</name></expr></argument>, <argument><expr><name>TXN_DTL_INMEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<constructor_decl><name>LSN_NOT_LOGGED</name><parameter_list>(<param><decl><type>*</type><name>ret_lsnp</name></decl></param>)</parameter_list>;</constructor_decl>
		}</block></else></if>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction2</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>dbenv</name></expr></argument>, <argument><expr><name>logrec</name></expr></argument>, <argument><expr><name>ret_lsnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>/home/joliebig/workspace/cnife/test/BerkleyDB_HASH/HAVE_HASH/HashAutoHookFunction3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></function>

	<comment type="block">/*
	* PUBLIC: int __ham_chgpg_read __P((DB_ENV *, void *, __ham_chgpg_args **));
	*/</comment>

	<function><type><name>static</name> <name>int</name></type> <name>ham_chgpg_read</name><parameter_list>(<param><decl><type><name>DB_ENV</name> *</type><name>dbenv</name></decl></param>, <param><decl><type><name>void</name> *</type><name>recbuf</name></decl></param>, <param><decl><type><name>__ham_chgpg_args</name> **</type><name>argpp</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>__ham_chgpg_args</name> *</type><name>argp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>uinttmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int8_t</name> *</type><name>bp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>COsAlloc</name>::<name>os_malloc</name></name><argument_list>(<argument><expr><name>dbenv</name></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>__ham_chgpg_args</name></expr></argument>)</argument_list></call> + <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_TXN</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>argp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>bp</name> = <call><name>static_cast<argument_list>&lt;<argument><name>u_int8_t</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>recbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>txnid</name> = (<name>DB_TXN</name> *)&amp;<name><name>argp</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>type</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>,  <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>argp</name>-&gt;<name>txnid</name>-&gt;<name>txnid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>argp</name>-&gt;<name>prev_lsn</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>DB_LSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>fileid</name> = (<name>int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>mode</name> = (<name>db_ham_mode</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>old_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_pgno</name> = (<name>db_pgno_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>old_indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>uinttmp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>argp</name>-&gt;<name>new_indx</name> = (<name>u_int32_t</name>)<name>uinttmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bp</name> += <call><name>sizeof</name><argument_list>(<argument><expr><name>uinttmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr>*<name>argpp</name> = <name>argp</name></expr>;</expr_stmt>
		<return>return <expr>(0)</expr>;</return>
	}</block></function>

</public>
}</block></class>;</unit>