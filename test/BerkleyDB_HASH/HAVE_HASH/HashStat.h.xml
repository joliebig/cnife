<?xml version="1.0" encoding="UTF-8"?><unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" dir="" filename="vorlage.h" language="C++">
<comment>//---refactored defines</comment>
<class>refines class <name>CHashStat</name>
<block>{
<comment>//---refactored functions</comment><public>
public:
<comment type="line">//#ifndef HAVE_HASH</comment>


<comment type="block">/*
	* __ham_traverse
	*	 Traverse an entire hash table.  We use the callback so that we
	* can use this both for stat collection and for deallocation.
	*
	* PUBLIC: int __ham_traverse __P((DBC *, db_lockmode_t,
	* PUBLIC:     int (*)(DB *, PAGE *, void *, int *), void *, int));
	*/</comment>
	<decl_stmt><decl><type><name>static</name> <name>int</name></type> <name>ham_traverse</name><argument_list>(<argument><expr><name>DBC</name> *<name>dbc</name></expr></argument>, <argument><expr><name>db_lockmode_t</name> <name>mode</name></expr></argument>, <argument><expr><call><name>int</name> <argument_list>(<argument><expr>*<name>callback</name></expr></argument>)</argument_list></call> <call><name>__P</name><argument_list>(<argument><expr>(<name>DB</name> *, <name>PAGE</name> *, <name>void</name> *, <name>int</name> *)</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> *<name>cookie</name></expr></argument>, <argument><expr><name>int</name> <name>look_past_max</name></expr></argument>)</argument_list>
	<block>{
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> message("CHashStat::ham_traverse")</cpp:pragma>
		<decl_stmt><decl><type><name>DB</name> *</type><name>dbp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DBC</name> *</type><name>opd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DB_MPOOLFILE</name> *</type><name>mpf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_CURSOR</name> *</type><name>hcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HKEYDATA</name> *</type><name>hk</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>db_pgno_t</name></type> <name>pgno</name>, <name>opgno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>did_put</name>, <name>i</name>, <name>ret</name>, <name>t_ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>u_int32_t</name></type> <name>bucket</name>, <name>spares_entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbp</name> = <name>dbc</name>-&gt;<name>dbp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opd</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpf</name> = <name>dbp</name>-&gt;<name>mpf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hcp</name> = (<name>HASH_CURSOR</name> *)<name>dbc</name>-&gt;<name>internal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>

		<comment type="block">/*
		* In a perfect world, we could simply read each page in the file
		* and look at its page type to tally the information necessary.
		* Unfortunately, the bucket locking that hash tables do to make
		* locking easy, makes this a pain in the butt.  We have to traverse
		* duplicate, overflow and big pages from the bucket so that we
		* don't access anything that isn't properly locked.
		*
		*/</comment>
		<for>for (<init><expr><name>bucket</name> = 0</expr>;</init><condition>;</condition> <incr><expr><name>bucket</name>++</expr></incr>) <block>{
			<comment type="block">/*
			* We put the loop exit condition check here, because
			* it made for a really vile extended ?: that made SCO's
			* compiler drop core.
		 *
		 * If look_past_max is not set, we can stop at max_bucket;
		 * if it is set, we need to include pages that are part of
		 * the current doubling but beyond the highest bucket we've
		 * split into, as well as pages from a "future" doubling
		 * that may have been created within an aborted
		 * transaction.  To do this, keep looping (and incrementing
		 * bucket) until the corresponding spares array entries
		 * cease to be defined.
		 */</comment>
			<if>if <condition>(<expr><name>look_past_max</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>spares_entry</name> = <call><name><name>CDbLog2</name>::<name>db_log2</name></name><argument_list>(<argument><expr><name>bucket</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>spares_entry</name> &gt;= <name>NCACHED</name> ||
					<name>hcp</name>-&gt;<name>hdr</name>-&gt;<name><name>spares</name><index>[<expr><name>spares_entry</name></expr>]</index></name> == 0</expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><name>bucket</name> &gt; <name>hcp</name>-&gt;<name>hdr</name>-&gt;<name>max_bucket</name></expr>)</condition><then>
					<break>break;</break></then></if>
			}</block></else></if>

			<expr_stmt><expr><name>hcp</name>-&gt;<name>bucket</name> = <name>bucket</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hcp</name>-&gt;<name>pgno</name> = <name>pgno</name> = <call><name>BUCKET_TO_PAGE</name><argument_list>(<argument><expr><name>hcp</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_get_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ret</name> == 0</expr>;</condition>
				<incr><expr><name>ret</name> = <call><name><name>CHashPage</name>::<name>ham_next_cpage</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></incr>) <block>{

					<comment type="block">/*
					* If we are cleaning up pages past the max_bucket,
					* then they may be on the free list and have their
					* next pointers set, but they should be ignored.  In
					* fact, we really ought to just skip anybody who is
					* not a valid page.
					*/</comment>
					<if>if <condition>(<expr><call><name>TYPE</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call> == <name>P_INVALID</name></expr>)</condition><then>
						<break>break;</break></then></if>
					<expr_stmt><expr><name>pgno</name> = <call><name>NEXT_PGNO</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					* Go through each item on the page checking for
					* duplicates (in which case we have to count the
					* duplicate pages) or big key/data items (in which
					* case we have to count those pages).
					*/</comment>
					<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>NUM_ENT</name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
						<expr_stmt><expr><name>hk</name> = (<name>HKEYDATA</name> *)<call><name>P_ENTRY</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><call><name>HPAGE_PTYPE</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BTREE</name></cpp:ifdef>
<case>case <expr><name>H_OFFDUP</name></expr>:
	<block>{
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>opgno</name></expr></argument>, <argument><expr><call><name>HOFFDUP_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbCam</name>::<name>db_c_newopd</name></name><argument_list>(<argument><expr><name>dbc</name></expr></argument>,
			<argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>opd</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>

		<function_decl><type><name>CBTreeTraverse</name></type> <name>traverse</name><parameter_list>(<param><decl><type>*</type><name>opd</name></decl></param>, <param><decl><type><name>callback</name></type></decl></param>)</parameter_list>;</function_decl>
		<if>if <condition>(<expr>(<name>ret</name> = <name>traverse</name>.<call><name>bam_traverse</name><argument_list>(<argument><expr><name>DB_LOCK_READ</name></expr></argument>, <argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<goto>goto <name>err</name>;</goto></then></if>
		<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbCam</name>::<name>db_c_close</name></name><argument_list>(<argument><expr><name>opd</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
			<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
		<expr_stmt><expr><name>opd</name> = <name>NULL</name></expr>;</expr_stmt>
		<break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>H_OFFPAGE</name></expr>:
	<comment type="block">/*
	* We are about to get a big page
	* which will use the same spot that
	* the current page uses, so we need
	* to restore the current page before
	* looking at it again.
	*/</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>opgno</name></expr></argument>, <argument><expr><call><name>HOFFPAGE_PGNO</name><argument_list>(<argument><expr><name>hk</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>db_pgno_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CDbReclaim</name>::<name>db_traverse_big</name></name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
		<argument><expr><name>opgno</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
		<goto>goto <name>err</name>;</goto></then></if>
	<break>break;</break>
</case><case>case <expr><name>H_KEYDATA</name></expr>:
</case><case>case <expr><name>H_DUPLICATE</name></expr>:
	<break>break;</break>
</case><default>default:
	<expr_stmt><expr><call><name>DB_ASSERT</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> = <name>EINVAL</name></expr>;</expr_stmt>
	<goto>goto <name>err</name>;</goto>

						</default>}</block></switch>
					}</block></for>

					<comment type="block">/* Call the callback on main pages. */</comment>
					<if>if <condition>(<expr>(<name>ret</name> = <call><name>callback</name><argument_list>(<argument><expr><name>dbp</name></expr></argument>,
						<argument><expr><call><name>static_cast<argument_list>&lt;<argument><name>PAGE</name>*</argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cookie</name></expr></argument>, <argument><expr>&amp;<name>did_put</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
						<goto>goto <name>err</name>;</goto></then></if>

					<if>if <condition>(<expr><name>did_put</name></expr>)</condition><then>
						<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
					<if>if <condition>(<expr><name>pgno</name> == <name>PGNO_INVALID</name></expr>)</condition><then>
						<break>break;</break></then></if>
			}</block></for>
			<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
				<goto>goto <name>err</name>;</goto></then></if>

			<if>if <condition>(<expr><name>hcp</name>-&gt;<name>page</name> != <name>NULL</name></expr>)</condition><then> <block>{
				<if>if <condition>(<expr>(<name>ret</name> = <call><name><name>CMpFput</name>::<name>memp_fput</name></name><argument_list>(<argument><expr><name>mpf</name></expr></argument>, <argument><expr><name>hcp</name>-&gt;<name>page</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
					<return>return <expr>(<name>ret</name>)</expr>;</return></then></if>
				<expr_stmt><expr><name>hcp</name>-&gt;<name>page</name> = <name>NULL</name></expr>;</expr_stmt>
			}</block></then></if>

		}</block></for>
<label><name>err</name>:</label>	<if>if <condition>(<expr><name>opd</name> != <name>NULL</name> &amp;&amp;
			(<name>t_ret</name> = <call><name><name>CDbCam</name>::<name>db_c_close</name></name><argument_list>(<argument><expr><name>opd</name></expr></argument>)</argument_list></call>) != 0 &amp;&amp; <name>ret</name> == 0</expr>)</condition><then>
			<expr_stmt><expr><name>ret</name> = <name>t_ret</name></expr>;</expr_stmt></then></if>
		<return>return <expr>(<name>ret</name>)</expr>;</return>
	}</block></decl></decl_stmt>

 

	</public>
}</block></class>;</unit>