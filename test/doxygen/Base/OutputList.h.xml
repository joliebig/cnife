<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="" filename="OutputList.h"><comment type="block">/******************************************************************************
 *
 * $Id: outputlist.h,v 1.47 2001/03/19 19:27:41 root Exp $
 *
 * Copyright (C) 1997-2008 by Dimitri van Heesch.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation under the terms of the GNU General Public License is hereby 
 * granted. No representations are made about the suitability of this software 
 * for any purpose. It is provided "as is" without express or implied warranty.
 * See the GNU General Public License for more details.
 *
 * Documents produced by Doxygen are derivative works derived from the
 * input used in their production; they are not affected by this license.
 *
 */</comment>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> once</cpp:pragma>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qtbc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;qlist.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"index.h"</cpp:file></cpp:include> <comment type="line">// for IndexSections</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"outputgen.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"definition.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"docparser.h"</cpp:file></cpp:include>


<comment type="line">// one argument</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORALL1</name>(a1,p1)                                        \
	void OutputList::forall(void (OutputGenerator::*func)(a1),a1) \
{                                                             \
	OutputGenerator *og=outputs-&gt;first();                       \
	while (og)                                                  \
  {                                                           \
  if (og-&gt;isEnabled()) (og-&gt;*func)(p1);                     \
  og=outputs-&gt;next();                                       \
  }                                                           \
}</cpp:define>                     

<comment type="line">// two arguments</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORALL2</name>(a1,a2,p1,p2)                                        \
	void OutputList::forall(void (OutputGenerator::*func)(a1,a2),a1,a2) \
{                                                                   \
	OutputGenerator *og=outputs-&gt;first();                             \
	while (og)                                                        \
  {                                                                 \
  if (og-&gt;isEnabled()) (og-&gt;*func)(p1,p2);                        \
  og=outputs-&gt;next();                                             \
  }                                                                 \
}</cpp:define>                     

<comment type="line">// three arguments</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORALL3</name>(a1,a2,a3,p1,p2,p3)                                        \
	void OutputList::forall(void (OutputGenerator::*func)(a1,a2,a3),a1,a2,a3) \
{                                                                         \
	OutputGenerator *og=outputs-&gt;first();                                   \
	while (og)                                                              \
  {                                                                       \
  if (og-&gt;isEnabled()) (og-&gt;*func)(p1,p2,p3);                           \
  og=outputs-&gt;next();                                                   \
  }                                                                       \
}</cpp:define>                     

<comment type="line">// four arguments</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORALL4</name>(a1,a2,a3,a4,p1,p2,p3,p4)                                        \
	void OutputList::forall(void (OutputGenerator::*func)(a1,a2,a3,a4),a1,a2,a3,a4) \
{                                                                               \
	OutputGenerator *og=outputs-&gt;first();                                         \
	while (og)                                                                    \
  {                                                                             \
  if (og-&gt;isEnabled()) (og-&gt;*func)(p1,p2,p3,p4);                              \
  og=outputs-&gt;next();                                                         \
  }                                                                             \
}</cpp:define>                     

<comment type="line">// five arguments</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>FORALL5</name>(a1,a2,a3,a4,a5,p1,p2,p3,p4,p5)                                        \
	void OutputList::forall(void (OutputGenerator::*func)(a1,a2,a3,a4,a5),a1,a2,a3,a4,a5) \
{                                                                                     \
	OutputGenerator *og=outputs-&gt;first();                                               \
	while (og)                                                                          \
  {                                                                                   \
  if (og-&gt;isEnabled()) (og-&gt;*func)(p1,p2,p3,p4,p5);                                 \
  og=outputs-&gt;next();                                                               \
  }                                                                                   \
}</cpp:define>                     
  
<class_decl>class <name>ClassDiagram</name>;</class_decl>
<class_decl>class <name>DotClassGraph</name>;</class_decl>
<class_decl>class <name>DotDirDeps</name>;</class_decl>
<class_decl>class <name>DotInclDepGraph</name>;</class_decl>
<class_decl>class <name>DotGfxHierarchyTable</name>;</class_decl>
<class_decl>class <name>SectionDict</name>;</class_decl>
<class_decl>class <name>DotGroupCollaboration</name>;</class_decl>

<class>class <name>OutputList</name> <super>: <specifier>public</specifier> <name>OutputDocInterface</name></super>
<block>{<private type="default">
  </private><public>public:
	  <constructor><name>OutputList</name><parameter_list>(<param><decl><type><name>bool</name></type></decl></param>)</parameter_list>
	  <block>{
		  <comment type="line">//printf("OutputList::OutputList()\n");</comment>
		  <expr_stmt><expr><name>outputs</name> = new <name><name>QList</name><argument_list>&lt;<argument><name>OutputGenerator</name></argument>&gt;</argument_list></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>outputs</name>-&gt;<call><name>setAutoDelete</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  }</block></constructor>

	  <destructor><specifier>virtual</specifier> <name>~<name>OutputList</name></name><parameter_list>()</parameter_list>
	  <block>{
		  <comment type="line">//printf("OutputList::~OutputList()\n");</comment>
		  <expr_stmt><expr>delete <name>outputs</name></expr>;</expr_stmt>
	  }</block></destructor>

	  <function><type><name>void</name></type> <name>add</name><parameter_list>(<param><decl><type><name>const</name> <name>OutputGenerator</name> *</type><name>og</name></decl></param>)</parameter_list>
	  <block>{
		  <if>if <condition>(<expr><name>og</name></expr>)</condition><then> <expr_stmt><expr><name>outputs</name>-&gt;<call><name>append</name><argument_list>(<argument><expr><name>og</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	  }</block></function>
    
	  <function><type><name>void</name></type> <name>disableAllBut</name><parameter_list>(<param><decl><type><name><name>OutputGenerator</name>::<name>OutputType</name></name></type> <name>o</name></decl></param>)</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>disableIfNot</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>
	  <function><type><name>void</name></type> <name>enableAll</name><parameter_list>()</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>enable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>
	  <function><type><name>void</name></type> <name>disableAll</name><parameter_list>()</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>disable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>
	  <function><type><name>void</name></type> <name>disable</name><parameter_list>(<param><decl><type><name><name>OutputGenerator</name>::<name>OutputType</name></name></type> <name>o</name></decl></param>)</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>disableIf</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>
	  <function><type><name>void</name></type> <name>enable</name><parameter_list>(<param><decl><type><name><name>OutputGenerator</name>::<name>OutputType</name></name></type> <name>o</name></decl></param>)</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>enableIf</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>

	  <function><type><name>bool</name></type> <name>isEnabled</name><parameter_list>(<param><decl><type><name><name>OutputGenerator</name>::<name>OutputType</name></name></type> <name>o</name></decl></param>)</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>bool</name></type> <name>result</name>=<init><expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>result</name>=<name>result</name> || <name>og</name>-&gt;<call><name>isEnabled</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
		  <return>return <expr><name>result</name></expr>;</return>
	  }</block></function>
	  <function><type><name>void</name></type> <name>pushGeneratorState</name><parameter_list>()</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>pushGeneratorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>
	  <function><type><name>void</name></type> <name>popGeneratorState</name><parameter_list>()</parameter_list>
	  <block>{
		  <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <while>while <condition>(<expr><name>og</name></expr>)</condition>
		  <block>{
			  <expr_stmt><expr><name>og</name>-&gt;<call><name>popGeneratorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		  }</block></while>
	  }</block></function>



    <comment type="line">//////////////////////////////////////////////////</comment>
    <comment type="line">// OutputDocInterface implementation</comment>
    <comment type="line">//////////////////////////////////////////////////</comment>

    <function><type><name>void</name></type> <name>parseDoc</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fileName</name></decl></param>,<param><decl><type><name>int</name></type> <name>startLine</name></decl></param>,
                  <param><decl><type><name>Definition</name> *</type><name>ctx</name></decl></param>,<param><decl><type><name>MemberDef</name> *</type><name>md</name></decl></param>,<param><decl><type><name>const</name> <name>QCString</name> &amp;</type><name>docStr</name></decl></param>,
                  <param><decl><type><name>bool</name></type> <name>indexWords</name></decl></param>,<param><decl><type><name>bool</name></type> <name>isExample</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>exampleName</name>=<init><expr>0</expr></init></decl></param>,
				  <param><decl><type><name>bool</name></type> <name>singleLine</name>=<init><expr><name>FALSE</name></expr></init></decl></param>,<param><decl><type><name>bool</name></type> <name>linkFromIndex</name>=<init><expr><name>FALSE</name></expr></init></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>count</name>=<init><expr>0</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>docStr</name>.<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then> <return>return;</return></then></if>

		<decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>og</name></expr>)</condition>
		<block>{
			<if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<if>if <condition>(<expr><name>count</name>==0</expr>)</condition><then> <return>return;</return></then></if> <comment type="line">// no output formats enabled.</comment>

		<decl_stmt><decl><type><name>DocNode</name> *</type><name>root</name>=<init><expr>0</expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>docStr</name>.<call><name>at</name><argument_list>(<argument><expr><name>docStr</name>.<call><name>length</name><argument_list>()</argument_list></call>-1</expr></argument>)</argument_list></call>=='\n'</expr>)</condition><then>
		<block>{
			<expr_stmt><expr><name>root</name> = <call><name>validatingParseDoc</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>,<argument><expr><name>startLine</name></expr></argument>,
				<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>md</name></expr></argument>,<argument><expr><name>docStr</name></expr></argument>,<argument><expr><name>indexWords</name></expr></argument>,<argument><expr><name>isExample</name></expr></argument>,<argument><expr><name>exampleName</name></expr></argument>,
				<argument><expr><name>singleLine</name></expr></argument>,<argument><expr><name>linkFromIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then>
		<else>else
		<block>{
			<expr_stmt><expr><name>root</name> = <call><name>validatingParseDoc</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>,<argument><expr><name>startLine</name></expr></argument>,
				<argument><expr><name>ctx</name></expr></argument>,<argument><expr><name>md</name></expr></argument>,<argument><expr><name>docStr</name>+"\n"</expr></argument>,<argument><expr><name>indexWords</name></expr></argument>,<argument><expr><name>isExample</name></expr></argument>,<argument><expr><name>exampleName</name></expr></argument>,
				<argument><expr><name>singleLine</name></expr></argument>,<argument><expr><name>linkFromIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>

		<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>og</name></expr>)</condition>
		<block>{
			<comment type="line">//printf("og-&gt;printDoc(extension=%s)\n",</comment>
			<comment type="line">//    ctx?ctx-&gt;getDefFileExtension().data():"&lt;null&gt;");</comment>
			<if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>og</name>-&gt;<call><name>printDoc</name><argument_list>(<argument><expr><name>root</name></expr></argument>,<argument><expr><name>ctx</name>?<name>ctx</name>-&gt;<call><name>getDefFileExtension</name><argument_list>()</argument_list></call>:<call><name>QCString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></while>

		<expr_stmt><expr>delete <name>root</name></expr>;</expr_stmt>
	}</block></function>
	<function><type><name>void</name></type> <name>parseText</name><parameter_list>(<param><decl><type><name>const</name> <name>QCString</name> &amp;</type><name>textStr</name></decl></param>)</parameter_list>
	<block>{
		<decl_stmt><decl><type><name>int</name></type> <name>count</name>=<init><expr>0</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>og</name></expr>)</condition>
		<block>{
			<if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<if>if <condition>(<expr><name>count</name>==0</expr>)</condition><then> <return>return;</return></then></if> <comment type="line">// no output formats enabled.</comment>

		<decl_stmt><decl><type><name>DocNode</name> *</type><name>root</name> =<init> <expr><call><name>validatingParseText</name><argument_list>(<argument><expr><name>textStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>og</name></expr>)</condition>
		<block>{
			<if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>og</name>-&gt;<call><name>printDoc</name><argument_list>(<argument><expr><name>root</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></while>

		<expr_stmt><expr>delete <name>root</name></expr>;</expr_stmt>
	}</block></function>
    

    <function><type><name>void</name></type> <name>startIndexSection</name><parameter_list>(<param><decl><type><name>IndexSections</name></type> <name>is</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexSection</name></name></expr></argument>,<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexSection</name><parameter_list>(<param><decl><type><name>IndexSections</name></type> <name>is</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexSection</name></name></expr></argument>,<argument><expr><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writePageLink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,<param><decl><type><name>bool</name></type> <name>first</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writePageLink</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startProjectNumber</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startProjectNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endProjectNumber</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endProjectNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeStyleInfo</name><parameter_list>(<param><decl><type><name>int</name></type> <name>part</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeStyleInfo</name></name></expr></argument>,<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startFile</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>manName</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>title</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startFile</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>manName</name></expr></argument>,<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeFooter</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeFooter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endFile</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startTitleHead</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fileName</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startTitleHead</name></name></expr></argument>,<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endTitleHead</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fileName</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endTitleHead</name></name></expr></argument>,<argument><expr><name>fileName</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startTitle</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startTitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endTitle</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endTitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <comment type="line">//void newParagraph() </comment>
    <comment type="line">//{ forall(&amp;OutputGenerator::newParagraph); }</comment>
    <function><type><name>void</name></type> <name>startParagraph</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startParagraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endParagraph</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endParagraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeString</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>text</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeString</name></name></expr></argument>,<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startIndexListItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexListItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexListItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexListItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startIndexList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startIndexKey</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexKey</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startIndexValue</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>b</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexValue</name></name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexValue</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,<param><decl><type><name>bool</name></type> <name>b</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexValue</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startItemList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startItemList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endItemList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endItemList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startIndexItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>ref</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndexItem</name></name></expr></argument>,<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndexItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>ref</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndexItem</name></name></expr></argument>,<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>docify</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>docify</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>codify</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>codify</name></name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeObjectLink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>ref</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>,
                         <param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeObjectLink</name></name></expr></argument>,<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeCodeLink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>ref</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>,
                       <param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,
                       <param><decl><type><name>const</name> <name>char</name> *</type><name>tooltip</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeCodeLink</name></name></expr></argument>,<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>tooltip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startTextLink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startTextLink</name></name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endTextLink</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endTextLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startHtmlLink</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>url</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startHtmlLink</name></name></expr></argument>,<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endHtmlLink</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endHtmlLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeStartAnnoItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>type</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>, 
                            <param><decl><type><name>const</name> <name>char</name> *</type><name>path</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeStartAnnoItem</name></name></expr></argument>,<argument><expr><name>type</name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>path</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeEndAnnoItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeEndAnnoItem</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startTypewriter</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startTypewriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endTypewriter</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endTypewriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startGroupHeader</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startGroupHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endGroupHeader</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endGroupHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <comment type="line">//void writeListItem() </comment>
    <comment type="line">//{ forall(&amp;OutputGenerator::writeListItem); }</comment>
    <function><type><name>void</name></type> <name>startItemListItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startItemListItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endItemListItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endItemListItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberSections</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberSections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberSections</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberSections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberHeader</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberHeader</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberSubtitle</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberSubtitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberSubtitle</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberSubtitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberDocList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberDocList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberDocList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberDocList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startAnonTypeScope</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i1</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startAnonTypeScope</name></name></expr></argument>,<argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endAnonTypeScope</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i1</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endAnonTypeScope</name></name></expr></argument>,<argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberItem</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i1</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberItem</name></name></expr></argument>,<argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberTemplateParams</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberTemplateParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberTemplateParams</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberTemplateParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberGroupHeader</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>b</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberGroupHeader</name></name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberGroupHeader</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberGroupHeader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberGroupDocs</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberGroupDocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberGroupDocs</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberGroupDocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberGroup</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberGroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberGroup</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>last</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberGroup</name></name></expr></argument>,<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>insertMemberAlign</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>templ</name>=<init><expr><name>FALSE</name></expr></init></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>insertMemberAlign</name></name></expr></argument>,<argument><expr><name>templ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeRuler</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeRuler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeAnchor</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fileName</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeAnchor</name></name></expr></argument>,<argument><expr><name>fileName</name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startCodeFragment</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startCodeFragment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endCodeFragment</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endCodeFragment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startCodeLine</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startCodeLine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endCodeLine</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endCodeLine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeLineNumber</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>ref</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>,
                         <param><decl><type><name>int</name></type> <name>lineNumber</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeLineNumber</name></name></expr></argument>,<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>lineNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startEmphasis</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startEmphasis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endEmphasis</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endEmphasis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeChar</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeChar</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberDoc</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>clName</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>memName</name></decl></param>,
                        <param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>title</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberDoc</name></name></expr></argument>,<argument><expr><name>clName</name></expr></argument>,<argument><expr><name>memName</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberDoc</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>hasArgs</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberDoc</name></name></expr></argument>,<argument><expr><name>hasArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDoxyAnchor</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fName</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>manName</name></decl></param>,
                         <param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>,
                         <param><decl><type><name>const</name> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDoxyAnchor</name></name></expr></argument>,<argument><expr><name>fName</name></expr></argument>,<argument><expr><name>manName</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDoxyAnchor</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>fn</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDoxyAnchor</name></name></expr></argument>,<argument><expr><name>fn</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startCodeAnchor</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>label</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startCodeAnchor</name></name></expr></argument>,<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endCodeAnchor</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endCodeAnchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeLatexSpacing</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeLatexSpacing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescription</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescription</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescription</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescription</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescForItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescForItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescForItem</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescForItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startSubsection</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startSubsection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endSubsection</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endSubsection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startSubsubsection</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startSubsubsection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endSubsubsection</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endSubsubsection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startCenter</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startCenter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endCenter</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endCenter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startSmall</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startSmall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endSmall</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endSmall</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>lineBreak</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>style</name>=<init><expr>0</expr></init></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>lineBreak</name></name></expr></argument>,<argument><expr><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startBold</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startBold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endBold</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endBold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberDescription</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberDescription</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberDescription</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberDescription</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startSimpleSect</name><parameter_list>(<param><decl><type><name>SectionTypes</name></type> <name>t</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>file</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>anchor</name></decl></param>,
                         <param><decl><type><name>const</name> <name>char</name> *</type><name>title</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startSimpleSect</name></name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>file</name></expr></argument>,<argument><expr><name>anchor</name></expr></argument>,<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endSimpleSect</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endSimpleSect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startParamList</name><parameter_list>(<param><decl><type><name>ParamListTypes</name></type> <name>t</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>title</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startParamList</name></name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endParamList</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endParamList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <comment type="line">//void writeDescItem() </comment>
    <comment type="line">//{ forall(&amp;OutputGenerator::writeDescItem); }</comment>
    <function><type><name>void</name></type> <name>startIndent</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startIndent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endIndent</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endIndent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startSection</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>lab</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>title</name></decl></param>,<param><decl><type><name><name>SectionInfo</name>::<name>SectionType</name></name></type> <name>t</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startSection</name></name></expr></argument>,<argument><expr><name>lab</name></expr></argument>,<argument><expr><name>title</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endSection</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>lab</name></decl></param>,<param><decl><type><name><name>SectionInfo</name>::<name>SectionType</name></name></type> <name>t</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endSection</name></name></expr></argument>,<argument><expr><name>lab</name></expr></argument>,<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>addIndexItem</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>s1</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>s2</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>addIndexItem</name></name></expr></argument>,<argument><expr><name>s1</name></expr></argument>,<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeSynopsis</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeSynopsis</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startClassDiagram</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startClassDiagram</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endClassDiagram</name><parameter_list>(<param><decl><type><name>const</name> <name>ClassDiagram</name> &amp;</type><name>d</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>f</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>n</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endClassDiagram</name></name></expr></argument>,<argument><expr><name>d</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startPageRef</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startPageRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endPageRef</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>c</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>a</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endPageRef</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>,<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startQuickIndices</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startQuickIndices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endQuickIndices</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endQuickIndices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeQuickLinks</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>compact</name></decl></param>,<param><decl><type><name>HighlightedItem</name></type> <name>hli</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeQuickLinks</name></name></expr></argument>,<argument><expr><name>compact</name></expr></argument>,<argument><expr><name>hli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startContents</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startContents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endContents</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endContents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeNonBreakableSpace</name><parameter_list>(<param><decl><type><name>int</name></type> <name>num</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeNonBreakableSpace</name></name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescTable</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescTable</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescTableTitle</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescTableTitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescTableTitle</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescTableTitle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDescTableData</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDescTableData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDescTableData</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDescTableData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDotGraph</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDotGraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDotGraph</name><parameter_list>(<param><decl><type><name>const</name> <name>DotClassGraph</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDotGraph</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startInclDepGraph</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startInclDepGraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endInclDepGraph</name><parameter_list>(<param><decl><type><name>const</name> <name>DotInclDepGraph</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endInclDepGraph</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startCallGraph</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startCallGraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endCallGraph</name><parameter_list>(<param><decl><type><name>const</name> <name>DotCallGraph</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endCallGraph</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startDirDepGraph</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startDirDepGraph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endDirDepGraph</name><parameter_list>(<param><decl><type><name>const</name> <name>DotDirDeps</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endDirDepGraph</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startGroupCollaboration</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startGroupCollaboration</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endGroupCollaboration</name><parameter_list>(<param><decl><type><name>const</name> <name>DotGroupCollaboration</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endGroupCollaboration</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeGraphicalHierarchy</name><parameter_list>(<param><decl><type><name>const</name> <name>DotGfxHierarchyTable</name> &amp;</type><name>g</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeGraphicalHierarchy</name></name></expr></argument>,<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startTextBlock</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>dense</name>=<init><expr><name>FALSE</name></expr></init></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startTextBlock</name></name></expr></argument>,<argument><expr><name>dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endTextBlock</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>paraBreak</name>=<init><expr><name>FALSE</name></expr></init></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endTextBlock</name></name></expr></argument>,<argument><expr><name>paraBreak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>lastIndexPage</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>lastIndexPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberDocPrefixItem</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberDocPrefixItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberDocPrefixItem</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberDocPrefixItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startMemberDocName</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>align</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startMemberDocName</name></name></expr></argument>,<argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endMemberDocName</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endMemberDocName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startParameterType</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>first</name></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startParameterType</name></name></expr></argument>,<argument><expr><name>first</name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endParameterType</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endParameterType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startParameterName</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>one</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startParameterName</name></name></expr></argument>,<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endParameterName</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>last</name></decl></param>,<param><decl><type><name>bool</name></type> <name>one</name></decl></param>,<param><decl><type><name>bool</name></type> <name>bracket</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endParameterName</name></name></expr></argument>,<argument><expr><name>last</name></expr></argument>,<argument><expr><name>one</name></expr></argument>,<argument><expr><name>bracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startParameterList</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>openBracket</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startParameterList</name></name></expr></argument>,<argument><expr><name>openBracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endParameterList</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endParameterList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><name>void</name></type> <name>startConstraintList</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>header</name></decl></param>)</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startConstraintList</name></name></expr></argument>,<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startConstraintParam</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startConstraintParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endConstraintParam</name><parameter_list>()</parameter_list> 
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endConstraintParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startConstraintType</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startConstraintType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endConstraintType</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endConstraintType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startConstraintDocs</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startConstraintDocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endConstraintDocs</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endConstraintDocs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endConstraintList</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endConstraintList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startFontClass</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>c</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>startFontClass</name></name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>endFontClass</name><parameter_list>()</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>endFontClass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>writeCodeAnchor</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>forall</name><argument_list>(<argument><expr>&amp;<name><name>OutputGenerator</name>::<name>writeCodeAnchor</name></name></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
    <function><type><name>void</name></type> <name>startPlainFile</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
    <block>{ 
      <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>og</name></expr>)</condition>
      <block>{
        <if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr>(<name>og</name>-&gt;<name>startPlainFile</name>)(<name>name</name>)</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
    }</block></function>
    <function><type><name>void</name></type> <name>endPlainFile</name><parameter_list>()</parameter_list> 
    <block>{ 
      <decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>og</name></expr>)</condition>
      <block>{
        <if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr>(<name>og</name>-&gt;<name>endPlainFile</name>)()</expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
    }</block></function>
    <function><type><name>void</name></type> <name>linkableSymbol</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>,<param><decl><type><name>const</name> <name>char</name> *</type></decl></param>,<param><decl><type><name>Definition</name> *</type></decl></param>,<param><decl><type><name>Definition</name> *</type></decl></param>)</parameter_list> <block>{}</block></function>



  </public><private>private:
    <function_decl><type><name>void</name></type> <name>debug</name><parameter_list>()</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>
    
	<decl_stmt><decl><type><name>void</name></type> <name>forall</name><argument_list>(<argument><expr><call><name>void</name> <argument_list>(<argument><expr><name><name>OutputGenerator</name>::</name>*<name>func</name></expr></argument>)</argument_list></call>()</expr></argument>)</argument_list>
	<block>{
		<decl_stmt><decl><type><name>OutputGenerator</name> *</type><name>og</name>=<init><expr><name>outputs</name>-&gt;<call><name>first</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>og</name></expr>)</condition>
		<block>{
			<if>if <condition>(<expr><name>og</name>-&gt;<call><name>isEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then> <expr_stmt><expr>(<name>og</name>-&gt;*<name>func</name>)()</expr>;</expr_stmt></then></if>
			<expr_stmt><expr><name>og</name>=<name>outputs</name>-&gt;<call><name>next</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	}</block></decl></decl_stmt>
	<macro><name>FORALL1</name><argument_list>(<argument>const char *a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>char a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>int a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotClassGraph &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotInclDepGraph &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotCallGraph &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotDirDeps &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotGfxHierarchyTable &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>const DotGroupCollaboration &amp;a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>SectionTypes a1</argument>,<argument>a1</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAS_BOOL_TYPE</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>Q_HAS_BOOL_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<macro><name>FORALL1</name><argument_list>(<argument>bool a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>bool a1</argument>,<argument>int a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>bool a1</argument>,<argument>bool a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL4</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>bool a4</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>,<argument>a4</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<macro><name>FORALL2</name><argument_list>(<argument>int a1</argument>,<argument>bool a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>bool a1</argument>,<argument>HighlightedItem a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>bool a1</argument>,<argument>const char *a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>ParamListTypes a1</argument>,<argument>const char *a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL1</name><argument_list>(<argument>IndexSections a1</argument>,<argument>a1</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>const char *a1</argument>,<argument>bool a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL2</name><argument_list>(<argument>const char *a1</argument>,<argument>SectionInfo::SectionType a2</argument>,<argument>a1</argument>,<argument>a2</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>bool a1</argument>,<argument>bool a2</argument>,<argument>bool a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>const ClassDiagram &amp;a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>bool a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>SectionInfo::SectionType a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL3</name><argument_list>(<argument>uchar a1</argument>,<argument>uchar a2</argument>,<argument>uchar a3</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>)</argument_list></macro>
	<macro><name>FORALL4</name><argument_list>(<argument>SectionTypes a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>const char *a4</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>,<argument>a4</argument>)</argument_list></macro>
	<macro><name>FORALL4</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>const char *a4</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>,<argument>a4</argument>)</argument_list></macro>
	<macro><name>FORALL4</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>int a4</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>,<argument>a4</argument>)</argument_list></macro>
	<macro><name>FORALL5</name><argument_list>(<argument>const char *a1</argument>,<argument>const char *a2</argument>,<argument>const char *a3</argument>,<argument>const char *a4</argument>,<argument>const char *a5</argument>,<argument>a1</argument>,<argument>a2</argument>,<argument>a3</argument>,<argument>a4</argument>,<argument>a5</argument>)</argument_list></macro>
  
    <constructor_decl><name>OutputList</name><parameter_list>(<param><decl><type><name>const</name> <name>OutputList</name> &amp;</type><name>ol</name></decl></param>)</parameter_list>;</constructor_decl>
    <decl_stmt><decl><type><name><name>QList</name><argument_list>&lt;<argument><name>OutputGenerator</name></argument>&gt;</argument_list></name> *</type><name>outputs</name></decl>;</decl_stmt>
</private>}</block>;</class>

</unit>
