<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" dir="" filename="suggestmgr.hxx"><cpp:pragma>#<cpp:directive>pragma</cpp:directive> once</cpp:pragma>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXSWL</name> 100</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXSWUTF8L</name> (MAXSWL * 4)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_ROOTS</name> 100</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_WORDS</name> 100</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAX_GUESS</name> 200</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXNGRAMSUGS</name> 4</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXPHONSUGS</name> 2</cpp:define>

<comment type="line">// timelimit: max ~1/4 sec (process time on Linux) for a time consuming function</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>TIMELIMIT</name> (CLOCKS_PER_SEC &gt;&gt; 2)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MINTIMER</name> 100</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>MAXPLUSTIMER</name> 100</cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <name>NGRAM_LONGER_WORSE</name>  (1 &lt;&lt; 0)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>NGRAM_ANY_MISMATCH</name>  (1 &lt;&lt; 1)</cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <name>NGRAM_LOWERING</name>      (1 &lt;&lt; 2)</cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atypes.hxx"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"affixmgr.hxx"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hashmgr.hxx"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"langnum.hxx"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<enum>enum <block>{ <expr><name>LCS_UP</name></expr>, <expr><name>LCS_LEFT</name></expr>, <expr><name>LCS_UPLEFT</name></expr> }</block>;</enum>

<class>class <name>SuggestMgr</name>
<block>{<private type="default">
  <decl_stmt><decl><type><name>char</name> *</type>          <name>ckey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>ckeyl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name> *</type>        <name>ckey_utf</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> *</type>          <name>ctry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>ctryl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>w_char</name> *</type>        <name>ctry_utf</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>AffixMgr</name>*</type>       <name>pAMgr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>maxSug</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>cs_info</name> *</type> <name>csconv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>utf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>langnum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>nosplitsugs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>maxngramsugs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>             <name>complexprefixes</name></decl>;</decl_stmt>


</private><public>public:
  <constructor_decl><name>SuggestMgr</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>tryme</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxn</name></decl></param>, <param><decl><type><name>AffixMgr</name> *</type><name>aptr</name></decl></param>)</parameter_list>;</constructor_decl>
  <destructor_decl><name>~<name>SuggestMgr</name></name><parameter_list>()</parameter_list>;</destructor_decl>

  <function_decl><type><name>int</name></type> <name>suggest</name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>onlycmpdsug</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> <name>ngsuggest</name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>HashMgr</name>**</type> <name>pHMgr</name></decl></param>, <param><decl><type><name>int</name></type> <name>md</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> <name>suggest_auto</name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> <name>suggest_stems</name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>int</name></type> <name>suggest_pos_stems</name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>;</function_decl>

  <function_decl><type><name>char</name> *</type> <name>suggest_morph</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>char</name> *</type> <name>suggest_gen</name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>pl</name></decl></param>, <param><decl><type><name>int</name></type> <name>pln</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>pattern</name></decl></param>)</parameter_list>;</function_decl>
  <function_decl><type><name>char</name> *</type> <name>suggest_morph_for_spelling_error</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list>;</function_decl>

</public><private>private:
   <function_decl><type><name>int</name></type> <name>testsug</name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>candidate</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>,
     <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>clock_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>checkword</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>clock_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>check_forbidden</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

   <function_decl><type><name>int</name></type> <name>capchars</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>replchars</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>doubletwochars</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>forgotchar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>swapchar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>longswapchar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>movechar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>extrachar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>badcharkey</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>badchar</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>twowords</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>fixstems</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

   <function_decl><type><name>int</name></type> <name>capchars_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>doubletwochars_utf</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>forgotchar_utf</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>extrachar_utf</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>badcharkey_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>badchar_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>swapchar_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>longswapchar_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>movechar_utf</name><parameter_list>(<param><decl><type><name>char</name> **</type></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

   <function_decl><type><name>int</name></type> <name>mapchars</name><parameter_list>(<param><decl><type><name>char</name>**</type></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>map_related</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>const</name> <name>mapentry</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>clock_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>map_related_utf</name><parameter_list>(<param><decl><type><name>w_char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>const</name> <name>mapentry</name>*</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>clock_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>ngram</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name></type> <name>opt</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>mystrlen</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>leftcommonsubstring</name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>commoncharacterpositions</name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>is_swap</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>void</name></type> <name>bubblesort</name><parameter_list>( <param><decl><type><name>char</name> **</type> <name>rwd</name></decl></param>, <param><decl><type><name>char</name> **</type> <name>rwd2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>rsc</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>void</name></type> <name>lcs</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l1</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l2</name></decl></param>, <param><decl><type><name>char</name> **</type> <name>result</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>int</name></type> <name>lcslen</name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><name>const</name> <name>char</name>*</type> <name>s2</name></decl></param>)</parameter_list>;</function_decl>
   <function_decl><type><name>char</name> *</type> <name>suggest_hentry_gen</name><parameter_list>(<param><decl><type><name>hentry</name> *</type> <name>rv</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>pattern</name></decl></param>)</parameter_list>;</function_decl>

</private>}</block>;</class>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"license.hunspell"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"license.myspell"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<comment type="line">//#include "suggestmgr.hxx"</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"htypes.hxx"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"csutil.hxx"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>const</name> <name>w_char</name></type> <name>W_VLINE</name> =<init> <expr><block>{ <expr>'\0'</expr>, <expr>'|'</expr> }</block></expr></init></decl>;</decl_stmt>

<constructor><name><name>SuggestMgr</name>::<name>SuggestMgr</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>tryme</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxn</name></decl></param>, 
					   <param><decl><type><name>AffixMgr</name> *</type> <name>aptr</name></decl></param>)</parameter_list>
<block>{

	<comment type="line">// register affix manager and check in string of chars to </comment>
	<comment type="line">// try when building candidate suggestions</comment>
	<expr_stmt><expr><name>pAMgr</name> = <name>aptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ckeyl</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>ckey</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckey_utf</name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctryl</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>ctry</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctry_utf</name> = <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>utf8</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>langnum</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>complexprefixes</name> = 0</expr>;</expr_stmt>  

	<expr_stmt><expr><name>maxSug</name> = <name>maxn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nosplitsugs</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>maxngramsugs</name> = <name>MAXNGRAMSUGS</name></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type> <name>enc</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>get_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>csconv</name> = <call><name>get_current_cs</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>langnum</name> = <name>pAMgr</name>-&gt;<call><name>get_langnum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ckey</name> = <name>pAMgr</name>-&gt;<call><name>get_key_string</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nosplitsugs</name> = <name>pAMgr</name>-&gt;<call><name>get_nosplitsugs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>pAMgr</name>-&gt;<call><name>get_maxngramsugs</name><argument_list>()</argument_list></call> &gt;= 0</expr>)</condition><then> <expr_stmt><expr><name>maxngramsugs</name> = <name>pAMgr</name>-&gt;<call><name>get_maxngramsugs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>utf8</name> = <name>pAMgr</name>-&gt;<call><name>get_utf8</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>complexprefixes</name> = <name>pAMgr</name>-&gt;<call><name>get_complexprefixes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>ckey</name></expr>)</condition><then> <block>{  
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>w_char</name></type> <name><name>t</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>    
			<expr_stmt><expr><name>ckeyl</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>ckey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ckey_utf</name> = (<name>w_char</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>ckeyl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ckey_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ckey_utf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>ckeyl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>ckeyl</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>ckey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>tryme</name></expr>)</condition><then> <block>{  
		<expr_stmt><expr><name>ctry</name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>tryme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ctry</name></expr>)</condition><then> <expr_stmt><expr><name>ctryl</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>ctry</name> &amp;&amp; <name>utf8</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>w_char</name></type> <name><name>t</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>    
			<expr_stmt><expr><name>ctryl</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>tryme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ctry_utf</name> = (<name>w_char</name> *) <call><name>malloc</name><argument_list>(<argument><expr><name>ctryl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ctry_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctry_utf</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>ctryl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
			<else>else <expr_stmt><expr><name>ctryl</name> = 0</expr>;</expr_stmt></else></if>
		}</block></then></if>
	}</block></then></if>
}</block></constructor>


<destructor><name><name>SuggestMgr</name>::~<name>SuggestMgr</name></name><parameter_list>()</parameter_list>
<block>{
	<expr_stmt><expr><name>pAMgr</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ckey</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ckey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>ckey</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ckey_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ckey_utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>ckey_utf</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ckeyl</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ctry</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>ctry</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ctry_utf</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctry_utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>ctry_utf</name> = <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctryl</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name>maxSug</name> = 0</expr>;</expr_stmt>
}</block></destructor>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>testsug</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>candidate</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>,
						<param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>clock_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list> <block>{
							<decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
							<if>if <condition>(<expr><name>ns</name> == <name>maxSug</name></expr>)</condition><then> <return>return <expr><name>maxSug</name></expr>;</return></then></if>
							<for>for (<init><decl><type><name>int</name></type> <name>k</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
								<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if>
							}</block></for>
							<if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; <call><name>checkword</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
								<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
									<for>for (<init><decl><type><name>int</name></type> <name>j</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>j</name>&lt;<name>ns</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
									<return>return <expr>-1</expr>;</return>
								}</block></then></if>
								<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
							}</block></then></if> 
							<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// generate suggestions for a mispelled word</comment>
<comment type="line">//    pass in address of array of char * pointers</comment>
<comment type="line">// onlycompoundsug: probably bad suggestions (need for ngram sugs, too)</comment>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>,
						<param><decl><type><name>int</name> *</type> <name>onlycompoundsug</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nocompoundtwowords</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>    
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>word_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type> <name>word</name> =<init> <expr><name>w</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// word reversing wrapper for complex prefixes</comment>
	<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>malloc</name><argument_list>(<argument><expr><name>maxSug</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		}</block></for>
	}</block></else></if>

	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>wl</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<for>for (<init><decl><type><name>int</name></type> <name>cpdsuggest</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr>(<name>cpdsuggest</name>&lt;2) &amp;&amp; (<name>nocompoundtwowords</name>==0)</expr>;</condition> <incr><expr><name>cpdsuggest</name>++</expr></incr>) <block>{

		<comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>capchars_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>capchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// perhaps we made a typical fault of spelling</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then>
			<expr_stmt><expr><name>nsug</name> = <call><name>replchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<comment type="line">// perhaps we made chose the wrong char from a related set</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = <call><name>mapchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we swap the order of chars by mistake</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>swapchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>swapchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we swap the order of non adjacent chars by mistake</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>longswapchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>longswapchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we just hit the wrong key in place of a good char (case and keyboard)</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>badcharkey_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>badcharkey</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// only suggest compound words when no other suggestion</comment>
		<if>if <condition>(<expr>(<name>cpdsuggest</name> == 0) &amp;&amp; (<name>nsug</name> &gt; 0)</expr>)</condition><then> <expr_stmt><expr><name>nocompoundtwowords</name>=1</expr>;</expr_stmt></then></if>

		<comment type="line">// did we add a char that should not be there</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>extrachar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>extrachar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>


		<comment type="line">// did we forgot a char</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>forgotchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>forgotchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we move a char</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>movechar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>movechar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we just hit the wrong key in place of a good char</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>badchar_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>badchar</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// did we double two characters</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = (<name>utf8</name>) ? <call><name>doubletwochars_utf</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call> :
				<call><name>doubletwochars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<comment type="line">// perhaps we forgot to hit space and two words ran together</comment>
		<if>if <condition>(<expr>(!<name>nosplitsugs</name>) &amp;&amp; (<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = <call><name>twowords</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

	}</block></for> <comment type="line">// repeating ``for'' statement compounding support</comment>

	<if>if <condition>(<expr><name>nsug</name> &lt; 0</expr>)</condition><then> <block>{
		<comment type="line">// we ran out of memory - we should free up as much as possible</comment>
		<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wlst</name> = <name>NULL</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr>!<name>nocompoundtwowords</name> &amp;&amp; (<name>nsug</name> &gt; 0) &amp;&amp; <name>onlycompoundsug</name></expr>)</condition><then> <expr_stmt><expr>*<name>onlycompoundsug</name> = 1</expr>;</expr_stmt></then></if>

	<expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
	<return>return <expr><name>nsug</name></expr>;</return>
}</block></function>

<comment type="line">// generate suggestions for a word with typical mistake</comment>
<comment type="line">//    pass in address of array of char * pointers</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUNSPELL_EXPERIMENTAL</name></cpp:ifdef>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest_auto</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nocompoundtwowords</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type> <name>word</name> =<init> <expr><name>w</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// word reversing wrapper for complex prefixes</comment>
	<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>malloc</name><argument_list>(<argument><expr><name>maxSug</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>

	<for>for (<init><decl><type><name>int</name></type> <name>cpdsuggest</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr>(<name>cpdsuggest</name>&lt;2) &amp;&amp; (<name>nocompoundtwowords</name>==0)</expr>;</condition> <incr><expr><name>cpdsuggest</name>++</expr></incr>) <block>{

		<comment type="line">// perhaps we made a typical fault of spelling</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then>
			<expr_stmt><expr><name>nsug</name> = <call><name>replchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<comment type="line">// perhaps we made chose the wrong char from a related set</comment>
		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1)</expr>)</condition><then>
			<expr_stmt><expr><name>nsug</name> = <call><name>mapchars</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<if>if <condition>(<expr>(<name>cpdsuggest</name>==0) &amp;&amp; (<name>nsug</name>&gt;0)</expr>)</condition><then> <expr_stmt><expr><name>nocompoundtwowords</name>=1</expr>;</expr_stmt></then></if>

		<comment type="line">// perhaps we forgot to hit space and two words ran together</comment>

		<if>if <condition>(<expr>(<name>nsug</name> &lt; <name>maxSug</name>) &amp;&amp; (<name>nsug</name> &gt; -1) &amp;&amp; <call><name>check_forbidden</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nsug</name> = <call><name>twowords</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nsug</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

	}</block></for> <comment type="line">// repeating ``for'' statement compounding support</comment>

	<if>if <condition>(<expr><name>nsug</name> &lt; 0</expr>)</condition><then> <block>{
		<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>maxSug</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
			<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr>-1</expr>;</return>
	}</block></then></if>

	<expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
	<return>return <expr><name>nsug</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// END OF HUNSPELL_EXPERIMENTAL CODE</comment>

<comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>capchars_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mkallcap_utf</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// suggestions for an uppercase word (html -&gt; HTML)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>capchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mkallcap</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// suggestions for when chose the wrong char out of a related set</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>mapchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>clock_t</name></type> <name>timelimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timer</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 2 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>int</name></type> <name>nummap</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>get_nummap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>mapentry</name>*</type> <name>maptable</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>get_maptable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>maptable</name>==<name>NULL</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>

	<expr_stmt><expr><name>timelimit</name> = <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>timer</name> = <name>MINTIMER</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>map_related</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, 
							<param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>,  <param><decl><type><name>int</name></type> <name>ns</name></decl></param>,
							<param><decl><type><name>const</name> <name>mapentry</name>*</type> <name>maptable</name></decl></param>, <param><decl><type><name>int</name></type> <name>nummap</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>clock_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name>c</name> =<init> <expr>*(<name>word</name> + <name>i</name>)</expr></init></decl>;</decl_stmt>  
	<if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for (<init><decl><type><name>int</name></type> <name>m</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>m</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>m</name>++</expr></incr>)
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
		<if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; <call><name>checkword</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><name>ns</name></expr>;</return>
	}</block></then></if> 
	<decl_stmt><decl><type><name>int</name></type> <name>in_map</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nummap</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
			<expr_stmt><expr><name>in_map</name> = 1</expr>;</expr_stmt>
			<decl_stmt><decl><type><name>char</name> *</type> <name>newword</name> =<init> <expr><call><name>mystrdup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr>!<name>newword</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>len</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
				<expr_stmt><expr>*(<name>newword</name> + <name>i</name>) = *(<name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set</name> + <name>k</name>)</expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr>(<name>i</name>+1)</expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>,
					<argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!(*<name>timer</name>)</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
			}</block></for>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr>!<name>in_map</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>map_related</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>,
			<argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>map_related_utf</name></name><parameter_list>(<param><decl><type><name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>,
								<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>const</name> <name>mapentry</name>*</type> <name>maptable</name></decl></param>, <param><decl><type><name>int</name></type> <name>nummap</name></decl></param>,
								<param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>clock_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list> 
<block>{
	<if>if <condition>(<expr><name>i</name> == <name>len</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>cwrd</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>wl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wl</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><decl><type><name>int</name></type> <name>m</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>m</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>m</name>++</expr></incr>)
			<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
		<if>if <condition>(<expr>(<name>cwrd</name>) &amp;&amp; <call><name>checkword</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then></if>
		<return>return <expr><name>ns</name></expr>;</return>
	}</block></then></if> 
	<decl_stmt><decl><type><name>int</name></type> <name>in_map</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name> =<init> <expr>*((<name>unsigned</name> <name>short</name> *) <name>word</name> + <name>i</name>)</expr></init></decl>;</decl_stmt>
	<for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nummap</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<if>if <condition>(<macro><name>flag_bsearch</name><argument_list>(<argument>(unsigned short *) maptable[j].set_utf16</argument>, <argument>c</argument>, <argument>maptable[j].len</argument>)</argument_list></macro>)</condition><then> <block>{
			<expr_stmt><expr><name>in_map</name> = 1</expr>;</expr_stmt>
			<for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>len</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
				<expr_stmt><expr>*(<name>word</name> + <name>i</name>) = *(<name><name>maptable</name><index>[<expr><name>j</name></expr>]</index></name>.<name>set_utf16</name> + <name>k</name>)</expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>,
					<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr>!(*<name>timer</name>)</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
			}</block></for>
			<expr_stmt><expr>*((<name>unsigned</name> <name>short</name> *) <name>word</name> + <name>i</name>) = <name>c</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>
	<if>if <condition>(<expr>!<name>in_map</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>map_related_utf</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>,
			<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>maptable</name></expr></argument>, <argument><expr><name>nummap</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>, <argument><expr><name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>



<comment type="line">// suggestions for a typical fault of spelling, that</comment>
<comment type="line">// differs with more, than 1 letter from the right form.</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>replchars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lenr</name>, <name>lenp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 2 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<decl_stmt><decl><type><name>int</name></type> <name>numrep</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>get_numrep</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type>struct <name>replentry</name>*</type> <name>reptable</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>get_reptable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>reptable</name>==<name>NULL</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>numrep</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> ) <block>{
		<expr_stmt><expr><name>r</name> = <name>word</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenr</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lenp</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// search every occurence of the pattern in the word</comment>
		<while>while <condition>(<expr>(<name>r</name>=<call><name>strstr</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>r</name>-<name>word</name> + <name>lenr</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>r</name>+<name>lenp</name></expr></argument>)</argument_list></call> &gt;= <name>MAXSWUTF8L</name></expr>)</condition><then> <break>break;</break></then></if>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+(<name>r</name>-<name>word</name>)</expr></argument>,<argument><expr><name><name>reptable</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pattern2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+(<name>r</name>-<name>word</name>)+<name>lenr</name></expr></argument>, <argument><expr><name>r</name>+<name>lenp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-<name>lenp</name>+<name>lenr</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<comment type="line">// check REP suggestions with space</comment>
			<decl_stmt><decl><type><name>char</name> *</type> <name>sp</name> =<init> <expr><call><name>strchr</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>sp</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>sp</name> = '\0'</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>checkword</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<decl_stmt><decl><type><name>int</name></type> <name>oldns</name> =<init> <expr><name>ns</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr>*<name>sp</name> = ' '</expr>;</expr_stmt>
					<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>sp</name> + 1</expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>sp</name> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
					<if>if <condition>(<expr><name>oldns</name> &lt; <name>ns</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>ns</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name> - 1</expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr>!<name><name>wlst</name><index>[<expr><name>ns</name> - 1</expr>]</index></name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
					}</block></then></if>
				}</block></then></if>            
				<expr_stmt><expr>*<name>sp</name> = ' '</expr>;</expr_stmt>
			}</block></then></if>
			<expr_stmt><expr><name>r</name>++</expr>;</expr_stmt> <comment type="line">// search for the next letter</comment>
		}</block></while>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// perhaps we doubled two characters (pattern aba -&gt; ababa, for example vacation -&gt; vacacation)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>doubletwochars</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>state</name>=<init><expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 5 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>2</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr> ) <block>{
		<if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>==<name><name>word</name><index>[<expr><name>i</name>-2</expr>]</index></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>state</name>==3</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name>+<name>i</name>-1</expr></argument>,<argument><expr><name>word</name>+<name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-2</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// perhaps we doubled two characters (pattern aba -&gt; ababa, for example vacation -&gt; vacacation)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>doubletwochars_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type>        <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>          <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>state</name>=<init><expr>0</expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 5 || ! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>2</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><call><name>w_char_eq</name><argument_list>(<argument><expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>word</name><index>[<expr><name>i</name>-2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>  <block>{
			<expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
			<if>if <condition>(<expr><name>state</name>==3</expr>)</condition><then> <block>{
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr>(<name>i</name> - 1) * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name>+<name>i</name>-1</expr></argument>, <argument><expr><name>word</name>+<name>i</name>+1</expr></argument>, <argument><expr>(<name>wl</name>-<name>i</name>-1) * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
			}</block></then></if>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>state</name>=0</expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one (case and keyboard related version)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badcharkey</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type>  <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>  <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// swap out each char one by one and try uppercase and neighbor</comment>
	<comment type="line">// keyboard chars in its place to see if that makes a good word</comment>

	<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>tmpc</name> = <name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="line">// check with uppercase letters</comment>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>csconv</name><index>[<expr>((<name>unsigned</name> <name>char</name>)<name>tmpc</name>)</expr>]</index></name>.<name>cupper</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>tmpc</name> != <name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		}</block></then></if>
		<comment type="line">// check neighbor characters in keyboard string</comment>
		<if>if <condition>(<expr>!<name>ckey</name></expr>)</condition><then> <continue>continue;</continue></then></if>
		<decl_stmt><decl><type><name>char</name> *</type> <name>loc</name> =<init> <expr><call><name>strchr</name><argument_list>(<argument><expr><name>ckey</name></expr></argument>, <argument><expr><name>tmpc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>loc</name></expr>)</condition> <block>{
			<if>if <condition>(<expr>(<name>loc</name> &gt; <name>ckey</name>) &amp;&amp; (*(<name>loc</name> - 1) != '|')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = *(<name>loc</name> - 1)</expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<if>if <condition>(<expr>(*(<name>loc</name> + 1) != '|') &amp;&amp; (*(<name>loc</name> + 1) != '\0')</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = *(<name>loc</name> + 1)</expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>loc</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>loc</name> + 1</expr></argument>, <argument><expr><name>tmpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one (case and keyboard related version)</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badcharkey_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type>        <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type>        <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>          <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// swap out each char one by one and try all the tryme</comment>
	<comment type="line">// chars in its place to see if that makes a good word</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>wl</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>tmpc</name> = <name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="line">// check with uppercase letters</comment>
		<expr_stmt><expr><call><name>mkallcap_utf</name><argument_list>(<argument><expr><name>candidate_utf</name> + <name>i</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>!<call><name>w_char_eq</name><argument_list>(<argument><expr><name>tmpc</name></expr></argument>, <argument><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		}</block></then></if>
		<comment type="line">// check neighbor characters in keyboard string</comment>
		<if>if <condition>(<expr>!<name>ckey</name></expr>)</condition><then> <continue>continue;</continue></then></if>
		<decl_stmt><decl><type><name>w_char</name> *</type> <name>loc</name> =<init> <expr><name>ckey_utf</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr>(<name>loc</name> &lt; (<name>ckey_utf</name> + <name>ckeyl</name>)) &amp;&amp; !<call><name>w_char_eq</name><argument_list>(<argument><expr>*<name>loc</name></expr></argument>, <argument><expr><name>tmpc</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><name>loc</name>++</expr>;</expr_stmt></while>
		<while>while <condition>(<expr><name>loc</name> &lt; (<name>ckey_utf</name> + <name>ckeyl</name>)</expr>)</condition> <block>{
			<if>if <condition>(<expr>(<name>loc</name> &gt; <name>ckey_utf</name>) &amp;&amp; !<call><name>w_char_eq</name><argument_list>(<argument><expr>*(<name>loc</name> - 1)</expr></argument>, <argument><expr><name>W_VLINE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = *(<name>loc</name> - 1)</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<if>if <condition>(<expr>((<name>loc</name> + 1) &lt; (<name>ckey_utf</name> + <name>ckeyl</name>)) &amp;&amp; !<call><name>w_char_eq</name><argument_list>(<argument><expr>*(<name>loc</name> + 1)</expr></argument>, <argument><expr><name>W_VLINE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = *(<name>loc</name> + 1)</expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			}</block></then></if>
			<do>do <block>{ <expr_stmt><expr><name>loc</name>++</expr>;</expr_stmt> }</block> while <condition>(<expr>(<name>loc</name> &lt; (<name>ckey_utf</name> + <name>ckeyl</name>)) &amp;&amp; !<call><name>w_char_eq</name><argument_list>(<argument><expr>*<name>loc</name></expr></argument>, <argument><expr><name>tmpc</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		}</block></while>
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type>  <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>  <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clock_t</name></type> <name>timelimit</name> =<init> <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timer</name> =<init> <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// swap out each char one by one and try all the tryme</comment>
	<comment type="line">// chars in its place to see if that makes a good word</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>j</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>ctryl</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr><name>wl</name>-1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = <name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name><name>ctry</name><index>[<expr><name>j</name></expr>]</index></name> == <name>tmpc</name></expr>)</condition><then> <continue>continue;</continue></then></if>
			<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ctry</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr>!<name>timer</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
			<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is wrong char in place of correct one</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>badchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type>        <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type>        <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>          <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clock_t</name></type> <name>timelimit</name> =<init> <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timer</name> =<init> <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>  
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// swap out each char one by one and try all the tryme</comment>
	<comment type="line">// chars in its place to see if that makes a good word</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>j</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>ctryl</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
		<for>for (<init><decl><type><name>int</name></type> <name>i</name>=<init><expr><name>wl</name>-1</expr></init></decl>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = <name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>(<expr><call><name>w_char_eq</name><argument_list>(<argument><expr><name>tmpc</name></expr></argument>, <argument><expr><name><name>ctry_utf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <continue>continue;</continue></then></if>
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>ctry_utf</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr>!<name>timer</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is word has an extra letter it does not need </comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>extrachar_utf</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name> =<init> <expr><name>W_VLINE</name></expr></init></decl>;</decl_stmt> <comment type="line">// not used value, only for VCC warning message</comment>
	<if>if <condition>(<expr><name>wl</name> &lt; 2</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<comment type="line">// try omitting one char of word at a time</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate_utf</name> + <name>wl</name> - 1</expr>;</init>  <condition><expr><name>p</name> &gt;= <name>candidate_utf</name></expr>;</condition> <incr><expr><name>p</name>--</expr></incr>) <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name>tmpc2</name> =<init> <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>p</name> &lt; <name>candidate_utf</name> + <name>wl</name> - 1</expr>)</condition><then> <expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>tmpc</name> = <name>tmpc2</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is word has an extra letter it does not need </comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>extrachar</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type>    <name>tmpc</name> =<init> <expr>'\0'</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type>  <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 2</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
	<comment type="line">// try omitting one char of word at a time</comment>
	<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate</name> + <name>wl</name> - 1</expr>;</init> <condition><expr><name>p</name> &gt;=<name>candidate</name></expr>;</condition> <incr><expr><name>p</name>--</expr></incr>) <block>{
		<decl_stmt><decl><type><name>char</name></type> <name>tmpc2</name> =<init> <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>-1</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name>tmpc</name> = <name>tmpc2</name></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is missing a letter it needs</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>forgotchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clock_t</name></type> <name>timelimit</name> =<init> <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timer</name> =<init> <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// try inserting a tryme character before every letter (and the null terminator)</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>p</name> = <name>candidate</name> + <name>wl</name></expr>;</init>  <condition><expr><name>p</name> &gt;= <name>candidate</name></expr>;</condition> <incr><expr><name>p</name>--</expr></incr>)  <block>{
			<expr_stmt><expr>*(<name>p</name>+1) = *<name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p</name> = <name><name>ctry</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name>+1</expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr>!<name>timer</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is missing a letter it needs</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>forgotchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type>  <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>    <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clock_t</name></type> <name>timelimit</name> =<init> <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timer</name> =<init> <expr><name>MINTIMER</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// try inserting a tryme character at the end of the word and before every letter</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init>  <condition><expr><name>i</name> &lt; <name>ctryl</name></expr>;</condition>  <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for (<init><expr><name>p</name> = <name>candidate_utf</name> + <name>wl</name></expr>;</init>  <condition><expr><name>p</name> &gt;= <name>candidate_utf</name></expr>;</condition> <incr><expr><name>p</name>--</expr></incr>)  <block>{
			<expr_stmt><expr>*(<name>p</name> + 1) = *<name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>p</name> = <name><name>ctry_utf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr>&amp;<name>timer</name></expr></argument>, <argument><expr>&amp;<name>timelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
			<if>if <condition>(<expr>!<name>timer</name></expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="block">/* error is should have been two words */</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>twowords</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>c1</name>, <name>c2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>forbidden</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cwrd</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>wl</name>=<init><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>wl</name> &lt; 3</expr>)</condition><then> <return>return <expr><name>ns</name></expr>;</return></then></if>

	<if>if <condition>(<expr><name>langnum</name> == <name>LANG_hu</name></expr>)</condition><then> <expr_stmt><expr><name>forbidden</name> = <call><name>check_forbidden</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name> + 1</expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// split the string into two pieces after every char</comment>
	<comment type="line">// if both pieces are good words make them a suggestion</comment>
	<for>for (<init><expr><name>p</name> = <name>candidate</name> + 1</expr>;</init>  <condition><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> != '\0'</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>p</name><index>[<expr>-1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
		<comment type="line">// go to end of the UTF-8 character</comment>
		<while>while <condition>(<expr><name>utf8</name> &amp;&amp; ((<name><name>p</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) == 0x80)</expr>)</condition> <block>{
			<expr_stmt><expr>*<name>p</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
		}</block></while>
		<if>if <condition>(<expr><name>utf8</name> &amp;&amp; <name><name>p</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then> <break>break;</break></then></if> <comment type="line">// last UTF-8 character</comment>
		<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><name>c1</name> = <call><name>checkword</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>c1</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>c2</name> = <call><name>checkword</name><argument_list>(<argument><expr>(<name>p</name>+1)</expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name>+1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>c2</name></expr>)</condition><then> <block>{
				<expr_stmt><expr>*<name>p</name> = ' '</expr>;</expr_stmt>

				<comment type="line">// spec. Hungarian code (need a better compound word support)</comment>
				<if>if <condition>(<expr>(<name>langnum</name> == <name>LANG_hu</name>) &amp;&amp; !<name>forbidden</name> &amp;&amp;
					<comment type="line">// if 3 repeating letter, use - instead of space</comment>
					(((<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>1</expr>]</index></name>) &amp;&amp; (((<name>p</name>&gt;<name>candidate</name>+1) &amp;&amp; (<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>-2</expr>]</index></name>)) || (<name><name>p</name><index>[<expr>-1</expr>]</index></name> == <name><name>p</name><index>[<expr>2</expr>]</index></name>))) ||
					<comment type="line">// or multiple compounding, with more, than 6 syllables</comment>
					((<name>c1</name> == 3) &amp;&amp; (<name>c2</name> &gt;= 2)))</expr>)</condition><then> <expr_stmt><expr>*<name>p</name> = '-'</expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>cwrd</name> = 1</expr>;</expr_stmt>
				<for>for (<init><decl><type><name>int</name></type> <name>k</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)
					<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
				<if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>cwrd</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
						<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
					}</block></then></if>
				}</block></then> <else>else <return>return <expr><name>ns</name></expr>;</return></else></if>
				<comment type="line">// add two word suggestion with dash, if TRY string contains</comment>
				<comment type="line">// "a" or "-"</comment>
				<comment type="line">// NOTE: cwrd doesn't modified for REP twoword sugg.</comment>
				<if>if <condition>(<expr><name>ctry</name> &amp;&amp; (<call><name>strchr</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>, <argument><expr>'a'</expr></argument>)</argument_list></call> || <call><name>strchr</name><argument_list>(<argument><expr><name>ctry</name></expr></argument>, <argument><expr>'-'</expr></argument>)</argument_list></call>) &amp;&amp;
					<call><name>mystrlen</name><argument_list>(<argument><expr><name>p</name> + 1</expr></argument>)</argument_list></call> &gt; 1 &amp;&amp;
					<call><name>mystrlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call> - <call><name>mystrlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
						<expr_stmt><expr>*<name>p</name> = '-'</expr>;</expr_stmt> 
						<for>for (<init><decl><type><name>int</name></type> <name>k</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)
							<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>,<argument><expr><name><name>wlst</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <expr_stmt><expr><name>cwrd</name> = 0</expr>;</expr_stmt></then></if></for>
						<if>if <condition>(<expr><name>ns</name> &lt; <name>maxSug</name></expr>)</condition><then> <block>{
							<if>if <condition>(<expr><name>cwrd</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
								<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
							}</block></then></if>
						}</block></then> <else>else <return>return <expr><name>ns</name></expr>;</return></else></if>
				}</block></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>swapchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name>=<init><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// try swapping adjacent chars one by one</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
	}</block></for>
	<comment type="line">// try double swaps for short words</comment>
	<comment type="line">// ahev -&gt; have, owudl -&gt; would</comment>
	<if>if <condition>(<expr><name>wl</name> == 4 || <name>wl</name> == 5</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>candidate</name><index>[<expr>0</expr>]</index></name> = <name><name>word</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr>1</expr>]</index></name> = <name><name>word</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr>2</expr>]</index></name> = <name><name>word</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>wl</name> - 2</expr>]</index></name> = <name><name>word</name><index>[<expr><name>wl</name> - 1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate</name><index>[<expr><name>wl</name> - 1</expr>]</index></name> = <name><name>word</name><index>[<expr><name>wl</name> - 2</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>wl</name> == 5</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>candidate</name><index>[<expr>0</expr>]</index></name> = <name><name>word</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>candidate</name><index>[<expr>1</expr>]</index></name> = <name><name>word</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>candidate</name><index>[<expr>2</expr>]</index></name> = <name><name>word</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>swapchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<comment type="line">// try swapping adjacent chars one by one</comment>
	<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name> - 1)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = <name><name>p</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = <name>tmpc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<expr_stmt><expr><name><name>p</name><index>[<expr>1</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
	}</block></for>
	<comment type="line">// try double swaps for short words</comment>
	<comment type="line">// ahev -&gt; have, owudl -&gt; would, suodn -&gt; sound</comment>
	<if>if <condition>(<expr><name>wl</name> == 4 || <name>wl</name> == 5</expr>)</condition><then> <block>{
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>0</expr>]</index></name> = <name><name>word</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>1</expr>]</index></name> = <name><name>word</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>2</expr>]</index></name> = <name><name>word</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>wl</name> - 2</expr>]</index></name> = <name><name>word</name><index>[<expr><name>wl</name> - 1</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr><name>wl</name> - 1</expr>]</index></name> = <name><name>word</name><index>[<expr><name>wl</name> - 2</expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		<if>if <condition>(<expr><name>wl</name> == 5</expr>)</condition><then> <block>{
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>0</expr>]</index></name> = <name><name>word</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>1</expr>]</index></name> = <name><name>word</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>candidate_utf</name><index>[<expr>2</expr>]</index></name> = <name><name>word</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is not adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>longswapchar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wl</name>=<init><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// try swapping not adjacent chars one by one</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>q</name> != 0</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>p</name> = *<name>q</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr>*<name>q</name> = *<name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// error is adjacent letter were swapped</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>longswapchar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
	<comment type="line">// try swapping not adjacent chars</comment>
	<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>q</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>tmpc</name> = *<name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>p</name> = *<name>q</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
				<expr_stmt><expr>*<name>q</name> = *<name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr>*<name>p</name> = <name>tmpc</name></expr>;</expr_stmt>
			}</block></then></if>
		}</block></for>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is a letter was moved</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>movechar</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>tmpc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>wl</name>=<init><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// try moving a char</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate</name></expr>;</init>  <condition><expr>*<name>p</name> != 0</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>p</name> + 1</expr>;</init>  <condition><expr>(*<name>q</name> != 0) &amp;&amp; ((<name>q</name> - <name>p</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = *(<name>q</name>-1)</expr>;</expr_stmt>
			<expr_stmt><expr>*(<name>q</name>-1) = *<name>q</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>q</name>-<name>p</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>p</name> = <name>candidate</name> + <name>wl</name> - 1</expr>;</init>  <condition><expr><name>p</name> &gt; <name>candidate</name></expr>;</condition>  <incr><expr><name>p</name>--</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>p</name> - 1</expr>;</init>  <condition><expr>(<name>q</name> &gt;= <name>candidate</name>) &amp;&amp; ((<name>p</name> - <name>q</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>--</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = *(<name>q</name>+1)</expr>;</expr_stmt>
			<expr_stmt><expr>*(<name>q</name>+1) = *<name>q</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>p</name>-<name>q</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>   
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// error is a letter was moved</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>movechar_utf</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>wlst</name></decl></param>, <param><decl><type><name>const</name> <name>w_char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>wl</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>candidate_utf</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>   <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name> *</type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name>tmpc</name></decl>;</decl_stmt>
	<comment type="line">// try moving a char</comment>
	<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for (<init><expr><name>p</name> = <name>candidate_utf</name></expr>;</init>  <condition><expr><name>p</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)</expr>;</condition>  <incr><expr><name>p</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>p</name> + 1</expr>;</init>  <condition><expr>(<name>q</name> &lt; (<name>candidate_utf</name> + <name>wl</name>)) &amp;&amp; ((<name>q</name> - <name>p</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = *(<name>q</name>-1)</expr>;</expr_stmt>
			<expr_stmt><expr>*(<name>q</name>-1) = *<name>q</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>q</name>-<name>p</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<for>for (<init><expr><name>p</name> = <name>candidate_utf</name> + <name>wl</name> - 1</expr>;</init>  <condition><expr><name>p</name> &gt; <name>candidate_utf</name></expr>;</condition>  <incr><expr><name>p</name>--</expr></incr>) <block>{
		<for>for (<init><expr><name>q</name> = <name>p</name> - 1</expr>;</init>  <condition><expr>(<name>q</name> &gt;= <name>candidate_utf</name>) &amp;&amp; ((<name>p</name> - <name>q</name>) &lt; 10)</expr>;</condition>  <incr><expr><name>q</name>--</expr></incr>) <block>{
			<expr_stmt><expr><name>tmpc</name> = *(<name>q</name>+1)</expr>;</expr_stmt>
			<expr_stmt><expr>*(<name>q</name>+1) = *<name>q</name></expr>;</expr_stmt>
			<expr_stmt><expr>*<name>q</name> = <name>tmpc</name></expr>;</expr_stmt>
			<if>if <condition>(<expr>(<name>p</name>-<name>q</name>) &lt; 2</expr>)</condition><then> <continue>continue;</continue></then></if> <comment type="line">// omit swap char</comment>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ns</name> = <call><name>testsug</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>cpdsuggest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> == -1</expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>candidate_utf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name> * <call><name>sizeof</name><argument_list>(<argument><expr><name>w_char</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></for>
	<return>return <expr><name>ns</name></expr>;</return>   
}</block></function>

<comment type="line">// generate a set of suggestions for very poorly spelled words</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>ngsuggest</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>wlst</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns</name></decl></param>, <param><decl><type><name>HashMgr</name>**</type> <name>pHMgr</name></decl></param>, <param><decl><type><name>int</name></type> <name>md</name></decl></param>)</parameter_list>
<block>{

	<decl_stmt><decl><type><name>int</name></type> <name>i</name>, <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sc</name>, <name>scphon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lp</name>, <name>lpphon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nonbmp</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="line">// exhaustively search through all root words</comment>
	<comment type="line">// keeping track of the MAX_ROOTS most similar root words</comment>
	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name><name>roots</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name><name>rootsphon</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>scores</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>scoresphon</name><index>[<expr><name>MAX_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scores</name><index>[<expr><name>i</name></expr>]</index></name> = -100 * <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scoresphon</name><index>[<expr><name>i</name></expr>]</index></name> = -100 * <name>i</name></expr>;</expr_stmt>
	}</block></for>
	<expr_stmt><expr><name>lp</name> = <name>MAX_ROOTS</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>lpphon</name> = <name>MAX_ROOTS</name> - 1</expr>;</expr_stmt>
	<expr_stmt><expr><name>scphon</name> = <name><name>scoresphon</name><index>[<expr><name>MAX_ROOTS</name>-1</expr>]</index></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXWORDUTF8LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>f</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>word</name> =<init> <expr><name>w</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// word reversing wrapper for complex prefixes</comment>
	<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
	}</block></then></if>

	<decl_stmt><decl><type><name>char</name></type> <name><name>mw</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>u8</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nc</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name> =<init> <expr>(<name>utf8</name>) ? <call><name>u8_u16</name><argument_list>(<argument><expr><name>u8</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call> : <name>nc</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// set character based ngram suggestion for words with non-BMP Unicode characters</comment>
	<if>if <condition>(<expr><name>n</name> == -1</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>utf8</name> = 0</expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <name>nc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nonbmp</name> = 1</expr>;</expr_stmt>
	}</block></then></if>

	<decl_stmt><decl><type>struct <name>hentry</name>*</type> <name>hp</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>col</name> =<init> <expr>-1</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>phonetable</name> *</type> <name>ph</name> =<init> <expr>(<name>pAMgr</name>) ? <name>pAMgr</name>-&gt;<call><name>get_phonetable</name><argument_list>()</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>target</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>candidate</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ph</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mkallcap</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>phonet</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>*<name>ph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>md</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{  
		<while>while <condition>(<expr>0 != (<name>hp</name> = (<name><name>pHMgr</name><index>[<expr><name>i</name></expr>]</index></name>)-&gt;<call><name>walk_hashtable</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>hp</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
			<if>if <condition>(<expr>(<name>hp</name>-&gt;<name>astr</name>) &amp;&amp; (<name>pAMgr</name>) &amp;&amp; 
				(<call><name>TESTAFF</name><argument_list>(<argument><expr><name>hp</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_forbiddenword</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hp</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
				<call><name>TESTAFF</name><argument_list>(<argument><expr><name>hp</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name>hp</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
				<call><name>TESTAFF</name><argument_list>(<argument><expr><name>hp</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_nosuggest</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hp</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
				<call><name>TESTAFF</name><argument_list>(<argument><expr><name>hp</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_onlyincompound</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>hp</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <continue>continue;</continue></then></if>

			<expr_stmt><expr><name>sc</name> = <call><name>ngram</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NGRAM_LONGER_WORSE</name> + <name>NGRAM_LOWERING</name></expr></argument>)</argument_list></call> +
				<call><name>leftcommonsubstring</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// check special pronounciation</comment>
			<if>if <condition>(<expr>(<name>hp</name>-&gt;<name>var</name> &amp; <name>H_OPT_PHON</name>) &amp;&amp; <call><name>copy_field</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MORPH_PHON</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>sc2</name> =<init> <expr><call><name>ngram</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>NGRAM_LONGER_WORSE</name> + <name>NGRAM_LOWERING</name></expr></argument>)</argument_list></call> +
					<call><name>leftcommonsubstring</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>sc2</name> &gt; <name>sc</name></expr>)</condition><then> <expr_stmt><expr><name>sc</name> = <name>sc2</name></expr>;</expr_stmt></then></if>
			}</block></then></if>

			<if>if <condition>(<expr><name>ph</name> &amp;&amp; (<name>sc</name> &gt; 2) &amp;&amp; (<call><name>abs</name><argument_list>(<argument><expr><name>n</name> - (<name>int</name>) <name>hp</name>-&gt;<name>clen</name></expr></argument>)</argument_list></call> &lt;= 3)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name></type> <name><name>target2</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mkallcap</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>phonet</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>target2</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>*<name>ph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>scphon</name> = 2 * <call><name>ngram</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>target2</name></expr></argument>, <argument><expr><name>NGRAM_LONGER_WORSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>

			<if>if <condition>(<expr><name>sc</name> &gt; <name><name>scores</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>scores</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>sc</name></expr>;</expr_stmt>  
				<expr_stmt><expr><name><name>roots</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>hp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lval</name> = <name>sc</name></expr>;</expr_stmt>
				<for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
					<if>if <condition>(<expr><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <name>lval</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>lp</name> = <name>j</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>lval</name> = <name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					}</block></then></if></for>
			}</block></then></if>

			<if>if <condition>(<expr><name>scphon</name> &gt; <name><name>scoresphon</name><index>[<expr><name>lpphon</name></expr>]</index></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>scoresphon</name><index>[<expr><name>lpphon</name></expr>]</index></name> = <name>scphon</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rootsphon</name><index>[<expr><name>lpphon</name></expr>]</index></name> = <call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>hp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lval</name> = <name>scphon</name></expr>;</expr_stmt>
				<for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
					<if>if <condition>(<expr><name><name>scoresphon</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <name>lval</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>lpphon</name> = <name>j</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>lval</name> = <name><name>scoresphon</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					}</block></then></if></for>
			}</block></then></if>
		}</block></while>}</block></for>

	<comment type="line">// find minimum threshhold for a passable suggestion</comment>
	<comment type="line">// mangle original word three differnt ways</comment>
	<comment type="line">// and score them to generate a minimum acceptable score</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>thresh</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init><decl><type><name>int</name></type> <name>sp</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>sp</name> &lt; 4</expr>;</condition> <incr><expr><name>sp</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
			<for>for (<init><decl><type><name>int</name></type> <name>k</name>=<init><expr><name>sp</name></expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>+=4</expr></incr>) <expr_stmt><expr>*((<name>unsigned</name> <name>short</name> *) <name>u8</name> + <name>k</name>) = '*'</expr>;</expr_stmt></for>
			<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>mw</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>u8</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>thresh</name> = <name>thresh</name> + <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>mw</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name> + <name>NGRAM_LOWERING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mw</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for (<init><decl><type><name>int</name></type> <name>k</name>=<init><expr><name>sp</name></expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>+=4</expr></incr>) <expr_stmt><expr>*(<name>mw</name> + <name>k</name>) = '*'</expr>;</expr_stmt></for>
			<expr_stmt><expr><name>thresh</name> = <name>thresh</name> + <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>mw</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name> + <name>NGRAM_LOWERING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
	}</block></for>
	<expr_stmt><expr><name>thresh</name> = <name>thresh</name> / 3</expr>;</expr_stmt>
	<expr_stmt><expr><name>thresh</name>--</expr>;</expr_stmt>

	<comment type="line">// now expand affixes on each of these root words and</comment>
	<comment type="line">// and use length adjusted ngram scores to select</comment>
	<comment type="line">// possible suggestions</comment>
	<decl_stmt><decl><type><name>char</name> *</type> <name><name>guess</name><index>[<expr><name>MAX_GUESS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name><name>guessorig</name><index>[<expr><name>MAX_GUESS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>gscore</name><index>[<expr><name>MAX_GUESS</name></expr>]</index></name></decl>;</decl_stmt>
	<for>for(<init><expr><name>i</name>=0</expr>;</init><condition><expr><name>i</name>&lt;<name>MAX_GUESS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> = -100 * <name>i</name></expr>;</expr_stmt>
	}</block></for>

	<expr_stmt><expr><name>lp</name> = <name>MAX_GUESS</name> - 1</expr>;</expr_stmt>

	<decl_stmt><decl><type>struct <name>guessword</name> *</type> <name>glst</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>glst</name> = (struct <name>guessword</name> *) <call><name>calloc</name><argument_list>(<argument><expr><name>MAX_WORDS</name></expr></argument>,<argument><expr><call><name>sizeof</name><argument_list>(<argument>struct <expr><name>guessword</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>! <name>glst</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>nonbmp</name></expr>)</condition><then> <expr_stmt><expr><name>utf8</name> = 1</expr>;</expr_stmt></then></if>
		<return>return <expr><name>ns</name></expr>;</return>
	}</block></then></if>

	<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rp</name> =<init> <expr><name><name>roots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>nw</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>expand_rootword</name><argument_list>(<argument><expr><name>glst</name></expr></argument>, <argument><expr><name>MAX_WORDS</name></expr></argument>, <argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rp</name>-&gt;<name>blen</name></expr></argument>,
				<argument><expr><name>rp</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>rp</name>-&gt;<name>alen</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>nc</name></expr></argument>, 
				<argument><expr>((<name>rp</name>-&gt;<name>var</name> &amp; <name>H_OPT_PHON</name>) ? <call><name>copy_field</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MORPH_PHON</name></expr></argument>)</argument_list></call> : <name>NULL</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>nw</name></expr> ;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
				<expr_stmt><expr><name>sc</name> = <call><name>ngram</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>, <argument><expr><name>NGRAM_ANY_MISMATCH</name> + <name>NGRAM_LOWERING</name></expr></argument>)</argument_list></call> +
					<call><name>leftcommonsubstring</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if>if <condition>(<expr>(<name>sc</name> &gt; <name>thresh</name>)</expr>)</condition><then> <block>{
					<if>if <condition>(<expr><name>sc</name> &gt; <name><name>gscore</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
						<if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
							<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if>if <condition>(<expr><name><name>guessorig</name><index>[<expr><name>lp</name></expr>]</index></name></expr>)</condition><then> <block>{
								<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guessorig</name><index>[<expr><name>lp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>guessorig</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
							}</block></then></if>
						}</block></then></if>
						<expr_stmt><expr><name><name>gscore</name><index>[<expr><name>lp</name></expr>]</index></name> = <name>sc</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>guess</name><index>[<expr><name>lp</name></expr>]</index></name> = <name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>guessorig</name><index>[<expr><name>lp</name></expr>]</index></name> = <name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>orig</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>lval</name> = <name>sc</name></expr>;</expr_stmt>
						<for>for (<init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
							<if>if <condition>(<expr><name><name>gscore</name><index>[<expr><name>j</name></expr>]</index></name> &lt; <name>lval</name></expr>)</condition><then> <block>{
								<expr_stmt><expr><name>lp</name> = <name>j</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>lval</name> = <name><name>gscore</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
							}</block></then></if></for>
					}</block></then> <else>else <block>{ 
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if>if <condition>(<expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>orig</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
					}</block></else></if>
				}</block></then> <else>else <block>{
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>orig</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>glst</name><index>[<expr><name>k</name></expr>]</index></name>.<name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></else></if>
			}</block></for>
		}</block></then></if>
	}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>glst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// now we are done generating guesses</comment>
	<comment type="line">// sort in order of decreasing score</comment>


	<expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>guess</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>guessorig</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>gscore</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_GUESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ph</name></expr>)</condition><then> <expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>rootsphon</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name><name>scoresphon</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_ROOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="line">// weight suggestions with a similarity index, based on</comment>
	<comment type="line">// the longest common subsequent algorithm and resort</comment>

	<decl_stmt><decl><type><name>int</name></type> <name>is_swap</name></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<comment type="line">// lowering guess[i]</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>gl</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>w_char</name></type> <name><name>_w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<decl_stmt><decl><type><name>int</name></type> <name>_lcs</name> =<init> <expr><call><name>lcslen</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// same characters with different casing</comment>
			<if>if <condition>(<expr>(<name>n</name> == <name>len</name>) &amp;&amp; (<name>n</name> == <name>_lcs</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> += 2000</expr>;</expr_stmt>
				<break>break;</break>
			}</block></then></if>

			<comment type="line">// heuristic weigthing of ngram scores</comment>
			<expr_stmt><expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> +=
				<comment type="line">// length of longest common subsequent minus length difference</comment>
				2 * <name>_lcs</name> - <call><name>abs</name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>n</name> - <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
				<comment type="line">// weight length of the left common substring</comment>
				<call><name>leftcommonsubstring</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call> +
				<comment type="line">// weight equal character positions</comment>
				((<name>_lcs</name> == <call><name>commoncharacterpositions</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>, <argument><expr>&amp;<name>is_swap</name></expr></argument>)</argument_list></call>) ? 1: 0) +
				<comment type="line">// swap character (not neighboring)</comment>
				((<name>is_swap</name>) ? 1000 : 0)</expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>guess</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>guessorig</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>gscore</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_GUESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// phonetic version</comment>
	<if>if <condition>(<expr><name>ph</name></expr>)</condition><then> <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<comment type="line">// lowering rootphon[i]</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>gl</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>w_char</name></type> <name><name>_w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>u16_u8</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>MAXSWUTF8L</name></expr></argument>, <argument><expr><name>_w</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>gl</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></else></if>

			<comment type="line">// heuristic weigthing of ngram scores</comment>
			<expr_stmt><expr><name><name>scoresphon</name><index>[<expr><name>i</name></expr>]</index></name> += 2 * <call><name>lcslen</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call> - <call><name>abs</name><argument_list>(<argument><expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>n</name> - <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> +
				<comment type="line">// weight length of the left common substring</comment>
				<call><name>leftcommonsubstring</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for></then></if>

	<if>if <condition>(<expr><name>ph</name></expr>)</condition><then> <expr_stmt><expr><call><name>bubblesort</name><argument_list>(<argument><expr>&amp;<name><name>rootsphon</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name><name>scoresphon</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>MAX_ROOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="line">// copy over</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>oldns</name> =<init> <expr><name>ns</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>same</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_GUESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ns</name> &lt; <name>oldns</name> + <name>maxngramsugs</name>) &amp;&amp; (<name>ns</name> &lt; <name>maxSug</name>) &amp;&amp; (!<name>same</name> || (<name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 1000))</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>unique</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
				<comment type="line">// leave only excellent suggestions, if exists</comment>
				<if>if <condition>(<expr><name><name>gscore</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 1000</expr>)</condition><then> <expr_stmt><expr><name>same</name> = 1</expr>;</expr_stmt></then></if>
				<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
					<comment type="line">// don't suggest previous suggestions or a previous suggestion with prefixes or affixes</comment>
					<if>if <condition>(<expr>(!<name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <call><name>strstr</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call>) ||
						(<name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <call><name>strstr</name><argument_list>(<argument><expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call>) ||
						<comment type="line">// check forbidden words</comment>
						!<call><name>checkword</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>unique</name> = 0</expr>;</expr_stmt></then></if>
				}</block></for>
				<if>if <condition>(<expr><name>unique</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name>++</expr>]</index></name> = <name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<if>if <condition>(<expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name>-1</expr>]</index></name> = <name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					}</block></then></if>
				}</block></then> <else>else <block>{
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
				}</block></else></if>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guess</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>(<expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>guessorig</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			}</block></else></if>
		}</block></then></if>
	}</block></for>

	<expr_stmt><expr><name>oldns</name> = <name>ns</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>ph</name></expr>)</condition><then> <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>MAX_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<if>if <condition>(<expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>ns</name> &lt; <name>oldns</name> + <name>MAXPHONSUGS</name>) &amp;&amp; (<name>ns</name> &lt; <name>maxSug</name>)</expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>unique</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
				<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>ns</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
					<comment type="line">// don't suggest previous suggestions or a previous suggestion with prefixes or affixes</comment>
					<if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> || 
						<comment type="line">// check forbidden words</comment>
						!<call><name>checkword</name><argument_list>(<argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>unique</name> = 0</expr>;</expr_stmt></then></if>
				}</block></for>
				<if>if <condition>(<expr><name>unique</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>wlst</name><index>[<expr><name>ns</name>++</expr>]</index></name> = <call><name>mystrdup</name><argument_list>(<argument><expr><name><name>rootsphon</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if>if <condition>(<expr>!<name><name>wlst</name><index>[<expr><name>ns</name> - 1</expr>]</index></name></expr>)</condition><then> <return>return <expr><name>ns</name> - 1</expr>;</return></then></if>
				}</block></then></if>
			}</block></then></if>
		}</block></then></if>
	}</block></for></then></if>

	<if>if <condition>(<expr><name>nonbmp</name></expr>)</condition><then> <expr_stmt><expr><name>utf8</name> = 1</expr>;</expr_stmt></then></if>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>


<comment type="line">// see if a candidate suggestion is spelled correctly</comment>
<comment type="line">// needs to check both root words and words with affixes</comment>

<comment type="line">// obsolote MySpell-HU modifications:</comment>
<comment type="line">// return value 2 and 3 marks compounding with hyphen (-)</comment>
<comment type="line">// `3' marks roots without suffix</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>checkword</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>cpdsuggest</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>timer</name></decl></param>, <param><decl><type><name>clock_t</name> *</type> <name>timelimit</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name>=<init><expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nosuffix</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>

	<comment type="line">// check time limit</comment>
	<if>if <condition>(<expr><name>timer</name></expr>)</condition><then> <block>{
		<expr_stmt><expr>(*<name>timer</name>)--</expr>;</expr_stmt>
		<if>if <condition>(<expr>!(*<name>timer</name>) &amp;&amp; <name>timelimit</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<call><name>clock</name><argument_list>()</argument_list></call> - *<name>timelimit</name>) &gt; <name>TIMELIMIT</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
			<expr_stmt><expr>*<name>timer</name> = <name>MAXPLUSTIMER</name></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{ 
		<if>if <condition>(<expr><name>cpdsuggest</name>==1</expr>)</condition><then> <block>{
			<if>if <condition>(<expr><name>pAMgr</name>-&gt;<call><name>get_compound</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
				<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>compound_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>100</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//EXT</comment>
				<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <return>return <expr>3</expr>;</return></then></if> <comment type="line">// XXX obsolote categorisation</comment>
			}</block></then></if>
			<return>return <expr>0</expr>;</return>
		}</block></then></if>

		<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>lookup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
			<if>if <condition>(<expr>(<name>rv</name>-&gt;<name>astr</name>) &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_forbiddenword</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>
				|| <call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_nosuggest</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
			<while>while <condition>(<expr><name>rv</name></expr>)</condition> <block>{
				<if>if <condition>(<expr><name>rv</name>-&gt;<name>astr</name> &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_needaffix</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
					<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
					<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_onlyincompound</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
						<expr_stmt><expr><name>rv</name> = <name>rv</name>-&gt;<name>next_homonym</name></expr>;</expr_stmt>
				}</block></then> <else>else <break>break;</break></else></if>
			}</block></while>
		}</block></then> <else>else <expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>prefix_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if> <comment type="line">// only prefix, and prefix + suffix XXX</comment>

		<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>nosuffix</name>=1</expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>suffix_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// only suffix</comment>
		}</block></else></if>

		<if>if <condition>(<expr>!<name>rv</name> &amp;&amp; <name>pAMgr</name>-&gt;<call><name>have_contclass</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>suffix_check_twosfx</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FLAG_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if>if <condition>(<expr>!<name>rv</name></expr>)</condition><then> <expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>prefix_check_twosfx</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>FLAG_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>

		<comment type="line">// check forbidden words</comment>
		<if>if <condition>(<expr>(<name>rv</name>) &amp;&amp; (<name>rv</name>-&gt;<name>astr</name>) &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_forbiddenword</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>ONLYUPCASEFLAG</name></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_nosuggest</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_onlyincompound</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>

		<if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{ <comment type="line">// XXX obsolote    </comment>
			<if>if <condition>(<expr>(<name>pAMgr</name>-&gt;<call><name>get_compoundflag</name><argument_list>()</argument_list></call>) &amp;&amp; 
				<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_compoundflag</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>2 + <name>nosuffix</name></expr>;</return></then></if> 
			<return>return <expr>1</expr>;</return>
		}</block></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>check_forbidden</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>pAMgr</name></expr>)</condition><then> <block>{ 
		<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>lookup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>rv</name> &amp;&amp; <name>rv</name>-&gt;<name>astr</name> &amp;&amp; (<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_needaffix</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_onlyincompound</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <expr_stmt><expr><name>rv</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr>!(<name>pAMgr</name>-&gt;<call><name>prefix_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>)</expr>)</condition><then>
			<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>suffix_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// prefix+suffix, suffix</comment>
		<comment type="line">// check forbidden words</comment>
		<if>if <condition>(<expr>(<name>rv</name>) &amp;&amp; (<name>rv</name>-&gt;<name>astr</name>) &amp;&amp; <call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_forbiddenword</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
	}</block></then></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUNSPELL_EXPERIMENTAL</name></cpp:ifdef>
<comment type="line">// suggest possible stems</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>suggest_pos_stems</name></name><parameter_list>(<param><decl><type><name>char</name>***</type> <name>slst</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>w</name></decl></param>, <param><decl><type><name>int</name></type> <name>nsug</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name></decl>;</decl_stmt>    

	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type> <name>word</name> =<init> <expr><name>w</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// word reversing wrapper for complex prefixes</comment>
	<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
	}</block></then></if>

	<decl_stmt><decl><type><name>int</name></type> <name>wl</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<if>if <condition>(<expr>*<name>slst</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>wlst</name> = *<name>slst</name></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>wlst</name> = (<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>maxSug</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>wlst</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr>-1</expr>;</return></then></if>
	}</block></else></if>

	<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>suffix_check</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>wl</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wlst</name></expr></argument>, <argument><expr><name>maxSug</name></expr></argument>, <argument><expr>&amp;<name>nsug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// delete dash from end of word</comment>
	<if>if <condition>(<expr><name>nsug</name> &gt; 0</expr>)</condition><then> <block>{
		<for>for (<init><decl><type><name>int</name></type> <name>j</name>=<init><expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>nsug</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> - 1</expr>]</index></name> == '-'</expr>)</condition><then> <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
		}</block></for>
	}</block></then></if>

	<expr_stmt><expr>*<name>slst</name> = <name>wlst</name></expr>;</expr_stmt>
	<return>return <expr><name>nsug</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// END OF HUNSPELL_EXPERIMENTAL CODE</comment>


<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_morph</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>w</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>r</name> =<init> <expr>(<name>char</name> *) <name>result</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>st</name></decl>;</decl_stmt>

	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr>*<name>result</name> = '\0'</expr>;</expr_stmt>

	<if>if <condition>(<expr>! <name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<decl_stmt><decl><type><name>char</name></type> <name><name>w2</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>const</name> <name>char</name> *</type> <name>word</name> =<init> <expr><name>w</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// word reversing wrapper for complex prefixes</comment>
	<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>w2</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <expr_stmt><expr><call><name>reverseword_utf</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>reverseword</name><argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
		<expr_stmt><expr><name>word</name> = <name>w2</name></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>lookup</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>rv</name></expr>)</condition> <block>{
		<if>if <condition>(<expr>(!<name>rv</name>-&gt;<name>astr</name>) || !(<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_forbiddenword</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>pAMgr</name>-&gt;<call><name>get_needaffix</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call> ||
			<call><name>TESTAFF</name><argument_list>(<argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>,<argument><expr><name>pAMgr</name>-&gt;<call><name>get_onlyincompound</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
				<if>if <condition>(<expr>!<call><name>HENTRY_FIND</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>MORPH_STEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                
					<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MORPH_STEM</name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<if>if <condition>(<expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                
					<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>HENTRY_DATA2</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<expr_stmt><expr><name>rv</name> = <name>rv</name>-&gt;<name>next_homonym</name></expr>;</expr_stmt>
	}</block></while>

	<expr_stmt><expr><name>st</name> = <name>pAMgr</name>-&gt;<call><name>affix_check_morph</name><argument_list>(<argument><expr><name>word</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr><name>st</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><name>pAMgr</name>-&gt;<call><name>get_compound</name><argument_list>()</argument_list></call> &amp;&amp; (*<name>result</name> == '\0')</expr>)</condition><then>
		<expr_stmt><expr><name>pAMgr</name>-&gt;<call><name>compound_check_morph</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>100</expr></argument>, <argument><expr>0</expr></argument>,<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<return>return <expr>(*<name>result</name>) ? <call><name>mystrdup</name><argument_list>(<argument><expr><call><name>line_uniq</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>MSEP_REC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HUNSPELL_EXPERIMENTAL</name></cpp:ifdef>
<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_morph_for_spelling_error</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> **</type> <name>wlst</name> =<init> <expr>(<name>char</name> **) <call><name>calloc</name><argument_list>(<argument><expr><name>maxSug</name></expr></argument>, <argument><expr><call><name>sizeof</name><argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!**<name>wlst</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
	<comment type="line">// we will use only the first suggestion</comment>
	<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>maxSug</name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>wlst</name><index>[<expr><name>i</name></expr>]</index></name> = ""</expr>;</expr_stmt></for>
	<decl_stmt><decl><type><name>int</name></type> <name>ns</name> =<init> <expr><call><name>suggest</name><argument_list>(<argument><expr>&amp;<name>wlst</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>maxSug</name> - 1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>ns</name> == <name>maxSug</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>p</name> = <call><name>suggest_morph</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>maxSug</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>wlst</name><index>[<expr><name>maxSug</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>
	<if>if <condition>(<expr><name>wlst</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wlst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// END OF HUNSPELL_EXPERIMENTAL CODE</comment>

<comment type="block">/* affixation */</comment>
<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_hentry_gen</name></name><parameter_list>(<param><decl><type><name>hentry</name> *</type> <name>rv</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>pattern</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr>*<name>result</name> = '\0'</expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sfxcount</name> =<init> <expr><call><name>get_sfxcount</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr><call><name>get_sfxcount</name><argument_list>(<argument><expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; <name>sfxcount</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<if>if <condition>(<expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>char</name> *</type> <name>aff</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>morphgen</name><argument_list>(<argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>blen</name></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>rv</name>-&gt;<name>alen</name></expr></argument>,
			<argument><expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>aff</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></then></if>

	<comment type="line">// check all allomorphs</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>allomorph</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>p</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>p</name> = (<name>char</name> *) <call><name>strstr</name><argument_list>(<argument><expr><call><name>HENTRY_DATA2</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MORPH_ALLOMORPH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
	<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
		<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv2</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>p</name> += <name>MORPH_TAG_LEN</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>plen</name> =<init> <expr><call><name>fieldlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>allomorph</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>allomorph</name><index>[<expr><name>plen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
		<expr_stmt><expr><name>rv2</name> = <name>pAMgr</name>-&gt;<call><name>lookup</name><argument_list>(<argument><expr><name>allomorph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>rv2</name></expr>)</condition> <block>{
			<comment type="line">//            if (HENTRY_DATA(rv2) &amp;&amp; get_sfxcount(HENTRY_DATA(rv2)) &lt;= sfxcount) {</comment>
			<if>if <condition>(<expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv2</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type> <name>st</name> =<init> <expr>(<name>char</name> *) <call><name>strstr</name><argument_list>(<argument><expr><call><name>HENTRY_DATA2</name><argument_list>(<argument><expr><name>rv2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MORPH_STEM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>st</name> &amp;&amp; (<call><name>strncmp</name><argument_list>(<argument><expr><name>st</name> + <name>MORPH_TAG_LEN</name></expr></argument>, 
					<argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fieldlen</name><argument_list>(<argument><expr><name>st</name> + <name>MORPH_TAG_LEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
						<decl_stmt><decl><type><name>char</name> *</type> <name>aff</name> =<init> <expr><name>pAMgr</name>-&gt;<call><name>morphgen</name><argument_list>(<argument><expr><call><name>HENTRY_WORD</name><argument_list>(<argument><expr><name>rv2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rv2</name>-&gt;<name>blen</name></expr></argument>, <argument><expr><name>rv2</name>-&gt;<name>astr</name></expr></argument>, <argument><expr><name>rv2</name>-&gt;<name>alen</name></expr></argument>,
							<argument><expr><call><name>HENTRY_DATA</name><argument_list>(<argument><expr><name>rv2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if>if <condition>(<expr><name>aff</name></expr>)</condition><then> <block>{
							<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						}</block></then></if>    
				}</block></then></if>
			}</block></then></if>
			<expr_stmt><expr><name>rv2</name> = <name>rv2</name>-&gt;<name>next_homonym</name></expr>;</expr_stmt>
		}</block></while>
		<expr_stmt><expr><name>p</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>p</name> + <name>plen</name></expr></argument>, <argument><expr><name>MORPH_ALLOMORPH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<return>return <expr>(*<name>result</name>) ? <call><name>mystrdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type> <name><name>SuggestMgr</name>::<name>suggest_gen</name></name><parameter_list>(<param><decl><type><name>char</name> **</type> <name>desc</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>pattern</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>result2</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>newpattern</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr>*<name>newpattern</name> = '\0'</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr>*<name>result2</name> = '\0'</expr>;</expr_stmt>
	<decl_stmt><decl><type>struct <name>hentry</name> *</type> <name>rv</name> =<init> <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>pAMgr</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

	<comment type="line">// search affixed forms with and without derivational suffixes</comment>
	<while>while<condition>(<expr>1</expr>)</condition> <block>{

		<for>for (<init><decl><type><name>int</name></type> <name>k</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>k</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
			<expr_stmt><expr>*<name>result</name> = '\0'</expr>;</expr_stmt>
			<comment type="line">// add compound word parts (except the last one)</comment>
			<decl_stmt><decl><type><name>char</name> *</type> <name>s</name> =<init> <expr>(<name>char</name> *) <name><name>desc</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> *</type> <name>part</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>MORPH_PART</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>part</name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>char</name> *</type> <name>nextpart</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name>part</name> + 1</expr></argument>, <argument><expr><name>MORPH_PART</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>nextpart</name></expr>)</condition> <block>{
					<expr_stmt><expr><call><name>copy_field</name><argument_list>(<argument><expr><name>result</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>MORPH_PART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>part</name> = <name>nextpart</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>nextpart</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>part</name> + 1</expr></argument>, <argument><expr><name>MORPH_PART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<expr_stmt><expr><name>s</name> = <name>part</name></expr>;</expr_stmt>
			}</block></then></if>

			<decl_stmt><decl><type><name>char</name> **</type><name>pl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>tok</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>char</name> *</type> <name>alt</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>" | "</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr><name>alt</name></expr>)</condition> <block>{
				<expr_stmt><expr><name><name>alt</name><index>[<expr>1</expr>]</index></name> = <name>MSEP_ALT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>alt</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>alt</name></expr></argument>, <argument><expr>" | "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></while>
			<decl_stmt><decl><type><name>int</name></type> <name>pln</name> =<init> <expr><call><name>line_tok</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>&amp;<name>pl</name></expr></argument>, <argument><expr><name>MSEP_ALT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>pln</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<comment type="line">// remove inflectional and terminal suffixes</comment>
				<decl_stmt><decl><type><name>char</name> *</type> <name>is</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MORPH_INFL_SFX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>is</name></expr>)</condition><then> <expr_stmt><expr>*<name>is</name> = '\0'</expr>;</expr_stmt></then></if>
				<decl_stmt><decl><type><name>char</name> *</type> <name>ts</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MORPH_TERM_SFX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<while>while <condition>(<expr><name>ts</name></expr>)</condition> <block>{
					<expr_stmt><expr>*<name>ts</name> = '_'</expr>;</expr_stmt>
					<expr_stmt><expr><name>ts</name> = <call><name>strstr</name><argument_list>(<argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MORPH_TERM_SFX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></while>
				<decl_stmt><decl><type><name>char</name> *</type> <name>st</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>MORPH_STEM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if>if <condition>(<expr><name>st</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><call><name>copy_field</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>MORPH_STEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rv</name> = <name>pAMgr</name>-&gt;<call><name>lookup</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<while>while <condition>(<expr><name>rv</name></expr>)</condition> <block>{
						<decl_stmt><decl><type><name>char</name></type> <name><name>newpat</name><index>[<expr><name>MAXLNLEN</name></expr>]</index></name></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newpat</name></expr></argument>, <argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>newpat</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<decl_stmt><decl><type><name>char</name> *</type> <name>sg</name> =<init> <expr><call><name>suggest_hentry_gen</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>newpat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if>if <condition>(<expr>!<name>sg</name></expr>)</condition><then> <expr_stmt><expr><name>sg</name> = <call><name>suggest_hentry_gen</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
						<if>if <condition>(<expr><name>sg</name></expr>)</condition><then> <block>{
							<decl_stmt><decl><type><name>char</name> **</type> <name>gen</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type> <name>genl</name> =<init> <expr><call><name>line_tok</name><argument_list>(<argument><expr><name>sg</name></expr></argument>, <argument><expr>&amp;<name>gen</name></expr></argument>, <argument><expr><name>MSEP_REC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>sg</name> = <name>NULL</name></expr>;</expr_stmt>
							<for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>j</name> &lt; <name>genl</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
								<if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MORPH_SURF_PFX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
									<decl_stmt><decl><type><name>int</name></type> <name>r2l</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
									<expr_stmt><expr><name><name>result2</name><index>[<expr><name>r2l</name></expr>]</index></name> = <name>MSEP_REC</name></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result2</name> + <name>r2l</name> + 1</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>copy_field</name><argument_list>(<argument><expr><name>result2</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MORPH_SURF_PFX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><call><name>mystrcat</name><argument_list>(<argument><expr><name>result2</name></expr></argument>, <argument><expr><name><name>gen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>MAXLNLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								}</block></then> <else>else <block>{
									<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>result2</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"%c%s%s"</expr></argument>,
										<argument><expr><name>MSEP_REC</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>gen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								}</block></else></if>
							}</block></for>
							<expr_stmt><expr><call><name>freelist</name><argument_list>(<argument><expr>&amp;<name>gen</name></expr></argument>, <argument><expr><name>genl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						}</block></then></if>
						<expr_stmt><expr><name>rv</name> = <name>rv</name>-&gt;<name>next_homonym</name></expr>;</expr_stmt>
					}</block></while>
				}</block></then></if>
			}</block></for>
			<expr_stmt><expr><call><name>freelist</name><argument_list>(<argument><expr>&amp;<name>pl</name></expr></argument>, <argument><expr><name>pln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></for>

		<if>if <condition>(<expr>*<name>result2</name> || !<call><name>strstr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>MORPH_DERI_SFX</name></expr></argument>)</argument_list></call></expr>)</condition><then> <break>break;</break></then></if>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newpattern</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pattern</name> = <name>newpattern</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> *</type> <name>ds</name> =<init> <expr><call><name>strstr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>MORPH_DERI_SFX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>ds</name></expr>)</condition> <block>{
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>MORPH_TERM_SFX</name></expr></argument>, <argument><expr><name>MORPH_TAG_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ds</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>MORPH_DERI_SFX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></while>
	}</block></while>
	<return>return <expr>(*<name>result2</name> ? <call><name>mystrdup</name><argument_list>(<argument><expr><name>result2</name></expr></argument>)</argument_list></call> : <name>NULL</name>)</expr>;</return>
}</block></function>


<comment type="line">// generate an n-gram score comparing s1 and s2</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>ngram</name></name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name></type> <name>opt</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>nscore</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>

	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><name>l1</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>l2</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr>(<name>l2</name> &lt;= 0) || (<name>l1</name> == -1)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
		<comment type="line">// lowering dictionary word</comment>
		<if>if <condition>(<expr><name>opt</name> &amp; <name>NGRAM_LOWERING</name></expr>)</condition><then> <expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
			<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= (<name>l1</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<for>for (<init><decl><type><name>int</name></type> <name>l</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>l</name> &lt;= (<name>l2</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>l</name>++</expr></incr>) <block>{
					<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
					<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr>(<name>k</name> &lt; <name>j</name>)</expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
						<decl_stmt><decl><type><name>w_char</name> *</type> <name>c1</name> =<init> <expr><name>su1</name> + <name>i</name> + <name>k</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>w_char</name> *</type> <name>c2</name> =<init> <expr><name>su2</name> + <name>l</name> + <name>k</name></expr></init></decl>;</decl_stmt>
						<if>if <condition>(<expr>(<name>c1</name>-&gt;<name>l</name> != <name>c2</name>-&gt;<name>l</name>) || (<name>c1</name>-&gt;<name>h</name> != <name>c2</name>-&gt;<name>h</name>)</expr>)</condition><then> <break>break;</break></then></if>
					}</block></for>
					<if>if <condition>(<expr><name>k</name> == <name>j</name></expr>)</condition><then> <block>{
						<expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt>
						<break>break;</break>
					}</block></then></if>
				}</block></for>
			}</block></for>
			<expr_stmt><expr><name>nscore</name> = <name>nscore</name> + <name>ns</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> &lt; 2</expr>)</condition><then> <break>break;</break></then></if>
		}</block></for>
	}</block></then> <else>else <block>{  
		<expr_stmt><expr><name>l2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name>l2</name> == 0</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
		<expr_stmt><expr><name>l1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> *</type><name>t</name> =<init> <expr><call><name>mystrdup</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if>if <condition>(<expr><name>opt</name> &amp; <name>NGRAM_LOWERING</name></expr>)</condition><then> <expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<for>for (<init><decl><type><name>int</name></type> <name>j</name> =<init> <expr>1</expr></init></decl>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
			<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= (<name>l1</name>-<name>j</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
				<decl_stmt><decl><type><name>char</name></type> <name>c</name> =<init> <expr>*(<name>s1</name> + <name>i</name> + <name>j</name>)</expr></init></decl>;</decl_stmt>
				<expr_stmt><expr>*(<name>s1</name> + <name>i</name> + <name>j</name>) = '\0'</expr>;</expr_stmt>
				<if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>,<argument><expr>(<name>s1</name>+<name>i</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>ns</name>++</expr>;</expr_stmt></then></if>
				<expr_stmt><expr>*(<name>s1</name> + <name>i</name> + <name>j</name> ) = <name>c</name></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><name>nscore</name> = <name>nscore</name> + <name>ns</name></expr>;</expr_stmt>
			<if>if <condition>(<expr><name>ns</name> &lt; 2</expr>)</condition><then> <break>break;</break></then></if>
		}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<expr_stmt><expr><name>ns</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>opt</name> &amp; <name>NGRAM_LONGER_WORSE</name></expr>)</condition><then> <expr_stmt><expr><name>ns</name> = (<name>l2</name>-<name>l1</name>)-2</expr>;</expr_stmt></then></if>
	<if>if <condition>(<expr><name>opt</name> &amp; <name>NGRAM_ANY_MISMATCH</name></expr>)</condition><then> <expr_stmt><expr><name>ns</name> = <call><name>abs</name><argument_list>(<argument><expr><name>l2</name>-<name>l1</name></expr></argument>)</argument_list></call>-2</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>ns</name> = (<name>nscore</name> - ((<name>ns</name> &gt; 0) ? <name>ns</name> : 0))</expr>;</expr_stmt>
	<return>return <expr><name>ns</name></expr>;</return>
}</block></function>

<comment type="line">// length of the left common substring of s1 and (decapitalised) s2</comment>
<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>leftcommonsubstring</name></name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<comment type="line">// decapitalize dictionary word</comment>
		<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>l1</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>l2</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr>*((<name>short</name> *)<name>su1</name>+<name>l1</name>-1) == *((<name>short</name> *)<name>su2</name>+<name>l2</name>-1)</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>idx</name> =<init> <expr>(<name>su2</name>-&gt;<name>h</name> &lt;&lt; 8) + <name>su2</name>-&gt;<name>l</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>otheridx</name> =<init> <expr>(<name>su1</name>-&gt;<name>h</name> &lt;&lt; 8) + <name>su1</name>-&gt;<name>l</name></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr><name>otheridx</name> != <name>idx</name> &amp;&amp;
				(<name>otheridx</name> != <call><name>unicodetolower</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
			<decl_stmt><decl><type><name>int</name></type> <name>l1</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>l2</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<for>for(<init><expr><name>i</name> = 1</expr>;</init> <condition><expr>(<name>i</name> &lt; <name>l1</name>) &amp;&amp; (<name>i</name> &lt; <name>l2</name>) &amp;&amp;
				(<name><name>su1</name><index>[<expr><name>i</name></expr>]</index></name>.<name>l</name> == <name><name>su2</name><index>[<expr><name>i</name></expr>]</index></name>.<name>l</name>) &amp;&amp; (<name><name>su1</name><index>[<expr><name>i</name></expr>]</index></name>.<name>h</name> == <name><name>su2</name><index>[<expr><name>i</name></expr>]</index></name>.<name>h</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
				<return>return <expr><name>i</name></expr>;</return>
		}</block></else></if>
	}</block></then> <else>else <block>{
		<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>l1</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>l2</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if>if <condition>(<expr>*(<name>s2</name>+<name>l1</name>-1) == *(<name>s2</name>+<name>l2</name>-1)</expr>)</condition><then> <return>return <expr>1</expr>;</return></then></if>
		}</block></then> <else>else <block>{
			<decl_stmt><decl><type><name>char</name> *</type> <name>olds</name> =<init> <expr><name>s1</name></expr></init></decl>;</decl_stmt>
			<comment type="line">// decapitalise dictionary word</comment>
			<if>if <condition>(<expr>(*<name>s1</name> != *<name>s2</name>) &amp;&amp; (*<name>s1</name> != <name><name>csconv</name><index>[<expr>((<name>unsigned</name> <name>char</name>)*<name>s2</name>)</expr>]</index></name>.<name>clower</name>)</expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
			<do>do <block>{
				<expr_stmt><expr><name>s1</name>++</expr>;</expr_stmt> <expr_stmt><expr><name>s2</name>++</expr>;</expr_stmt>
			}</block> while <condition>(<expr>(*<name>s1</name> == *<name>s2</name>) &amp;&amp; (*<name>s1</name> != '\0')</expr>)</condition>;</do>
			<return>return <expr><name>s1</name> - <name>olds</name></expr>;</return>
		}</block></else></if>
	}</block></else></if>
	<return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>commoncharacterpositions</name></name><parameter_list>(<param><decl><type><name>char</name> *</type> <name>s1</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>is_swap</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>num</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>diffpos</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr>*<name>is_swap</name> = 0</expr>;</expr_stmt>
	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su1</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>l1</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su1</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>l2</name> =<init> <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// decapitalize dictionary word</comment>
		<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name>+<name>l2</name>-1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>mkallsmall_utf</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>langnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<for>for (<init><decl><type><name>int</name></type> <name>i</name> =<init> <expr>0</expr></init></decl>;</init> <condition><expr>(<name>i</name> &lt; <name>l1</name>) &amp;&amp; (<name>i</name> &lt; <name>l2</name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>((<name>short</name> *) <name>su1</name>)[<name>i</name>] == ((<name>short</name> *) <name>su2</name>)[<name>i</name>]</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>num</name>++</expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><name>diff</name> &lt; 2</expr>)</condition><then> <expr_stmt><expr><name><name>diffpos</name><index>[<expr><name>diff</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>diff</name>++</expr>;</expr_stmt>
			}</block></else></if>
		}</block></for>
		<if>if <condition>(<expr>(<name>diff</name> == 2) &amp;&amp; (<name>l1</name> == <name>l2</name>) &amp;&amp;
			(((<name>short</name> *) <name>su1</name>)[<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>] == ((<name>short</name> *) <name>su2</name>)[<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>]) &amp;&amp;
			(((<name>short</name> *) <name>su1</name>)[<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>] == ((<name>short</name> *) <name>su2</name>)[<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>])</expr>)</condition><then> <expr_stmt><expr>*<name>is_swap</name> = 1</expr>;</expr_stmt></then></if>
	}</block></then> <else>else <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>t</name><index>[<expr><name>MAXSWUTF8L</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// decapitalize dictionary word</comment>
		<if>if <condition>(<expr><name>complexprefixes</name></expr>)</condition><then> <block>{
			<decl_stmt><decl><type><name>int</name></type> <name>l2</name> =<init> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr>*(<name>t</name>+<name>l2</name>-1) = <name><name>csconv</name><index>[<expr>((<name>unsigned</name> <name>char</name>)*(<name>t</name>+<name>l2</name>-1))</expr>]</index></name>.<name>clower</name></expr>;</expr_stmt>
		}</block></then> <else>else <block>{
			<expr_stmt><expr><call><name>mkallsmall</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>csconv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if>
		<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr>(*(<name>s1</name>+<name>i</name>) != 0) &amp;&amp; (*(<name>t</name>+<name>i</name>) != 0)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
			<if>if <condition>(<expr>*(<name>s1</name>+<name>i</name>) == *(<name>t</name>+<name>i</name>)</expr>)</condition><then> <block>{
				<expr_stmt><expr><name>num</name>++</expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<if>if <condition>(<expr><name>diff</name> &lt; 2</expr>)</condition><then> <expr_stmt><expr><name><name>diffpos</name><index>[<expr><name>diff</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name>diff</name>++</expr>;</expr_stmt>
			}</block></else></if>
		}</block></for>
		<if>if <condition>(<expr>(<name>diff</name> == 2) &amp;&amp; (*(<name>s1</name>+<name>i</name>) == 0) &amp;&amp; (*(<name>t</name>+<name>i</name>) == 0) &amp;&amp;
			(*(<name>s1</name>+<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>) == *(<name>t</name>+<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>)) &amp;&amp;
			(*(<name>s1</name>+<name><name>diffpos</name><index>[<expr>1</expr>]</index></name>) == *(<name>t</name>+<name><name>diffpos</name><index>[<expr>0</expr>]</index></name>))</expr>)</condition><then> <expr_stmt><expr>*<name>is_swap</name> = 1</expr>;</expr_stmt></then></if>
	}</block></else></if>
	<return>return <expr><name>num</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>mystrlen</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>word</name></decl></param>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<decl_stmt><decl><type><name>w_char</name></type> <name><name>w</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
		<return>return <expr><call><name>u8_u16</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return>
	}</block></then> <else>else <return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="line">// sort in decreasing order of score</comment>
<function><type><name>void</name></type> <name><name>SuggestMgr</name>::<name>bubblesort</name></name><parameter_list>(<param><decl><type><name>char</name>**</type> <name>rword</name></decl></param>, <param><decl><type><name>char</name>**</type> <name>rword2</name></decl></param>, <param><decl><type><name>int</name>*</type> <name>rsc</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param> )</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> =<init> <expr>1</expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>m</name> &lt; <name>n</name></expr>)</condition> <block>{
		<decl_stmt><decl><type><name>int</name></type> <name>j</name> =<init> <expr><name>m</name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>j</name> &gt; 0</expr>)</condition> <block>{
			<if>if <condition>(<expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name> &lt; <name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><then> <block>{
				<decl_stmt><decl><type><name>int</name></type> <name>sctmp</name> =<init> <expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> *</type> <name>wdtmp</name> =<init> <expr><name><name>rword</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>rsc</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rword</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name><name>rword</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rsc</name><index>[<expr><name>j</name></expr>]</index></name> = <name>sctmp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rword</name><index>[<expr><name>j</name></expr>]</index></name> = <name>wdtmp</name></expr>;</expr_stmt>
				<if>if <condition>(<expr><name>rword2</name></expr>)</condition><then> <block>{
					<expr_stmt><expr><name>wdtmp</name> = <name><name>rword2</name><index>[<expr><name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rword2</name><index>[<expr><name>j</name>-1</expr>]</index></name> = <name><name>rword2</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rword2</name><index>[<expr><name>j</name></expr>]</index></name> = <name>wdtmp</name></expr>;</expr_stmt>
				}</block></then></if>
				<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
			}</block></then> <else>else <break>break;</break></else></if>
		}</block></while>
		<expr_stmt><expr><name>m</name>++</expr>;</expr_stmt>
	}</block></while>
	<return>return;</return>
}</block></function>

<comment type="line">// longest common subsequence</comment>
<function><type><name>void</name></type> <name><name>SuggestMgr</name>::<name>lcs</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><name>const</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l1</name></decl></param>, <param><decl><type><name>int</name> *</type> <name>l2</name></decl></param>, <param><decl><type><name>char</name> **</type> <name>result</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>n</name>, <name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>su</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>w_char</name></type> <name><name>su2</name><index>[<expr><name>MAXSWL</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>utf8</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><name>m</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>u8_u16</name><argument_list>(<argument><expr><name>su2</name></expr></argument>, <argument><expr><name>MAXSWL</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else>else <block>{
		<expr_stmt><expr><name>m</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>
	<expr_stmt><expr><name>c</name> = (<name>char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>m</name> + 1) * (<name>n</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> = (<name>char</name> *) <call><name>malloc</name><argument_list>(<argument><expr>(<name>m</name> + 1) * (<name>n</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>c</name> || !<name>b</name></expr>)</condition><then> <block>{
		<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<if>if <condition>(<expr><name>b</name></expr>)</condition><then> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
		<expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1)</expr>]</index></name> = 0</expr>;</expr_stmt></for>
	<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <expr_stmt><expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
	<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>m</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt;= <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<if>if <condition>( <expr>((<name>utf8</name>) &amp;&amp; (*((<name>short</name> *) <name>su</name>+<name>i</name>-1) == *((<name>short</name> *)<name>su2</name>+<name>j</name>-1)))
				|| ((!<name>utf8</name>) &amp;&amp; ((*(<name>s</name>+<name>i</name>-1)) == (*(<name>s2</name>+<name>j</name>-1))))</expr>)</condition><then> <block>{
					<expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name>+1</expr>;</expr_stmt>
					<expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_UPLEFT</name></expr>;</expr_stmt>
			}</block></then> <else>else <if>if <condition>(<expr><name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name></expr>]</index></name> &gt;= <name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name></expr>)</condition><then> <block>{
				<expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr>(<name>i</name>-1)*(<name>n</name>+1) + <name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_UP</name></expr>;</expr_stmt>
			}</block></then> <else>else <block>{
				<expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name><name>c</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name>-1</expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> = <name>LCS_LEFT</name></expr>;</expr_stmt>
			}</block></else></if></else></if>
		}</block></for>
	}</block></for>
	<expr_stmt><expr>*<name>result</name> = <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>l1</name> = <name>m</name></expr>;</expr_stmt>
	<expr_stmt><expr>*<name>l2</name> = <name>n</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>int</name></type> <name><name>SuggestMgr</name>::<name>lcslen</name></name><parameter_list>(<param><decl><type><name>const</name> <name>char</name> *</type> <name>s</name></decl></param>, <param><decl><type><name>const</name> <name>char</name>*</type> <name>s2</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> =<init> <expr>0</expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>lcs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <return>return <expr>0</expr>;</return></then></if>
	<expr_stmt><expr><name>i</name> = <name>m</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> = <name>n</name></expr>;</expr_stmt>
	<while>while <condition>(<expr>(<name>i</name> != 0) &amp;&amp; (<name>j</name> != 0)</expr>)</condition> <block>{
		<if>if <condition>(<expr><name><name>result</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> == <name>LCS_UPLEFT</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
		}</block></then> <else>else <if>if <condition>(<expr><name><name>result</name><index>[<expr><name>i</name>*(<name>n</name>+1) + <name>j</name></expr>]</index></name> == <name>LCS_UP</name></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
		}</block></then> <else>else <expr_stmt><expr><name>j</name>--</expr>;</expr_stmt></else></if></else></if>
	}</block></while>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
}</block></function>
</unit>
